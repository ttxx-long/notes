<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Monkey使用</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_Monkey%E4%BD%BF%E7%94%A8/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_Monkey%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>一、Monkey压力测试的原理</strong></p><p><strong>1. adb shell monkey的运行机制</strong></p><p><strong>实际上是执行手机中&#x2F;system&#x2F;bin&#x2F;monkey这个脚本；</strong></p><p><strong>2. Monkey事件注入机制Monkey注入系统事件是通过 framework 层的 hidenApi (如：activemanager,inputmanager,windowmanager) 获取系统服务。</strong></p><p><strong>Monkey中有11种事件，这些事件在MonkeyEventSource中对事件之间的比例进行设置。</strong></p><p><strong>Monkey事件根据类型比例生成事件队列，循环查找事件。</strong></p><p><strong>a.触摸事件(inputmanager)：包括屏幕以及物理键的触摸，滑动，点击事件</strong></p><p><strong>b.Activity事件(activemanager):是指我们调用Android系统组件的事件。</strong></p><p><strong>c.Window事件(windowmanager)：是指操作Window的事件，例如转屏</strong></p><p><strong>3.Monkey核心类</strong></p><p><strong>a. Monkey.java, 程序的入口，根据参数选择合适的MonkeyEventSource，并适时触发MonkeyEvent；</strong></p><p><strong>b. MonkeyEventSource.java,MonkeyEvent的工厂，是一个接口；</strong></p><p><strong>c. MonkeyEvent.java，各种事件的具体实现。</strong></p><p><strong>二、查找手机上的安装包包名</strong></p><p><strong>1.adb shell pm list package 查看手机上所有的安装包</strong></p><p><strong>2.adb shell pm list package -3 查看第三方安装包</strong></p><p><img src="/assets/image-20220312153216-8qt8k4z.png" alt="image.png"></p><p><strong>3.adb shell pm list packages -s 查看系统的包</strong></p><p><strong>4.adb shell pm list packages -e “要搜索的内容” 查看启动包中搜索的包</strong></p><p><img src="/assets/image-20220312153223-azw8vyc.png" alt="image.png"></p><p><strong>5.adb shell dumpsys window | findstr mCurrentFocus 后面的是当前启动的acivity）：获取当前打开的APP包名（前面的为包名，斜杠</strong></p><p><img src="/assets/image-20220312153229-ysknr4c.png" alt="image.png"></p><p><strong>三、Monkey 命令 基本参数的介绍注意：所有的参数都需要放在monkey和设置的次数之间，参数的顺序可以调整；若带了-p ，-p必须放在monkey之后，参数必须在-p和count之间：</strong></p><p><strong>adb shell monkey -p 包名 –throttle 100 –ignore-crashes –ignore-timeouts –ignore-security-exceptions –ignore-native-crashes –monitor-native-crashes -v -v -v –s 1540475754297 100</strong></p><p><strong>1.-p ，此命令用于指定包，若不指定则在整个系统中执行</strong></p><p><strong>a.指定一个包执行10次：adb shell monkey -p包名 10，如下出现事件执行次数和所耗时间，则算是执行成功；</strong></p><p><img src="/assets/image-20220312153237-5ve4t6y.png" alt="image.png"></p><p><strong>b.指定多个包执行10次：adb shell monkey -p 包名–p包名10，</strong></p><p><img src="/assets/image-20220312153242-oe4tten.png" alt="image.png"></p><p><strong>2.-v ，用于反馈日志的详细程度级别</strong></p><p><strong>Level 0:adb shell monkey -p 包名 -v 10&#x2F;&#x2F; 默认级别，仅提供启动、测试完成和最终结果等少量信息</strong></p><p><strong>Level 1:adb shell monkey -p包名 -v-v 10&#x2F;&#x2F; 提供较为详细的日志，包括每个发送到Activity的事件信息</strong></p><p><strong>Level 2:adb shell monkey -p包名 -v-v-v 10 &#x2F;&#x2F; 提供最详细的日志，包括了测试中选中&#x2F;未选中的Activity信息</strong></p><p><strong>3.-s ，用于指定伪随机数生成器的seed值</strong></p><p><strong>命令：adb shell monkey -p 包名 –s seed值 执行次数</strong></p><p><strong>如果seed值相同，则两次Monkey测试所产生的事件序列也相同的，示例：</strong></p><p><strong>测试1：adb shell monkey -pcom.kugou.android –s 1540475754297 100</strong></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> Monkey使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逍遥虚拟机</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E5%89%AF%E6%9C%AC%20(3)/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E5%89%AF%E6%9C%AC%20(3)/</url>
      
        <content type="html"><![CDATA[<p>1、先进入逍遥模拟器安装目录（MEmu文件夹下），如：D:\Program Files\Microvirt\MEmu  （如果设置变量  不需要）</p><p>2、在CMD下输入：adb connect 127.0.0.1:21503</p><p>我输入后提示：already connected to 127.0.0.1:21503</p><p>3、查看是否连接到模拟器，输入命令：adb devices</p><p>我输入后提示以下两行：</p><p>List of devices attached<br>127.0.0.1:21503 device</p><p>4、OK，连接成功</p><p>5.查询模拟器信息：adb devices -l</p><p>6..dumpsys:查看包名和activity</p><p>（1）启动要查看的程序</p><p>（2）命令行输入：adb shell dumpsys window w |findstr / |findstr name&#x3D;</p><p>(3) 使用adb shell dumpsys window | findstr mCurrentFocus  命令查看当前运行的包名和Activity更清晰一些。</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 逍遥虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逍遥虚拟机</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E5%89%AF%E6%9C%AC%20(2)/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%20-%20%E5%89%AF%E6%9C%AC%20(2)/</url>
      
        <content type="html"><![CDATA[<p>1、先进入逍遥模拟器安装目录（MEmu文件夹下），如：D:\Program Files\Microvirt\MEmu  （如果设置变量  不需要）</p><p>2、在CMD下输入：adb connect 127.0.0.1:21503</p><p>我输入后提示：already connected to 127.0.0.1:21503</p><p>3、查看是否连接到模拟器，输入命令：adb devices</p><p>我输入后提示以下两行：</p><p>List of devices attached<br>127.0.0.1:21503 device</p><p>4、OK，连接成功</p><p>5.查询模拟器信息：adb devices -l</p><p>6..dumpsys:查看包名和activity</p><p>（1）启动要查看的程序</p><p>（2）命令行输入：adb shell dumpsys window w |findstr / |findstr name&#x3D;</p><p>(3) 使用adb shell dumpsys window | findstr mCurrentFocus  命令查看当前运行的包名和Activity更清晰一些。</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 逍遥虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monkey工具介绍</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_Monkey%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_Monkey%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>Monkey的概念：</p><p>“猴子测试”是指没有测试经验的人甚至对计算机根本不了解的人（就像猴子一样）不需要知道程序的任何用户交互方面的知识，如果给他一个程序，他就会针对他看到的界面进行操作，其操作是无目的的、乱点乱按的。</p><p>这种测试方式在产品周期中的早期阶段会找到很多很好的bug，为用户节省不少的时间。</p><p>Monkey的介绍</p><p>它是Android系统自带一个命令行工具，可以运行在模拟器里或者真是设备中运行。</p><p>monkey向系统发送伪随机的用户事件流，实现对正在开发的应用程序进行压力测试。</p><p>monkey包括很多选项，大致四大类：</p><p>1.基本配置选项，如设置尝试的事件数量。</p><p>2.运行约束选项，如设置只对单独的一个包进行测试。</p><p>3.事件类型和频率。</p><p>4.调试选项</p><p>monkey命令特性</p><p>不可能使用monkey来指定做一样测试，重复做很多次。因为monkey产生的是伪随机的事件流。但是我们可以通过添加命令选项将操作限制在一定的范围内。</p><p>一，首先你要先搭建环境</p><p>1.先下载jdk   具体安装流程请参考：<a href="https://blog.csdn.net/write6/article/details/79136388">https://blog.csdn.net/write6/article/details/79136388</a></p><p>2.再下载sdk  具体安装流程请参考：<a href="https://blog.csdn.net/u011541946/article/details/77142045">https://blog.csdn.net/u011541946/article/details/77142045</a></p><p>二，打开手机的开发者调试工具，用usb数据线链接你的手机；</p><p>三，monkey前的准备命令</p><p>1.windows+r 输入cmd进入dos命令行；</p><p>2.输入adb devices 下面出现类似下图的组合你就成功了；（</p><p><img src="/assets/image-20220312153527-miroy1y.png" alt="image.png"></p><p>3.获取包名（我常用的几种）</p><p>（1）输入 adb shell pm list packages    查看你的手机所有的安装包；输入 adb shell pm list packages -3 查看手机上所有的第三方安装包，看一眼差不多就知道哪一个是你要的安装包;</p><p>（2）使用uiaotumator之类的软件查看，</p><p><img src="/assets/image-20220312153538-c9b58oa.png" alt="image.png"></p><p>（3）DOS环境输入：adb shell logcat|findstr “Displayed”   ，打开待测试的APP；</p><p>红线1是包名，红线2是appActivity（自动化测试时能用到）</p><p><img src="/assets/image-20220312153549-tym78kw.png" alt="image.png"></p><p>这样可以尽快的找到想要的安装包名称；</p><p>四，首先用一个最简单的mokey去试着找哪个是你想要的安装包名称：</p><p>1.&#x2F; &#x2F; -p参数：表示指定测试的程序（空格后面跟安装包名字，拿刚才的第三方安装包一个个试）</p><p>  &#x2F; &#x2F;-v参数：表示查看monkey执行过程的信息(日志级别）（-v 越多越详细，最多三个）</p><p>  &#x2F; &#x2F;数字100:表示测试事件数为100</p><p> 指定一个包   adb shell monkey  -p  com.tencent.news  -v -v -v  100   （此时指定软件会被打开并开始乱点乱按）<br> 指定多个包   adb shell monkey -p com.tencent.news -p com.pdfreader -p com.widgets  -v 1000<br> 不指定包       adb shell monkey -v 1000</p><p> 结果如图：</p><p><img src="/assets/image-20220312153601-91xcpjd.png" alt="image.png"></p><p>Event percentages（事件百分比）:</p><p>0：触摸事件百分比，参数–pct-touch</p><p>1：滑动事件百分比，参数–pct-motion</p><p>2：缩放事件百分比，参数–pct-pinchzoom</p><p>3：轨迹球事件百分比，参数–pct-trackball</p><p>4：屏幕旋转事件百分比，参数–pct-rotation</p><p>5：暂时不知道这个是什么</p><p>6：基本导航事件百分比，参数–pct-nav</p><p>7：主要导航事件百分比，参数–pct-majornav</p><p>8：系统事件百分比，参数–pct-syskeys</p><p>9：Activity启动事件百分比，参数–pct-appswitch</p><p>10：键盘翻转事件百分比，参数–pct-flip</p><p>11：其他事件百分比，参数–pct-anyevent</p><p>2.尽管monkey产生是伪随机事件流，但是我们希望我们的操作有一定的规律性，即按键、触屏等各类事件操作有所偏重。</p><p>eg：（1）.对文本框操作，需要更多的按键操作。</p><pre><code>    （2）.玩游戏，需要更多的点击和滑动操作。</code></pre><p>3.–throttle  设定两个事件之间一个固定延迟，可以减缓monkey的执行速度。如果不指定，monkey将不会被延迟，事件将尽可能快地生成和发送消息。单位：毫秒</p><p>eg:adb shell monkey  –throttle  3000  -p com.tencent.news  100</p><p>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。</p><p>4.–pct-touch  （空格后加数字）设定触屏事件生成的百分比。触屏事件是一个有手指按下，抬起事件的手势。</p><p>eg:      adb shell monkey   –throttle  3000   –pct-touch  50  -p  com.tencent.news  100</p><p>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定触屏的事件占比为50%。</p><p>5.–pct-motion  设定滑动事件生成的百分比。滑动事件是一个先在某一个位置手指按下，滑动一段距离后再抬起手指的手势。</p><p>eg:       adb shell monkey   –throttle  3000 –pct-motion  50  -p  com.tencent.news  100</p><p>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定滑动的事件占比为50%。</p><p>6.–pct-trackball  设定轨迹球事件生成的百分比。轨迹球事件是包含一系列随机移动和单击事件的事件</p><p>eg:adb shell monkey –throttle  3000 –pct-trackball  50  -p  com.tencent.news  100</p><p>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定轨迹球的事件占比为50%。</p><p>7.–pct-nav  设定基本导航事件生成的百分比。基本导航事件是模拟方向性在设备上输入向上、向下、向左、向右的事件。</p><p>eg:adb shell monkey –throttle  3000 –pct-nav  40  -p  com.tencent.news  100</p><p>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定基本导航事件的占比为40%。</p><p>8.–pct-majornav  设定主要导航事件生成的百分比。主要导航事件通常会导致UI产生回馈信息，如单击Back键、Home键、Menu键等、</p><p>eg:     adb shell monkey  –throttle  3000   –pct-majornav  40  -p  com.tencent.news  100</p><p>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定主要导航事件的占比为40%。</p><p>9.–hprof</p><p>指定了该参数，Monkey会在发送事件序列的前、后，生成性能分析报告。通常会在data&#x2F;misc目录下生成一个5MB左右大小的文件</p><p>10.–ignore-crashes</p><p>通常情况下，monkey会在测试应用程序崩溃或者发生异常后停止运行，若指定了该参数，则monkey将会在产生异常后，继续向系统发送事件，直到指定事件全部运行完毕。</p><p>11.–ignore-timeouts</p><p>通常情况下，当应用程序发生任何超时错误（application  not  responding）时，monkey将停止运行。若指定了该参数，则monkey将会在产生错误信息后，继续向系统发送事件，直到指定事件全部运行完毕</p><p>12.–ignore-security-exceptions    通常情况下，指定应用程序发生许可错误时（如证书许可，网络许可等），monkey将停止运行。若指定了该参数，即使应用程序发生许可错误，monkey会继续向系统发送事件，直到指定事件全部运行完毕。</p><p>eg：adb shell monkey  –throttle  3000 –pct-trackball  50  -p  com.tencent.news  –ignore-security-exceptions  100</p><p>到这里简单的monkey就完了；<br><br /></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> Monkey工具介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逍遥虚拟机</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>1、先进入逍遥模拟器安装目录（MEmu文件夹下），如：D:\Program Files\Microvirt\MEmu  （如果设置变量  不需要）</p><p>2、在CMD下输入：adb connect 127.0.0.1:21503</p><p>我输入后提示：already connected to 127.0.0.1:21503</p><p>3、查看是否连接到模拟器，输入命令：adb devices</p><p>我输入后提示以下两行：</p><p>List of devices attached<br>127.0.0.1:21503 device</p><p>4、OK，连接成功</p><p>5.查询模拟器信息：adb devices -l</p><p>6..dumpsys:查看包名和activity</p><p>（1）启动要查看的程序</p><p>（2）命令行输入：adb shell dumpsys window w |findstr / |findstr name&#x3D;</p><p>(3) 使用adb shell dumpsys window | findstr mCurrentFocus  命令查看当前运行的包名和Activity更清晰一些。</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 逍遥虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的adb的命令操作</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_%E5%B8%B8%E7%94%A8%E7%9A%84adb%E7%9A%84%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_%E5%B8%B8%E7%94%A8%E7%9A%84adb%E7%9A%84%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>adb 其实就是 Android Debug Bridge, Android 调试桥的缩写，adb 是一个 <em>C&#x2F;S</em> 架构的命令行工具，用于通过电脑端与模拟器或者真实设备交互。在某些特殊的情况下进入不了系统，adb就派上用场啦！主要由 3 部分组成：</p><p>· 运行在 PC 端的 Client : 可以通过它对 Android 应用进行安装、卸载及调试</p><p>· 运行在 PC 端的 Service : 其管理客户端到 Android 设备上 adb 后台进程的连接</p><p>adb 服务启动后，Windows 可以在任务管理器中找到 adb.exe 这个进程</p><p>· 运行在 Android 设备上的 adb 后台进程</p><p>执行 adb shell ps | grep adbd ，可以找到该后台进程，windows 请使用 findstr 替代 grep</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155428238-1085192595.png"><img src="/assets/image-20211209002906-t3thtny.png" alt="image.png"></a></p><p><strong>通过adb<strong><strong>操作android</strong></strong>设备</strong></p><p>连接上数据线，然后把手机开发者模式打开，打开usb调试。</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155429039-1959136890.png"><img src="/assets/image-20211209002912-qu9x3ln.png" alt="image.png"></a></p><h3 id="adb-命令"><a href="#adb-命令" class="headerlink" title="adb 命令"></a>adb 命令</h3><p>在开发或者测试的过程中，我们可以通过 adb 来管理多台设备，其一般的格式为：</p><p>| adb [-e | -d | -s &lt;设备序列号&gt;] &lt;子命令&gt; |<br>| —————————————— |</p><p>在配好环境变量的前提下，在命令窗口当中输入 adb help 或者直接输入 adb ，将会列出所有的选项说明及子命令。</p><h4 id="这里介绍一些里面常用的命令："><a href="#这里介绍一些里面常用的命令：" class="headerlink" title="这里介绍一些里面常用的命令："></a>这里介绍一些里面常用的命令：</h4><p><strong>1.adb devices</strong> , 获取设备列表及设备状态</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155429797-1825941225.png"><img src="/assets/image-20211209002919-iijez5g.png" alt="image.png"></a></p><p><strong>2.adb get-state</strong> , 获取设备的状态</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155430475-494564427.png"><img src="/assets/image-20211209002927-cz0moet.png" alt="image.png"></a></p><p>设备的状态有 3 钟，device , offline , unknown</p><p>device：设备正常连接</p><p>offline：连接出现异常，设备无响应</p><p>unknown：没有连接设备</p><p> <strong>3.</strong> <strong>安装卸载应用程序</strong></p><p>adb install <strong>用于安装</strong></p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155431186-1764437344.png"><img src="/assets/image-20211209002933-8fu1e6o.png" alt="image.png"></a></p><p>安装成功，返回成功提示 “Success”；</p><p>安装失败，会返回以下：</p><p>INSTALL_FAILED_ALREADY_EXISTS</p><p>此时需要用 -r 参数来重新安装。</p><p>INSTALL_FAILED_SIGNATURE_ERROR</p><p>应用的签名不一致，可能是发布版和调试版签名不同所致。也有可能是没卸载旧应用导致。</p><p>INSTALL_FAILED_INSUFFICIENT_STORAGE</p><p>存储空间不足，需要检查设备存储情况。</p><p><strong>adb uninstall</strong> 用于卸载</p><p>adb uninstall 后面带的是应用的包名，而不是应用名。</p><p>查看系统所有应用的包名：</p><p>adb shell pm list packages –f</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155432148-1001670330.png"><img src="/assets/image-20211209002941-sseqhpz.png" alt="image.png"></a></p><p> <strong>4</strong> <strong>．上传、下载文件</strong></p><p>adb push 命令将PC机上的文件推到 DLT-RK3288 机器上；</p><p>adb pull  命令将DLT-RK3288机器上的文件拉到PC机上；</p><p>例如：</p><p>adb push d:&#x2F;new.txt &#x2F;sdcard&#x2F;</p><p>将D盘下new.txt文件 推到内部存储器</p><p>adb pull &#x2F;sdcard&#x2F;new.txt    d:\</p><p>将DLT-RK3288 内部存储器根目录下的new.txt 拉到D盘</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155433167-1446733020.png"><img src="/assets/image-20211209002948-6va6z60.png" alt="image.png"></a></p><p><strong>5. adb shell pm list package</strong></p><p>Package Manager , 可以用获取到一些安装在 Android 设备上得应用信息</p><p>-s：列出系统应用</p><p>-f：列出应用包名及对应的apk名及存放位置</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155433984-688635705.png"><img src="/assets/image-20211209002954-o4pcw6x.png" alt="image.png"></a></p><p><strong>过滤应用</strong></p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155434808-820533597.png"><img src="/assets/image-20211209003001-a9kavr6.png" alt="image.png"></a></p><p><strong>5.adb shell</strong></p><p>通过adb shell 命令，就可以进入设备或者模拟器的shell环境了，在这个Linux shell中，我们就可以执行各种Linux命令了。</p><p>如果只想执行一条shell命令，就可以采用：adb shell [shell_command]，在实际使用中，经常与grep或findstr一起使用，起到过滤作用，查看自己需要的关键信息。    exit ：  退出  shell状态</p><p> <strong>6.</strong> <strong>常见命令：</strong></p><p>如 ls, cd, rm, mkdir, touch, pwd, cp, mv, ifconfig, netstat, ping, ps, top等，进入adb shell即可执行，与linux相似</p><p><strong>7. adb logcat</strong></p><p> <strong>一.</strong> <strong>在cmd<strong><strong>窗口查看手机的Log</strong></strong>日志</strong></p><p>有时候我们在手机程序上的日志要在其他地方调试，然后要看里面的Log日志。在cmd窗口中输入如下命令：</p><table><thead><tr><th>&#x2F;&#x2F;格式1：打印默认日志数据<br />adb logcat<br />&#x2F;&#x2F;格式2：需要打印日志详细时间的简单数据<br />adb logcat -v time<br />&#x2F;&#x2F;格式3：需要打印级别为Error的信息<br />adb logcat *:E<br />&#x2F;&#x2F;格式4：需要打印时间和级别是Error的信息<br />adb logcat -v time *:E<br />&#x2F;&#x2F;格式5：将日志保存到电脑固定的位置，比如D:\log.txt<br />adb logcat -v time &gt;D:\log.txt<br /></th></tr></thead></table><p>这时手机日志更新什么日志，cmd窗口也会同步更新数据。</p><p>但是这样没有过滤条件，如果Log日志很多，很难找到我们想要的信息，</p><p>当然也可以复制cmd中的数据到一个文本中慢慢处理的，就是效率不高。</p><p>下面介绍adb logcat中的详细参数命令以及如何才能高效的打印日志，或者把日志保存到我们指定的位置。</p><p>二.adb logcat <strong>详解</strong></p><p>adb logcat如果用过，但是具体命令又不记得，可以输入adb logcat -help，查看一下一些简单的数据格式：</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155435688-2050217910.png"><img src="/assets/image-20211209003008-58zctpg.png" alt="image.png"></a></p><p><strong>日志过滤：adb logcat <tag>[:priority]</strong></p><p>tag表示标签，priority输出的级别，日志默认级别是V，如果错误日志我们选择E就可以。</p><p>Android 的日志分为如下几个优先级（priority）：</p><p>V —— Verbose（最低，输出得最多）</p><p>D —— Debug</p><p>I —— Info</p><p>W —— Warning</p><p>E —— Error</p><p>F —— Fatal</p><p>S —— Silent（最高，啥也不输出）</p><p>按某级别过滤日志则会将该级别及以上的日志输出。比如，命令：adb logcat *:W</p><p>其实*可以是某个tag，如果没有指明，就表示所有。</p><p>tag可以由多个 [:priority] 组成。比如，命令：</p><p>adb logcat ActivityManager:I MyApp:D *:S</p><p>表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p><p><strong>adb logcat选项解析</strong></p><p>–”-s”选项 : 设置输出日志*：s的标签, 只显示该标签的日志;</p><p>–”-f”选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;</p><p>–”-r”选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;</p><p>–”-n”选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;</p><p>–”-v”选项 : 设置日志的输出格式, 注意只能设置一项;</p><p>–”-c”选项 : 清空所有的日志缓存信息;</p><p>–”-d”选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;</p><p>–”-t”选项 : 输出最近的几行日志, 输出完退出, 不阻塞;</p><p>–”-g”选项 : 查看日志缓冲区信息;</p><p>–”-B”选项 : 以二进制形式输出日志;</p><p><strong>把日志信息保存到电脑中</strong></p><p>adb logcat最后添加” &gt; 保存文件的地址，比如需要将的信息保存到电脑中使用下面的命令： adb logcat -v time &gt; D:\log.txt</p><p><strong>8.monkey测试</strong></p><p><strong>一、Monkey测试简介</strong></p><p>Monkey测试是Android平台自动化测试的一种手段，通过Monkey程序模拟用户触摸屏幕、滑动Trackball、按键等操作来对设备上的程序进行压</p><p><strong>二、Monkey命令的简单帮助</strong></p><p>要获取Monkey命令自带的简单帮助，在CMD中执行命令：</p><p>adb shell monkey –help</p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155436837-2037617676.png"><img src="/assets/image-20211209003017-y9nul0y.png" alt="image.png"></a></p><p><strong>四、Monkey命令参数介绍</strong></p><p><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155437967-241629749.png"><img src="/assets/image-20211209003024-qq7uae5.png" alt="image.png"></a></p><p>说明：第一个-s指定设备，如果只连接了一台设备，可不用该参数。</p><p>-p &lt;apk包名&gt;只允许系统启动指定的app，如果不指定，将允许系统启动设备中的所有app，也可指定多个包。</p><p>–throttle &lt;毫秒数&gt; 指定用户操作（事件）间的时延。</p><p>–ignore-crashes 指定当应用程序崩溃时，Monkey依然发送事件，直到事件计数完成。</p><p>–ignore-timeouts 当应用程序发生ANR错误时，Monkey依然会发送事件，直到事件计数完成。</p><p>第2个-s，用于指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。</p><p>-v 用于指定反馈信息级别，总共分为level 0、level 1、level 2三个级别，级别越高，输出的日志越详细。</p><p>日志级别 Level0 示例 adb shellmonkey -p com.amaker.mp –v 100</p><p>说明 缺省值，仅提供启动提示、测试完成和最终结果等少量信息</p><p>日志级别 Level 1 示例 adb shellmonkey -p com.amaker.mp –v -v 100</p><p>说明 提供较为详细的日志，包括每个发送到Activity的事件信息</p><p><strong>日志级别 Level 2</strong> 示例 adb shellmonkey -p com.amaker.mp –v -v –v 100</p><p>说明 最详细的日志，包括了测试中选中&#x2F;未选中的Activity信息</p><p>最后的数字（这里是500）：表示Monkey程序模拟500次随机用户操作事件。</p><blockquote><p>输出测试结果到D:\monkeylog.txt</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 常用的adb的命令操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adb命令环境配置</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_adb%E5%91%BD%E4%BB%A4%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_adb%E5%91%BD%E4%BB%A4%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>1、环境的安装</strong></p><p><strong>1.1 环境的准备</strong></p><ul><li>jdk1.6以上</li><li>android-sdk</li></ul><p><strong>1.2 jdk 安装</strong></p><ul><li>下载JDK后傻瓜式安装，<strong>注意：不要有中文路径和空格</strong></li><li><strong>配置环境变量：</strong></li></ul><p><strong>右击“我的电脑”–&gt;”属性”–&gt;”高级系统设置”–&gt;”高级”–&gt;”环境变量”</strong></p><ol><li>在系统变量里新建”JAVA_HOME”变量，变量值为：C:\Program Files\Java\jdk1.8.0_60（根据自己的jdk的安装路径填写）</li><li>在系统变量里新建”classpath”变量，变量值为：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar <strong>(注意最前面有一点)</strong></li><li>找到path变量（已存在不用新建）添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</li></ol><p><strong>1.3 安装Android的测试开发环境</strong></p><ol><li><strong>Android-SDK的安装：</strong> SDK manager.exe 双击打开下载</li></ol><p><img src="/assets/image-20211205190359-2l4539b.png" alt="image.png"></p><p><strong>2.android-sdk环境变量的配置</strong></p><p>具体操作步骤：</p><ul><li><strong>新建ANDROID_HOME</strong></li></ul><p>路径为C:\Program Files (x86)\Android\android-sdk\</p><ul><li><strong>在Path 变量中加入路径</strong></li></ul><p>%ANDROID_HOME%\platform-tools 和 %ANDROID_HOME%\tools</p><p><strong>3.检查adb 环境变量</strong></p><p><img src="/assets/image-20211205190406-lp0oe3n.png" alt="image.png"></p><p><strong>4.连接手机</strong></p><p>如果是真机，手机插上USB连接电脑，打开开发者模式，cmd输入adb devices</p><p>如果是模拟器，需要输入adb connect 127.0.0.1:62001或者52001连接，然后再输入adb devices</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> adb命令环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world - 副本</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/hello-world/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello-world - 副本</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/hello-world/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello-world - 副本</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/05_%E5%85%B6%E4%BB%96/hello-world/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/05_%E5%85%B6%E4%BB%96/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>navicat  安装</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/06_navicat/01_navicat%E5%AE%89%E8%A3%85/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/06_navicat/01_navicat%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>1.Navicat 下载安装-破解</p><p>1）关闭所有的杀毒软件（很重要的步骤）</p><p>2）如果之前装过navicat,必须彻底删除navicat的残留文件</p><ul><li>卸载    点开windows设置，选择应用，找道navicat，点击选择卸载。</li><li>*为了安全起见，记得去 我的电脑里把文件夹删除，如果你是默认安装的路径，那么就在 C:\Program Files\PremiumSoft 下，<ul><li></li></ul></li><li>*如果不是默认的，就去找你当时安装的路径，删除 Navicat Premium  ，这个文件夹或者是你当初另外命名的文件夹<ul><li></li></ul></li><li>*删除注册表     win+r 输入 “regedit”，回车   *</li><li><em>在里面找到 HKEY_CURRENT_USER\Software\PremiumSoft 这个路径下的 Navicat 的相关注册表 删除(我是有几个删几个，从不慌)，</em></li></ul><p>2.1.Navicat 下载位置：<a href="https://www.navicat.com.cn/download/navicat-premium">Navicat | 下载 Navicat Premium 14 天免费 Windows、macOS 和 Linux 的试用版</a></p><p>注释：可按照电脑版本下载使用</p><p>2.2.安装Navicat Premium15</p><p><img src="/assets/image-20211120233620-y8dv58o.png" alt="image.png"></p><p><strong>然后一直傻瓜式操作就行，注意看一下自己的安装目录</strong></p><p><strong>利用注册机激活Navicat Premium15     破解文件在附件中（Navicat Keygen Patch v5.6.0 DFoX.exe）</strong></p><p><img src="/assets/image-20211120233626-ijrquw5.png" alt="image.png"></p><p>如果你是默认安装的话，你的navicat的安装路径是在C:\Program Files\PremiumSoft\Navicat Premium 15，</p><p>navicat破解工具：[Navicat Keygen Patch v5.6.0 DFoX.exe](assets&#x2F;Navicat Keygen Patch v5.6.0 DFoX-20211120233821-d5tl62s.exe)</p><p>然后将上述图片中的破解工具复制到C:\Program Files\PremiumSoft\Navicat Premium 15。</p><p>如果不是默认安装，就把破解工具放到你自定义的navicat的安装目录下</p><p><img src="/assets/image-20211120233634-ufire3z.png" alt="image.png"></p><h3 id="点击patch"><a href="#点击patch" class="headerlink" title="点击patch"></a>点击patch</h3><p><img src="/assets/image-20211120233641-lm58r9j.png" alt="image.png"></p><h3 id="等待出现navicat-exe-x64-gt-Cracked"><a href="#等待出现navicat-exe-x64-gt-Cracked" class="headerlink" title="等待出现navicat.exe -x64-&gt; Cracked!"></a>等待出现navicat.exe -x64-&gt; Cracked!</h3><p><img src="/assets/image-20211120233647-qm4cagp.png" alt="image.png"></p><h3 id="点击Generate"><a href="#点击Generate" class="headerlink" title="点击Generate"></a>点击Generate</h3><p><img src="/assets/image-20211120233654-iq1d694.png" alt="image.png"></p><h3 id="打开Navicat-Premium-15，点击注册"><a href="#打开Navicat-Premium-15，点击注册" class="headerlink" title="打开Navicat Premium 15，点击注册"></a>打开Navicat Premium 15，点击注册</h3><p><img src="/assets/image-20211120233700-0om93mu.png" alt="image.png"></p><h3 id="粘贴秘钥，然后点击激活按钮"><a href="#粘贴秘钥，然后点击激活按钮" class="headerlink" title="粘贴秘钥，然后点击激活按钮"></a>粘贴秘钥，然后点击<strong>激活</strong>按钮</h3><p><img src="/assets/image-20211120233722-y7g41tg.png" alt="image.png"></p><h3 id="在弹出的界面选择手动激活"><a href="#在弹出的界面选择手动激活" class="headerlink" title="在弹出的界面选择手动激活"></a>在弹出的界面选择手动激活</h3><p><img src="/assets/image-20211120233717-uuw1zk8.png" alt="image.png"></p><h3 id="将请求码粘贴到注册机Request-Code框中（完整过程看图）"><a href="#将请求码粘贴到注册机Request-Code框中（完整过程看图）" class="headerlink" title="将请求码粘贴到注册机Request Code框中（完整过程看图）"></a><em>将请求码粘贴到注册机Request Code框中（完整过程看图）</em></h3><p><img src="/assets/image-20211120233730-s4jcf0e.png" alt="image.png"></p><h3 id="点击激活页面的激活弹出（说明激活成功）"><a href="#点击激活页面的激活弹出（说明激活成功）" class="headerlink" title="点击激活页面的激活弹出（说明激活成功）"></a>点击激活页面的激活弹出（说明激活成功）</h3><p><img src="/assets/image-20211120233736-swj24yz.png" alt="image.png"></p><p><img src="/assets/image-20211120233741-8iiy4vj.png" alt="image.png"></p><p>到此navicat15安装和破解成功</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> navicat  安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>navicat  SQL语句练习</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/06_navicat/02_SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/06_navicat/02_SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="">SQL语句实例</a></strong></p><p><img src="/assets/image-20211120234345-rcfnit1.png" alt="image.png"></p><p><strong>表操作</strong></p><p><strong>例 1 对于表的教学管理数据库中的表 STUDENTS ，可以定义如下：</strong></p><p>CREATE TABLE STUDENTS</p><p>(SNO NUMERIC (6, 0) NOT NULL</p><p>SNAME CHAR (8) NOT NULL</p><p>AGE NUMERIC(3,0)</p><p>SEX CHAR(2)</p><p>BPLACE CHAR(20)</p><p>PRIMARY KEY(SNO))</p><p><strong>例 2 对于表的教学管理数据库中的表 ENROLLS ，可以定义如下：</strong></p><p>CREATE TABLE ENROLLS</p><p>(SNO NUMERIC(6,0) NOT NULL</p><p>CNO CHAR(4) NOT NULL</p><p>GRADE INT</p><p>PRIMARY KEY(SNO,CNO)</p><p>FOREIGN KEY(SNO) REFERENCES STUDENTS(SNO)</p><p>FOREIGN KEY(CNO) REFERENCES COURSES(CNO)</p><p>CHECK ((GRADE IS NULL) OR (GRADE BETWEEN 0 AND 100)))</p><p><strong>例 3 根据表的 STUDENTS 表，建立一个只包含学号、姓名、年龄的女学生表。</strong></p><p>CREATE TABLE GIRL</p><p>AS SELECT SNO, SNAME, AGE</p><p>FROM STUDENTS</p><p>WHERE SEX&#x3D;’ 女 ‘;</p><p><strong>例 4 删除教师表 TEACHER 。</strong></p><p>DROP TABLE TEACHER</p><p><strong>例 5 在教师表中增加住址列。</strong></p><p>ALTER TABLE TEACHERS</p><p>ADD (ADDR CHAR(50))</p><p><strong>例 6 把 STUDENTS 表中的 BPLACE 列删除，并且把引用 BPLACE 列的所有视图和约束也一起删除。</strong></p><p>ALTER TABLE STUDENTS</p><p>DROP BPLACE CASCADE</p><p><strong>例 7 补充定义 ENROLLS 表的主关键字。</strong></p><p>ALTER TABLE ENROLLS</p><p>ADD PRIMARY KEY (SNO,CNO) ；</p><p><strong>视图操作（虚表）</strong></p><p><strong>例 9 建立一个只包括教师号、姓名和年龄的视图 FACULTY 。 ( 在视图定义中不能包含 ORDER BY 子句 )</strong></p><p>CREATE VIEW FACULTY</p><p>AS SELECT TNO, TNAME, AGE</p><p>FROM TEACHERS</p><p><strong>例 10 从学生表、课程表和选课表中产生一个视图 GRADE_TABLE ， 它包括学生姓名、课程名和成绩。</strong></p><p>CREATE VIEW GRADE_TABLE</p><p>AS SELECT SNAME,CNAME,GRADE</p><p>FROM STUDENTS,COURSES,ENROLLS</p><p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND</p><p>COURSES.CNO&#x3D;ENROLLS.CNO</p><p><strong>例 11 删除视图 GRADE_TABLE</strong></p><p>DROP VIEW GRADE_TABLE RESTRICT</p><p><strong>索引操作</strong></p><p><strong>例 12 在学生表中按学号建立索引。</strong></p><p>CREATE UNIQUE INDEX ST</p><p>ON STUDENTS (SNO,ASC)</p><p><strong>例 13 删除按学号所建立的索引。</strong></p><p>DROP INDEX ST</p><p><strong>数据库模式操作</strong></p><p><strong>例 14 创建一个简易教学数据库的数据库模式 TEACHING_DB ，属主为 ZHANG 。</strong></p><p>CREATE SCHEMA TEACHING_DB AUTHRIZATION ZHANG</p><p><strong>例 15 删除简易教学数据库模式 TEACHING_DB 。（（ 1 ）选用 CASCADE ，即当删除数据库模式时，则本数据库模式和其下属的基本表、视图、索引等全部被删除。（ 2 ）选用 RESTRICT ，即本数据库模式下属的基本表、视图、索引等事先已清除，才能删除本数据库模式，否则拒绝删除。）</strong></p><p>DROP SCHEMA TEACHING_DB CASCADE</p><p><strong>单表操作</strong></p><p><strong>例 16 找出 3 个学分的课程号和课程名。</strong></p><p>SELECT CNO, CNAME</p><p>FROM 　 COURSES</p><p>WHERE 　 CREDIT ＝ 3</p><p><strong>例 17 查询年龄大于 22 岁的学生情况。</strong></p><p>SELECT *</p><p>FROM STUDENTS</p><p>WHERE AGE ＞ 22</p><p><strong>例 18 找出籍贯为河北的男生的姓名和年龄。</strong></p><p>SELECT SNAME, AGE</p><p>FROM 　 STUDENTS</p><p>WHERE 　 BPLACE ＝ ‘ 河北 ‘ AND SEX ＝ ‘ 男 ‘</p><p><strong>例 19 找出年龄在 20 ～ 23 岁之间的学生的学号、姓名和年龄，并按年龄升序排序。 (ASC （升序）或 DESC （降序）声明排序的方式，缺省为升序。 )</strong></p><p>SELECT SNO, SNAME, AGE</p><p>FROM STUDENTS</p><p>WHERE AGE BETWEEN 20 AND 23</p><p>ORDER BY AGE</p><p><strong>例 20 找出年龄小于 23 岁、籍贯是湖南或湖北的学生的姓名和性别。（条件比较运算符＝、＜ 和逻辑运算符 AND （与），此外还可以使用的运算符有：＞（大于）、＞＝（大于等于）、＜＝（小于等于）、＜＞（不等于）、 NOT （非）、 OR （或）等。</strong></p><p><strong>谓词 LIKE 只能与字符串联用，常常是 “ ＜列名＞ LIKE pattern” 的格式。特殊字符 “_” 和 “%” 作为通配符。</strong></p><p><strong>谓词 IN 表示指定的属性应与后面的集合（括号中的值集或某个查询子句的结果）中的某个值相匹配，实际上是一系列的 OR （或）的缩写。谓词 NOT IN 表示指定的属性不与后面的集合中的某个值相匹配。</strong></p><p><strong>谓词 BETWEEN 是 “ 包含于 … 之中 ” 的意思。）</strong></p><p>SELECT SNAME, SEX</p><p>FROM STUDENTS</p><p>WHERE AGE ＜ 23 AND BPLACE LIKE’ 湖％ ‘</p><p>或</p><p>SELECT SNAME, SEX</p><p>FROM STUDENTS</p><p>WHERE AGE ＜ 23 AND BPLACE IN （ ‘ 湖南 ‘ ， ‘ 湖北 ‘ ）</p><p><strong>例 22 找出学生表中籍贯是空值的学生的姓名和性别。（在 SQL 中不能使用条件：＜列名＞＝ NULL 。在 SQL 中只有一个特殊的查询条件允许查询 NULL 值：）</strong></p><p>SELECT SNAME, SEX</p><p>FROM STUDENTS</p><p>WHERE BPLACE IS NULL</p><p><strong>多表操作</strong></p><p><strong>例 23 找出成绩为 95 分的学生的姓名。（子查询）</strong></p><p>SELECT SNAME</p><p>FROM 　 STUDENTS</p><p>WHERE 　 SNO ＝</p><p>(SELECT SNO</p><p>FROM ENROLLS</p><p>WHERE GRADE ＝ 95)</p><p><strong>例 24 找出成绩在 90 分以上的学生的姓名。</strong></p><p>SELECT SNAME</p><p>FROM STUDENTS</p><p>WHERE SNO IN</p><p>(SELECT SNO</p><p>FROM ENROLLS</p><p>WHERE GRADE ＞ 90)</p><p>或</p><p>SELECT SNAME</p><p>FROM STUDENTS</p><p>WHERE SNO ＝ ANY</p><p>(SELECT SNO</p><p>FROM ENROLLS</p><p>WHERE GRADE ＞ 90)</p><p><strong>例 25 查询全部学生的学生名和所学课程号及成绩。（连接查询）</strong></p><p>SELECT SNAME, CNO, GRADE</p><p>FROM STUDENTS, ENROLLS</p><p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO</p><p><strong>例 26 找出籍贯为山西或河北，成绩为 90 分以上的学生的姓名、籍贯和成绩。（当构造多表连接查询命令时，必须遵循两条规则。第一，连接条件数正好比表数少 1 （若有三个表，就有两个连接条件 ) ；第二，若一个表中的主关键字是由多个列组成，则对此主关键字中的每一个列都要有一个连接条件（也有少数例外情况））</strong></p><p>SELECT SNAME, BPLACE, GRADE</p><p>FROM STUDENTS, ENROLLS</p><p>WHERE BPLACE IN (‘ 山西 ’ ， ‘ 河北 ’) AND GRADE ＞＝ 90 AND 　STUDENTS.SNO&#x3D;ENROLLS.SNO</p><p><strong>例 28 查出课程成绩在 80 分以上的女学生的姓名、课程名和成绩。（ FROM 子句中的子查询）</strong></p><p>SELECT SNAME,CNAME, GRADE</p><p>FROM (SELECT SNAME, CNAME , GRADE</p><p>FROM STUDENTS, ENROLLS,COURSES</p><p>WHERE SEX ＝ ‘ 女 ‘)</p><p>AS TEMP (SNAME, CNAME,GRADE)</p><p>WHERE GRADE ＞ 80</p><p><strong>表达式与函数的使用</strong></p><p><strong>例 29 查询各课程的学时数。（算术表达式由算术运算符＋、－、 * 、／与列名或数值常量所组成。）</strong></p><p>SELECT CNAME,COURSE_TIME ＝ CREDIT*16</p><p>FROM COURSES</p><p><strong>例 30 找出教师的最小年龄。（内部函数： SQL 标准中只使用 COUNT 、 SUM 、 AVG 、 MAX 、 MIN 函数，称之为聚集函数（ Set Function ）。 COUNT 函数的结果是该列统计值的总数目， SUM 函数求该列统计值之和， AVG 函数求该列统计值之平均值， MAX 函数求该列最大值， MIN 函数求该列最小值。）</strong></p><p>SELECT MIN(AGE)</p><p>FROM TEACHERS</p><p><strong>例 31 统计年龄小于等于 22 岁的学生人数。（统计）</strong></p><p>SELECT COUNT(*)</p><p>FROM STUDENTS</p><p>WHERE AGE &lt; ＝ 22</p><p><strong>例 32 找出学生的平均成绩和所学课程门数。</strong></p><p>SELECT SNO, AVG(GRADE), COURSES ＝ COUNT(*)</p><p>FROM ENROLLS</p><p>GROUP BY SNO</p><p><strong>例 34 找出年龄超过平均年龄的学生姓名。</strong></p><p>SELECT SNAME</p><p>FROM STUDENTS</p><p>WHERE AGE ＞</p><p>(SELECT AVG(AGE)</p><p>FROM STUDENTS)</p><p><strong>例 35 找出各课程的平均成绩，按课程号分组，且只选择学生超过 3 人的课程的成绩。（ GROUP BY 与 HAVING</strong></p><p><strong>GROUP BY 子句把一个表按某一指定列（或一些列）上的值相等的原则分组，然后再对每组数据进行规定的操作。</strong></p><p><strong>GROUP BY 子句总是跟在 WHERE 子句后面，当 WHERE 子句缺省时，它跟在 FROM 子句后面。</strong></p><p><strong>HAVING 子句常用于在计算出聚集之后对行的查询进行控制。）</strong></p><p>SELECT CNO, AVG(GRADE), STUDENTS ＝ COUNT(*)</p><p>FROM ENROLLS</p><p>GROUP BY CNO</p><p>HAVING COUNT(*) &gt;&#x3D; 3</p><p><strong>相关子查询</strong></p><p><strong>例 37 查询没有选任何课程的学生的学号和姓名。（当一个子查询涉及到一个来自外部查询的列时，称为相关子查询（ Correlated Subquery) 。相关子查询要用到存在测试谓词 EXISTS 和 NOT EXISTS ，以及 ALL 、 ANY （ SOME ）等。）</strong></p><p>SELECT SNO, SNAME</p><p>FROM STUDENTS</p><p>WHERE NOT EXISTS</p><p>(SELECT *</p><p>FROM ENROLLS</p><p>WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO)</p><p><strong>例 38 查询哪些课程只有男生选读。</strong></p><p>SELECT DISTINCT CNAME</p><p>FROM COURSES C</p><p>WHERE ‘ 男 ‘ ＝ ALL</p><p>(SELECT SEX</p><p>FROM ENROLLS ， STUDENTS</p><p>WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO AND</p><p>ENROLLS.CNO&#x3D;C.CNO)</p><p><strong>例 39 要求给出一张学生、籍贯列表，该表中的学生的籍贯省份，也是其他一些学生的籍贯省份。</strong></p><p>SELECT SNAME, BPLACE</p><p>FROM STUDENTS A</p><p>WHERE EXISTS</p><p>(SELECT *</p><p>FROM STUDENTS B</p><p>WHERE A.BPLACE&#x3D;B.BPLACE AND</p><p>A.SNO &lt; &gt; B.SNO)</p><p><strong>例 40 找出选修了全部课程的学生的姓名。</strong></p><p>本查询可以改为：查询这样一些学生，没有一门课程是他不选修的。</p><p>SELECT SNAME</p><p>FROM STUDENTS</p><p>WHERE NOT EXISTS</p><p>(SELECT *</p><p>FROM COURSES</p><p>WHERE NOT EXISTS</p><p>(SELECT *</p><p>FROM ENROLLS</p><p>WHERE ENROLLS.SNO ＝ STUDENTS.SNO</p><p>AND ENROLLS.CNO ＝ COURSES.CNO))</p><p><strong>关系代数运算</strong></p><p><strong>例 41 设有某商场工作人员的两张表：营业员表 SP_SUBORD 和营销经理表 SP_MGR ，其关系数据模式如下：</strong></p><p><strong>SP_SUBORD (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)</strong></p><p><strong>SP_MGR (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)</strong></p><p><strong>其中，属性 SALPERS_ID 为工作人员的编号 , SALPERS_NAME 为工作人员的姓名 , MANAGER_ID 为所在部门经理的编号 , OFFICE 为工作地点。</strong></p><p>若查询全部商场工作人员，可以用下面的 SQL 语句：</p><p>(SELECT * FROM SP_SUBORD)</p><p>UNION</p><p>(SELECT * FROM SP_MGR)</p><p>或等价地用下面的 SQL 语句：</p><p>SELECT *</p><p>FROM (TABLE SP_SUBORD UNION TABLE SP_MGR)</p><p>（ 2 ） INTERSECT</p><p>(SELECT * FROM SP_SUBORD)</p><p>INTERSECT</p><p>(SELECT * FROM SP_MGR)</p><p>或等价地用下面的 SQL 语句：</p><p>SELECT *</p><p>FROM (TABLE SP_SUBORD INTERSECT TABLE SP_MGR)</p><p>或用带 ALL 的 SQL 语句：</p><p>(SELECT * FROM SP_SUBORD)</p><p>INTERSECTALL</p><p>(SELECT * FROM SP_MGR)</p><p>或</p><p>SELECT *</p><p>FROM (TABLE SP_SUBORD INTERSECT ALL TABLE SP_MGR)</p><p>（ 3 ） EXCEPT</p><p>(SELECT * FROM SP_MGR)</p><p>EXCEPT</p><p>(SELECT * FROM SP_SUBORD)</p><p>或等价地用下面的 SQL 语句：</p><p>SELECT *</p><p>FROM (TABLE SP_MGR EXCEPT TABLE SP_ SUBORD)</p><p>或用带 ALL 的 SQL 语句：</p><p>(SELECT * FROM SP_MGR)</p><p>EXCEPT ALL</p><p>(SELECT * FROM SP_SUBORD)</p><p><strong>例 42 查询籍贯为四川、课程成绩在 80 分以上的学生信息及其成绩。（自然连接）</strong></p><p>(SELECT * FROM STUDENTS</p><p>WHERE BPLACE&#x3D;‘ 四川 ’)</p><p>NATURAL JOIN</p><p>(SELECT * FROM ENROLLS</p><p>WHERE GRADE &gt;&#x3D;80)</p><p><strong>例3.43 列出全部教师的姓名及其任课的课程号、班级。</strong></p><p><strong>（外连接与外部并外连接允许在结果表中保留非匹配元组，空缺部分填以 NULL 。外连接的作用是在做连接操作时避免丢失信息。</strong></p><p><strong>外连接有 3 类：</strong></p><p><strong>（ 1 ）左外连接（ Left Outer Join ）。连接运算谓词为 LEFT [OUTER] JOIN ，其结果表中保留左关系的所有元组。</strong></p><p><strong>（ 2 ）右外连接（ Right Outer Join ）。连接运算谓词为 RIGHT [OUTER] JOIN ，其结果表中保留右关系的所有元组。</strong></p><p><strong>（ 3 ）全外连接（ Full Outer Join ）。连接运算谓词为 FULL [OUTER] JOIN ，其结果表中保留左右两关系的所有元组。）</strong></p><p>SELECT TNAME, CNO, CLASS</p><p>FROM TEACHERS LEFT OUTER JOIN TEACHING USING (TNO)</p><p><strong>SQL 的数据操纵</strong></p><p><strong>例 44 把教师李映雪的记录加入到教师表 TEACHERS 中。（插入）</strong></p><p>INSERT INTO TEACHERS</p><p>VALUES(1476 ， ‘ 李映雪 ‘ ， 44 ， ‘ 副教授 ‘)</p><p><strong>例 45 成绩优秀的学生将留下当教师。</strong></p><p>INSERT INTO TEACHERS (TNO ， TNAME)</p><p>SELECT DISTINCT SNO ， SNAME</p><p>FROM STUDENTS ， ENROLLS</p><p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO ANDGRADE ＞＝ 90</p><p><strong>例 47 把所有学生的年龄增加一岁。（修改）</strong></p><p>UPDATE STUDENTS</p><p>SET AGE ＝ AGE+1</p><p><strong>例 48 学生张春明在数据库课考试中作弊，该课成绩应作零分计。</strong></p><p>UPDATE ENROLLS</p><p>SET GRADE ＝ 0</p><p>WHERE CNO ＝ ‘C1’ AND</p><p>‘ 张春明 ‘ ＝</p><p>(SELECT SNAME</p><p>FROM STUDENTS</p><p>WHERE STUDENTS.SNO&#x3D;ENROLLS.SNO)</p><p><strong>例 49 从教师表中删除年龄已到 60 岁的退休教师的数据。（删除）</strong></p><p>DELETE FROM TEACHERS</p><p>WHERE AGE ＞＝ 60</p><p><strong>SQL 的数据控制</strong></p><p><strong>例 50 授予 LILI 有对表 STUDENTS 的查询权。（表／视图特权的授予</strong></p><p><strong>一个 SQL 特权允许一个被授权者在给定的数据库对象上进行特定的操作。授权操作的数据库对象包括：表 &#x2F; 视图、列、域等。授权的操作包括： INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 、 UNDER 、 USAGE 、 EXECUTE 等。其中 INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 有对表做相应操作的权限，故称为表特权。）</strong></p><p>GRANT SELECT ON STUDENTS</p><p>TO LILI</p><p>WITH GRANT OPTION</p><p><strong>例 51 取消 LILI 的存取 STUDENTS 表的特权。</strong></p><p>REVOKE ALL</p><p>ON STUDENTS</p><p>FROM LILI CASCADE</p><p>**不断补充中：</p><ol><li>模糊查找:<br> **它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。<br> 　　可使用以下通配字符：<br> 　　百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。<br> 　　下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。<br> 　　方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。[^]：其取值也[]相同，但它要求所匹配对象为指定字符以外的任一个字符。<br> 例如：<br> 　　限制以Publishing结尾，使用LIKE ‘%Publishing’<br> 　　限制以A开头：LIKE ‘[A]%’<br> 　　限制以A开头外：LIKE ‘[^A]%’</li></ol><p>**2.更改表格　**<br>ALTER TABLE table_name<br>ADD COLUMN column_name DATATYPE<br>说明：增加一个栏位（没有删除某个栏位的语法。)<br>ALTER TABLE table_name<br>ADD PRIMARY KEY (column_name)<br>说明：更改表得的定义把某个栏位设为主键。<br>ALTER TABLE table_name<br>DROP PRIMARY KEY (column_name)<br>说明：把主键的定义删除。</p><p><strong>3.group by</strong></p><p>在select 语句中可以使用group by 子句将行划分成较小的组，然后，使用聚组函数返回每一个组的汇总信息，另外，可以使用having子句限制返回的结果集。group by 子句可以将查询结果分组，并返回行的汇总信息Oracle 按照group by 子句中指定的表达式的值分组查询结果。</p><p>在带有group by 子句的查询语句中，在select 列表中指定的列要么是group by 子句中指定的列，要么包含聚组函数</p><p>select max(sal),job emp group byjob;<br>(注意max(sal),job的job并非一定要出现，但有意义)</p><p>查询语句的select 和group by ,having 子句是聚组函数唯一出现的地方，在where 子句中不能使用聚组函数。</p><p>select deptno,sum(sal) from empwhere sal&gt;1200 group by deptno having sum(sal)&gt;8500 order by deptno;</p><p>当在gropu by 子句中使用having 子句时，查询结果中只返回满足having条件的组。在一个sql语句中可以有where子句和having子句。having 与where 子句类似，均用于设置限定条件</p><p>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。<br>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</p><p>查询每个部门的每种职位的雇员数<br>select deptno,job,count(*) from emp group by deptno,job;</p><p><strong>4.外连接与内连接</strong></p><p>有时候，即使在连接的表中没有相应的行，用户可能想从一张表中看数据，Oracle提供了外连接实现该功能。<br>内连接是指连接查询只显示完全满足连接条件的记录，即等值连接，外连接的查询结果是内连接查询结果的扩展。外连接不仅返回满足连接条件的所有记录而且也返回了一个表中那些在另一个表中没有匹配行的记录。外连接的操作符是“+”。“+”号放在连接条件中信息不完全的那一边（即没有相应行的那一边）。运算符“+”影响NULL行的建立。建一行或多行NULL来匹配连接的表中信息完全的行。</p><p>外连接运算符“+”只能出现在where子句中表达式的一边。</p><p>假如在多张表之间有多个连接条件，外连接运算符不能使用or,in逻辑运算符与其它条件组合。</p><p>假如emp表中deptno&#x3D;10的ename为空值，dept表中deptno&#x3D;20的loc为空值：</p><ol><li></li></ol><p>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno(+)&#x3D;dept.deptno;</p><p>如果在dept.deptno中有的数值在emp.deptno中没有值，则在做外连接时，<br>结果中ename会产生一个空值。(emp.deptno&#x3D;10)</p><ol start="2"><li></li></ol><p>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno&#x3D;dept.deptno(+);</p><p>如果在emp.deptno中有的数值在dept.deptno中没有值，则在做外连接时，<br>结果中loc会产生一个空值。。(dept.deptno&#x3D;20)</p><p><strong>5.自连接</strong></p><p>自连接是指同一张表的不同行间的连接。该连接不受其他表的影响。用自连接可以比较同一张表中不同行的某一列的值。因为自连接查询仅涉及到某一张表与其自身的连接。所以在from子句中该表名出现两次，分别用两个不同的别名表示，两个别名当作两张不同的表进行处理，与其它的表连接一样，别名之间也使用一个或多个相关的列连接。为了区分同一张表的不同行的列，在名前永别名加以限制。</p><p>select<br>worker.ename,<br>manager.ename manager<br>from<br>emp worker,<br>emp manager<br>where<br>work.mgr&#x3D;manager.empno;</p><p><strong>6.集合运算</strong></p><p>基合运算符可以用于从多张表中选择数据。</p><p>①UNION运算<br>用于求两个结果集合的并集（两个结果集合的所有记录），并自动去掉重复行。</p><p>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;</p><p>注：ename,sal 是必须一致的。</p><p>②UNION ALL运算<br>用于求两个结果集合的并集（两个结果集中的所有记录），并且不去掉重复行。</p><p>select ename,sal from account wheresal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;</p><p>③INTERSECT运算<br>intersect运算返回查询结果中相同的部分。</p><p>各部门中有哪些相同的职位？</p><p>select Job from account<br>intersect<br>select Job from research<br>intersect<br>select Job from sales;</p><p>④MINUS运算<br>minus返回两个结果集的差集。（在第一个结果集中存在的，而在第二个结果集中不存在的行。）</p><p>有那些职位是财务部中有，而在销售部门中没有？</p><p>select Job from account<br>minus<br>select Job from sales;</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> SQL语句练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xshell</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/05_Xshell/05_Xshell/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/05_Xshell/05_Xshell/</url>
      
        <content type="html"><![CDATA[<p><strong>Xshell 是一个强大的远程管理软件，它支持SSH，TELNET 协议。Xshell可以在Windows下访问远端服务器、路由器、网络机顶盒等，类似的常用软件还有putty，以及Windows下的Telnet。</strong></p><p><strong>下面简单介绍一下xshell软件。</strong></p><p><strong>Xshell的几个特点：</strong></p><p><strong>1、界面设计简洁、人性，使用方便。</strong></p><p><strong>2、支持标签，打开多个服务器时候很方便，点击标签切换。</strong></p><p><strong>3、可以保存密码，注意安全，尽量不要保存，除非个人电脑。</strong></p><p><strong>Xshell下载安装及基本使用方法：</strong></p><p><strong>1、从网上搜索下载，注意别下载错了，很多混有病毒的。我一般用来管理自己的路由器，本地局域网内，用的是xshell4绿色中文版的。</strong></p><p><strong>2、打开xshell。</strong></p><p><img src="/assets/image-20211122223946-4zmezpj.png" alt="image.png"></p><p><strong>3、个性化设置。设置好，用起来更顺手。经过这样设置，以后使用事半功倍。其他地方，根据自己的喜好，可以进行相关设置。</strong></p><p><img src="/assets/image-20211122223957-ut3oqle.png" alt="image.png"></p><p><strong>4、连接服务器或路由器。点击打开。</strong></p><p><img src="/assets/image-20211122224005-2ek1wc5.png" alt="image.png"></p><p><strong>5、点击左上角，新建</strong></p><p><img src="/assets/image-20211122224012-un6v0dw.png" alt="image.png"></p><p><strong>6、填写完，点击确定。其他高级参数，有需要可以填写。常用的主机或路由器，可以点击身份验证，填写用户名和密码，这样不需要输入就可以直接登录系统了。</strong></p><p><img src="/assets/image-20211122224019-r50vjsq.png" alt="image.png"></p><p><strong>7、第一次连接会出现提示，如下图。</strong></p><p><img src="/assets/image-20211122224026-fmhe8f2.png" alt="image.png"></p><p><strong>8、登录成功，可以输入相关命令，进行各种操作。</strong></p><p><img src="/assets/image-20211122224032-ktayq76.png" alt="image.png"></p><p><strong>xshell几个常用命令以及注意事项：</strong></p><p><strong>cd .. 回到上级目录</strong></p><p><strong>cd xx 进入xx目录</strong></p><p><strong>rm xx 删除文件xx</strong></p><p><strong>rm -rf 删除目录及其所包含的所有文件，</strong>高危命令，一定谨慎</p><p><strong>mkdir xx 创建目录xx</strong></p><p><strong>vi 查看&#x2F;编辑文件 按 i进入编辑模式；按Esc键退出编辑模式。按:q退出不保存； 按：wq保存退出。</strong></p><p><strong>更多命令可以搜索，不同系统命令可能有所区别。</strong></p><p><strong>以上就是对xshell软件的简单介绍，以及几点注意事项和个人的心得体会。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> Xshell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/04_VMware/04_VMware/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/04_VMware/04_VMware/</url>
      
        <content type="html"><![CDATA[<p>1、准备工作<br>VMware Workstation虚拟机软件<br><a href="https://www.vmware.com/cn/products/workstation-pro.html">VMware Workstation官网</a><br>系统镜像 （使用ContOS 7示例）<br><a href="https://www.centos.org/download/">ContOS 官网下载地址</a><br>2.载入镜像</p><p><img src="/assets/image-20211221100125-tks1t19.png" alt="image.png"></p><p><img src="/assets/image-20211221100132-b8cmgz5.png" alt="image.png"><img src="/assets/image-20211221100140-5a5rsrv.png" alt="image.png"></p><p><img src="/assets/image-20211221100151-6mia1zl.png" alt="image.png"></p><p><img src="/assets/image-20211221100156-57s3rzq.png" alt="image.png"></p><p><img src="/assets/image-20211221100200-rjkr466.png" alt="image.png"><img src="/assets/image-20211221100205-72zrms0.png" alt="image.png"><img src="/assets/image-20211221100258-myh67of.png" alt="image.png"></p><p>到此，我们就成功把系统镜像文件载入虚拟机了。</p><p>3、 安装系统<br>经过第二步系统启动后，进入这个页面，点击黑框，这时候，我们就可以操作ContOS系统了，放向键选中第一项，回车。进入系统安装。</p><p><img src="/assets/image-20211221100333-h0d8ib5.png" alt="image.png"></p><p>然后等待系统跑就行了。</p><p><img src="/assets/image-20211221100341-akkmb09.png" alt="image.png"></p><p><img src="/assets/image-20211221100348-scaymac.png" alt="image.png"></p><p><img src="/assets/image-20211221100423-3m50yno.png" alt="image.png"></p><p><img src="/assets/image-20211221100428-3lbq38z.png" alt="image.png"></p><p><img src="/assets/image-20211221100435-0moq65v.png" alt="image.png"></p><p><img src="/assets/image-20211221100452-rw65w8t.png" alt="image.png"></p><p><img src="/assets/image-20211221100503-2y2amz0.png" alt="image.png"></p><p>同样的，选择完毕后，点击Done</p><p><img src="/assets/image-20211221100546-f5zr9tf.png" alt="image.png"></p><p><img src="/assets/image-20211221100714-j9new7l.png" alt="image.png"></p><p><img src="/assets/image-20211221100551-w3o49xy.png" alt="image.png"></p><p>这里我是选择设置root用户密码，毕竟是虚拟机，直接用root用户就好了。</p><p><img src="/assets/image-20211221100558-47d8cxr.png" alt="image.png"></p><p><img src="/assets/image-20211221100604-6m9d9h9.png" alt="image.png"></p><p><img src="/assets/image-20211221100609-km8hmf7.png" alt="image.png"></p><p><img src="/assets/image-20211221100615-nil4aae.png" alt="image.png"></p><p>接下来等待开机就行了,直到下图界面，才开始操作</p><p><img src="/assets/image-20211221100624-jn8575d.png" alt="image.png"></p><p>ok，到此完成全部安装操作<br>然后配置ip：vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</p><pre><code>    修改ONBOOT=no 为    ONBOOT=yes                                                         重启系统</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> VMware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/03_soap%20UI/03_soap%20UI/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/03_soap%20UI/03_soap%20UI/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/02_postman/02_postman/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/02_postman/02_postman/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jmeter简单的性能测试</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/16_jmeter%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/16_jmeter%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是压力测试"><a href="#什么是压力测试" class="headerlink" title="什么是压力测试"></a>什么是压力测试</h1><p>顾名思义：压力测试，就是  被测试的系统，在一定的访问压力下，看程序运行是否稳定&#x2F;服务器运行是否稳定（资源占用情况）</p><p>比如： 2000个用户同时到一个购物网站购物，这些用户打开页面的速度是否会变慢，或者网站是否会奔溃</p><h1 id="做压力测试的常用工具"><a href="#做压力测试的常用工具" class="headerlink" title="做压力测试的常用工具"></a><strong>做压力测试的常用工具</strong></h1><p>做压力测试，一般要使用工具， 人工是没办法做的。   最常用的工具是LoadRunner, 但是LoadRunner毕竟是收费软件，而且使用上也比较复杂。 现在越来越多的人开始使用Jmeter来做压力测试。 免费， 而且使用上非常简单。</p><h1 id="做压力测试的步骤如下"><a href="#做压力测试的步骤如下" class="headerlink" title="做压力测试的步骤如下:"></a><strong>做压力测试的步骤如下:</strong></h1><ol><li>写脚本 或者录制脚本</li><li>使用用户自定义参数</li><li>场景设计</li><li>使用控制器，来控制 模拟多少用户。</li><li>使用监听器， 查看测试结果</li></ol><h1 id="本文做压力测试的例子"><a href="#本文做压力测试的例子" class="headerlink" title="本文做压力测试的例子"></a><strong>本文做压力测试的例子</strong></h1><p>本文举的实例是： 在一台电脑用Jmeter模拟200个用户，同时去使用bing搜索不同的关键字， 查看页面返回的时间是否在正常范围内。</p><h1 id="第一步：-使用CSV-Data-Set-Config-来参数化"><a href="#第一步：-使用CSV-Data-Set-Config-来参数化" class="headerlink" title="第一步： 使用CSV Data Set Config 来参数化"></a><strong>第一步： 使用CSV Data Set Config 来参数化</strong></h1><p>首先我们把测试需要用到的2个参数放在txt文件中，</p><p>新建一个data.txt文件，输入些数据， 一行有两个数据，用逗号分隔。</p><p><img src="/assets/wpsA389.tmp-20211222151639-v1yct5t.png"><img src="/assets/wpsA38A.tmp-20211222151639-jjq1wud.jpg"></p><p>启动Jmeter, 先添加一个Thread Group, 然后添加一个CSV Data Set Config (Add -&gt; Config Element -&gt; CSV Data Set Config)</p><p><img src="/assets/wpsA38B.tmp-20211222151639-2pu141a.png"><img src="/assets/wpsA38C.tmp-20211222151639-pau65wi.jpg"></p><h1 id="第二步：添加HTTP-Request"><a href="#第二步：添加HTTP-Request" class="headerlink" title="第二步：添加HTTP Request."></a><strong>第二步：添加HTTP Request.</strong></h1><p>我们添加http 请求，发送get 到 <a href="http://cn.bing.com/search?q=testteststtssdfds">http://cn.bing.com/search?q=</a>博客园+小坦克</p><p>选择Thread Group 右键 (Add -&gt;Sampler -&gt; HTTP Request)，  需要填的数据如下：</p><p><img src="/assets/wpsA38D.tmp-20211222151639-lnmmrhi.png"> <img src="/assets/wpsA38E.tmp-20211222151639-xufwtlv.jpg"></p><h1 id="第三步：-使用Thread-Group，-控制模拟多少用户"><a href="#第三步：-使用Thread-Group，-控制模拟多少用户" class="headerlink" title="第三步： 使用Thread Group， 控制模拟多少用户"></a><strong>第三步： 使用Thread Group， 控制模拟多少用户</strong></h1><p>选中Thread Group</p><p><img src="/assets/wpsA38F.tmp-20211222151639-q49txfd.png"> <img src="/assets/wpsA390.tmp-20211222151639-pzriw4y.jpg"></p><p>Number of Threads(users):     一个用户占一个线程，  200个线程就是模拟200个用户</p><p>Ramp-Up Period(in seconds):   设置线程需要多长时间全部启动。如果线程数为200 ，准备时长为10 ，那么需要1秒钟启动20个线程。也就是每秒钟启动20个线程。</p><p>Loop Count: 每个线程发送请求的次数。如果线程数为200 ，循环次数为10 ，那么每个线程发送10次请求。总请求数为200*10&#x3D;2000 。如果勾选了“永远”，那么所有线程会一直发送请求，直到选择停止运行脚本。</p><h1 id="第四步：-添加Summary-Report-用来查看测试结果"><a href="#第四步：-添加Summary-Report-用来查看测试结果" class="headerlink" title="第四步：  添加Summary Report 用来查看测试结果"></a><strong>第四步：  添加Summary Report 用来查看测试结果</strong></h1><p>选中Thread Group 右键(Add -&gt; Listener -&gt; Summary Report)</p><h1 id="第五步：-运行一下"><a href="#第五步：-运行一下" class="headerlink" title="第五步： 运行一下"></a><strong>第五步： 运行一下</strong></h1><p>到目前为止， 脚本就全写好了， 我们来运行下， 如何看下测试的结果</p><p><img src="/assets/wpsA391.tmp-20211222151639-p939i7p.png"><img src="/assets/wpsA392.tmp-20211222151639-w2xoqt3.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter简单的性能测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter监控服务器性能</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/17_Jmeter%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/17_Jmeter%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="jmeter也可以像loadrunner一样监控服务器CPU、内存等性能参数，不过需要安装一些插件"><a href="#jmeter也可以像loadrunner一样监控服务器CPU、内存等性能参数，不过需要安装一些插件" class="headerlink" title="jmeter也可以像loadrunner一样监控服务器CPU、内存等性能参数，不过需要安装一些插件"></a>jmeter也可以像loadrunner一样监控服务器CPU、内存等性能参数，不过需要安装一些插件</h3><h3 id="1、下载需要的jmeter插件"><a href="#1、下载需要的jmeter插件" class="headerlink" title="** 1、下载需要的jmeter插件**"></a>** 1、下载需要的jmeter插件**</h3><p><img src="/assets/image-20220326104327-nzp9r33.png" alt="image.png"></p><pre><code>   如图上面两个是jmeter插件，可以再下面的链接中下载：</code></pre><p><a href="https://jmeter-plugins.org/downloads/old">https://jmeter-plugins.org/downloads/old</a></p><p> 第三个是放在服务器中的，可在下面的度盘中下载：</p><p><a href="http://pan.baidu.com/share/link?shareid=2974853586&amp;uk=1528396991&amp;fid=512652594025385">http://pan.baidu.com/share/link?shareid=2974853586&amp;uk=1528396991&amp;fid=512652594025385</a></p><h3 id="2、解压压缩包"><a href="#2、解压压缩包" class="headerlink" title="2、解压压缩包"></a>2、解压压缩包</h3><p>参见包里面的说明文档：”Just copy the JAR file into JMeter’s lib&#x2F;ext directory.Then you can start JMeter and add additional items to your Test Plan.Java version 1.6 and JMeter 2.4 are required.”</p><p>所以我们需要找到解压包中的JAR文件，并拷贝到jmeter的lib&#x2F;ext目录下，这里下载的1.4版本的插件需要在jdk1.6及jmeter2.4以上的版本使用</p><p><img src="/assets/image-20220326104336-mnxzztx.png" alt="image.png"></p><p>   如上图，把的两个jar包放到JMeter的 lib&#x2F;ext目录下，重启jmeter，出现如下新增的组件，则说明启动成功</p><p><img src="/assets/image-20220326104342-izjjvmn.png" alt="image.png"></p><h3 id="3、-常用组件简要介绍："><a href="#3、-常用组件简要介绍：" class="headerlink" title="** 3、 常用组件简要介绍：**"></a>** 3、 常用组件简要介绍：**</h3><ol><li><strong>jp@gc - Bytes Throughput Over Time:</strong> 不同时间吞吐量展示（图表）<br> 聚合报告里，Throughput是按请求个数来展示的，比如说1.9&#x2F;sec，就是每s发送1.9个请求；而这里的展示是按字节Bytes来展示的图表</li><li>**jp@gc - Composite Graph： **混合图表<br> 在它的Graphs里面可以设置多少个图表一起展示，它可以同时展示多个图表</li><li><strong>jp@gc - Hits per Second：</strong> 每秒点击量</li><li><strong>jp@gc - PerfMon Metrics Collector</strong> <strong>：</strong>服务器性能监测控件，包括CPU，Memory，Network，I&#x2F;O等等</li><li><strong>jp@gc - Reponse Latencies Over Time：</strong> 记录客户端发送请求完成后，服务器端返回请求之前这段时间</li><li><strong>jp@gc - Reponse Times Distribution：</strong> 显示测试的响应时间分布，X轴显示由时间间隔分组的响应时间，Y轴包含每个区间的样本数</li><li><strong>jp@gc - Transactions per Second：</strong> 每秒事务数，服务器每秒处理的事务数</li></ol><p> 4、将监控服务器的serverAgent拷贝到需监测的服务器</p><p><img src="/assets/image-20220326104350-fmnkbou.png" alt="image.png"></p><pre><code>   windows服务器中启动startAgent.bat，Linux服务器启动startAgent.sh即可   在linux中启动 ./startAgent.sh 是，可能会提示：“-bash: ./startAgent.sh: 权限不够”，那么我们需要执行命令：   chmod +x startAgent.sh</code></pre><p><img src="/assets/image-20220326104359-7bjy6ks.png" alt="image.png"></p><h3 id="5、准备测试脚本"><a href="#5、准备测试脚本" class="headerlink" title="** 5、准备测试脚本**"></a>** 5、准备测试脚本**</h3><pre><code>    这里用到一个登陆测试系统的简单脚本做压力测试demo</code></pre><p><img src="/assets/image-20220326104405-5wtfz9j.png" alt="image.png"></p><h3 id="6、配置监控服务器性能参数的组件"><a href="#6、配置监控服务器性能参数的组件" class="headerlink" title="**  6、配置监控服务器性能参数的组件**"></a>**  6、配置监控服务器性能参数的组件**</h3><pre><code>    主要用到这个组件：jp@gc - PerfMon Metrics Collector，配置如下：</code></pre><p><img src="/assets/image-20220326104411-n8o04th.png" alt="image.png"></p><h3 id="7、设置负载，执行脚本，查看监控结果"><a href="#7、设置负载，执行脚本，查看监控结果" class="headerlink" title="7、设置负载，执行脚本，查看监控结果"></a>7、设置负载，执行脚本，查看监控结果</h3><p><img src="/assets/image-20220326104416-6yys6lr.png" alt="image.png"></p><h3 id="8、图表可导出成csv文件，配合聚合报告，分析服务器性能状况"><a href="#8、图表可导出成csv文件，配合聚合报告，分析服务器性能状况" class="headerlink" title="8、图表可导出成csv文件，配合聚合报告，分析服务器性能状况"></a>8、图表可导出成csv文件，配合聚合报告，分析服务器性能状况</h3>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> Jmeter监控服务器性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blazemeter</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/14_blazemeter(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/14_blazemeter(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/</url>
      
        <content type="html"><![CDATA[<p> blazemeter 插件：<a href="assets/BlazeMeter-20211210140654-8y5ux10.zip">BlazeMeter.zip</a></p><p> <strong>一、下载安装Chrome浏览器</strong></p><p> 　　地址：<a href="http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html%EF%BC%9B">http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html；</a></p><p> <strong>二、离线安装BLazeMeter插件</strong></p><p> 　　1、下载BlazeMeter插件，地址：<a href="https://www.chromefor.com/down/?wp_file=mbopgmdnpcbohhpnfglgohlbhfongabi/blazemeter-the-continuous_v3.2.2.crx&amp;tdd=1526367875">https://www.chromefor.com/down/?wp_file=mbopgmdnpcbohhpnfglgohlbhfongabi/blazemeter-the-continuous_v3.2.2.crx&amp;tdd=1526367875</a></p><p> 　　2、打开Chrome浏览器，按如下步骤操作</p><p> <a href="http://www.51testing.com/batch.download.php?aid=79445"><img src="/assets/image-20211210141231-08a4h1s.png" alt="image.png"></a></p><p> <a href="http://www.51testing.com/batch.download.php?aid=79446"><img src="/assets/image-20211210141236-o7wjrgi.png" alt="image.png"></a></p><p> 　　3、安装成功的标志：Chrome浏览器右上角出现如下标志，证明安装BlazeMeter成功了。</p><p> <a href="http://www.51testing.com/batch.download.php?aid=79447"><img src="/assets/image-20211210141241-4xws5a2.png" alt="image.png"></a></p><p> <strong>三、使用BlazeMeter录制，并导出.jmx文件</strong></p><p> 　<strong>1、用Chrome浏览器打开要<a href=""><strong>测试</strong></a>的网页，打开BlazeMeter界面，如下：</strong></p><p> <a href="http://www.51testing.com/batch.download.php?aid=79448"><img src="/assets/image-20211210141245-av7walp.png" alt="image.png"></a></p><p> <img src="/assets/image-20211210141249-5m0b3le.png" alt="image.png"></p><p> 　　注意，该界面前四个按钮在非登陆的状态下都可使用，但是.jmx按钮是录制完成后导出.jmx文件，只有在登录BlazeMeter状态下才可以使用。</p><p> 四、脚本录制过程</p><h3 id="1-2-插件介绍"><a href="#1-2-插件介绍" class="headerlink" title="1.2 插件介绍"></a>1.2 插件介绍</h3><h4 id="1-2-1-登录注册"><a href="#1-2-1-登录注册" class="headerlink" title="1.2.1 登录注册"></a>1.2.1 登录注册</h4><p> 点击右上角图标，等待几分钟左右进入注册界面，根据相关提示填入用户名和邮箱信息，保存即可进入BlazeMeter界面。此时，再进入插件界面用户已自动登录，参见图1-3。</p><p> <img src="/assets/image-20211210144911-ozdafn1.png" alt="image.png"></p><p> 图1-3 用户登录</p><h4 id="1-2-2-基本设置工程命名"><a href="#1-2-2-基本设置工程命名" class="headerlink" title="1.2.2 基本设置工程命名"></a>1.2.2 基本设置工程命名</h4><p> 在<img src="/assets/image-20211210144917-arhdvjw.png" alt="image.png">输入测试任务名称，录制完成后以此作为名字导出脚本。</p><p> 停止录制</p><p> 点击<img src="/assets/image-20211210144924-79zvbqp.png" alt="image.png">按钮，停止录制。</p><p> 开始录制</p><p> 点击<img src="/assets/image-20211210144929-oue8lzl.png" alt="image.png">按钮，开始页面录制。</p><p> 恢复默认值</p><p> 点击<img src="/assets/image-20211210144934-3ypmr68.png" alt="image.png">按钮，恢复默认值。</p><p> 使用场景</p><p> Perfornamce（Jmeter）：性能测试；</p><p> API Functional（Jmeter）：API功能测试；</p><p> GUI Functional（Selenium）：API功能测试；</p><p> End User Experence Monitoring（JMeter &amp; Selenium）：联合测试；</p><p> 更多细节，参见<a href="https://www.blazemeter.com/product/">https://www.blazemeter.com/product/</a></p><p> 编辑</p><p> JMeter Script：编辑Jmeter录制脚本后进行上传，参见图1-4；</p><p> <img src="/assets/image-20211210144938-4ny6cwk.png" alt="image.png"></p><p> 图1-4 编辑Jmeter录制脚本</p><p> Selenium：编辑Jmeter录制脚本后进行上传；</p><p> <img src="/assets/image-20211210144942-4z1huxi.png" alt="image.png"></p><p> 图1-5 编辑Selenium录制脚本</p><p> l 保存</p><p> 点击，选择保存类型JMeter（JMX）、Selenium only、JMeter &amp; Selenium combined（YAML）。</p><p> <img src="/assets/image-20211210144948-4evg0aq.png" alt="image.png"> <img src="/assets/image-20211210144951-cfmivha.png" alt="image.png"> <img src="/assets/image-20211210144955-evf4d5r.png" alt="image.png"></p><p> 图1-6 脚本保存类型</p><h4 id="1-2-3-高级设置"><a href="#1-2-3-高级设置" class="headerlink" title="1.2.3 高级设置"></a>1.2.3 高级设置</h4><p> 不再详细介绍。</p><h4 id="1-2-4-保存项目"><a href="#1-2-4-保存项目" class="headerlink" title="1.2.4 保存项目"></a>1.2.4 保存项目</h4><p> 在保存项目选项中，配置好账号、工作空间、项目，不填按照默认值填写，参见图1-7。</p><p> <img src="/assets/image-20211210145002-u47qpvl.png" alt="image.png"></p><p> 图1-7 保存选项</p><h3 id="1-3-Web录制"><a href="#1-3-Web录制" class="headerlink" title="1.3 Web录制"></a>1.3 Web录制</h3><p> 打开录制的网页，点击图标，开始页面录制，参见图1-8。</p><p> <img src="/assets/image-20211210145006-a8mqxb4.png" alt="image.png"></p><p> 图1-8 blazeMeter界面</p><p> 开始录制前在输入框中工程名称，点击开始录制按钮，可以观察到<img src="/assets/image-20211210145016-8g51qlz.png" alt="image.png">下数字一直在变化，说明界面操作事件被录制到，参见图1-9。</p><p> <img src="/assets/image-20211210145011-g0jdql8.png" alt="image.png"></p><p> 图1-9 BlazeMeter录制</p><p> 录制完成后点击图标，停止录制；点击<img src="/assets/image-20211210145021-1s5hw6m.png" alt="image.png">图标，选择导出脚本类型JMeter、Selenium only、Jmeter &amp; Selenium combined，直接导出录制脚本，参见图1-10。</p><p> 注意：JMeter需要先注册登录才能导出使用。勾选JMeter（JMX）生成Jmeter脚本并下载，参见图1-11。</p><p> <img src="/assets/image-20211210145025-hsmkj6c.png" alt="image.png"></p><p> 图1-10 直接导出JMX脚本</p><p> 或者点击<img src="/assets/image-20211210145030-tt1flfw.png" alt="image.png">编辑按钮，选择JMeter Script、Selenium一种类型，进入编辑界面，可以对脚本进行编辑，被选中编辑的内容高亮显示，参见图1-11，编辑完成后点击页面右上角<img src="https://img.jbzj.com/file_images/article/202112/2021120109093129.png">，选择一种保存类型后浏览器直接开始下载脚本到本地默认路径下。</p><p> <img src="/assets/image-20211210145035-g9uzrpm.png" alt="image.png"></p><p> 图1-11 编辑脚本后下载</p><p> 打开Jmeter界面，将下载到本地的JMX录制脚本直接拖到Jmeter窗口，BlazeMeter自动填充全局配置信息（Http信息头，抽取出接口环境变量），参见图1-11。</p><p> <img src="/assets/image-20211210145040-cpwrq55.png" alt="image.png"></p><p> <img src="/assets/image-20211210145044-f65h5ne.png" alt="image.png"></p><p> 图1-11 环境参数</p><p> 到此这篇关于Jmeter BlazeMeter实现web录制的文章就介绍到这了,</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> blazemeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>badboy</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/15_badboy(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/15_badboy(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/</url>
      
        <content type="html"><![CDATA[<p> <strong>Badboy工具介绍</strong></p><p> Badboy是一个强大的工具，被设计用于测试和开发复杂的动态应用。Badboy功能丰富（包括一个捕获&#x2F;重播接口，强大的压力测试支持，详细的报告、图形）使得测试和开发更加容易。bodbay 是一个录制脚本的工具，主要是搭配jmeter工具进行搭配。bodbay 适合小白使用，录制比较方便。</p><p> <strong>安装</strong><br> 下载地址：<a href="https://badboy.en.softonic.com/">https://badboy.en.softonic.com/</a>下载完成后进行安装，完毕。</p><p> 安装包：<a href="assets/badboy2.2.5-20211210150333-3tfp0p3.zip">badboy2.2.5.zip</a><br> <img src="/assets/image-20211210145212-qhs98i9.png" alt="image.png"></p><p> <strong>使用方法：</strong><br> 打开软件，可以看到如下操作界面<br> <img src="/assets/image-20211210145216-gwand93.png" alt="image.png"></p><p> 这里使用<a href="http://www.so.com进行演示,如下/">www.so.com进行演示，如下</a>:<br> <img src="/assets/image-20211210145221-4tattt4.png" alt="image.png"></p><p> 然后进行搜索Badboy关键字进行搜索<br> <img src="/assets/image-20211210145225-qy3jasq.png" alt="image.png"><br> 最后按暂停，进行回放，就可以看到刚刚的操作<br> <img src="/assets/image-20211210145241-95231ej.png" alt="image.png"></p><p> <strong>检查点的使用</strong><br> 停止录制后，添加检查点；选中搜索框中的关键词，点击工具栏中Tools→Add Assertion for selection<br> <img src="/assets/image-20211210145246-etw732c.png" alt="image.png"></p><p> 选择variables,右键选择Add Variable…<br> <img src="/assets/image-20211210145250-wolo6pw.png" alt="image.png"><br> <img src="/assets/image-20211210145254-wsh96bs.png" alt="image.png"><br> 最后进行检查点的替换，如下图：<br> <img src="/assets/image-20211210145259-eiyws6h.png" alt="image.png"><br> <img src="/assets/image-20211210145304-b6otgt6.png" alt="image.png"><br> <img src="/assets/image-20211210145308-wyfjqmc.png" alt="image.png"><br> <img src="/assets/image-20211210145312-8r05e4c.png" alt="image.png"></p><p> 最后选择回放：</p><p> 并发使用<br> <img src="/assets/image-20211210145317-hq1n6w8.png" alt="image.png"><br> <img src="/assets/image-20211210145322-9pgbji8.png" alt="image.png"><br> 测试报告<br> <img src="/assets/image-20211210145643-o87elku.png" alt="image.png"><br> <img src="/assets/image-20211210145647-384qtj6.png" alt="image.png"><br> <strong>其他说明</strong><br> <strong>其他相关配置说明</strong><br> Windows10+IE11+Badboy2.2.5</p><p> 提示：提示Badboy为201602版本，已经停止维护；</p><p> <strong>问题汇总</strong><br> 1)Badboy.exe，一运行就提示Badboy Script File 停止运行问题；</p><p> 处理方式：换电脑，运行没问题；检查端口占用、没占用；考虑软件冲突，卸载360、可能影响的软件，没解决；<br> 解决方式：重装系统。</p><p> 2)录制问题，用baidu，输入搜索条件，录制的url有问题； taobao，录制有问题，无法加载完成；<br> 解决方式：用<a href="https://www.jd.com/">https://www.jd.com</a></p><p> 3)参数化回放时，只回放一遍<br> 解决方式：重新设置录入参数，再回放，就ok了。</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> badboy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter 连接 MySQL数据库测试</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/12_jmeter%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/12_jmeter%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p> 1、下载安装mysql驱动包<br> 提供下载地址：<a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a></p><p> <img src="/assets/image-20220326104628-z3y3izm.png" alt="image.png"></p><p> 也可以自行百度搜索下载。</p><p> 下载完成之后，将mysql驱动放置到…\apache-jmeter-3.2\lib目录下。</p><p> <img src="/assets/image-20220326104637-3hy3v7z.png" alt="image.png"></p><p> 然后重新启动JMeter。</p><p> 2、测试计划添加mysql驱动</p><p> <img src="/assets/image-20220326104648-8ad0kyu.png" alt="image.png"></p><p> 3、配置JDBC<br> 给线程组添加配置原件&gt;JDBC Connection Configuration。</p><p> 1)Varible Name: 这个是变量的名字，具有唯一性，不能重复</p><ol start="2"><li>Database URL: jdbc:mysql:&#x2F;&#x2F;数据库地址:数据库端口号&#x2F;数据库名</li><li>JDBC Driver Class ：org.gjt.mm.mysql.Driver  或者 com.mysql.jdbc.Driver   这是固定值</li><li>Username：这个数据库的登录名</li><li>Password： 这个是数据库的登录密码</li><li><img src="/assets/image-20220326104701-ypfc3ln.png" alt="image.png"></li><li><img src="/assets/image-20220326104737-abfdea1.png" alt="image.png"></li></ol><p> 4、添加JDBC Request<br> 给线程组添加Sampler&gt;JDBC Request。</p><p> Variable Name：<br> 数据库连接池的名字，需要与上面配置的JDBC Connection Configuration中Variable Name Bound Pool的Variable Name相同<br> Query：填写的sql语句未尾不要加“;”<br> Parameter valus：参数值<br> Parameter types：参数类型，可参考：Javadoc for java.sql.Types<br> Variable names：保存sql语句返回结果的变量名<br> Result variable name：创建一个对象变量，保存所有返回的结果<br> Query timeout：查询超时时间<br> Handle result set：定义如何处理由callable statements语句返回的结果</p><p> <img src="/assets/image-20220326104745-60ube5i.png" alt="image.png"></p><p> 5、添加查看结果树，运行线程组，查看结果</p><p> <img src="/assets/image-20220326104754-janco21.png" alt="image.png"></p><p> 6、其他地方引用查询结果作为参数<br> 我们需要在JDBC Request中设置Variable names作为参数名，该参数名也具有唯一性，必须不与其他变量名重复。</p><p> 上图中我们已经设置了Variable names&#x3D;UserName。</p><p> 我们的SQL语句只查询了UserName这一个字段，那么我们想要引用第1个UserName，可以如下书写：${UserName_1}；第2个可以如下书写：${UserName_2}，依次类推。</p><p> <img src="/assets/image-20220326104807-cnwxb7i.png" alt="image.png"></p><p> 以下是JMeter帮助文档中的介绍：</p><p> <img src="/assets/image-20220326104814-x9ytcpj.png" alt="image.png"></p><h1 id="jmeter使用beanshell和jdbc-将sql查询出来的数据写入文件中"><a href="#jmeter使用beanshell和jdbc-将sql查询出来的数据写入文件中" class="headerlink" title="jmeter使用beanshell和jdbc 将sql查询出来的数据写入文件中"></a>jmeter使用beanshell和jdbc 将sql查询出来的数据写入文件中</h1><p> 需求<br> 通过sql查询结果，将结果写入scv文件中。<br> 1<br> 思路<br> 1、使用jdbc取样器获取sql查询结果<br> 2、使用beanshell将查询结果写入指定的文件中。</p><p> 操作步骤<br> 1、创建一个配置原件JDBC Connection Configuration，如下图</p><p> <img src="/assets/image-20220326150842-uw0e7l1.png" alt="image.png"></p><p> 2、创建一个jdbc request 请求，如下图：</p><p> <img src="/assets/image-20220326150851-j6kt7mi.png" alt="image.png"></p><p> 3、创建一个beanshell取样器，如下图</p><p> <img src="/assets/image-20220326150857-sv6vur8.png" alt="image.png"></p><blockquote><p>&#x2F;&#x2F;创建文件对象<br>FileWriter fw &#x3D;new FileWriter(“d:\deviceNum.csv”,true);</p><p>&#x2F;&#x2F;创建一个字符缓存输出流<br>BufferedWriter bufw&#x3D;new BufferedWriter (fw);<br>&#x2F;&#x2F;获取sql查询结果的行数<br>String num&#x3D;vars.get(“deviceNum_#”);<br>&#x2F;&#x2F;字符串转换成int<br>int count &#x3D; Integer.parseInt(num);<br>&#x2F;&#x2F;控制循环次数，写入count行文件<br>for(int i&#x3D;1;i&lt;&#x3D;count;i++){<br>    &#x2F;&#x2F;获取sql查询结果第i行的数据<br>    str&#x3D;vars.get(“deviceNum_”+i);<br>    &#x2F;&#x2F;将数据写入磁盘文件中<br>    bufw.write(str);<br>    &#x2F;&#x2F;换行<br>    bufw.write(“\r\n”);<br>}<br>&#x2F;&#x2F;文件写入结束后，关闭流<br>bufw.close();<br>fw.close();<br><br /></p></blockquote><p> 4、执行，查看结果，生成了文件，并查看文件内容。</p><p> <img src="/assets/image-20220326151132-f02glae.png" alt="image.png"></p><p> <img src="/assets/image-20220326151136-6ejnxww.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> JMeter 连接 MySQL数据库测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter接口自动化</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/13_Jmeter%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/13_Jmeter%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p> 目录   ：  来源：<a href="https://blog.csdn.net/weixin_46518133/article/details/121516830">(36条消息) Jmeter接口自动化_陈晴chenqing的博客-CSDN博客_jmeter自动化</a></p><p> 变更记录变更日期变更说明附件2021-02-26【TestReport名称优化】将html报告名称index.html 改为动态变化的（不然每次生成的报告Html报告都会把原有的报告覆盖）详细见【五-8】📎build.xml</p><p> 一、JMeter简介</p><p> 二、JMeter 基本使用</p><ol><li>启动Jmeter</li><li>设置为中文版(根据个人喜好)</li><li>配置元件-Http Cookie管理器</li></ol><p> 4.断言</p><p> 5.接口关联（Json提取器&amp;正则表达式提取器）</p><p> 6.Jmeter数据驱动</p><p> 7.JDBC Request</p><p> 8.函数助手</p><p> 9.BeanShell</p><p> 10.Jmeter事物&#x2F;模块控制器</p><p> 三、Ant简介</p><p> 四、Jenkins介绍及安装配置</p><p> 五、Jmeter自动化测试的配置</p><ol><li>原理</li><li>Jmeter.property配置</li><li>Ant配置</li><li>Jenkins 配置-相关插件安装</li><li>邮件通知配置</li><li>Ant build.xml 文件</li><li>运行-看结果</li><li>配置过程中遇到的问题总结</li><li>分享中提到的关于TestReport的名称优化</li></ol><blockquote><div class="table-box"><table id="f0sx4"><tbody><tr><td colspan="3"> <p id="cecccdb2ff1ee959ba8a5b48d7fb9a87"><strong>演示文档（2021-02-25）</strong></p> </td></tr><tr><td> <p id="40710764d5260149b37ef7014227487b">1</p> </td><td> <p id="d3ca34bca2b3d164fd4b2dd1c9747479"><a href="https://so.csdn.net/so/search?q=Jmeter&spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{"spm":"1001.2101.3001.7020","dest":"https://so.csdn.net/so/search?q=Jmeter&spm=1001.2101.3001.7020"}" data-tit="Jmeter" data-pretit="jmeter">Jmeter</a> 脚本</p> </td><td> <p id="8be3c97346a1e903bd4c391a60fd65ce"><a href="https://www.yuque.com/attachments/yuque/0/2021/jmx/136643/1614238704259-cb8bb684-4e14-4317-8337-a9edbfe9813e.jmx" id="WfbNf" title="📎testDemo.jmx">📎testDemo.jmx</a></p> </td></tr><tr><td> <p id="9f7af416c864fbbb76ef0f01e59c8949">2</p> </td><td> <p id="f625fa9f1b0d44a668793f59b9b879fd_p_0">build.xml 文件</p> </td><td> <p id="b6e722eb507baf32cac65fbe5e13b0b9"><a href="https://www.yuque.com/attachments/yuque/0/2021/xml/136643/1614238731270-c114447b-b516-4d8e-b028-210b75de56e2.xml" id="D7TVC" title="📎build.xml">📎build.xml</a></p> </td></tr><tr><td> <p id="a20d224c568e48b9d67847a2c66a8c01_p_0">3</p> </td><td> <p id="b5c06d45b8d476b78b70091a4b612fa8_p_0">PPT</p> </td><td> <p id="1e75db477fa0689b45d27536bb379750"><a href="https://www.yuque.com/attachments/yuque/0/2021/pptx/136643/1614238817575-7d736599-743a-4e13-87e7-7eb84c5d88cf.pptx" id="weRQJ" title="📎Jmeter+Ant+Jenkins接口自动化测试-20210225.pptx">📎Jmeter+Ant+Jenkins接口自动化测试-20210225.pptx</a></p> </td></tr><tr><td> <p id="u2692a67c">4</p> </td><td> <p id="28f0509faa924657fc4f6292ddb8463d_p_0">CSV文件</p> </td><td> <p id="u6b9a0b16"><a href="https://www.yuque.com/attachments/yuque/0/2021/csv/136643/1614238743200-e97b2b2c-1d22-490f-983b-1111b61db9be.csv" id="HsnWU" title="📎计数器演示.csv">📎计数器演示.csv</a><a href="https://www.yuque.com/attachments/yuque/0/2021/csv/136643/1614238743397-6115e40b-5b16-4357-b1b0-7dbe1e079d45.csv" id="Gm7Bp" title="📎jmeter数据驱动演示.csv">📎jmeter数据驱动演示.csv</a></p> </td></tr></tbody></table></div></blockquote><p> 一、JMeter简介<br> 二、JMeter 基本使用</p><ol><li>启动Jmeter<br> MAC启动Jmeter，进入到jmeter的bin目录下 ，运行以下命令</li></ol><p> sh jmeter</p><p> <img src="/assets/image-20220329110728-p8yq4py.png" alt="image.png"></p><ol start="2"><li><p>设置为中文版(根据个人喜好)<br> 进入jmeter -bin目录下，找到jmeter.properties 文件，设置language&#x3D;zh_CN，设置完需要重启Jmeter</p><p> <img src="/assets/image-20220329110738-012ezuy.png" alt="image.png"></p></li><li><p>配置元件-Http Cookie管理器<br> 配置元件（Config Element）用于提供对静态数据配置的支持，Http Cookie管理器可以用来对 HTTP Request Sampler 的 cookie 进行管理</p></li></ol><p> 如果想要Jmeter像浏览器一样，保存cookie，那么可以借助“配置元件-Http Cookie管理器”，</p><p> （1）若没有 Http Cookie管理器：</p><p> <img src="/assets/image-20220329110751-cekwjn7.png" alt="image.png"></p><p> （2）当我们第一个请求，有了cookie之后，那么“Http Cookie管理器”就会保存这个cookie，给后面的请求用，就像在浏览器里的用法一样</p><p> <img src="/assets/image-20220329110759-9twhwms.png" alt="image.png"></p><p> 4.断言<br> 比较重要的断言主要有：响应断言(Response Assertion)、大小断言(Size Assertion)、持续时间断言(Duration Assertion)</p><p> （1）响应断言(Response Assertion)</p><p> ①响应文本(Test Response)断言</p><p> 断言内容 –相当于预期结果</p><p> <img src="/assets/image-20220329110812-jvc7c57.png" alt="image.png"></p><p> 响应中看到的数据 –相当于实际结果</p><p> <img src="/assets/image-20220329110844-gioik3d.png" alt="image.png"></p><p> 执行脚本后，若实际结果与预期结果不一致，则断言失败</p><p> <img src="/assets/image-20220329110854-hegwwd0.png" alt="image.png"></p><p> ②响应代码(Response Code)断言</p><p> 设置断言，假设Response Code预期应为500</p><p> <img src="/assets/image-20220329110900-2q9ure7.png" alt="image.png"></p><p> 实际运行结果，Response Code 为200</p><p> <img src="/assets/image-20220329110907-fvv6jl7.png" alt="image.png"></p><p> 则断言失败</p><p> （2）大小断言(Size Assertion)</p><p> 验证生成的响应的大小，以字节为单位，这也是吞吐量参数，当我们加负载的时候，若网站处理不过来时，就可能出现有的数据没有加载出来，这时的就不会返回完整的字节大小，当我们加负载时，我们也会参考这个参数，看看是否完全加载出来</p><p> <img src="/assets/image-20220329110922-z7yzpnx.png" alt="image.png"></p><p> <img src="/assets/image-20220329110927-a25tlos.png" alt="image.png"></p><p> <img src="/assets/image-20220329110934-qzvoi78.png" alt="image.png"></p><p> （3）持续时间断言(Duration Assertion)-主要用来验证性能指标</p><p> 当我们在断言中，设置为1000时，代表最大耗时不能超过1000ms</p><p> 这边为了演示断言出错，持续时间故意设置比较短，方便查看效果</p><p> <img src="/assets/image-20220329110941-xhqopv6.png" alt="image.png"></p><p> 断言失败，并给出提示</p><p> <img src="/assets/image-20220329110946-dpcmple.png" alt="image.png"></p><p> 通过“监听器-用表格查看结果”来看下这个sample的持续时间</p><p> <img src="/assets/image-20220329110954-bosq9nn.png" alt="image.png"></p><p> 5.接口关联（Json提取器&amp;正则表达式提取器）<br> 我们在进行接口测试时，一般会有业务场景的关联性，接口关联就是把应用中动态变化返回的数据获取到，把它保存为一个参数，提供给后面需要用到的地方进行使用。</p><p> 最常见的比如登录的接口会返回一个token，便于之后其他接口调用时来认证身份，那么这个时候，我们就需要通过接口关联来实现参数传递，最常用的方法有两种，一个是Json提取器，一个是正则表达式提取器</p><p> <img src="/assets/image-20220329111002-2mbz4a9.png" alt="image.png"></p><p> (1)Json 提取器</p><p> 我们先来看下登录接口返回参数中，是否能把pytoken这个值取到，其中$表示根元素，图中$.data.pyToken为Json路径表达式</p><p> <img src="/assets/image-20220329111011-dsqe93e.png" alt="image.png"></p><p> 然后在登录接口里添加后置处理器-json提取器，用json path表达式取到得值，放在pyToken这个变量里</p><p> Names of created variables ：接收值的变量名，自定义</p><p> JSON Path expression： json path表达式</p><p> Match No.(0 for Random)：1 代表匹配获取到的第一个值，我们这边只有一个值（0表示随机；n取第几个匹配值；-1匹配所有。若只要获取到匹配的第一个值，则填写1）</p><p> Default Values： 缺省值，匹配不到值的时候取该值，可写error也可不写</p><p> <img src="/assets/image-20220329111038-yu16ymc.png" alt="image.png"></p><p> 我们也可以使用调试取样器（Debug Sample）来查看pyToken取值是否正确</p><p> <img src="/assets/image-20220329111050-nndd4wc.png" alt="image.png"></p><p> 对json提取器取到的值，进行变量引用，格式为${变量名}，所以此处为 ${pyToken}</p><p> <img src="/assets/image-20220329111056-x39n204.png" alt="image.png"></p><p> (2)正则表达式提取器</p><p> 运行登录接口，查看响应结果，把需要提取的数据复制出来，然后用正则表达式代替即可</p><p> <img src="/assets/image-20220329111104-lutkk9n.png" alt="image.png"></p><p> “pyToken”:”03d8aa93-8f52-471f-8c12-f51a692ae7b5”}}</p><p> –&gt; 可以看到黄色部分，我们使用(.+?)进行了替代，因为黄色部分是动态变化的</p><p> <img src="/assets/image-20220329111112-z0y8vtn.png" alt="image.png"></p><p> 说明：</p><p> . 代表：匹配换行符\n之外的任何单字符</p><p> +代表：匹配前面的子表达式一次或多次</p><p> ?代表：匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</p><p> 关于正则表达式的语法可参考：正则表达式 – 语法 | 菜鸟教程</p><p> 模板(Template)–&gt; $0$ 代表取正则表达式输入项内输入的值，$1$指取第一个括号内的内容，此处即为.+?</p><p> 匹配数字(Match No.) –&gt;若jmeter在匹配Regular Expression中的值时，匹配出了多项，那么Jmeter是不知道要取哪个值的，所以可以用来指定，比如输入1，即匹配查到的第一个值</p><p> 缺省值（Default Value） –&gt;默认值，设置默认值，若匹配不到，则使用默认值</p><p> 6.Jmeter数据驱动<br> Jmeter里参数化一般分为①从文件里读数据，②从数据库里读数据，③用后置处理器从响应里读数据(第五节中就是从后置处理器中进行数据读取)</p><p> 数据驱动的目标就是，我们在单独的一个Execl里来维护数据，而不是在请求里面硬编码</p><p> (1)添加配置元素-CSV Data Set Config</p><p> 数据驱动csv文件：<img src="/assets/image-20220329111123-8vn9dch.png" alt="image.png"></p><p> <img src="/assets/image-20220329111128-3vksb6n.png" alt="image.png"></p><p> <img src="/assets/image-20220329111133-0wri3fv.png" alt="image.png"></p><p> <img src="/assets/image-20220329111137-y9f44d1.png" alt="image.png"></p><p> 设置线程数2，运行后结果查看：</p><p> <img src="/assets/image-20220329111145-dbl0nse.png" alt="image.png"></p><p> CSV数据文件设置字段说明：</p><p> ① 变量名称(Variable Names)：需要输入文本里各列都叫什么名字</p><p> ② 分隔符(Delimiter)：用英文的逗号隔开</p><p> ③遇到文件结束符再次循环？(Recycle on EOF？)：数据再循环，例如设置为True，我们的CSV中共有7条数据，但是我们有10个用户，那么第8个用户就会就会从第一条数据开始，再次循环取值</p><p> ④遇到文件结束符停止线程？(Stop thread on EOF?)：例如是true，执行了文件，则停止运行，如果是False，执行了文件，不停止线程，当Recycle on EOF设置为True时，此项设置无效。</p><p> 注意点：</p><p> ①文件一定要保存.csv格式</p><p> ②当csv文件在jmeter的bin目录或脚本目录时，只需给出文件名即可</p><p> (2)用函数助手参数化-从csv文件取数据</p><p> 依然使用（1）中的csv文件</p><p> <img src="/assets/image-20220329111154-cxrpva0.png" alt="image.png"></p><p> 点击生成后，就拷贝到粘贴板上，直接去粘贴就可以了</p><p> <img src="/assets/image-20220329111203-88y4cc4.png" alt="image.png"></p><p> <img src="/assets/image-20220329111208-rez34ee.png" alt="image.png"></p><p> (3)计数器</p><p> 在CSV里读数据，不管是用CSV Date Set Config还是用函数助手，那些数据都可能重复，我们都是手动的把它设置成不一样，如果我们不想一直去修改csv的数据，那么可以使用计数器，这样我们只需要修改计数器的起始点，最大值等，就能通过csv里的测试数据和计数器使得测试数据不重复</p><p> 来看下计数器的定义：允许用户在线程组中任何位置创建引用的计数器。 计数器配置允许用户配置起始点，最大值和增量。 计数器将从开始循环到最大，然后从开始重新开始，继续进行，直到测试结束。</p><p> 我们以函数助手参数化为实例（CSV Data Set Config同理）来实战一下</p><p> ①设置计数器</p><p> <img src="/assets/image-20220329111219-o15996z.png" alt="image.png"></p><p> a. Staring value：开始值，比如设置为1</p><p> b. 递增(Increment) ：递增值，比如设置为2，那么从1开始，下一个数就是3，是两个两个递增的</p><p> c. Maximum value： 最大值，比如设置10，就是涨到10就不涨了</p><p> d. 数字格式(Number format)： 什么格式的，比如我写00，则是01，02，03一直到10，如果写的是000，则是001，002，003这种</p><p> e. 引用名称(Exported Variable Name)：变量名，比如就叫num</p><p> ②设置csv文件</p><p> <img src="/assets/image-20220329111228-6rorvdl.png" alt="image.png"></p><p> ③函数助手设置</p><p> <img src="/assets/image-20220329111234-gepxtrv.png" alt="image.png"></p><p> ④根据计数器和函数助手设置接口变量</p><p> <img src="/assets/image-20220329111239-xibw7da.png" alt="image.png"></p><p> ⑤运行查看结果（此处实例中用了循环控制器，一个线程，但设置新增项目进度接口循环五次），查看结果</p><p> <img src="/assets/image-20220329111246-r6y3m5l.png" alt="image.png"></p><p> <img src="/assets/image-20220329111256-fby96lv.png" alt="image.png"></p><p> <img src="/assets/image-20220329111301-9n038tm.png" alt="image.png"></p><p> ⑥计数器的定义中提到： 计数器将从开始循环到最大，然后从开始重新开始，继续进行，直到测试结束</p><p> 这个是指，如果我循环的次数（或者是线程数）多于开始到最大的总数，那么会从开始的值继续执行，知道我们设置的循环次数（或者是线程数）执行完毕，例如设置开始数字1，递增是2，最大值是10，而我们设置的循环次数或者是线程数是 7，则num 分别为1，3，5，7，9，1</p><p> ⑦与每个用户独立的跟踪计数器(Track counter independently for each user)：若勾选这一项，则代表每个用户（线程）是独立计数的，我们可以设置线程数是2，循环次数是3，来看下效果</p><p> <img src="/assets/image-20220329111309-5qtrwom.png" alt="image.png"></p><p> 7.JDBC Request<br> 要用这个JDBC Request，需要配置下数据库链接 添加(Add)–&gt;配置与案件(Config Element) –&gt;JDBC链接配置(JDBC Connection Configuration)</p><p> 网站：JDBC Driver List | SoapUI 可以下载JDBC的Driver，还可以找到不同数据库的链接地址，不同的数据库，有不同的链接地址和数据库驱动</p><p> (1)配置</p><p> ①下载数据库驱动</p><p> <img src="/assets/image-20220329111322-ii079cw.png" alt="image.png"></p><p> 按照提示进行下载，下载解压后，将文件夹中的两个jar包中的一个，拷贝到Jmeter的lib目录下</p><p> <img src="/assets/image-20220329111328-7074j17.png" alt="image.png"></p><p> 为了方便大家下载，此处提供mysql driver的网盘下载地址：<a href="https://pan.baidu.com/s/1rSz0cEvAhAElPC9WPO44mw">https://pan.baidu.com/s/1rSz0cEvAhAElPC9WPO44mw</a>  密码:pxuv</p><p> ②复制数据库连接地址(这个也可以直接问开发要)</p><p> <img src="/assets/image-20220329111335-mr908un.png" alt="image.png"></p><p> 复制链接地址到 Database URL里，并在图中红框之后维护你的数据库的地址和端口号，后面的用户名和密码可以删除，因为Jmeter后面可以直接维护</p><p> <img src="/assets/image-20220329111343-9722roi.png" alt="image.png"></p><p> ③JDBC Driver class(mysql的固定写法是 com.mysql.jdbc.Driver)</p><p> <img src="/assets/image-20220329111353-tac4hzb.png" alt="image.png"></p><p> 完成数据库链接配置，并设置Variable Name for created pool（为了在JDBC Request中被引用）</p><p> <img src="/assets/image-20220329111401-97jv5xr.png" alt="image.png"></p><p> <img src="/assets/image-20220329111408-zh7shdh.png" alt="image.png"></p><p> (2)Jmeter中数据库操作</p><p> ①Query Type ：Select Statement (查询)</p><p> <img src="/assets/image-20220329111415-olsxb61.png" alt="image.png"></p><p> 察看结果树：</p><p> <img src="/assets/image-20220329111422-3wrcdep.png" alt="image.png"></p><p> 来验证下，看看数据库里数据是否和查出来的一致</p><p> <img src="/assets/image-20220329111428-v2k1fad.png" alt="image.png"></p><p> ②Query Type ：Update Statement (更新)</p><p> <img src="/assets/image-20220329111434-p1rxzak.png" alt="image.png"></p><p> <img src="/assets/image-20220329111440-cnw602a.png" alt="image.png"></p><p> <img src="/assets/image-20220329111445-kcjou9i.png" alt="image.png"></p><p> <img src="/assets/image-20220329111454-ohlu7qg.png" alt="image.png"></p><p> 大家可以在尝试下delete</p><p> <img src="/assets/image-20220329111505-8ues2ze.png" alt="image.png"></p><p> 数据已被删除</p><p> <img src="/assets/image-20220329111513-4tk2gk2.png" alt="image.png"></p><p> ③按照以上的测试配置，仅能执行一条sql语句，若想执行多条，需在 JDBC Connection Configuration中设置的Database URL中设置allowMultiQueries&#x3D;true</p><p> <img src="/assets/image-20220329111525-8vg2o1g.png" alt="image.png"></p><p> 5种Query Type 总结（以是否设置allowMultiQueries&#x3D;true来分类）：</p><table><thead><tr><th>Query Type</th><th>已设置(基本前提为语句正确)</th><th>未设置<br /></th></tr></thead></table><table><thead><tr><th>Select Statement<br />或<br />Prepared Select Statement<br /></th><th>不管填写1条还是多条，仅执行第1条语句，且第1条语句必须为select，否则会报错</th><th>仅能填写1条sql语句，且必须为select语句，否则会报错</th></tr></thead></table><table><thead><tr><th>Update Statement或Prepared Update Statement</th><th>不管设置1条还是多条，只要第一条为非select语句，则能正确运行，且会忽略所有select语句，若第一条是select语句，则会报错</th><th>仅能填写1条sql语句，且必须为非select语句，否则会报错</th></tr></thead></table><table><thead><tr><th>Callable Statement</th><th>可执行多条sql语句</th><th>仅能填写一条sql语句，否则会报错</th></tr></thead></table><p> ④若在测试过程中，执行成功，却未得到对应的结果，可能是因为编码的问题，jmeter识别不了，那么此时，我们需要在 JDBC Connection Configuration的Database URL加上useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8来对他进行编码</p><p> <img src="/assets/image-20220329111935-jhhvptk.png" alt="image.png"></p><p> ⑤接下来我们来看下Select Statement与Prepared Select Statement，Update Statement与Prepared Update Statement的区别</p><p> Select Statement：静态select语句</p><p> Update Statement： 静态DML(insert、update、delete)</p><p> Prepared Select Statement：动态select语句，参数化select语句</p><p> Prepared Update Statement：动态DML语句，参数化DML语句</p><p> Prepared Select Statement和Prepared Update Statement是可以防sql注入的</p><p> 一般我们测试insert的时候会使用Prepared Update Statement而不是Update Statement</p><p> <img src="/assets/image-20220329111946-xoiet3s.png" alt="image.png"></p><p> <img src="/assets/image-20220329111951-7k7l3a3.png" alt="image.png"></p><p> <img src="/assets/image-20220329111956-qvucil1.png" alt="image.png"></p><p> 上一次安全培训的时候，有提到关于防止sql注入的问题，一个很有效的方式，就是采用预编译的方式组装sql， “？”就是占位符，我们温习下：</p><p> 【预编译占位符为什么能防止sql注入】</p><p> a. 使用占位符：select * from table where name &#x3D; ？</p><p> b. 那么你传进来的参数 sql会解析成 select * from table where name &#x3D; ‘张三 or  1&#x3D;1’</p><p> 这个就不会有注入的风险了，sql会把传进来的是一个参数字符串，而不是语法</p><p> ⑥JDBC Request本身也是可以将返回值取出给到定义好的变量</p><p> 我们以select查询返回后的结果为例</p><p> <img src="/assets/image-20220329112005-fzzjkw2.png" alt="image.png"></p><p> 运行后的结果</p><p> <img src="/assets/image-20220329112011-qmlr3wq.png" alt="image.png"></p><p> 调试取样器查看取值情况</p><p> <img src="/assets/image-20220329112017-ngokexr.png" alt="image.png"></p><p> (3)JDBC Request 结合后置处理器-正则表达式提取器</p><p> 通过JDBC Request获取数据库的数据，用正则表达式提取器进行提取后，给到其他接口使用</p><p> 假设此处我们需要取出这边的登录账号 admin</p><p> <img src="/assets/image-20220329112029-kppl3ot.png" alt="image.png"></p><p> 添加调试取样器，我们来查看结果（调试取样器直接用${username}命名），可以看到是可以正确取到值的</p><p> <img src="/assets/image-20220329112035-rgmtssu.png" alt="image.png"></p><p> 注意：正则表达式中 空白用\s ，换行用 \n</p><p> 8.函数助手<br> 在第6节中，我们有简单讲到过一个函数助手，用CSVRead实现数据驱动，不管是使用什么函数，使用方法都是类似的，就是我们选择某个函数，并且按要求为其参数设定值，不同的函数要求的参数也不同，然后生成函数字符串，供脚本使用，后续时间充裕会将常用的Jmeter函数做下总结，这边我们就先拿__Random函数取了例子，主要演示下函数生成和使用</p><p> __Random函数：返回指定最大值和最小值之间的随机数</p><p> <img src="/assets/image-20220329112044-fce51qc.png" alt="image.png"></p><p> <img src="/assets/image-20220329112050-gfunnb2.png" alt="image.png"></p><p> <img src="/assets/image-20220329112053-25pe9vq.png" alt="image.png"></p><p> 9.BeanShell<br> 10.Jmeter事物&#x2F;模块控制器<br> 三、Ant简介<br> 下载地址：Apache Ant - Binary Distributions</p><p> windows下载zip包，mac下载tar包</p><p> <img src="/assets/image-20220329112105-ywqkh6w.png" alt="image.png"></p><p> 下载后解压，配置环境变量（同java的配置方式，可百度）</p><p> 配置环境变量后，在命令行运行如下命令，查看ant是否生效</p><p> ant -version</p><p> <img src="/assets/image-20220329112110-j041oem.png" alt="image.png"></p><p> 四、Jenkins介绍及安装配置<br> Jenkins官网下载地址（选择稳定的版本进行下载）：Jenkins download and deployment</p><p> MAC版本下载：链接:<a href="https://pan.baidu.com/s/19OpTt5aQhAhmXx4oeW4JeA">https://pan.baidu.com/s/19OpTt5aQhAhmXx4oeW4JeA</a>  密码:hltv</p><p> 下载后按照提示安装即可</p><p> mac版本获取密码时，可以在iterm里 输入：sudo less 提示的地址 ，来获取登录的初始密码</p><p> 登录后记得及时修改密码！！！</p><p> <img src="/assets/image-20220329112121-uxlruia.png" alt="image.png"></p><p> 五、Jmeter自动化测试的配置</p><ol><li><p>原理</p><p> <img src="/assets/image-20220329112127-di6hlur.png" alt="image.png"></p></li><li><p>Jmeter.property配置<br> Jmeter配置文件中，默认的报告是csv格式的，因为csv的报告不是很好看，达不到想要的效果，所以要改成xml，改成xml后，生成的报告，就能生成html的格式（注：修改后要重启Jmeter才能生效）</p><p> <img src="/assets/image-20220329112147-6zucq8s.png" alt="image.png"></p></li><li><p>Ant配置<br> 需要把Jmeter下面的一个Jar包（ant-jmeter-x.x.x.jar），复制到ant的安装目录lib目录下面，这样Ant就能使用Jmeter</p><p> <img src="/assets/image-20220329112156-i9aqdla.png" alt="image.png"></p></li><li><p>Jenkins 配置-相关插件安装<br> （1）安装Ant插件：安装后，我们才能用Jenkins结合Ant去运行build.xml文件</p><p> <img src="/assets/image-20220329112206-3gxcbrc.png" alt="image.png"></p></li></ol><p> （2）安装完成后，还需要配置Java 和Ant的环境变量</p><p> <img src="/assets/image-20220329112213-ma31b32.png" alt="image.png"></p><p> <img src="/assets/image-20220329112222-n7v1zno.png" alt="image.png"></p><p> （3）安装jtl和html报告插件：HTML Publisher</p><p> <img src="/assets/image-20220329112228-r3fsf4q.png" alt="image.png"></p><ol start="5"><li><p>邮件通知配置<br> （1）安装插件：Email Extension Template、Email Ext Recipients Column</p><p> <img src="/assets/image-20220329112245-qcg5tbq.png" alt="image.png"></p></li></ol><p> （2）以QQ邮箱为例，配置发送邮箱，QQ邮箱-设置-账户-SMTP服务必须是开启的，才能发送邮件，需要获得授权码</p><p> <img src="/assets/image-20220329112252-o5tjbi8.png" alt="image.png"></p><p> <img src="/assets/image-20220329112256-x9sb5he.png" alt="image.png"></p><p> （3）进入Jenkins - Manage Jenkins - Configure System，找到邮件服务器，进行配置</p><p> <img src="/assets/image-20220329112303-e39zlrr.png" alt="image.png"></p><p> （4）将Jmeter里的两个Jar包（javax.activation-1.2.0.jar，mail-1.5.0-b01.jar）拷贝到Ant的lib目录下 ，否则进行ant build的时候会报错</p><p> <img src="/assets/image-20220329112311-hdods8i.png" alt="image.png"></p><ol start="6"><li><p>Ant build.xml 文件</p><p> <img src="/assets/image-20220329112318-iyd1ewj.png" alt="image.png"></p></li></ol><p> Jenkins 新建Job<br> （1）构建触发器，此处设置一个定时任务，为了演示，假设每1分钟执行一次</p><p> <img src="/assets/image-20220329112331-yde7206.png" alt="image.png"></p><p> （2）安装过Ant插件后，此处构建时下拉列表就会有“Invoke Ant”选项，如图进行配置</p><p> <img src="/assets/image-20220329112338-j7w1mjz.png" alt="image.png"></p><p> <img src="/assets/image-20220329112342-4uwc06v.png" alt="image.png"></p><p> （3）构建后操作里下拉选择 “Publish HTML reports”，HTML文件的路径为jenkins workspace中html报告 的存放路径，报告名称为 index.html(可自定义，但需和xml文件中一致)</p><p> <img src="/assets/image-20220329112350-obucsvl.png" alt="image.png"></p><ol start="6"><li><p>运行-看结果</p><p> <img src="/assets/image-20220329112403-ywffi1t.png" alt="image.png"></p><p> <img src="/assets/image-20220329112413-n3ak8ol.png" alt="image.png"></p></li></ol><p> 查看邮件</p><p> <img src="/assets/image-20220329112422-uw4xrm4.png" alt="image.png"></p><ol start="7"><li><p>配置过程中遇到的问题总结<br> （1）jenkins html 报告格式丢失</p><p> <img src="/assets/image-20220329112437-3kg61n8.png" alt="image.png"></p></li></ol><p> 解决方法参考：jenkins使用HTML Publisher Plugin插件 拉取报告样式缺失问题解决 - 凯宾斯基 - 博客园</p><p> ①安装插件：Groovy，startup Trigger</p><p> ②配置方法</p><p> 新建一个job，该job专门用于Jenkins启动时执行的配置命令；<br> 在Build Triggers模块下，勾选Build when job nodes start；<br> 在Build模块下，Add build step-&gt; Execute system Groovy script，在Groovy Script中输入配置命令，System.setProperty(“hudson.model.DirectoryBrowserSupport.CSP”, “”)<br> 解决后，报告显示正常</p><p> <img src="/assets/image-20220329112446-58a067u.png" alt="image.png"></p><p> （2）Html报告中，MinTime和 Max Time 显示为NaN</p><p> <img src="/assets/image-20220329112453-clzth2w.png" alt="image.png"></p><p> 解决方法一：</p><p> jmete-lib目录下这两个jar包，复制到ant的lib目录下即可</p><p> <img src="/assets/image-20220329112459-dvivbp0.png" alt="image.png"></p><p> 解决方法二：在xml文档中引用这两个jar包即可</p><p> <img src="/assets/image-20220329112505-9soji57.png" alt="image.png"></p><p> （3）Jenkins构建时遇到SSL警告</p><p> <img src="/assets/image-20220329112511-2lexqq6.png" alt="image.png"></p><p> 解决方法，需要在JDBC Connection Configuration的Database URL中，增加三个参数：useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false</p><p> <img src="/assets/image-20220329112520-arj1oaf.png" alt="image.png"></p><p> （4）Jenkins构建时 控制台提示jmeter.log 权限不足</p><p> <img src="/assets/image-20220329112527-4vj8e1v.png" alt="image.png"></p><p> <img src="/assets/image-20220329112531-z2s6btq.png" alt="image.png"></p><p> 解决方法：进入到jmeter.log的目录下，对该文件的权限进行变更</p><p> <img src="/assets/image-20220329112540-11x47zt.png" alt="image.png"></p><ol start="8"><li>分享中提到的关于TestReport的名称优化<br> 目标：使展示的TestReport展示成变化的值(本身展示的是index.html)</li></ol><p> （1）在Jenkins中安装插件</p><p> <img src="/assets/image-20220329112551-bu7qznm.png" alt="image.png"></p><p> （2）进入系统配置</p><p> <img src="/assets/image-20220329112557-ocebez9.png" alt="image.png"></p><p> <img src="/assets/image-20220329112604-ihl79vz.png" alt="image.png"></p><p> <img src="/assets/image-20220329112610-s1tpg83.png" alt="image.png"></p><p> <img src="/assets/image-20220329112615-zcy27c2.png" alt="image.png"></p><p> 进入jenkins 对应的jmeter自动化的Job中，点击Configure，我们去修改一下当时的配置，</p><p> <img src="/assets/image-20220329112622-vfi5b12.png" alt="image.png"></p><p> 修改构建后操作（Post-build Actions），将原先设置的index.html改成和 TestReport${time}.html，点击save</p><p> <img src="/assets/image-20220329112719-4kwtn2h.png" alt="image.png"></p><p> 我们来构建并查看报告，看下是否达到我们想要的效果</p><p> <img src="/assets/image-20220329112645-2czf07j.png" alt="image.png"></p><p> <img src="/assets/image-20220329112654-zcqagi3.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> Jmeter接口自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter远程启动</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/10_jmeter%E8%BF%9C%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/10_jmeter%E8%BF%9C%E7%A8%8B%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p> 使用JMeter，来完成一台机器控制，多台远程机器，即实现1主多从来进行压测脚本。</p><p> 过程：</p><p> 1、主从机器上均安装相同版本的JMeter 和JDK。</p><p> 2、配置主从机器，详见步骤：</p><p> a、将主机器的JMeter&#x2F;bin中的jmeter.properties文件，修改如下2处信息，</p><p> <img src="/assets/image-20220324113829-81yj5kl.png" alt="image.png"></p><p> 切记要修改：server.rmi.ssl.disable&#x3D;true，否则会报如下的错误</p><p> <img src="/assets/image-20220324113835-1lawuv2.png" alt="image.png"></p><p> <img src="/assets/image-20220324113840-ln4o8lp.png" alt="image.png"></p><p> b、从机器也做类似的配置</p><p> <img src="/assets/image-20220324113846-8jdlhfd.png" alt="image.png"></p><p> <img src="/assets/image-20220324113850-k8890gu.png" alt="image.png"></p><p> 3、启动从主机器</p><p> 启动机器前，一定要先启动 jmeter-server，否则会报 如下错</p><p> <img src="/assets/image-20220324113856-rvktg8z.png" alt="image.png"></p><p> <img src="/assets/image-20220324113901-miz90ql.png" alt="image.png"></p><p> 4、启动jmeter.sh(mac)，jmeter.bat（window），执行脚本，运行—远程启动<br> <br /></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter远程启动 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter函数助手</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/11_jmeter%E5%87%BD%E6%95%B0%E5%8A%A9%E6%89%8B/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/11_jmeter%E5%87%BD%E6%95%B0%E5%8A%A9%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p> 在讲解函数助手之前，先讲解下jmeter的用户自定义变量</p><p> 用户自定义变量解决了那些问题？</p><p> 1.测试环境和线上环境切换，每次次都需要修改每个请求的IP地址</p><p> 2.请求的共用参数，每次只要修改一个地方，所有引用都被改变</p><p> 3.方便快捷，便于维护脚本</p><p> 废话不多话，下面步入正题</p><p> 如何添加自定义变量控件呢</p><p> 选中  线程组—配置元件—-用户自定义变量</p><p> <img src="/assets/image-20220326105124-7rgr85p.png" alt="image.png"></p><p> <img src="/assets/image-20220326105130-ujsj4py.png" alt="image.png"></p><p> 我们这里设置完了之后，我们怎么引用呢？</p><p> Jmeter的标准引用格式是：${IP}这种格式进行访问</p><p> <img src="/assets/image-20220326105140-vfl9a43.png" alt="image.png"></p><p> 接下来 咱们开始使用函数助手，重点即将开始—-点击选项—-选择 函数助手对话框</p><p> 文件参数化：</p><pre><code>                    1：函数助手                    2：csv data set config</code></pre><p> <img src="/assets/image-20220326105150-gafco24.png" alt="image.png"></p><p> 打开函数助手对话框，选择_CSVRead</p><p> <img src="/assets/image-20220326105158-04kx5nw.png" alt="image.png"></p><p> CSV file to get values from | * ,这个参数是 文件的路径，csv的文件分隔符是逗号，咱们使用txt文本进行逗号分隔也是可以使用的</p><p> CSV文件列号| next| *alias  见名知意    这里的主要意思，取列数，列入第一行是用户名，第二行是密码，一一对应</p><p> 注意：这里取值的时候  是从0进行开始取值，</p><p> <img src="/assets/image-20220326105211-xfyhoii.png" alt="image.png"></p><p> <img src="/assets/image-20220326105215-um5ggha.png" alt="image.png"></p><p> 生成之后，我们${__CSVRead(C:\Users\Administrator\Desktop\user.txt,0)}这行复制出来</p><p> 0代表取的文件第一列，1代表取的第二列</p><p> <img src="/assets/image-20220326105221-5me8p5z.png" alt="image.png"></p><p> 我们需要http请求的时候进行调用</p><p> 我们的参数，用户名使用${__CSVRead(C:\Users\Administrator\Desktop\user.txt,0)}</p><p> 密码使用。${__CSVRead(C:\Users\Administrator\Desktop\user.txt,1)}</p><p> <img src="/assets/image-20220326105229-xghzept.png" alt="image.png"></p><p> 然后我们设置完 就可以进行模仿不同用户进行登录</p><p> 我在这儿线程组，设置的为100，会一直循环进行模仿 这10个用户进行登录</p><p> <img src="/assets/image-20220326105239-wypbk2s.png" alt="image.png"></p><p> <img src="/assets/image-20220326105245-6o5iilg.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter函数助手 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter json提取器详解</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/08_jmeterjson%E6%8F%90%E5%8F%96%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/08_jmeterjson%E6%8F%90%E5%8F%96%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>一、JSON提取器</p><ol><li><p>JSON提取器是专门用来对返回的响应结果是application&#x2F;json格式的报文进行提取，如下所示</p><p> <img src="/assets/image-20220310180655-r4lg5zc.png" alt="image.png"></p><p> <img src="/assets/image-20220310180707-9lamju0.png" alt="image.png"></p></li><li><p>首先在需要提前变量的HTTP请求点击右键》添加》后置处理器》JSON提取器</p><p> <img src="/assets/image-20220310180717-swpsysb.png" alt="image.png"></p></li><li><p>JSON提取器，变量应用范围，默认选择Main sample only即可</p><p> <img src="/assets/image-20220310180725-zrdedue.png" alt="image.png"></p></li><li><p>下面给大家讲解写怎么写JSON PATH，只有写出正确的JSON PATH，才能获取到我们需要的变量值，默认我们jmeter的察看结果树显示的结果是Text文本格式，这样我们就不能快速的看出变量的层级，所以需要把查看结果树的显示格式改成JSON Path Tester，该查看结果树还支持直接对结果进行调试，这是很多刚入门的小伙伴不知道的一个功能，很方便，如下所示</p><p> <img src="/assets/image-20220310180734-7sd2ozo.png" alt="image.png"></p><p> <img src="/assets/image-20220310180740-17p7iyw.png" alt="image.png"></p></li><li><p>JSON的基本语法就是$.然后后面跟要取字段名，比如要取data，就直接写$.data，如果要取msg，就直接写$.msg如下所示</p><p> <img src="/assets/image-20220310180747-b5py5r7.png" alt="image.png"></p><p> <img src="/assets/image-20220310180752-9c6i5jn.png" alt="image.png"></p></li><li><p>如果还要往下取值，就像文中的token，就需要继续在后面加”.”，(.代表子元素)，然后跟字段名，如$.data.token</p><p> <img src="/assets/image-20220310180740-17p7iyw.png" alt="image.png"></p></li><li><p>在给大家介绍一种结果为数组格式的怎么取值，如下图所示，results保存了数组格式的值，先要知道数组索引，然后才能继续读取数组下的值，学过python的应该就清楚，只要从0依次递增就能取到需要的值，如resulst[0]，resulst[1]，比如我想取第一个数组中的name值，只需要填写$.data.results[0].name</p><p> <img src="/assets/image-20220310180813-2eois8o.png" alt="image.png"></p></li><li><p>实际工作中，可能返回的查询结果经常会变化，这时候如果在写死数组索引的位置，比如上面给大家介绍的，写成$.data.results[0].name，如果系统新增了项目，可能就会导致取的值不正确，这时候就需要用到另外一种取值方式，$…results[?(@.name&#x3D;&#x3D;‘function’)].id，该json path可以通过一个变量定位到自己所在的数组的索引，然后在去取需要的id，比如automation这个值是唯一值，就可以通过该值取到需要的值，语法如下$…然后后面跟数组名称，本文为results，然后跟[?(@.name&#x3D;&#x3D;‘function’)]，其中name是序列中的一个唯一值，可以根据需要修改，function是name实际为什么值就填什么，最后在加”.”后面跟你需要取的字段名如id，pah都行，只要在这个数组中存在</p><p> <img src="/assets/image-20220310180848-jkna4en.png" alt="image.png"></p></li><li><p>在给大家介绍一个经常用到的json 转换网站， <a href="https://www.json.cn/">https://www.json.cn/</a> 打开该网站，拷贝json格式响应结果到该网站，系统就会帮你自动转换成json层级格式，方便调试，如下所示</p><p> <img src="/assets/image-20220310180912-yqckvy7.png" alt="image.png"></p></li><li><p>我们之前通过json path取到的变量token，现在需要写入到信息头管理器，这样下面的请求才会被调用到，格式为${token}</p><p> <img src="/assets/image-20220310180927-3dcmt7l.png" alt="image.png"></p><p> <img src="/assets/image-20220310180934-cetu5ts.png" alt="image.png"></p></li><li><p>JSON PATH语法如下列表，具体语法使用规则，还需要大家多多尝试，可以在察看结果树中切换成JSON Path Tester模式进行测试</p><p> <img src="/assets/image-20220310181008-e6gbt4g.png" alt="image.png"></p></li><li><p>末尾在给大家介绍JSON怎么通过一个提取器提取多个变量，多个变量时则每个变量用“；”间隔开，正则表达式、匹配序列、默认值也一样，需要用“；”隔开，下面先介绍当正则表达式取固定的序列的时候，填写的规则如下图</p><p> <img src="/assets/image-20220310181022-g26pabm.png" alt="image.png"></p></li><li><p>当表达式取任意序列时(匹配所有符合的值)，填写规则如下图</p><p> <img src="/assets/image-20220310181035-d7kaned.png" alt="image.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter json提取器详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter脚本录制</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/09_jmeter%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/09_jmeter%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="配置JMeter"><a href="#配置JMeter" class="headerlink" title="配置JMeter"></a>配置JMeter</h2><ol><li><p>打开JMeter，并新增一个线程组（选中“测试计划”，右键选择“添加” -&gt; “Threads (Users)” -&gt; “线程组”），如下图所示：</p><p> <a href=""><img src="/assets/image-20211210100851-rgrip8q.png" alt="image.png"></a></p></li><li><p>添加“HTTP代理服务器”</p><p> 选中“工作台”，右键选择“添加” -&gt; “非测试元件” -&gt; “HTTP代理服务器”，如下图所示：</p><p> <img src="/assets/image-20211210100858-3hys0sy.png" alt="image.png"></p></li><li><p>配置HTTP代理服务器，如下图所示：</p><ol><li>打开新增的HTTP代理服务器，修改目标控制器为”测试计划 &gt; 线程组“</li><li>修改分组为“每个组放入一个新的控制器”</li><li>还根据需要可以修改代理端口号（默认8888）等配置</li></ol><p> <a href=""><img src="/assets/image-20211210100903-lbzw22o.png" alt="image.png"></a></p></li><li><ol start="4"><li>选择“Requests Filtering”，在“包含模式”中填入“.+(baidu.com).+”用以过滤非baidu.com的请求</li><li>同时在“排除模式”中填入“(?i).*.(bmp|css|js|gif|ico|jpe?g|png|swf|woff|woff2|htm|html).”用以过滤js、图片、html等资源文件请求</li><li>最后点击“启动”按钮启动HTTP代理，如下图所示：</li></ol><p> <a href=""><img src="/assets/image-20211210100907-xhe41n6.png" alt="image.png"></a></p><p> <strong>END</strong></p></li></ol><h2 id="录制脚本"><a href="#录制脚本" class="headerlink" title="录制脚本"></a>录制脚本</h2><ol><li><p>配置代理</p><p> 打开IE浏览器，点击右上方工具按钮，依次选择“Internet选项” -&gt; “连接” -&gt; “局域网设置” -&gt; “代理服务器”，勾选“为LAN使用代理服务器”，输入本地IP地址127.0.0.1及端口号8888，点击确定保存，如下图所示：</p><p> <a href=""><img src="/assets/image-20211210100912-26k2b0p.png" alt="image.png"></a></p></li><li><p>访问页面</p><p> 使用IE浏览器打开百度首页，并进行一次搜索（如搜索lovesoo）；若页面提示“此网站的安全证书存在问题”，点击“继续浏览此网站(不推荐) ”即可，如下图所示：</p><p> <a href=""><img src="/assets/image-20211210100917-yn5vsdk.png" alt="image.png"></a></p><p> <strong>END</strong></p></li></ol><h2 id="脚本处理"><a href="#脚本处理" class="headerlink" title="脚本处理"></a>脚本处理</h2><ol><li><p>现在我们打开JMeter查看我们刚才录制的脚本，可以看到JMeter录制了整个流程的请求，包括开始的搜索建议，访问首页请求，获取搜索历史及搜索等请求，如下图所示：</p><p> <a href=""><img src="/assets/image-20211210100921-lj9tq23.png" alt="image.png"></a></p></li><li><p>此时，我们需要对这些HTTP请求做一些删除操作，只保留访问首页及搜索的请求，如下图所示：</p><p> <a href=""><img src="/assets/image-20211210100926-hyot478.png" alt="image.png"></a></p></li><li><p>然后，我们添加“查看结果树”及“聚合报告”，点击运行即可查询相应的搜索结果，如下图所示：</p><p> <a href=""><img src="/assets/image-20211210100930-qn83bfp.png" alt="image.png"></a></p></li><li><p>最后，我们还可以对接口进行响应的参数化及断言，用以校验HTTP请求返回值是否正确，如下图所示：</p><p> <a href=""><img src="/assets/image-20211210100934-4sxodie.png" alt="image.png"></a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter脚本录制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter简单操作(四)</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/06_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E5%9B%9B)/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/06_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<p>使用cookie来请求网页：</p><p><img src="/assets/image-20211207112735-xvj9yck.png" alt="image.png"></p><p>假设我需要在登录后的某个页面进行下发请求操作</p><p><img src="/assets/image-20211207112743-ngk2o9t.png" alt="image.png"></p><p><img src="/assets/image-20211207112750-tk57rd2.png" alt="image.png"></p><p><img src="/assets/image-20211207112757-slim33r.png" alt="image.png"></p><p>我直接在jmeter中使用请求下发</p><p><img src="/assets/image-20211207112807-b1gz6i3.png" alt="image.png"></p><p><img src="/assets/image-20211207112815-5vuwvkh.png" alt="image.png"></p><p>此时需要用到cookie来通过认证</p><p><img src="/assets/image-20211207112821-9nkyp6u.png" alt="image.png"></p><p>此时我们添加一个Http Cookie管理器，来管理cookie值</p><p><img src="/assets/image-20211207112829-fekt06f.png" alt="image.png"></p><p><img src="/assets/image-20211207112838-xxl71hr.png" alt="image.png"></p><p>再次点击执行，观察结果</p><p><img src="/assets/image-20211207112844-cwoz4ef.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter简单操作(四) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter正则表达式详解</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/07_jmeter%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/07_jmeter%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>二、正则表达式提取器</p><ol><li><p>正则表达式也是我们在开发案例过程中用的最多的一种提取器，他支持对各种格式的响应结果进行提取，比如application&#x2F;json、HTML格式等等</p><p> <img src="/assets/image-20220310181104-6c4x6qh.png" alt="image.png"></p></li><li><p>首先在需要提前变量的HTTP请求点击右键》添加》后置处理器》正则表达式提取器</p><p> <img src="/assets/image-20220310181111-jer2dz0.png" alt="image.png"></p></li><li><p>正则表达式提取器，变量应用范围，默认选择Main sample only即可，要检查的响应字段选择主体</p><p> <img src="/assets/image-20220310181118-854pmzh.png" alt="image.png"></p></li><li><p>下面给大家讲解写怎么写正则表达式，只有写出正确的正则表达式，才能获取到我们需要的变量值，默认我们jmeter的察看结果树显示的结果是Text文本格式，所以需要把查看结果树的显示格式改成RegExp Tester，上面已经介绍了，这种可以支持写出正则，然后进行调试，看取值是否正确</p><p> <img src="/assets/image-20220310181126-moq19ue.png" alt="image.png"></p></li><li><p>我们写正则，只需要拷贝变量所在的左右边界，data”:“c7a86d03-4684-4302-9456-e4f15e849368”, 然后把需要取的变量替换成(.)即可，“data”:”(.)”, 该表达式即是我们需要的效果，当然如果返回的响应结果有很多相同的左右边界，这时候还需要细化正则(本人经验，返回结果为application&#x2F;json格式的都用json path取值，不用正则)</p></li><li><p>正则表达式，具体语法使用规则参考<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a> ，还需要大家多多尝试，可以在察看结果树中切换成RegExp Tester模式进行测试</p> <br /></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter正则表达式详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter简单操作(二)</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/04_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%BA%8C)/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/04_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>基础界面配置：<br>配置日志：</p><p><img src="/assets/image-20211207112138-drx2f7r.png" alt="image.png"></p><p>选择界面的显示语言：</p><p><img src="/assets/image-20211207112147-bxkf3xx.png" alt="image.png"></p><p>配置界面字体大小：<br>修改Body体内的字体大小<br>修改Jmeter文件目录中&#x2F;bin&#x2F;jmeter.properties文件中的font相关参数<br>jsyntaxtextarea.font.family&#x3D;Hack 和 jsyntaxtextarea.font.size&#x3D;20 ,将#去掉，修改完成之后，重启jmeter生效</p><p><img src="/assets/image-20211207112201-qtpz1co.png" alt="image.png"></p><p><img src="/assets/image-20211207112206-kvvl5as.png" alt="image.png"></p><p>配置界字体大小<br>修改Jmeter文件目录中&#x2F;bin&#x2F;jmeter.properties文件中的hidpi相关参数<br>jmeter.hidpi.mode&#x3D;true 和 jmeter.hidpi.scale.factor&#x3D;2.0 ,将#去掉，修改完成之后，重启jmeter生效</p><p><img src="/assets/image-20211207112215-y94l0vc.png" alt="image.png"></p><p><img src="/assets/image-20211207112220-29jond2.png" alt="image.png"></p><p>自定义字体大小<br>临时使用时，可以使用一直按着“Ctrl”键，上下滚动鼠标，来自定义字体大小，哪种大小字体舒服就可以自己调节选择，但是这种和以上2种方式不同之处在于，这个不能保存配置，重启Jmeter之后会还原到默认配置大小，但是这种修改方式比较人性化，而且很容易操作。</p><p><img src="/assets/20191031102614715-20211207112241-mqxwvh4.gif" alt="20191031102614715.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter简单操作(二) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter简单操作(三)</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/05_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%89)/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/05_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<p>Jmeter参数化方法：</p><ol><li>直接自定义入参<br> 举例：当前需要实现5个请求，请求中包含一个参数输入，需要分别读取5个不同值进行请求<br> 步骤1：设置一个线程组，在线程组下添加一个用户定义变量的配置元件；</li><li><img src="/assets/image-20211207112358-g2u7b44.png" alt="image.png"></li><li><img src="/assets/image-20211207112408-11olk9s.png" alt="image.png"></li></ol><p>步骤2：添加5个请求，每个请求中参数通过${用户定义的变量名}的方式读取值；</p><p><img src="/assets/image-20211207112415-t1zp0q5.png" alt="image.png"></p><p>步骤3：点击执行，并观察执行结果；</p><p><img src="/assets/image-20211207112421-6vqwrb2.png" alt="image.png"></p><p><img src="/assets/image-20211207112427-3i28sdh.png" alt="image.png"></p><ol start="2"><li>使用CSV Data Set Config的设置，从csv文件导入<br> 举例：当前需要实现一个请求，请求中包含一个参数输入，需要分别读取5个不同值进行请求<br> 步骤1：设置一个线程组，假设需要包含一共有5个参数入参，则设置循环次数为5次；</li><li><img src="/assets/image-20211207112434-dk9k02r.png" alt="image.png"></li></ol><p>步骤2：在一个目录中创建一个CSV文件，变量名写在第一行（也可以不写变量名，当不写变量名时，添加CSV数据文件配置中需要设置一下指定读取参数是否忽略首行），当然此处不仅仅可以读取csv文件，也可以读取txt文件之类的，此处我们用csv文件作为例子；</p><p><img src="/assets/image-20211207112441-h3u0ge2.png" alt="image.png"></p><p>步骤3：在线程组下添加一个CSV数据文件配置的配置元件，根据实际需要来进行配置；</p><p><img src="/assets/image-20211207112447-ta1gwgb.png" alt="image.png"></p><p><img src="/assets/image-20211207112452-kto9lah.png" alt="image.png"></p><p>步骤4：添加察看结果树，并将结果保存到一个指定文件；</p><p><img src="/assets/image-20211207112459-ymiepcc.png" alt="image.png"></p><p>步骤5：点击执行，并观察执行结果；</p><p><img src="/assets/image-20211207112505-ochla6s.png" alt="image.png"></p><p><img src="/assets/image-20211207112510-jn8tkga.png" alt="image.png"></p><ol start="3"><li>使用计数器，来输入<br> 举例：当前需要实现一个请求，请求中包含一个参数输入，这5个参数可以是前缀+数值递增的格式，需要分别读取5个不同值进行请求<br> 步骤1：设置一个线程组，假设需要包含一共有5个参数入参，则设置循环次数为5次；</li><li><img src="/assets/image-20211207112518-2c7xdd8.png" alt="image.png"></li></ol><p>步骤2：添加一个计数器，并设置输出的格式和参数变量名，我们此处举例是需要输入的参数为maowei-001、maowei-002、maowei-003、maowei-004、maowei-005，具体配置如下图所示；</p><p><img src="/assets/image-20211207112526-x0cpevn.png" alt="image.png"></p><p>步骤3：添加请求和查看结果树，具体操作如上一种方法所示；</p><p><img src="/assets/image-20211207112531-d8yjv77.png" alt="image.png"></p><p>步骤4：点击执行并查看执行结果；</p><p><img src="/assets/image-20211207112539-khj9gmq.png" alt="image.png"></p><p><img src="/assets/image-20211207112544-pca74ss.png" alt="image.png"></p><ol start="4"><li>使用随机函数来生成随机值</li><li><img src="/assets/image-20211207112549-byih28h.png" alt="image.png"></li></ol><p>4.1使用__Random函数来实现随机生成数值</p><p><img src="/assets/image-20211207112556-8vljx1e.png" alt="image.png"></p><p>将函数式复制到请求页面的变量值输入框中，可以在函数式前面加想要输入的字符串前缀，例如maowei-，后面接随机值</p><p><img src="/assets/image-20211207112605-d8lpmd3.png" alt="image.png"></p><p>点击执行，可以查看结果，【注意】此随机值函数，可以产生入值参数重复的情况，假如不想入参出现重复，建议不要使用这种方式</p><p><img src="/assets/image-20211207112611-9z64wa2.png" alt="image.png"></p><p>4.2使用__RandomDate函数来实现随机生成数值</p><p><img src="/assets/image-20211207112618-z7bjnzp.png" alt="image.png"></p><p>点击执行，可以查看结果，【注意】此随机值函数，可以产生入值参数重复的情况，假如不想入参出现重复，建议不要使用这种方式</p><p><img src="/assets/image-20211207112625-0je5puy.png" alt="image.png"></p><p><img src="/assets/image-20211207112631-g8flyis.png" alt="image.png"></p><p>4.3使用__RandomString函数来实现随机生成数值</p><p><img src="/assets/image-20211207112638-t4nxhld.png" alt="image.png"></p><p>点击执行，可以查看结果，【注意】此随机值函数，概率性产生入值参数重复的情况，假如不想入参出现重复，建议不要使用这种方式</p><p><img src="/assets/image-20211207112645-l8ytl87.png" alt="image.png"></p><p><img src="/assets/image-20211207112658-y6oy4lk.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter简单操作(三) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter界面介绍</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/02_jmeter%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/02_jmeter%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p> JMeter主界面主要分为 标题栏、菜单栏、工具栏、测试计划树形目录、内容展示区</p><p> <img src="/assets/image-20211207110936-8xa0kh8.png" alt="image.png"></p><p> 标题栏：主要展示JMeter的程序版本、当前脚本的名称、脚本的储存路径</p><p> 菜单栏：程序基本上所有功能的所属分类目录，基本上可以通过菜单栏对程序进行所有的操作</p><p> 工具栏：可以理解为菜单栏中某些功能的快捷按钮</p><p> 测试计划树形目录：以树形结构展示测试计划的内容标签，可以理解为用例名称，通过点击标签查看任意标签的内容</p><p> 内容展示区：对当前所选树形目录的标签内容进行展示，当日志输出框显示时，还可以看到程序的运行日志记录</p><h2 id="菜单详解"><a href="#菜单详解" class="headerlink" title="菜单详解"></a>菜单详解</h2><h3 id="文件："><a href="#文件：" class="headerlink" title="文件："></a>文件：</h3><p> 　　　　新建：新建一个空白的测试计划</p><p> 　　　　Templates&lt;模板&gt;：对于一些常用功能的示例模板，点击模板中的链接可跳转到官方的介绍页面</p><p> 　　　　打开：弹出路径选择框，可选择并打开一个新的JMX格式的脚本文件</p><p> 　　　　Open Recent&lt;最近打开&gt;:显示最近打开过的脚本记录，选择后可打开对应的脚本</p><p> 　　　　合并：将多个JMX文件合并成一个文件，指将所选文件的内容合并到当前文件中来</p><p> 　　　　保存测试计划：就字面意思，保存整个测试计划</p><p> 　　　　保存测试计划为：类似于文本编辑器中的另存为，保存的是整个测试计划</p><p> 　　　　选中部分保存为：仅保存选择部分，类似于选中部分另存为XXX</p><p> 　　　　save as Test fragment：保存为测试片段，其中测试计划、测试组是不能被保存为测试片段的&lt;4.0之前的版本工作台也是不能保存的,4.0开始工作台被去掉了&gt;。</p><p> 　　　　Revert：还原,还原到上次保存时的状态</p><p> 　　　　退出：关闭程序</p><h3 id="编辑："><a href="#编辑：" class="headerlink" title="编辑："></a>编辑：</h3><p> 　　　　添加：根据当前再树形标签页中所选中的标签，来显示不同的添加内容</p><p> 　　　　粘贴：就是粘贴，将复制的部分粘贴过来</p><p> 　　　　打开：等同于文件—打开</p><p> 　　　　合并：等同于文件—合并</p><p> 　　　　选中部分另存为：等同于文件—选中部分保存为</p><p> 　　　　Save Node As Image:保存节点为图片，只会截取并保存右侧内容显示区域</p><p> 　　　　Save Screen As Image:保存屏幕为图片，会保存整个jmeter程序的界面</p><p> 　　　　启用：对当前选中的标签进行启用操作</p><p> 　　　　禁用：对当前选中的标签进行禁用操作</p><p> 　　　　Toggle：切换，对当前选中的标签进行禁用&#x2F;启用切换操作，禁用变启用、启用变禁用</p><p> 　　　　帮助：跳到官方帮助文档页面</p><h3 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h3><p> 　　　　Search：查询功能，查找到的内容会在树形结构中框红显示</p><p> 　　　　Reset Search：重置查询，对前面框红的内容进行清除</p><h3 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h3><p> 　　　　启动：运行测试计划</p><p> 　　　　Start no pauses:不停顿启动，运行测试计划，但会忽略测试计划中的定时器等待</p><p> 　　　　远程启动：分布式测试时使用，指定启动一个远程agent运行。</p><p> 　　　　远程全部启动：分布式测试时使用，启动所有的远程agent运行。</p><p> 　　　　停止：停止执行测试计划。</p><p> 　　　　关闭：没发现于停止有啥区别，但肯定有区别，哈哈。</p><p> 　　　　远程停止：分布式测试时使用，指定停止一个远程agent运行。</p><p> 　　　　远程全部停止：分布式测试时使用，停止所有的远程agent运行。</p><p> 　　　　远程关闭：类似于远程停止。</p><p> 　　　　远程全部关闭：类似于远程全部停止。</p><p> 　　　　远程退出：</p><p> 　　　　远程全部退出：</p><p> 　　　　清除：清除当前所选标签的执行结果，貌似只对监听器有用。</p><p> 　　　　清除全部：清除当前计划中的所有监听器的执行结果。</p><h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><p> 　　　　函数助手对话框：弹出函数助手弹窗，可快速生成需要的代码</p><p> 　　　　外观：可用改变jmeter的界面风格主题。</p><p> 　　　　Log Viewer：打开\关闭日志输出框</p><p> 　　　　Log Level：设定运行输出日期的等级</p><p> 　　　　SSL管理器：导入外置的SSL管理器，用于更好的管理证书。</p><p> 　　　　选择语言：改变界面的语言种类，适配不完善的地方依旧使用的英语。</p><p> 　　　　Collapse All：展开所有的菜单</p><p> 　　　　Expand All: 折叠所有的菜单</p><p> 　　　　Zoom In：放大，页面中的文字整体放大</p><p> 　　　　Zoom Out：缩小，页面中的文字整体缩小</p><p> 　　　　Save automatically before run：翻译过来是保存之前自动运行，但没发现实际意义</p><p> 　　　　Plugins Manager：插件管理器</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter界面介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter简单操作(一)</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/03_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%80)/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/03_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>线程组：<br>线程组相当于有多个用户,同时去执行相同的任务。每个线程之间都互不影响</p><p><img src="/assets/image-20211207111207-cgulay1.png" alt="image.png"></p><p><img src="/assets/image-20211207111221-u033b3i.png" alt="image.png"></p><p>新建一个HTTP请求：<br>服务器名称或IP、端口号 ：配置目标服务器名称或者IP地址，端口号默认情况下为80，也可以指定其它端口号。<br>方法：发送请求的具体方法，可以是GET、POST等。路径：配置路径，注意在填写路径时服务器地址、端口及参数不需要，只需要填写剩余后的部分。<br>Content encoding ：编码方式。此处采用utf-8，如果为空，则表示采用ISO-8859-1编码。<br>参数配置：表中每行表示一个参数（与URL中的 name&#x3D;value相对应）</p><p><img src="/assets/image-20211207111232-3t1zd5x.png" alt="image.png"></p><p><img src="/assets/image-20211207111239-9qwa1pt.png" alt="image.png"></p><p>常用监听器：</p><p><img src="/assets/image-20211207111245-txqh89u.png" alt="image.png"></p><p>聚合报告：<br>与Summary Report类似，但是表格中的内容有些许区别。聚合报告：记录这次却被行测试总请求数、错误率、用户响应时间（中间值、90%、最少、最大）、吞吐量等，用以帮助分析被测试系统的性能。</p><p><img src="/assets/image-20211207111253-vs9pyi1.png" alt="image.png"></p><p>查看结果树:<br>调试利器。想必大家也都经常用，不做介绍。有点类似我们的抓包，可以看到request以及response信息。</p><p><img src="/assets/image-20211207111302-fp1kwwa.png" alt="image.png"></p><p><img src="/assets/image-20211207111312-9ir0et8.png" alt="image.png"></p><p><img src="/assets/image-20211207111321-893xldm.png" alt="image.png"></p><p>图形结果:<br>样本数目：是总共发送到服务器的请求数。<br>最新样本：表示服务器相应最后一个请求的响应时间。<br>吞吐量：服务器每分钟处理的请求数。<br>平均值：是总运行时间除以发送到服务器的请求数（平均响应时间）。<br>中间值：一半的响应时间请求高于该值。<br>偏离：代表服务器相应时间变化的数据的分布</p><p><img src="/assets/image-20211207111328-i3hsb3g.png" alt="image.png"></p><p>用表格查看结果：<br>Sample：每个请求的序号<br>Start Time：每个请求开始时间<br>Thread Name：每个线程的名称<br>Label：Http请求名称<br>Sample Time：每个请求所花时间，单位毫秒<br>Status：请求状态，如果为勾则表示成功，如果为叉表示失败。<br>Bytes：请求的字节数<br>样本数目：也就是上面所说的请求个数，成功的情况下等于你设定的并发数目乘以循环次数<br>平均：每个线程请求的平均时间<br>最新样本：表示服务器响应最后一个请求的时间<br>偏离：服务器响应时间变化、离散程度测量值的大小，或者，换句话说，就是数据的分布。</p><p><img src="/assets/image-20211207111336-8h91k3w.png" alt="image.png"></p><p>常用工具栏图标：</p><p><img src="/assets/image-20211207111401-w2pchol.png" alt="image.png"></p><p><img src="/assets/image-20211207111407-tpdyjyy.png" alt="image.png"></p><p>断言：</p><p><img src="/assets/image-20211207111648-1v3brno.png" alt="image.png"></p><p><img src="/assets/image-20211207111655-h9ytrp1.png" alt="image.png"></p><p>响应断言</p><p><img src="/assets/image-20211207111701-hpna2yu.png" alt="image.png"></p><p><img src="/assets/image-20211207111707-e81ybg5.png" alt="image.png"></p><p><img src="/assets/image-20211207111717-knn6per.png" alt="image.png"></p><p><img src="/assets/image-20211207111729-g4sghej.png" alt="image.png"></p><p>持续时间断言</p><p><img src="/assets/image-20211207111735-f8nugga.png" alt="image.png"></p><p><img src="/assets/image-20211207111740-e1wtvwy.png" alt="image.png"></p><p><img src="/assets/image-20211207111745-vs7931a.png" alt="image.png"></p><p><img src="/assets/image-20211207111758-nwm8m8o.png" alt="image.png"></p><p><img src="/assets/image-20211207111803-q0flrz5.png" alt="image.png"></p><p>字节断言</p><p><img src="/assets/image-20211207111809-5z3mecx.png" alt="image.png"></p><p><img src="/assets/image-20211207111814-758zhjf.png" alt="image.png"></p><p><img src="/assets/image-20211207111820-getemqo.png" alt="image.png"></p><p><img src="/assets/image-20211207111826-x2umgq5.png" alt="image.png"></p><p>输出性能报告：</p><p><img src="/assets/image-20211207111153-gy9athg.png" alt="image.png"></p><p><img src="/assets/image-20211207111147-u7lzeyv.png" alt="image.png"></p><p>输入以下命令，进行性能测试并输出CSV执行结果文件和HTML报告<br>jmeter -n -t C:\temp\jmeter.jmx -l C:\temp\jmeterfile\test.csv -e -o C:\temp\jmetertest<br>三个路径依次是：xxx.jmx文件路径，输出xxx.csv文件路径，要保存的http report的文件路径<br>[注意]当这个两个目录已经生成了文件时，请先清除或者备份，保持目录为空时，在执行以下操作</p><p><img src="/assets/image-20211207111139-v05fczw.png" alt="image.png"></p><p><img src="/assets/image-20211207111128-9f04e1l.png" alt="image.png"></p><p><img src="/assets/image-20211207111120-of6rwip.png" alt="image.png"></p><p><img src="https://img-blog.csdnimg.cn/20191030172706725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA0Njk3NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter简单操作(一) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/01_jmeter/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/01_jmeter/</url>
      
        <content type="html"><![CDATA[<h2 id="jmeter操作"><a href="#jmeter操作" class="headerlink" title="jmeter操作"></a>jmeter操作</h2><p><a href="../999_%E5%B7%A5%E5%85%B7/01_jmeter%E5%AE%89%E8%A3%85/">jmeter安装</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/02_jmeter%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/">jmeter界面介绍</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/03_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%80)/">jmeter简单操作(一)</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/04_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%BA%8C)/">jmeter简单操作(二)</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/05_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%89)/">jmeter简单操作(三)</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/06_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E5%9B%9B)/">jmeter简单操作(四)</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/07_jmeter%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/">jmeter正则表达式详解</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/08_jmeterjson%E6%8F%90%E5%8F%96%E5%99%A8%E8%AF%A6%E8%A7%A3/">jmeterjson提取器详解</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/09_jmeter%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6/">jmeter脚本录制</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/10_jmeter%E8%BF%9C%E7%A8%8B%E5%90%AF%E5%8A%A8/">jmeter远程启动</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/11_jmeter%E5%87%BD%E6%95%B0%E5%8A%A9%E6%89%8B/">jmeter函数助手</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/12_jmeter%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/">jmeter连接数据库操作</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/13_Jmeter%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/">Jmeter接口自动化</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/16_jmeter%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">jmeter简单的性能测试</a></p><h2 id="第三方脚本录制"><a href="#第三方脚本录制" class="headerlink" title="第三方脚本录制"></a>第三方脚本录制</h2><p><a href="../999_%E5%B7%A5%E5%85%B7/14_blazemeter(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/">blazemeter(第三方录制脚本)</a></p><p><a href="../999_%E5%B7%A5%E5%85%B7/15_badboy(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/">badboy(第三方录制脚本)</a></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter安装</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/01_jmeter%E5%AE%89%E8%A3%85/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/01_jmeter%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p> <strong>特别需要注意的时，</strong> <strong>jdk版本和jmeter版本匹配问题。</strong></p><p><strong>Jdk1.8对应apache-jmeter-3.3</strong></p><p><strong>Jmeter下载及安装配置</strong></p><p>本文是在win7环境下安装使用jmeter，jmeter可以运行在多平台上Windows和Linux。</p><p>前提：使用jmeter工具之前需要安装java.并配置好java的环境变量。（备注：java下载和环境配置参考java下载安装）</p><p>下载地址<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p><p>（Windows版本下载zip，Linux版本下载tgz）</p><p> <strong>附录</strong> <strong>：java下载和环境配置参考java下载安装</strong></p><p>1、官网下载链接：</p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>2、选择accept，之后才能下载对应的版本；这里我选择的是Windows x86版本；</p><p><img src="/assets/image-20211204000805-eyza1hc.png" alt="image.png"></p><p>3、下载完后，找到下载后的这文件，双击运行。点击下一步，出现如下图一内容，这里是设置安装路径，可以默认，用户可自行选择，这里我安装在D:\JAVA\JDK，如下图二。这路径记好，一会设置环境变量需要用到，设置好后点击下一步，过一会会出现安装Jre路径，如下图三，用户自行选择，点击下一步等待安转完毕即可。</p><p><img src="/assets/image-20211204000813-ecja7mn.png" alt="image.png"></p><p><img src="/assets/image-20211204000819-zupyhze.png" alt="image.png"></p><p><img src="/assets/image-20211204000827-tfqdqnr.png" alt="image.png"></p><p>4、到了这，离成功又近了一步，开始设置环境变量。我的电脑是win7,这里主要以win7为例，其他系统可自行查阅资料，在桌面找到计算机图标右键选择属性，出现如下图一所示内容，点击高级系统设置，出现下图二内容，点击环境变量。</p><p><img src="/assets/image-20211204000834-lruterg.png" alt="image.png"></p><p><img src="/assets/image-20211204000839-2rca6yt.png" alt="image.png"></p><p>5、点击环境变量后出现如下图一所示，在系统变量下面点击新建,然后在下图二弹窗中输入以下内容，变量值就是在步骤4里设置的路径，我的是D:\JAVA\JDK，所以就设置成这个。设置完后再重复刚才步骤新建一个系统变量如下图三，这个可以和我设置一样，变量值为“%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”。设置好后别忘了确定呀，如下图四。</p><p><img src="/assets/image-20211204000846-cb27j2t.png" alt="image.png"></p><p><img src="/assets/image-20211204000856-xfwkx75.png" alt="image.png"></p><p>6、一切大功告成。但怎么样才能确定安装成功了呢？点击windows图标，在命令行中输入cmd，如下图一，按回车键。就会出现一个命令窗口（一个黑色的框框），再输入“javac”按回车键，如果出现如下图二就真的大功告成了，如果没有就重温下以上的步骤。</p><p><img src="/assets/image-20211204000905-bluwpbb.png" alt="image.png"></p><p><strong>JMETER下载及安装配置</strong></p><p>1、打开下载地址<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p><p>2、（Windows版本下载zip，Linux版本下载tgz）一般下载Binaries，Source含有源码；</p><p><img src="/assets/image-20211204000912-j11sxx2.png" alt="image.png"></p><p>3、下载后无需安装，解压后即可使用。下图为解压后的目录。</p><p><img src="/assets/image-20211204000918-11fk6vd.png" alt="image.png"></p><p>4、完成以上操作后，需要进行配置jmeter的环境变量。</p><p>jmeter环境变量配置如下：</p><p>（1）新增JMETER_HOME变量，注意：变量值为你下载后解压的路径。</p><p><img src="/assets/image-20211204000925-ts7ok5b.png" alt="image.png"></p><p>（2）编辑CLASSPATH变量，加上%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar;注：如果电脑重没找到CLASSPATH，添加在PATH也可以；</p><p><img src="/assets/image-20211204000930-31qpx0p.png" alt="image.png"></p><p>5、操作完上面的步骤，我们就可以点击Jmeter中bin目录下面的jmeter.bat文件即可打开Jmeter了。<br>注意：打开的时候会有两个窗口，Jmeter的命令窗口和Jmeter的图形操作界面，不可以关闭命令窗口。</p><p>注：打开如果提示“findstr不是内部或外部命令”， 这是PATH环境变量的问题，将windows命令的目录添加到PATH中就over了。即：在path中追加：%SystemRoot%&#x2F;system32;%SystemRoot%;</p><p><img src="/assets/image-20211204000935-jcinai9.png" alt="image.png"></p><p>6、进入JMeter界面。</p><p><img src="/assets/image-20211204000941-230j3vm.png" alt="image.png"></p><p>7、 备注：也可以通过ApacheJMeter.jar打开。</p><p><img src="/assets/image-20211204000949-k1rry3j.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> jmeter安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world - 副本</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/03_%E8%AF%BE%E5%90%8E/hello-world/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/03_%E8%AF%BE%E5%90%8E/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习规则</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周    1. 打卡        1. 要求每天打卡四次：            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00    2. 教学规则        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）        2. 晚上10点准时休息        3. 学习期间不准酗酒        4. 无重大事件不准请假    3. 日报        1. 每日必填    4. 教学时间        1. 分为大小周教学    5. 教室、宿舍环境保证清洁卫生    6. 教室、宿舍禁止抽烟</code></pre><h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天2. 第二章 操作              -----------&gt; 6工作天3. 第三章 接口测试        -----------&gt; 5工作日4. 第四章 性能测试        -----------&gt; 3工作天5. 第五章 APP测试        -----------&gt; 2工作天6. 第六章 自动化测试    -----------&gt; 6工作天7. 第七章 安全测试       -----------&gt; 1工作天8. 第八章 项目             -----------&gt; 5工作天9. 简历编写                 -----------&gt; 1工作天10. 模拟面试题分析       -----------&gt; 2工作天11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 学习规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习规则</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周    1. 打卡        1. 要求每天打卡四次：            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00    2. 教学规则        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）        2. 晚上10点准时休息        3. 学习期间不准酗酒        4. 无重大事件不准请假    3. 日报        1. 每日必填    4. 教学时间        1. 分为大小周教学    5. 教室、宿舍环境保证清洁卫生    6. 教室、宿舍禁止抽烟</code></pre><h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天2. 第二章 操作              -----------&gt; 6工作天3. 第三章 接口测试        -----------&gt; 5工作日4. 第四章 性能测试        -----------&gt; 3工作天5. 第五章 APP测试        -----------&gt; 2工作天6. 第六章 自动化测试    -----------&gt; 6工作天7. 第七章 安全测试       -----------&gt; 1工作天8. 第八章 项目             -----------&gt; 5工作天9. 简历编写                 -----------&gt; 1工作天10. 模拟面试题分析       -----------&gt; 2工作天11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 学习规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习规则</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周    1. 打卡        1. 要求每天打卡四次：            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00    2. 教学规则        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）        2. 晚上10点准时休息        3. 学习期间不准酗酒        4. 无重大事件不准请假    3. 日报        1. 每日必填    4. 教学时间        1. 分为大小周教学    5. 教室、宿舍环境保证清洁卫生    6. 教室、宿舍禁止抽烟</code></pre><h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天2. 第二章 操作              -----------&gt; 6工作天3. 第三章 接口测试        -----------&gt; 5工作日4. 第四章 性能测试        -----------&gt; 3工作天5. 第五章 APP测试        -----------&gt; 2工作天6. 第六章 自动化测试    -----------&gt; 6工作天7. 第七章 安全测试       -----------&gt; 1工作天8. 第八章 项目             -----------&gt; 5工作天9. 简历编写                 -----------&gt; 1工作天10. 模拟面试题分析       -----------&gt; 2工作天11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 学习规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习规则</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/08_%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%A1%B9%E7%9B%AE/08_%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%A1%B9%E7%9B%AE/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/08_%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%A1%B9%E7%9B%AE/08_%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周    1. 打卡        1. 要求每天打卡四次：            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00    2. 教学规则        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）        2. 晚上10点准时休息        3. 学习期间不准酗酒        4. 无重大事件不准请假    3. 日报        1. 每日必填    4. 教学时间        1. 分为大小周教学    5. 教室、宿舍环境保证清洁卫生    6. 教室、宿舍禁止抽烟</code></pre><h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天2. 第二章 操作              -----------&gt; 6工作天3. 第三章 接口测试        -----------&gt; 5工作日4. 第四章 性能测试        -----------&gt; 3工作天5. 第五章 APP测试        -----------&gt; 2工作天6. 第六章 自动化测试    -----------&gt; 6工作天7. 第七章 安全测试       -----------&gt; 1工作天8. 第八章 项目             -----------&gt; 5工作天9. 简历编写                 -----------&gt; 1工作天10. 模拟面试题分析       -----------&gt; 2工作天11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 学习规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习规则</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/07_%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/07_%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/07_%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/07_%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周    1. 打卡        1. 要求每天打卡四次：            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00    2. 教学规则        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）        2. 晚上10点准时休息        3. 学习期间不准酗酒        4. 无重大事件不准请假    3. 日报        1. 每日必填    4. 教学时间        1. 分为大小周教学    5. 教室、宿舍环境保证清洁卫生    6. 教室、宿舍禁止抽烟</code></pre><h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天2. 第二章 操作              -----------&gt; 6工作天3. 第三章 接口测试        -----------&gt; 5工作日4. 第四章 性能测试        -----------&gt; 3工作天5. 第五章 APP测试        -----------&gt; 2工作天6. 第六章 自动化测试    -----------&gt; 6工作天7. 第七章 安全测试       -----------&gt; 1工作天8. 第八章 项目             -----------&gt; 5工作天9. 简历编写                 -----------&gt; 1工作天10. 模拟面试题分析       -----------&gt; 2工作天11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 学习规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习规则</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周    1. 打卡        1. 要求每天打卡四次：            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00    2. 教学规则        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）        2. 晚上10点准时休息        3. 学习期间不准酗酒        4. 无重大事件不准请假    3. 日报        1. 每日必填    4. 教学时间        1. 分为大小周教学    5. 教室、宿舍环境保证清洁卫生    6. 教室、宿舍禁止抽烟</code></pre><h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天2. 第二章 操作              -----------&gt; 6工作天3. 第三章 接口测试        -----------&gt; 5工作日4. 第四章 性能测试        -----------&gt; 3工作天5. 第五章 APP测试        -----------&gt; 2工作天6. 第六章 自动化测试    -----------&gt; 6工作天7. 第七章 安全测试       -----------&gt; 1工作天8. 第八章 项目             -----------&gt; 5工作天9. 简历编写                 -----------&gt; 1工作天10. 模拟面试题分析       -----------&gt; 2工作天11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 学习规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP测试</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/01_APP%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/01_APP%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li><h3 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h3><ol><li><p>功能测试：需求分析、测试准备阶段、冒烟测试、单元测试、联调、系统测试</p></li><li><p>兼容性测试： </p><ol><li>不同品牌的手机上能否正常安装、运行、卸载</li><li>不同的操作系统上（ios、Android）能否正常安装、运行、卸载</li></ol></li><li><p>网络测试：</p><ol><li>网络异常情况下（时断时连，慢）</li><li>不同网络环境（2g、3g、4g、5g、wifi）下应用运行</li><li>网络未连接，断网情况下应用处理</li></ol></li><li><p>UI测试：核对每个页面的布局、字体与UI进行对比</p></li><li><p>中断测试：运行APP的时候突然进行电话、短信、其他APP的提示等会不会对APP本身的运行造成影响</p></li><li><p>协议测试：测试服务器对于软件发来的请求有没有做校验</p></li><li><p>耗电量测试：</p><ol><li>前端运行</li><li>后端运行</li><li>挂机运行</li></ol></li><li><p>客户端性能测试：对cpu、内存、耗电量、流量的使用情况、还有安装耗时、启动耗时和卸载耗时</p></li></ol></li><li><h3 id="Web测试与-app测试区别？"><a href="#Web测试与-app测试区别？" class="headerlink" title="Web测试与 app测试区别？"></a>Web测试与 app测试区别？</h3><ol><li>其实功能这块，app 测试与 Web 测试基本是一样，没有什么区别。（需求分析-&gt;提炼测试点-&gt;编写测试用例-&gt;执行用例-&gt;提Bug-&gt;复测，回归）等等的 ；区别主要在于，web 端是 B&#x2F;S 架构的，App 是C&#x2F;S 架构的，由于架构的不同，所以 web端一般服务器更新的时候，客户端不需要更新，因为它是通过浏览器来访问的，服务器更新了，客户端也更新。app 服务端要更新，同时客户端软件要进行升级更新，才算是新的版本对于app 测试来讲，除了功能之外，更多的还要考虑一些’专项测试’，比如：web 测试是基于浏览器的所以不必考虑安装卸载。 而 app 是客户端的，则必须测试安装、更新、卸载。兼容性 稳定性 性能测试   弱网测试  交互性测试等等还有就是，对于兼容性这块，Web 端主要考虑是：不同的浏览器，不同的操作系统的兼容性接口。而对于 app 测兼容性更多的考虑：不同的品牌机型，不同操作系统，不同手机屏幕大小，屏幕分辨率性能方面也会有所不同：Web 端性能测试更多关注的后台的性能，app 的性能测试关注的是手机本身的资源的性能问题：比如：CPU,内存，电量，流量，页面加载响应时间，软件启动时间等等他们两个之间的区别差不多就这些吧。</li><li>app测试和web端测试基本一样，没什么区别（需求分析-编写测试用例-评审用例-执行用例）web基于浏览器测试，不必考虑安装卸载，APP必须考虑安装卸载更新，兼容性，弱网<br> web测试不同的浏览器，APP测试考虑cpu，内存，耗电量，不同的品牌机型，不同的系统，不同手机的屏幕大小，屏幕分辨率</li></ol></li><li><h3 id="app测试你具体怎么做的？"><a href="#app测试你具体怎么做的？" class="headerlink" title="app测试你具体怎么做的？"></a><strong>app</strong>测试你具体怎么做的？</h3><ol><li>对于 App 这块，我主要做功能，先保证功能过关是第一位。对于功能这块的话，基本都跟 Web 端是一样的。除了功能之外，公司还会做了一些专项测试，像：安装，卸载测试,兼容性测试,稳定性测试,性能测试,弱网测试,交互性测试都有测试过的。专项测试这块，不是我负责的，但是大致了解：兼容性测试,稳定性测试,性能测试,弱网测试,交互性测试这是我这边负责的。像兼容性测试，公司有提供了差不多了7-8 款的真机，像：华为，小米，三星，vivo,oppo 等这些主流的机型都在真机想有测试过。其他的机型，公司用的是云测，云测平台我们用的TestIn 这个平台，公司会给我们提供账号。稳定性测试这块，用的 Monkey 命令工具去测的，主要就是通过 monkey 模拟用户发送一些伪随机时间，看 app 是否有Crash,ANR,Exception等现象，一般都是在晚上的时候去执行monkey 命令，然后出报告，分析。性能测试，用的GT 工具结合 Android Studio 工具去检测 app 在手机上运行的时候的 CPU,内存，电量，流量，启动时间，安装，卸载时间以及页面的响应时间。弱网我们用的fiddler工具去进行模拟的，模拟 2G,3G,4G 等弱网场景，看 app 在弱网情况，功能是否能正常使用。交互性测试这块主要就是看 app 与其他应用程序之间的交互运行，以及与系统应用程序之间交互运行，来回进行前后台切换，看是否会出现闪退，数据丢失等现象。</li></ol></li><li><h3 id="adb命令环境配置-常用的adb的命令操作"><a href="#adb命令环境配置-常用的adb的命令操作" class="headerlink" title="adb命令环境配置  常用的adb的命令操作"></a><a href="../999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_adb%E5%91%BD%E4%BB%A4%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">adb命令环境配置</a>  <a href="../999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_%E5%B8%B8%E7%94%A8%E7%9A%84adb%E7%9A%84%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/">常用的adb的命令操作</a></h3><ol><li><p>adb connect 127.0.0.1:21503     连接<a href="../999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/">逍遥虚拟机</a></p></li><li><p>adb connect 127.0.0.1:62001    连接夜游神虚拟机</p></li><li><p>海马模拟器端口号：26944</p><p> MuMu模拟器端口号：7555</p><p> 天天模拟器端口号：6555</p></li><li><p>adb start-server   打开adb服务</p><p> adb kill-server     # 关闭服务</p><p> adb devices        # 查询设备号</p><p> adb version  # 查询adb版本号</p><p> aapt dump badging 文件路径（apk在电脑端的路径） # 查询文件包名</p><p> adb connect ip地址    # 添加设备</p><p> adb disconnect ip   # 新设备端口</p><p> adb -s 设备 ID install 路径&#x2F;包名.apk    # 安装apk文件</p><p> adb -s 设备 ID shell pm list packeages -3   # 查看所有应用的包名</p><p> adb shell dumpsys activity   # 查询应用的包入口</p><p> adb shell # 进入模拟器的shell模式</p><p> adb  uninstall com.baidu.BaiduMap # 卸载应用程序</p><p> adb -s 设备 ID push D:\路径\文件 &#x2F;sdcard&#x2F;路径&#x2F; #手机上的文件传输到电脑端</p><p> adb -s 设备 ID pull &#x2F;sdcard&#x2F;路径&#x2F;文件      # 获取模拟器中的文件</p><p> adb logcat         # 查看日志</p><p> adb logcat -d     #打印完所有的日志文件之后，退出 shell 终端</p><p> adb logcat -c      #清除手机系统运行生成的日志文件</p><p> adb logcat -v time   #需要打印日志详细时间的简单数据</p><p> adb logcat -d *:E           #需要打印级别为 Error 的信息</p><p> adb logcat -d *:E &gt; D:\hello.log</p><p> adb logcat -d *:I &gt; D:\hello555.log #打印 I以上级别的所有日志信息</p><p> adb logcat -d *:E | findstr cn.csdn.activity &gt;D:&#x2F;hello_error2.log</p></li></ol></li><li><h3 id="App兼容性测试怎么做的？"><a href="#App兼容性测试怎么做的？" class="headerlink" title="App兼容性测试怎么做的？"></a><strong>App</strong>兼容性测试怎么做的？</h3><ol><li><p>像兼容性这块当时，我们主要用真机测试为主，公司当时使用提供大概 7,8 款机型吧，</p><p> 我记得像’华为荣耀系列’两款，例外小米机型有选择2 款，还有就是像 vivo,oppo 当时都有测过的,哦,对了还有三星等这些系列机型上都有做过真机测试。真机这块，像系统版本主要覆盖的系统其中 6.0 7.0 8.0 为主 4.0 以下公司当时都不要求测对于其他的机型覆盖不到位，我们都是通过云测进行覆盖的，云测这边，我们公司用的 testin 这个云测平台，公司有提供账号给我们只要登录上去，然后把 apk 上传上去，之后选择机型要测试的机型，当时我们在云测测试有差不多有 60 款多款机型吧，主要是市面上流程的主流机型，每个系列都会选个几款，如果用真机测了的就不在选择了，然后做一些相关的配置，云测平台上主要帮我们做了智能遍历，安装，启动，   运行，卸载，初始化，Monkey 测试相关的测试，不过 monkey 一般都是通过真机测的，云测平台没有测过。配置好了之后，提交测试就可以了。一般提交测试之后，需要几个小时就会出报告。然后分报告，主看遍历，安装，启动，运行，卸载，初始化相关哪些机型有出问题，对于出问题的机型，一般会先补测一下，如果还有问题，我们项目组一般会向公司申请真机再真机进行复测，如果真机复测有问题，就通过利用 adb logcat 查看错误日志，分析具体的问题所在。其实我们做兼容性测试，主要就是看软件在不同机型，不同系统版本下能不能正常安装，   卸载是否能正常启动，运行，初始化，我们都把各个功能都进行运行一遍，主要就是跑下主流程，看有不有问题。例外，就是看软件在不同屏幕大小，不同的分辨率的手机下显示是否正常，有不有拉伸，显示不全，或者显不清晰的等问题。当时我们兼容性就这么做测。</p></li></ol></li><li><h3 id="App稳定怎么做的？Monkey怎么用（App稳定测试）？"><a href="#App稳定怎么做的？Monkey怎么用（App稳定测试）？" class="headerlink" title="App稳定怎么做的？Monkey怎么用（App稳定测试）？"></a><strong>App</strong>稳定怎么做的？<strong>Monkey</strong>怎么用（<strong>App</strong>稳定测试）？</h3><ol><li><p>Monkey</p><ol><li><a href="../999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_Monkey%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">Monkey工具介绍</a></li><li><a href="../999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_Monkey%E4%BD%BF%E7%94%A8/">Monkey使用</a></li></ol></li><li><p>稳定性这块，我们当时用的是 SDK 自动的一个 Monkey 工具进行测试的，其实 Monkey 工具主要通过模拟用户发送伪随机时间去操作软件，通过执行 Monkey 命令，它会自动出报告，执行测试大概在 10 万次，每个动作的间隔时间250ms，主要就是看软件长时间，随机乱操作的情况，是否会出现异常，闪退，崩溃等现象。一般我都是在下班的时间晚上时间执行 Monkey 命令，并把生成的报告导出到电脑端， 大概需要 6-7 小时，第二天早上看报告，分析报告。如果出现问题，一般利用上次执行的那个种子值，再进行执行命令进行复测一下。</p><p> 像 monkey 命令：</p><p> adb   shell   monkey<br />-p   com.xy.android.junit   -s   种子 值   </p><p> –throttle 250<br> –ignore-crashes</p><p> –ignore-timeouts –monitor-native-crashes -v -v 100000 &gt;<br> E:\monkey_log\java_monkey_log.txt 这里主要关注几个点，1. 指定种子值， 2. 忽略一些异常，保证能正常执行完成 3. 设置间隔时间 4.配置一些时间比例 5.然后就是执行的次数。对于报告怎么分析这块，主要看有不有 CRASH（崩溃），ANR（超时无响应），Exception（异常）等的情况像看有不有空指针异常（NullPointException）啊，OOM 等现象啊等等， 找到 CRASH 崩溃 ANR 超时无响应Exception 异常的位置，看出现错误的上一个动作是什么，什么做了什么动作导致错误出现。异常信息会详细的指出哪个 Activity 出现了问题，甚至于哪个函数出问题了，具体哪个位置。然后把报告中出现的日志信息截图发给开发，开发修复完成之后，我们会根据种子值在进行复测一下。稳定性这块我们当时就是这么做的。</p></li></ol></li><li><h3 id="App弱网测试怎么做的？"><a href="#App弱网测试怎么做的？" class="headerlink" title="App弱网测试怎么做的？"></a><strong>App</strong>弱网测试怎么做的？</h3><ol><li>弱网测试这块我用的 fiddler 工具做的，通过 fiddler 实现延迟发送数据或接收的数据的时间来限制网络的下载速度和上传速度，从而达到模拟 2G,3G,4G,5G 的移动网络的弱网场景。具体操作，首先保证手机与电脑在同一个网络，然后在手机上，设置代理服务器，指定服务器为装了 fiddler 的电脑，端口为 8888，另外，手机端需要安装一个证书，主要为了实现对 https 包的抓取，然后就是在 fiddler 上设置上行，下行速率，实现对发送，接受数据的进行网络延迟。具体在 fiddler 的菜单上有一个 Rules-&gt;Customize Rules, 打开 Fiddler 的ScriptEditor 文件，在其中找到 m_SimulateMode 标志位。然后修改上行，下载的网络延迟时间即可。然后把 Rules-&gt;Performances-&gt;Simulate Modem Speeds 勾选上这样就可以了。弱网测试，看我们软件在弱网场景下是否会有丢包的现象，丢包率是否严重，页面是否能正常展示，是否有空白页，数据是否有丢失，页面加载速度是否会严重影响用户体验。</li><li>用fiddler工具<br> 通过 fiddler 实现延迟发送数据或接收的数据的时间来限制网络的下载速度和上传速度，从而达到模拟 2G,3G,4G,5G  的移动网络的弱网场景。具体操作，首先保证手机与电脑在同一个网络，然后在手机上，设置代理服务器，指定服务器为装了 fiddler 的电脑，端口为 8888，例外，手机端需要安装一个证书，主要为了实现对 https 包的抓取，然后就是在 fiddler 上设置上行，下行速率，实现对发送，接受数据的进行网络延迟。具体在 fiddler 的菜单上有一个 Rules-&gt;Customize Rules, 打开 Fiddler 的ScriptEditor 文件，在其中找到 m_SimulateMode 标志位。然后修改上行，下载的网络延迟时间即可。</li></ol></li><li><h3 id="App的性能测试怎么做的？"><a href="#App的性能测试怎么做的？" class="headerlink" title="App的性能测试怎么做的？"></a><strong>App</strong>的性能测试怎么做的？</h3><ol><li><p>App 性能这块，我们主要关注的是以下几个方面：</p><p> 一个就是我们应用程序的 CPU 占用率，内存使用情况，还有就是电量，流量的消耗， 帧率（FPS），另外，就是应用程序的启动耗时（冷启、热启），跟安装，卸载的时间除了以上两个方面之外，主要还有页面加载时间(响应时间)，页面的加载时间尤其是首页的加载   时间，页面切换响应时间，还有就是内存泄漏的一个检查。像应用程序的 CPU 占用率，内存使用情况，还有就是电量，流量的消耗，帧率（FPS）；</p></li><li><p>怎么操作的：</p><ol><li>我们用的是网易的 Emmagee 工具进行检查的。启动 Emmagee 之后–&gt;只要选择要测试的应用程序–&gt;开始测试–&gt;自动打开应用程序–&gt;随便操作应用程序。测试 30 分钟，自动生成测试报告，测试报告的形式.csv 格式。通过 excel 打开将数据转化为图标，进行分析。</li></ol></li><li><p>当时我主要检测了几个方面，</p><ol><li><ol><li><p>App 启动到页面加载完成这个过程的 Cpu，内存，电量， 流量，帧率（FPS）的情况 </p></li><li><p>在使用各个核心主要功能的过程中 Cpu，内存，电量，流量， 帧率（FPS）的情况，对他们进行分别统计分析的。一个应用程序不同的功能 Cpu，内存的消耗情况一般是不一样的，然后对不同场景的各个参数绘制成曲线图，进行详细的分析。我们当时对于 CPU 这块的指标要求是在 10-20%这个范围，像在使用一些基本的功能不是特别复杂的功能，CPU 的占有率要求在 10%左右，一些加载大批量数据，像图片，视频或其他大数据的复杂功能，要求 CPU 的占有率在 20%左右。而且当退出功能，应用程序在为操作的情况下 CPU 会有明显的下降。所以 CPU 一般是一个动态变化的一个曲线图！对于内存指标要求在 80M 以下，大数据处理的功能的内存指标要求在 200M 以下。</p></li><li><p>另外，对于内存这块最关键的是要注意内存泄漏的情况，如果在应用程序没有使用的情况下，或者说测试完成之后，手机内存应该要释放，这里需要检查内存是否释放完全。这个在测试前可以通过adb 命令查看手机内存的使用情况，通过 adb -s 127.0.0.1:62001   shell dumpsys meminfo 进行查看，测试完成之后再通过命令查看，看内存是否有释放。不过对于内存泄漏这块，我们开发那边会检查的比较细致一点，他们是通过 android studio 这个开发工具进行检查的，这个工具里面集成了对性能测试的一些插件，而且开发那边有源码包，他们会做详细的检查内存泄漏这块的问题。性能这块基本上就是这么测试的。</p></li></ol></li></ol></li></ol></li><li><h3 id="App交互性怎么做的？"><a href="#App交互性怎么做的？" class="headerlink" title="App交互性怎么做的？"></a><strong>App</strong>交互性怎么做的？</h3><ol><li><p>交互性这块，主要从以下几个方面去考虑测试的是：</p><ol><li><p>看我们软件与其他应用软件的同时运行,来回切换是否有问题</p></li><li><p>看软件切换到后台一段时间，再切换到前台，或者前后台来回切换，软件是否会有异常，比如：进程被杀死，或者切换到前端页面出现问题，或者页面数据丢失等等。</p></li><li><p>看软件被在使用过程中被其他应用中断，或者其他意外情况中断，比如: 来电，来短信，闹铃，低电量测试等，还要注意手机端硬件上，如：待机，锁屏，插拔数据线，耳机等操作不会影响客户端。</p></li></ol></li></ol></li><li><h3 id="App弱网测试怎么做的？-1"><a href="#App弱网测试怎么做的？-1" class="headerlink" title="App弱网测试怎么做的？"></a><strong>App</strong>弱网测试怎么做的？</h3><ol><li><p>弱网测试这块我用的 fiddler工具做的，通过 fiddler实现延迟发送数据或接收的数据的时间来限制网络的下载速度和上传速度，从而达到模拟2G,3G,4G的移动网络的弱网场景。</p></li><li><p>具体操作，首先保证手机与电脑在同一个网络，然后在手机上，设置代理服务器，指定服务器为装了 fiddler 的电脑的 ip 地址，端口为8888，然后就是在 fiddler 上设置上行， 下行速率，实现对发送， 接受数据的进行网络延迟。具体在 fiddler 的菜单上有一个Rules-&gt;CustomizeRules,打开 Fiddler 的 ScriptEditor文件，在其中找到 m_SimulateMode 标志位。然后修改上行，下载的网络延迟时间即可，具体设置参数的值SE 那边有给到一个参考文档</p></li><li><p>然后把 Rules-&gt;Performances-&gt;Simulate Modem Speeds 勾选上这样就可以了。</p></li><li><p>弱网测试，看我们软件在弱网场景下是否会有丢包的现象，丢包率是否严重，页面是否能正常展示，是否有空白页，数据是否有丢失，页面加载速度是否会严重影响用户体验。</p></li></ol></li><li><h3 id="H5界面怎么测试"><a href="#H5界面怎么测试" class="headerlink" title="H5界面怎么测试"></a><strong>H5</strong>界面怎么测试</h3><ol><li><p>基本功能测试：（浏览器、微信内置浏览器）</p></li><li><p>登陆</p><ol><li><p>目前 H5 与 native 各个客户端都做了互通，所以大家在测试的时候要注意两点：</p><ol><li>A、若客户端已登录，那么进入 H5 后仍然是登录状态。</li><li>B、若客户端未登录，进入 H5，点击对应按钮 OR 链接，如果需要登录，须拉起 native登录。若取消登录，是否可再次拉起登录，或者停留在的页面是否有对应的登录提示。</li><li>ps：本次测试过程中就发现，第一次点击链接，可以拉起登录，第二次却不能。</li></ol></li></ol></li><li><p>翻页</p><ol><li>遇到翻页加载的页面，需要注意内容为 1 页或者多页的情况。</li><li>A、数据分页加载时，注意后续页面请求数据的正确。</li><li>ps：这个需要注意在快速操作场景中，请求页数是不是依次递增，快速操作（如第一页尚未 loading 出来的时候仍然继续上拉操作）时是否发出去对应的请求了。</li></ol></li><li><p>刷新与返回</p><ol><li>A、下拉刷新是否仍然处于当前页面。</li><li>B、用户主动点击刷新按钮是否仍然处于当前页面。</li><li>C、点击返回与 back<br> 键，回退页面是否是期望页面</li><li>ps：本次测试过程中就发现，mtop 接口请求成功，但是 data 内无数据时，返回到的就是个空白页面，无法正常发送请求。</li></ol></li><li><p>H5 适配相关</p><ol><li><p>H5 的适配其实比客户端的相对来说，要少一些，手机品牌之间的差异不大，所以不用太多关注，最容易出现问题的是 android2.3 系统，这个要特别关注下：</p><ol><li>A、大屏（如 720<em>1280，重点关注页面背景是否完全撑开页面，刷新是否有抖动）、小屏手机（如 320</em>480，重点关注下弹框样式和文案折行）</li><li>B、android2.3、android4.X 随机找一个即可。</li><li>C、ios5、ios6、ios7。体验相关</li></ol></li></ol></li><li><p>资源相关</p><ol><li>A、页面中有图片的话，淘宝那边建议图片一般不大于 50kb，本着一个原则，尽量缩小图片。</li><li>B、资源是否压缩、是否通过 CDN 加载。</li><li>C、如何保证二次发布后有效更新。</li></ol></li><li><p>流量</p><ol><li>A、对于一些不会变化的图片，如游戏动画效果相关图片，不需要每次都请求的东西，  做本地缓存。</li><li>B、数据较多时是否做了分页加载。</li></ol></li><li><p>页面展现时间</p><ol><li>A、关注页面首屏加载时间。</li></ol></li><li><p>页面提示</p><ol><li>A、弱网络下，数据加载较慢，是否有对应的loading 提示。</li><li>B、接口获取异常时，提示是否友好。</li><li>C、刷新页面或者加载新内容时页面是否有抖动。</li></ol></li><li><p>手机操作相关</p><ol><li>A、锁屏之后展示页面。</li><li>B、回退到后台之后，重新呼出在前台展示。</li></ol></li></ol></li><li><h3 id="小程序怎么测试（详细）"><a href="#小程序怎么测试（详细）" class="headerlink" title="小程序怎么测试（详细）"></a>小程序怎么测试（详细）</h3><ol><li>1, 小程序测试（多用第一人称，口语化表达，多讲一些，讲细一些，先宏观，在微观）参考 面试问题<br> STAR 法则我们原来主要测试，几个方面，界面测试，功能测试，交互性测试，兼容性测试，安全测试，易用性测试， 异常测试，权限测试界面测试，主要是测试跟界面的原型图是否一致，同时我也要考虑不同屏幕大小跟分辨率功能测试，跟所有的功能测试都是一样的，还有小程序有位置功能 ，检查下，微信小程序附近中是否能找到对应小程序，使用小程序是否记录，交互性测试，，要考虑跟微信的功能交互使用，比如说一些，卡包，支付等功能，考虑跟手机固有功能交互， 比如说来电，短信等，兼容性测试，考虑跟微信不同版本的兼容，还有同时还要考虑不同手机厂商跟手机型号兼容，还要考虑当微信清除缓存后，小程序还能否继续使用安全测试，测试数据加密，包括 sql，与 xss 脚本攻击这块易用性测试，考虑功能是否方便还用异常测试，考虑断网，手机重启，关键的情况权限测试，小程序继承微信权限，测试手机对微信权限，还要考虑微信对小程序授权，是否允许操作原来我们测试阶段，上传小程序到微信小程序平台，上传到开发版本里面，通过扫描二维码去下载小程序进行测试上线后，我们也要测试下，微信搜索小程序中能否搜索的到</li></ol></li><li><h3 id="Android跟-ios测试有什么区别？"><a href="#Android跟-ios测试有什么区别？" class="headerlink" title="Android跟 ios测试有什么区别？"></a><strong>Android</strong>跟 <strong>ios</strong>测试有什么区别？</h3><ol><li>Android 和 ios 测试的共同点都需要进行界面测试、功能测试、兼容性测试、网络测试、交互性测试、易用性专项测试、异常测试、安全专项测试以及权限测试。不同的是 Android 测试除了以上的测试之外还要用 monkey 进行稳定性专项测试以及用 emmagee 或者 gt 进行性能专项测试。Ios 是用 itools 工具对功能进行测试：安装、传输文件以及查看日志。从操作系统，安装卸载，按键操作，开发语言这几个方面去区分操作系统：android 操作系统较多，IOS 较少只能升级不能降级，并且新的版本的资源库不能完全兼容旧版中系统中的应用，如果低版本应用调用了高版本的资源库，可能会导致系统崩溃。安装卸载测试，应用发布后：下载安卓包的平台和渠道很多：豌豆荚、应用宝、360手机助手等；IOS 主要有 Appstore、iTunes，安全性会更高点本地测试：安卓手机可以通过扫码或者直接安卓 APK 包安装测试包；IOS要安装测试包必须绑定手机的 id（证书）才可以安装ipa 测试包按键操作测试：安卓手机针对每一款手机有不一样的操作；苹果手机操作习惯单一开发语言：虽然同样的业务安卓和 IOS的展示形式和业务一致，但是底层全完不一样。安卓的应用是有 java语言实现的;iOS用 OC实现</li><li>运行机制，安卓的的运行机制是虚拟的，ios的运行机制是沙盒<br> 后台机制，ios推送的是系统常住进程，安卓需要给每个应用机制在后台建立指令权限，ios的指令权限ui是最高权限，安卓是数据处理的指令具有最高权限<br> 安卓在应用商店里面下载，ios是在蒲公英上下载安装<br> 按键操作测试：安卓手机针对每一款手机有不一样的操作；苹果手机操作习惯单一<br> 本地测试：安卓手机可以通过扫码或者直接安卓 APK 包安装测试包；IOS 要安装测试包必须绑定手机的 id（证书）才可以安装ipa 测试包</li></ol></li><li><h3 id="app突然崩溃白屏是什么原因造成的"><a href="#app突然崩溃白屏是什么原因造成的" class="headerlink" title="app突然崩溃白屏是什么原因造成的"></a>app突然崩溃白屏是什么原因造成的</h3><p> 1：内存管理，这个主要就是后台应该程序过多造成的内存过低</p><p> 2：用户连接过多，系统响应不过来导致APP崩溃</p><p> 3:   APP兼容性问题，这个主要考虑换下手机的机型进行测试</p><p> 4：代码错误，代码没有测试导致系统崩溃</p></li><li><h3 id="APP测试分H5界面和原生态界面"><a href="#APP测试分H5界面和原生态界面" class="headerlink" title="APP测试分H5界面和原生态界面"></a>APP测试分H5界面和原生态界面</h3><ol><li><p>什么是H5界面：</p><ol><li>H5界面是HTML的一种语言，H5界面比较炫</li><li>h5页面是采用HTML5前端技术设计的页面，目前，HTML5的标准在很多移动端的浏览器都支持，所以很多移动站点采用HTML5技术开发，h5页面是也可以理解为移动端网页。</li></ol></li><li><p>原生态界面：</p><ol><li>可以通过以下“H5界面和原生态界面的区别”来了解</li></ol></li></ol></li><li><h3 id="H5界面和原生态界面的区别"><a href="#H5界面和原生态界面的区别" class="headerlink" title="H5界面和原生态界面的区别"></a>H5界面和原生态界面的区别</h3><p> 1：断网的时候，看手机断点点击页面，如果可以正常显示的是原生态界面，显示404或者白屏的是H5界面</p><p> 2：看它的布局边界，打开手机里面有个开发者模式。里面有个查看布局，边界布局，显示密密麻麻的是H5界面，不显示的是原生态 的界面</p><p> 3：复制情况下，我们长时间按中选择的字体，显示复制，粘贴的就是H5界面，不显示的是原生态界面的</p><p> 4：加载方式，打开页面然后有个进度条，有的就是H5界面，没有就是原生态的</p><p> 5：观察APP顶部有没有关闭按钮，有的就是H5界面，没有就是原生态</p><p> 6：下拉页面的时候显示网址提供方的一定是H5</p><p> 我们测试一般用的是H5界面</p></li><li><h3 id="抓包你是怎么抓的？"><a href="#抓包你是怎么抓的？" class="headerlink" title="抓包你是怎么抓的？"></a>抓包你是怎么抓的？</h3><ol><li>首先保证移动端和PC端在一个局域网内，在移动端设置IP和端口号，设置完成后就可以抓包了</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> APP测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有没有做过性能测试</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/06_%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E8%BF%87%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/06_%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E8%BF%87%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="jmeter-为性能测试提供了一下特色："><a href="#jmeter-为性能测试提供了一下特色：" class="headerlink" title="jmeter 为性能测试提供了一下特色："></a><strong>jmeter 为性能测试提供了一下特色：</strong></h3><p>jmeter 可以对测试静态资源（例如 js、html 等）以及动态资源（例如 php、jsp、ajax 等等）进行性能测试<br>jmeter 可以挖掘出系统最大能处理的并发用户数<br>jmeter 提供了一系列各种形式的性能分析报告</p><p><strong>使用 jmeter 一般用于以下两种类型的性能测试</strong></p><p>负载测试：通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。<br>压力测试：测试系统能承受的最大负载能力。目的在于发挖掘出目标服务系统可以处理的最大负载。</p><h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><p> 下面我们看下使用 jmeter 进行性能测试的基本过程</p><p><img src="/assets/image-20211209004611-ubgkfsm.png" alt="image.png"></p><p>对上图进行简要的说明<br><strong>新增线程组</strong><br>创建测试线程组，并设置线程数量及线程初始化启动方式。<br><strong>新增 JMeter 元组</strong><br>创建各种默认元组及测试元组，填入目标测试静态资源请求和动态资源请求参数及数据。<br><strong>新增监听器</strong><br>创建各种形式的结果搜集元组，以便在运行过程及运行结束后搜集监控指标数据。<br><strong>运行&amp;查看结果</strong><br>调试运行，分析指标数据，挖掘性能瓶颈、评估系统性能状态；</p><p>示例<br>下面我们以打开百度演示上述过程。<br>新增线程组<br>在 jmeter 的 bin 目录下双击 jmeter.bat或ApacheJMeter.jar 启动 jmeter，如下图：</p><p><img src="/assets/image-20211209004618-fiqfada.png" alt="image.png"><br>在左边操作栏中选择“测试计划”，右击新增一个线程组，如图所示：</p><p><img src="/assets/image-20211209004634-l377nn4.png" alt="image.png"></p><p>初始化线程组相关信息</p><p><img src="/assets/image-20211209004641-gclhau2.png" alt="image.png"></p><p>新增 JMeter 元组<br>添加默认配置元素，添加如下默认配置，如图</p><p><img src="/assets/image-20211209004648-qgtsoxh.png" alt="image.png"></p><p>各默认组件配置如图所示。HTTP Cache Manager</p><p><img src="/assets/image-20211209004655-3p9tuyj.png" alt="image.png"></p><p>HTTP Cookie 管理器</p><p><img src="/assets/image-20211209004701-41vyihu.png" alt="image.png"></p><p>HTTP 请求默认值</p><p><img src="/assets/image-20211209004708-2gryv4f.png" alt="image.png"></p><p>添加 HTTP Request 元组<br>在线程组上右击新增 HTTP 请求，如图：</p><p><img src="/assets/image-20211209004714-l6raanu.png" alt="image.png"></p><p>HTTP 请求设置如图：</p><p><img src="/assets/image-20211209004721-o8a3zz8.png" alt="image.png"></p><p>新增监听器<br>在这里我们添加如下监听器，如图所示</p><p><img src="/assets/image-20211209004727-k4cadnq.png" alt="image.png"></p><p>运行&amp;查看结果<br>如果启动运行 jmeter，可以单击添加的监听器查看运行过程中的监控指标数据，也可以等运行结束后，再查看。</p><p><img src="/assets/image-20211209004734-osigcbx.png" alt="image.png"></p><p>结果说明<br>下面我们就监听器所采集的结果图进行简要的说明：图形结果</p><p><img src="/assets/image-20211209004740-o2l0pz4.png" alt="image.png"></p><p>察看结果树</p><p><img src="/assets/image-20211209004747-1ff5ysa.png" alt="image.png"></p><p>用表格查看结果</p><p><img src="/assets/image-20211209004754-uhk341o.png" alt="image.png"></p><p>聚合报告</p><p><img src="/assets/image-20211209004800-177qcka.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 有没有做过性能测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能指标的标准1</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%A0%87%E5%87%861/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%A0%87%E5%87%861/</url>
      
        <content type="html"><![CDATA[<p>对于性能测试,以上性能指标必须要有清楚的理解,自己总结如下:</p><ol><li>响应时间(RT)</li></ol><p>　　是指系统对请求作出响应的时间。这个指标与人对软件性能的主观感受是一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。</p><p>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。</p><p>注意: 在性能测试中, 响应时间要做更细致划分</p><p><img src="/assets/image-20211209005950-u0io3qv.png" alt="image.png"></p><ol start="2"><li>吞吐量(Throughput)</li></ol><p>吞吐量是指系统在单位时间内处理完成的客户端请求的数量, 直接体现软件系统的性能承载能力。这是目前最常用的性能测试指标。对于服务器来讲,吞吐量越高越好.吞吐量是一个很宽泛的概念, 通常情况下，用“请求数&#x2F;秒”或者“页面数&#x2F;秒”来衡量。</p><p>体现:</p><ol><li>业务角度: 业务数&#x2F;小时 或 访问人数&#x2F;天等</li><li>网络流量: 字节数&#x2F;小时 或 字节数&#x2F;天等</li><li>服务器性能处理能力(重点): TPS(每秒事务数) 和 QPS(每秒查询数):</li></ol><p>对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。</p><p>对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。</p><ol start="3"><li><p>TPS(Transactions Per Second,每秒事务数)</p><p> TPS是单位时间内处理事务的数量,从代码角度来说,一段代码或多段代码可以组成一个事务.单位时间内完成的事务数越多,服务器的性能越好</p></li></ol><p><img src="/assets/image-20211209005958-jbk9wq2.png" alt="image.png"></p><p>4.. QPS(Query Per Second,每秒查询数)</p><pre><code>     QPS是单位时间内处理请求的数量,比TPS划分的更细致一些,因为一个事务可能会包含多个请求. 在一个事务当中, 假如只包含一个请求, 那么 QPS 就是指该请求过程中, 发起的数据查询总次数. 注意: 在 JMeter 当中, 把 TPS 和 QPS 简单的认为是同一个指标, 用来考察服务器性能好坏</code></pre><p>TPS和QPS的区别?</p><p>TPS(transaction per second)是单位时间内处理事务的数量，QPS(query per second)是单位时间内请求的数量。TPS代表一个事务的处理，可以包含了多次请求。很多公司用QPS作为接口吞吐量的指标，也有很多公司使用TPS作为标准，两者都能表现出系统的吞吐量的大小，TPS的一次事务代表一次用户操作到服务器返回结果，QPS的一次请求代表一个接口的一次请求到服务器返回结果。当一次用户操作只包含一个请求接口时，TPS和QPS没有区别。当用户的一次操作包含了多个服务请求时，这个时候TPS作为这次用户操作的性能指标就更具有代表性了。</p><p>个人理解如下：</p><p>1、Tps即每秒处理事务数，包括了</p><p>1）用户请求服务器</p><p>2）服务器自己的内部处理</p><p>3）服务器返回给用户</p><p>这三个过程，每秒能够完成N个这三个过程，Tps也就是N；</p><p>2、Qps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。</p><p>例如：访问一个页面会请求服务器3次，一次访问，产生一个“T”，产生3个“Q”</p><p>5.并发数</p><pre><code>     并发测试的用户数量, 指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。     用户数概念划分:</code></pre><ol><li>并发用户数: 同一时间内发送请求的用户数量(同一个请求&#x2F;非同一个请求)</li><li>在线用户数: 某段时间内在系统内的用户数量(不是所有在线用户都会发送请求)</li><li>系统用户数: 系统内注册的用户数量(存在一人拥有多个账号的情况)</li></ol><p>结论: 系统用户数 &gt; 在线用户数 &gt; 并发用户数</p><p>6.点击数HPS (每秒点击次数)</p><pre><code>     是指发起请求时, 服务端对请求进行响应的页面资源对应的请求数量.</code></pre><p>注意:</p><ol><li>日常操作中, 对页面的点击动作不是这里说的点击数</li><li>该指标只在 Web 项目中需要注意</li></ol><p>例如,访问百度首页</p><p><img src="/assets/image-20211209010006-yv8nam9.png" alt="image.png"></p><p>7.资源利用率</p><p>定义: 系统资源(CPU&#x2F;内存&#x2F;磁盘&#x2F;网络)使用占比(使用量&#x2F;总量*100%)</p><p>利用率指标:(没有特殊要求情况下)</p><ol><li>CPU 不超过 75%-85%</li><li>内存不超过 80%</li><li>硬盘不超过 90%(容量占有率&#x2F;读写时间比)</li></ol><p>8.错误率</p><p>定义: 错误率指系统在负载情况下，失败交易的概率。</p><p>错误率 ＝ (失败交易数&#x2F;交易总数)*100%</p><p>注意:</p><ol><li>大多系统都会要求无限接近于 100% 成功率, 因此, 错误率一般都非常低</li><li>相对稳定的系统产生的错误率又称超时率(由网络传输导致的)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 性能指标的标准1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能指标的标准2</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%A0%87%E5%87%862/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%A0%87%E5%87%862/</url>
      
        <content type="html"><![CDATA[<p>响应时间：</p><p>　　1.利用2-5-8原则去判定<br>吞吐量：<br>　　1.125<em>x kb&#x2F;s</em>0.5，若小于前面的数值为优，其中x为x Mb&#x2F;s，例如1 Mb&#x2F;s<br>每秒点击数：</p><p>　　1.指客户端每秒钟向服务器端提交的请求数量，如果客户端发出的请求数量越多，与之相对的平均吞吐量也应该越大<br>并发用户数：</p><p>　　1)、经典公式1：</p><p>  　　 一般来说，利用以下经验公式进行估算系统的平均并发用户数和峰值数据</p><p>  　　　　1）平均并发用户数为 C &#x3D; nL&#x2F;T</p><p> 　　　　 2）并发用户数峰值 C‘ &#x3D; C + 3*根号C</p><pre><code>　　　　C是平均并发用户数，n是login session的数量，L是login session的平均长度，T是值考察的时间长度</code></pre><p>   　　　　 C’是并发用户数峰值</p><p>举例1，假设系统A，该系统有3000个用户，平均每天大概有400个用户要访问该系统（可以从系统日志从获得），对于一个典型用户来说，一天之内用户从登陆到退出的平均时间为4小时，而在一天之内，用户只有在8小时之内会使用该系统。</p><p>  那么，</p><p>  　　　　平均并发用户数为：C &#x3D; 400*4&#x2F;8 &#x3D; 200</p><p>  　　  　 并发用户数峰值为：C‘ &#x3D; 200 + 3*根号200 &#x3D; 243</p><p>举例2， 某公司为其170000名员工设计了一个薪酬系统，员工可进入该系统查询自己的薪酬信息，但并不是每个人都会用这个系统，假设只有50%的人会定期用该系统，这些人里面有70%是在每个月的最后一周使用一次该系统，且平均使用系统时间为5分钟。则一个月最后一周的平均并发用户数为（朝九晚五）：</p><p> 　　　　 n &#x3D; 170000<em>0.5</em>0.7&#x2F;5 &#x3D; 11900</p><p> 　　　　 C&#x3D; 11900*5&#x2F;60&#x2F;8 &#x3D; 124</p><p>  　　　　吞吐量计算为：F &#x3D; Vu * R &#x2F; T 单位为个&#x2F;s</p><p>   　　　　　 F为事务吞吐量，Vu为虚拟用户数个数，R为每个虚拟用户发出的请求数，T为处理这些请求所花费的时间</p><p>　　2)、通用公式2：</p><p>  　　对绝大多数场景，我们用（用户总量&#x2F;统计时间）*影响因子（一般为3）来进行估算并发量。</p><p>  　　比如，以乘坐地铁为例子，每天乘坐人数为5万人次，每天早高峰是7到9点，晚高峰是6到7点，根据8&#x2F;2原则，80%的乘客会在高峰期间乘坐地铁，则每秒 到达地铁检票口的人数为50000<em>80%&#x2F;（3</em>60<em>60）&#x3D;3.7，约4人&#x2F;S，考虑到安检，入口关闭等因素，实际堆积在检票口的人数肯定比这个要 大，假定每个人需要3秒才能进站，那实际并发应为4人&#x2F;s</em>3s&#x3D;12，当然影响因子可以根据实际情况增大！</p><p>　　3)、根据PV计算公式：</p><p> 　　 比如一个网站，每天的PV大概1000w，根据2&#x2F;8原则，我们可以认为这1000w pv的80%是在一天的9个小时内完成的（人的精力有限），那么TPS　　为：</p><p>  　　1000w<em>80%&#x2F;(9</em>3600)&#x3D;246.92个&#x2F;s,取经验因子3，则并发量应为：</p><p> 　　 246.92*3&#x3D;740</p><p>　　4)、根据TPS估计：</p><p>  　　 公式为 C &#x3D; (Think time + 1)*TPS</p><p>　　5)、根据系统用户数计算：</p><p>   　　并发用户数 &#x3D; 系统最大在线用户数的8%到12%</p><p>资源使用率：<br>　　1).平均事务响应时间<br>　　Average Transation Response Time优秀：&lt;2s<br>　　良好：2-5s<br>　　及格：6-10s<br>　　不及格：&gt;10s<br>　　2).每秒点击率<br>　　Hits per Second<br>　　当增大系统的压力(或增加并发用户数)时，吞吐率和TPS的变化曲线呈大体一致，则系统基本稳定若压力增大时，吞吐率的曲线增加到一定程度后出现变化缓慢，甚至平坦，很可能是网络出现带宽瓶颈.同理若点击率&#x2F;TPS曲线出现变化缓慢或者平坦，说明服务器开始出现.<br>　　3).请求响应时间<br>　　Time to Last Byte<br>　　4).每秒系统处理事务数<br>　　Transaction per second<br>　　5).吞吐量<br>　　Throughout<br>　　6).CPU利用率<br>　　Processor&#x2F;%Processor Time好：70%<br>　　坏：85%<br>　　很差：90%+<br>　　7).数据库操作消耗的CPU时间<br>　 　Processor&#x2F;%User Time如果该值较大，可以考虑是否能通过友好算法等方法降低这个值。如果该服务器是数据库服务器，Processor%User Time值大的原因很可能是数据库的排序或是函数操作消耗了过多的CPU时间，此时可以考虑对数据库系统进行优化。<br>　　8).核心态CPU平均利用率<br>　　Processor&#x2F;%Privileged Time如果该参数值和”Physical Disk”参数值一直很高，表明I&#x2F;O有问题。可考虑更换更快的硬盘系统<br>　　9).处理列队中的线程数<br>　 　Processor&#x2F;Processor Queue Length如果该值保持不变(&gt;&#x3D;2)个并且%Processor Time超过90%，那么可能存在处理器瓶颈。如果发现超过2，而处理器的利用率却一直很低，那么或许更应该去解决处理器阻塞问题，这里处理器一般不是瓶 颈。<br>　　10).文件系统缓存<br>　　Memory&#x2F;Cache Bytes 50%的可用物理内存<br>　　11).剩余的可用内存<br>　　Memory&#x2F;Avaiable Mbytes至少要有10%的物理内存值<br>　　12).每秒下载页数<br>　　Memory&#x2F;pages&#x2F;sec好：无页交换<br>　　坏：CPU每秒10个页交换<br>　　很差：更多的页交换<br>　　13).页面读取操作速率<br>　　Memory&#x2F;page read&#x2F;sec如果页面读取操作速率很低，同时%Disk Time和Avg.Disk Queue Length的值很高，则可能有磁盘瓶径。但是，如果队列长度增加的同时页面读取速率并未降低，则内存不足。<br>　　14).物理磁盘利用率<br>　　Physical Disk&#x2F;%Disk Time好：&lt;30%<br>　　坏：&lt;40%<br>　　很差：&lt;50%+<br>　　15).物理磁盘平均磁盘I&#x2F;O队列长度<br>　　Physical Disk&#x2F;Avg.Disk Queue Length该值应不超过磁盘数的1.5~2倍。要提高性能，可增加磁盘<br>　　16).网络吞吐量<br>　　Network Interface&#x2F;Bytes Total&#x2F;sec判断网络连接速度是否是瓶颈，可以用该计数器的值和目前网络的带宽，结果应该小于50%<br>　　17).数据高速缓存区命中率命中率应大于0.90最好<br>　　18).共享区库缓存区命中率命中率应大于0.99<br>　　19).监控SGA中字典缓冲区的命中率命中率应大于0.85<br>　　20)检测回滚段的争用小于1%<br>　　21).监控SGA中重做日志缓存区的命中率<br>　　应该小于1%<br>　　22).监控内存和硬盘的排序比率最好使它小于10%</p>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 性能指标的标准2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>locust</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_locust/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_locust/</url>
      
        <content type="html"><![CDATA[<ol><li><p>locust特点</p><ol><li>开源</li><li>python语言</li><li>基于协程</li><li>高并发</li><li>性能自动化测试平台</li><li>requests</li></ol></li><li><p>进程与协程的区别</p><ol><li><p><img src="/assets/image-20211210201855-6ee3igb.png" alt="image.png"></p></li><li><p>对于操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元</p></li><li><p>协程，英文coroutines ，是一种比县城更加轻量级的存在</p><ol><li>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</li></ol></li></ol></li><li><p>协程的应用</p><ol><li><p>lua语言</p><ol><li>lua从5.0版本开始使用协程，通过扩展库coroutine来实现</li></ol></li><li><p>python语言</p><ol><li>正如刚才缩写的代码示例，python可以通过yield&#x2F;send 的方式实现协程，在python3.5以后，async&#x2F;await，可以更好的替代方案</li></ol></li><li><p>go语言</p><ol><li>go语言对协程的实现非常强大而简洁，可以轻松创建成百上千个协程并发执行</li></ol></li></ol></li><li><p>环境部署</p><ol><li><p>locust-windows</p><ol><li>((20211205191704-1smubww “安装python”))</li><li>((20211205191238-tb9h7p1 “安装pycharm”))（开发工具）</li></ol></li><li><p>locust-linux</p><ol><li>目前省略……</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> locust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各项指标的计算方法</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E5%90%84%E9%A1%B9%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E5%90%84%E9%A1%B9%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="响应时间：对请求作出响应所需要的时间"><a href="#响应时间：对请求作出响应所需要的时间" class="headerlink" title="响应时间：对请求作出响应所需要的时间"></a>响应时间：对请求作出响应所需要的时间</h4><pre><code>网络传输时间：N1+N2+N3+N4应用服务器处理时间：A1+A3数据库服务器处理时间：A2响应时间=N1+N2+N3+N4+A1+A3+A2</code></pre><h4 id="并发用户数的计算公式"><a href="#并发用户数的计算公式" class="headerlink" title="并发用户数的计算公式"></a>并发用户数的计算公式</h4><pre><code>系统用户数：系统额定的用户数量，如一个OA系统，可能使用该系统的用户总数是5000个，那么这个数量，就是系统用户数。同时在线用户数：在一定的时间范围内，最大的同时在线用户数量。同时在线用户数=每秒请求数RPS（吞吐量）+并发连接数+平均用户思考时间平均并发用户数的计算：C=nL / T其中C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session的平均时间），T是考察时间长度（一天内多长时间有用户使用系统）并发用户数峰值计算：C^约等于C + 3*根号C其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论。</code></pre><h4 id="吞吐量的计算公式"><a href="#吞吐量的计算公式" class="headerlink" title="吞吐量的计算公式"></a>吞吐量的计算公式</h4><pre><code>指单位时间内系统处理用户的请求数从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量从网络角度看，吞吐量可以用：字节/秒来衡量对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU * R /其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间</code></pre><h4 id="性能计数器"><a href="#性能计数器" class="headerlink" title="性能计数器"></a>性能计数器</h4><pre><code>是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用/总的资源可用量”形成资源利用率。</code></pre><h4 id="思考时间的计算公式"><a href="#思考时间的计算公式" class="headerlink" title="思考时间的计算公式"></a>思考时间的计算公式</h4><pre><code>Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。在吞吐量这个公式中F=VU * R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS下面给出一个计算思考时间的一般步骤：A、首先计算出系统的并发用户数C=nL / T F=R×CB、统计出系统平均的吞吐量F=VU * R / T R×C = VU * R / TC、统计出平均每个用户发出的请求数量R=u*C*T/VUD、根据公式计算出思考时间TS=T/R</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 各项指标的计算方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QNET-网络测试工具</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_QNET-%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_QNET-%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是QNET"><a href="#一、什么是QNET" class="headerlink" title="一、什么是QNET"></a>一、什么是QNET</h3><p>QNET腾讯WeTest开放平台最近推出了一款针对移动应用的弱网测试工具QNET，解决了在Android设备上进行弱网络专项测试的痛点，QNET无需ROOT手机，无需连接数据线，以独立app的方式，为用户提供给快捷、可靠、功能完善的弱网络模拟服务。</p><p>另外QNET还有一个很好用的功能——TCP&#x2F;UDP网络协议抓包，帮助开发和测试人员进行网络流量分析，而不需要ROOT手机，使用tcpdump进行抓包。</p><p>QNET网络测试工具能够不借助PC或服务器，搭建一套完整的弱网测试环境，进行弱网络模拟测试，秩序在任意只能手机上安装QNET网络测试工具，即完成弱网络测试环境搭建工作，接下来根据需要选择不同场景进行测试即可，除此之外，还提供了网络数据包抓包功能，便于进行网络数据问题的分析。</p><h3 id="二、为什么要弱网测试"><a href="#二、为什么要弱网测试" class="headerlink" title="二、为什么要弱网测试"></a>二、为什么要弱网测试</h3><p>1、验证应用&#x2F;游戏在不同网络场景下表现是否符合预期，会不会触发未知的系统bug<br>2、提高不同网络场景下用户的体验<br>3、测试公用组件&#x2F;SDK在不同网络状态下的稳定性</p><p><strong>测试移动设备上进行弱网专项测试的方案主要有两种：</strong></p><p>1、通过Android设备连接到PC上进行弱网测试，比如Fiddler，Charles,NET-Simulator等。基本思路是在PC上装一个Fiddler网络抓包工具，然后再将Android设备的网络代理到PC上，通过PC的Fiddler在设置延时来进行弱网络模拟</p><p>2、在专有服务器上构建弱网络WI-FI，移动设备连接该Wi-Fi进行弱网测试，相关的技术方案有 Facebook的ATC和腾讯的WeTest-WiFi。</p><p><strong>以上两种方法都能够实现移动设备的弱网专项测试，也已经是比较成熟的方案，但都存在以下几点缺点：</strong></p><p>（1）需要额外的PC或者服务器，弱网环境构建成本高；<br>（2）需要安装、部署额外的工具，并且弱网络环境需要在PC上或者Web上进行配置，使用成本高；<br>（3）弱网络环境功能并不完善，比如Fiddler不支持丢包、抖动等弱网环境。</p><h3 id="三、工具使用介绍"><a href="#三、工具使用介绍" class="headerlink" title="三、工具使用介绍"></a>三、工具使用介绍</h3><p>具体查看官网：<a href="https://cdn.wetest.qq.com/qnet/files/QNET%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B72.0.pdf">https://cdn.wetest.qq.com/qnet/files/QNET网络测试工具2.0.pdf</a></p><h3 id="四、弱网功能详细介绍"><a href="#四、弱网功能详细介绍" class="headerlink" title="四、弱网功能详细介绍"></a>四、弱网功能详细介绍</h3><h4 id="1、自定义模板参数介绍"><a href="#1、自定义模板参数介绍" class="headerlink" title="1、自定义模板参数介绍"></a>1、自定义模板参数介绍</h4><p><img src="/assets/image-20220311173743-wnv5mqz.png" alt="image.png"></p><p>（1）网络模板<br>单位kbps，限制当前网络上下行最大的带宽容量，例如针对腾讯视频设置1024kbps限速后，下载速度 只能达到128KB&#x2F;s左右：</p><p>（2）网络延时<br>单位ms，当前网络的上下行延时约等于设置值，设置延时100ms,200ms,300ms</p><p>（3）延时抖动<br>对每个数据包以设置的概率进行抖动选择，延时范围在0~抖动值之间随时产生</p><p>（4）随机丢包<br>按设置的概率对每个包进行丢包</p><p>（5）周期弱网<br>按照放行时长、弱网时长设置交替切换，根据弱网类型进行弱网。</p><p>弱网类型：<br> <strong>【完全丢包】</strong> ：处于弱网时长的数据包直接丢包<br> <strong>【Burst】</strong> ：模拟路由或者底层硬件在判断当前网络连接不通时保存数据包，在网络通畅后爆发式的将 数据包推送出去，</p><p>（6）协议控制<br>支持对不同协议的弱网控制，协议类型包括TCP\UDP\ICMP\DNS；<br>（7）IP控制 可以针对IP进行弱网控制，多个IP以|分割。</p><h4 id="2、场景模板介绍"><a href="#2、场景模板介绍" class="headerlink" title="2、场景模板介绍"></a>2、场景模板介绍</h4><p><img src="/assets/image-20220311173751-5142qan.png" alt="image.png"></p><p>（1）网络选择<br>提供真实的省市间网络传递的数据参数、运营商数据、网络类型数据；<br>（2）场景选择<br>提供多个真实测量不同场景下的网络波形</p><p>接下来：<br>应用实际场景中<br>掌握基础知识</p>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> QNET-网络测试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习规则</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周    1. 打卡        1. 要求每天打卡四次：            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00    2. 教学规则        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）        2. 晚上10点准时休息        3. 学习期间不准酗酒        4. 无重大事件不准请假    3. 日报        1. 每日必填    4. 教学时间        1. 分为大小周教学    5. 教室、宿舍环境保证清洁卫生    6. 教室、宿舍禁止抽烟</code></pre><h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天2. 第二章 操作              -----------&gt; 6工作天3. 第三章 接口测试        -----------&gt; 5工作日4. 第四章 性能测试        -----------&gt; 3工作天5. 第五章 APP测试        -----------&gt; 2工作天6. 第六章 自动化测试    -----------&gt; 6工作天7. 第七章 安全测试       -----------&gt; 1工作天8. 第八章 项目             -----------&gt; 5工作天9. 简历编写                 -----------&gt; 1工作天10. 模拟面试题分析       -----------&gt; 2工作天11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 学习规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能测试</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/01_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/01_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li><h3 id="性能测试的定义-x2F-什么是性能测试？"><a href="#性能测试的定义-x2F-什么是性能测试？" class="headerlink" title="性能测试的定义&#x2F;什么是性能测试？"></a>性能测试的定义&#x2F;什么是性能测试？</h3><ol><li>涉及到大批量的并发时系统或软件的承载能力</li></ol></li><li><h3 id="性能测试的类型：压力测试和负载测试"><a href="#性能测试的类型：压力测试和负载测试" class="headerlink" title="性能测试的类型：压力测试和负载测试"></a>性能测试的类型：压力测试和负载测试</h3><ol><li>压力测试：系统软件能达到一个最大的峰值（峰值指：用户的访问量，用户的请求量）</li><li>负载测试：指系统或者软件能保持一定承载能力不变的情况下持续的最长时间，并负载一段时间的过程</li><li>并发测试：在同一时间段内服务器所能承受的最大并发量为多少，在同一时间内，服务器能处理的请求的最大数量是多少</li></ol></li><li><h3 id="为什么要做性能测试-x2F-性能测试的目的"><a href="#为什么要做性能测试-x2F-性能测试的目的" class="headerlink" title="为什么要做性能测试&#x2F;性能测试的目的"></a>为什么要做性能测试&#x2F;性能测试的目的</h3><ol><li><p>版本一</p><ol><li>验证系统软件的承载极限：比如承受多大的并发，在最大并发量的情况下能储蓄运行的最长的时间</li><li>验证是否能达到用户或产品组的性能要求</li><li>发现系统软件的瓶颈问题，找到是那些问题导致系统的性能上不去</li><li>找到系统软件的优化方向和性能目标</li></ol></li><li><p>版本二</p><ol><li>性能测试更关注系统的性能表现，也就是how fast和How much.做性能的测试就是排除系统瓶硕，使它表现的更好，更霸气，可以从以下几方面理解</li><li>①评估当前系统—了解你的产品</li><li>②寻找瓶颈，优化性能—优化你的产品</li><li>③预测未来性能—当用户数和业务量增加能否应对，如何调整</li></ol></li></ol></li><li><h3 id="什么样的系统软件需要做性能测试"><a href="#什么样的系统软件需要做性能测试" class="headerlink" title="什么样的系统软件需要做性能测试"></a>什么样的系统软件需要做性能测试</h3><ol><li>用户量大的系统</li><li>业务比较繁忙的系统</li><li>动态类型的接口请求</li><li>查询类型的接口请求</li></ol></li><li><p>性能分层</p><ol><li><p>前端性能</p><ol><li><p>APP</p><ol><li>卡顿</li><li>流畅度</li><li>资源消耗</li><li>流量监控</li></ol></li><li><p>web</p><ol><li><p>页面渲染</p><ol><li>不同的浏览器</li></ol></li><li><p>js性能</p><ol><li><p>推荐工具：dynatrace ajax edition    </p><ol><li>可以搞定页面渲染的性能、以及js的性能</li><li>能定位到js源码的位置</li></ol></li></ol></li></ol></li></ol></li><li><p>服务器端性能</p><ol><li><p>协议</p></li><li><p>并发</p><ol><li>多线程</li></ol></li><li><p>模拟真实场景：业务角度</p></li></ol></li></ol></li><li><h3 id="根据什么来做性能测试"><a href="#根据什么来做性能测试" class="headerlink" title="根据什么来做性能测试"></a>根据什么来做性能测试</h3><ol><li>性能需求，也叫性能指标</li><li>没有给出性能需求或给出不太明确的性能指标，要依据以往测试的真实的结果（压力值和负载值），在测试组内进行讨论，制定一个比较合适的指标，然后在进行测试</li></ol></li><li><h3 id="性能测试的核心方法"><a href="#性能测试的核心方法" class="headerlink" title="性能测试的核心方法"></a>性能测试的核心方法</h3><ol><li>逐步施压：（一步一步的慢慢的进行增加压力）看最后能不能达到性能的指标的要求，不管是负载方面的测试还是压力方面的测试都要采用逐步施压的方法</li></ol></li><li><h3 id="性能测试的原则"><a href="#性能测试的原则" class="headerlink" title="性能测试的原则"></a>性能测试的原则</h3><ol><li>尽可能的贴近真实的环境，尽可能的模拟用户操作</li></ol></li><li><h3 id="性能测试的过程"><a href="#性能测试的过程" class="headerlink" title="性能测试的过程"></a>性能测试的过程</h3><ol><li>对性能需求进行分析</li><li>设计性能测试的计划</li><li>性能测试的环境搭建（测试工具。测试数据（脚本）的准备）</li><li>执行测试（得出测试结果）</li><li>对测试结果进行分析，然后编写测试报告</li></ol></li><li><h3 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h3><ol><li><p><a href="../../../04_%E5%B7%A5%E5%85%B7/01_jmeter/01_jmeter/">jmeter</a>  <a href="../../../04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/16_jmeter%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">jmeter简单的性能测试</a></p></li><li><p>loadrunner</p><ol><li>LoadRunner，是一种预测系统行为和性能的负载测试工具。</li></ol></li><li><p><a href="../905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_locust/">locust</a></p><ol><li>开源</li><li>python语言</li><li>基于协程</li><li>高并发</li><li>性能自动化测试平台</li><li>requests</li></ol></li><li><p>jmeter 与loadrunner 的区别</p><ol><li><p>相同点</p><ol><li>jmeter 的架构跟loadrunner原理一样,都是通过中间代理,监控&amp;收集并发客户端发现的指令,把他们生成脚本,再发送到应用服务器,再监控服务器反馈的结果的一个过程.</li><li>分布式中间代理功能在Jmeter中也有,这个分布式分理是指可设置多台代理在不同PC中,通过远程进行控制,即通过使用多台机器运行所谓的 Agent 来分担 Load Generator 自身的压力，并借此来获取更大的并发用户数.loadrunner也有些功能．</li></ol></li><li><p>不同点：</p><ol><li>Jmeter 安装简单，只需要解压jmeter文件包到Ｃ盘上就可以了，其实是没有安装．要是你想执行调试测试脚本,前提是：装上jdk和netbean插件.而loadrunner安装包有１Ｇ多，在一台P3.0,1G内存的PC上安装要一个多小时.要是装过较旧的盗版还不能再装新版,解决办法倒是有,但麻烦且花时间.</li><li>Jmeter 没有IP欺骗功能,ＩＰ欺骗是指在一ＰＣ台上多个ＩＰ地址来分配给并发用户．这个功能对于模拟较真实的客户环境来说,是较有用.loadrunner有此功能.</li><li>Jmeter也提供了一个利用本地Proxy Server（代理服务器）来录制生成测试脚本的功能，但是这个功能并不好用,测试对象的个别参数却要手工增加上去,还得附带装个IE代理,如GoogleToolbarDownloader这些插件来捕捉参数.但是有一个工具bodboy，利用这个工具可以录制操作，然后选择将脚本保存为Jmeter脚本，然后利用Jmeter可以打开并修改脚本</li><li>jmeter的报表较少,对于要分析测试性能不足以作为依据.如要知道数据库服务器或应用程序服务的CPU,memory等参数,得在相关服务器上另外写脚本记录服务器的性能.</li><li>Jmeter做性能测试，主要是通过增加线程组的数目，或者是设置循环次数来增加并发用户，而loadrunner可以通过在场景中选择要设置什么样的场景，然后选择虚拟用户数。</li><li>jmeter可以通过逻辑控制器实现复杂的测试行为，相当于loadrunner中的测试场景</li><li>Jmeter可以做web程序的功能测试，利用jmeter中的样本，可以做灰盒测试，loadrunner主要用作性能测试</li><li>jmeter是开源的，但是使用的人较少，网络上相关资料不全面，需要自己去揣摩，而loadrunner是商业软件，如果是正版，有技术支持，同时，网络上的资料相当多。</li><li>jmeter的脚本修改，主要是对jmeter中各个部件的熟悉程度，已经相关的一些协议的掌握情况，而不依赖于编程，而loadrunner除了复杂的场景设置外，还需要掌握函数，修改脚本。</li></ol></li></ol></li><li><h1 id="QNET-网络测试工具"><a href="#QNET-网络测试工具" class="headerlink" title="QNET-网络测试工具"></a><a href="../905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_QNET-%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/">QNET-网络测试工具</a></h1></li></ol></li><li><h3 id="性能测试的作用及重要性"><a href="#性能测试的作用及重要性" class="headerlink" title="性能测试的作用及重要性"></a>性能测试的作用及重要性</h3><ol><li><h5 id="生活中的性能问题"><a href="#生活中的性能问题" class="headerlink" title="生活中的性能问题"></a>生活中的性能问题</h5><ol><li><p>案例1.最痛恨的12306（永流抢不到票）</p><p> 案例2.双十一抢购，系统繁忙其至报404错误</p><p> 案例3.上下班高峰期，怎一个堵字了得</p><p> 案例4：起市收银台永远不够用</p></li></ol></li><li><p>试问：什么样的系统需要做性转测试？</p><ol><li><p>案例1：做设使用word来编辑个1000多页的文档，该文档包含了丰富的图表，图片，需要等待系统花多少秒的时间进行处理</p><p> 案例2：某业务系统属于二次开发，之前没有做过性能测试。当并发达到100时会造成数据库服务器崩溃，这是很明显的性问题</p><p> 案例3：某企业内部信息系统.使用人数少，但并发时会出现重复的相同记录、这种场果很难在功能测试时出现，所以有时候性能测试并不是只能发现性能问题</p><p> 案例4：面响广互联网人群的网站，每天都要接受大量的访问请求，服务器压力大，这样的系统进行性能测试时十分必要的、现有系统大致分为单机系统.C&#x2F;S系统和B&#x2F;S系统.一般C&#x2F;S架构的应程序更关注系统资源的情况、数据库性能以及运行的配覆要求如内存，用户连接数、数据库死锁、数据库cache 命中率，运行的最低配置等；B&#x2F;S架构的应用程序，会再关注于web服务器相关指标如每秒点击数吞吐量，尝试连接数、事务成功率等</p></li></ol></li></ol></li><li><h3 id="性能指标的要求-各项指标的计算方法-性能指标的标准1-性能指标的标准2"><a href="#性能指标的要求-各项指标的计算方法-性能指标的标准1-性能指标的标准2" class="headerlink" title="性能指标的要求  各项指标的计算方法   性能指标的标准1    性能指标的标准2"></a>性能指标的要求  <a href="../905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E5%90%84%E9%A1%B9%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/">各项指标的计算方法</a>   <a href="../905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%A0%87%E5%87%861/">性能指标的标准1</a>    <a href="../905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%A0%87%E5%87%862/">性能指标的标准2</a></h3><ol><li><p>响应时间：90％的用户的响应时间不能超过8s．</p><p> 吞吐量：根据以前项目组内容自己进行设置</p><p> 平均点击率：（根据以前项目组内容自己进行设置）</p><p> 错误率：一般不超过3％</p><p> cpu占有率：一般不要超出90％．如果超出短时间内没问题，长时间不行</p><p> 磁盘占有率：一定要有空余＜如果没有空余，但是磁盘交互区swap使用率为0，说明刚好内存多用，磁盘交互区swap使用率为100％，一定会出现请求数据丢失）</p><p> Cpu负载值：    单个cpu负载值不能超过2.8s，2.8s以下表示为畅通  2.8s～5.0s短时间内没问题，5.0s以上会出现数据请求丢失</p></li></ol></li><li><h3 id="性能专测过程：压力测试"><a href="#性能专测过程：压力测试" class="headerlink" title="性能专测过程：压力测试"></a>性能专测过程：压力测试</h3><ol><li><p>当接到要求需要对系统进行性能测域的时候，首先根据已知的性专指标分析测试分析测式场景，使用Jmeter测域工具开始进行抓包录制请求，再对需要进行并发的请求进行改写比如设置</p><p> 参数化（包括请求参数的参数化和Cookie值的参数化），设置集合点，设置线程数和启动时间等，为了方便分析结果，再添加上聚合报告和查看结果树，改写完成之后，启动Jmter执行压力测试，通过逐步施压的方法。慢慢测试系统能承载的量大并发量，在达到规定的并发量的时候，观察一下对应的性能指标是否满足：比加当时在测试的时候，要求90％用户的响应时间不能超过85．错误率不能超过3％．cpu负载随不能超其2.8s等等  当时在测试时达到要求的并发量的时候响应时间超过了8s，性能测试未能通过．</p></li></ol></li><li><h3 id="jmeter负载测试总结"><a href="#jmeter负载测试总结" class="headerlink" title="jmeter负载测试总结"></a>jmeter负载测试总结</h3><ol><li>负载测试：当我们接到要求需要对系统进行性能测成的时候，首先根据已知的性能指标分析测试场景，使用Jmter 测试工具开始进行抓包录制请求，再对需要行并发的请求进行 改写，比如设置叁数化（包括请求参数的参数T化和cookie值的参数化）设置固定定时器，设置关联请求。设置线程数和循环次数等.在针对用户可能存在的不同操作分别进行录制改写完毕之后通过设置多个线程组分别模拟用尺的不同操作，同时启动进行负载方面的测试.</li></ol></li><li><h3 id="性能测试的优化方案"><a href="#性能测试的优化方案" class="headerlink" title="性能测试的优化方案"></a>性能测试的优化方案</h3><ol><li><p>数据库部分可以优化的方向</p><ol><li>表中设置主键和索引</li><li>列的属性使用字符类型比使用整型要节省时间</li><li>尽量减少多表联查</li><li>分库分表</li><li>使用内存库存储数据</li></ol></li><li><p>实现机制部分</p><ol><li>浏览器展示的时候，对页面进行分页处理</li><li>读取缓存</li><li>尽量采用静态页面</li><li>尽量多设置进程</li><li>设置多个服务器</li></ol></li></ol></li><li><h3 id="有没有做过性能测试，具体怎么做的"><a href="#有没有做过性能测试，具体怎么做的" class="headerlink" title="有没有做过性能测试，具体怎么做的"></a><a href="../905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/06_%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E8%BF%87%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">有没有做过性能测试，具体怎么做的</a></h3><ol><li>没有做过性能测试，但是知道是怎么做的。不过我们那个项目的性能做得不多，公司要求也不严格。一般SE给我们相关的性能需求，首先我们需要对性能需求进行场景分析与设计，这里，其实主要就是确定并发数，考虑是否需求设置集合点，以及个业务场景的性能指标要求，根据以上的分析来编写性能测试用例。然后就开始着手去准备性能测试需要用到数据，以便后期做参数化，搭建好性能测试环境，然后就进行性能脚本的开发与执行。就拿当时做过的一个抢购活动的抢购活动的性能测试来讲吧。当时抢购活动的下单接口要求抢购1000 个商品，做一个并发压测，当时公司要求设定的并发数在：5000考虑到抢购下单接口，必须要先登录，所以，首先我会准备 5000 个用户数据（账号，密码），这边当时是通过存储过程来实现。然后把创建好的 5000 个用户账号，提取出来，保存在 csv 文件中。之后就是编写性能测试脚本了，这里主要就是首先建一个 SetUp 线程组添加一个登录接口的 http 请求，这里需要对用户数据进行参数化，我当时是把所有的 5000 用户数据存储在 CSV 文件中，然后用’CSV 数据文件设置’这个配置元件来实现数据的参数化，然后需要在登录接口的 http 请求中添加一个后置处理器的正则表示式提取器，来提取所用用户的cookie 值，并且通过调用 Beanshell 取样器结合_setProperty 这个函数，将所有 cookie 设定为全部变量， 考虑到是抢购活动，这里需要设置集合点，需要添加一个同步定时器，用来设置集合点的。然后就再创建线程组，并创建一个下单接口的 http 请求，并在查询接口的 http 请求中添加一个 http cookies 管理器， 把登录接口的 cookie 通过 http cookies 管理器传递到后台。然后添加一个响应断言，用来检查请求是成功，最后添加一个查看结果树和聚合报告用来查看性能指标。例外对于服务器资源的监控，像 CPU,内存，磁盘 IO,网络，这块当时用的nmon 工具来获取这些数据的， 我们需要在服务器上安装一个nmon 工具，并运行启动就可以了，最后把它转化为 excel 表格形式的图形化报告。最后对报告做一个简单的分析。当时我们就是这么做的</li></ol></li><li><h3 id="性能测试流程是怎么样的？"><a href="#性能测试流程是怎么样的？" class="headerlink" title="性能测试流程是怎么样的？"></a>性能测试流程是怎么样的？</h3><ol><li><p>例外一种问法：简单介绍下你们公司的性能测试流程是怎么样的？</p><p> 我们那个项目的性能做得不多，公司要求也不严格。</p><p> 对于流程这块，首先就要对整个系统进行详细的分析，确定基本的测试范围，看下系统的哪些业务是需要做性能测试的，还有就是做哪方面的性能测试，对于我们那个项目，当时就做了几个业务做了些简单的并发压测（稳定性）这块，像登录的，搜索查询，下单，还有就是购物车里面的几个接口都有做过。然后就是对各个业务场景进行详细的场景分析与设计，确定每个业务场景的并发数，是否需要设置集合点啊，压测时间是多长，还有各个业务场景的性能指标等等，场景设计这块基本上都是老大跟产品哪个一起弄的，我参与的不是太多。</p><p> 上面把个场景设置好了之后，提交给我们，我们就是根据老大设置好的那些场景编写了基本的性能测试用例。其实做性能测试，我觉得前期最关键的还是业务场景一定要设计好，后期我们主要的任务就是准备各自任务需要用到的一些测试数据，搭建好测试环境，还有就是测试脚本设计与开发，执行，并生出测试报告，对于测试结果我们一般会简单的做个分析，如果没有什么问题，基本后期就写一个性能测试报告。流程大概就是这样的。</p></li></ol></li><li><h3 id="你们性能观察哪些指标，大概指标范围是怎么样的。"><a href="#你们性能观察哪些指标，大概指标范围是怎么样的。" class="headerlink" title="你们性能观察哪些指标，大概指标范围是怎么样的。"></a>你们性能观察哪些指标，大概指标范围是怎么样的。</h3><ol><li><p>响应时间</p><p> 错误率</p><p> 吞吐量&#x2F;吞吐率cpu</p><p> 内存网络</p><p> 磁盘读写速度</p></li></ol></li><li><h3 id="性能测试计划有哪些内容"><a href="#性能测试计划有哪些内容" class="headerlink" title="性能测试计划有哪些内容"></a>性能测试计划有哪些内容</h3><ol><li>写过，主要是时间进度安排与工作安排，主要是环境，测试任务，测试需求，测试方法与策略，测试环境准备，测试通过的标准、比如说原来我们一个项目性能测试时做了 5 天，那我们计划是，测试策略与用例编写一天，测试准备需要1 天，测试执行 2 天，报告总结 1 天。</li></ol></li><li><h3 id="有没有写过性能测试报告，具体包括哪些内容"><a href="#有没有写过性能测试报告，具体包括哪些内容" class="headerlink" title="有没有写过性能测试报告，具体包括哪些内容"></a>有没有写过性能测试报告，具体包括哪些内容</h3><ol><li><p>性能测试报告，需要每次 jmeter 压测完成的 html 报告的数据跟 nmon 工具监控的数据，整理出一份性能测试报告，性能测试报告，主要包含</p><p> 1，测试资源（环境，测试数据，表里面需要多少数据，测试工具）</p><p> 2，测试设计（测试业务，测试类型，测试时间，并发用户数）</p><p> 3，测试分析（每一个场景都需要分析）</p><p> 4，测试结论（能不能上线，不上线的原因）</p><p> 5，优化和建议</p><p> 6，测试通过的标准，平均响应时间&lt;5s，资源利用率&lt;75%，事务失败率&lt;5%</p></li></ol></li><li><h3 id="什么是内存泄漏，什么是内存溢出"><a href="#什么是内存泄漏，什么是内存溢出" class="headerlink" title="什么是内存泄漏，什么是内存溢出"></a>什么是内存泄漏，什么是内存溢出</h3><ol><li><p>内存泄漏：</p><p> 是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。通常少次数的内存无法及时回收并不会到程序造成什么影响，但是如果在内存本身就比较少获取多次</p><p> 导致内存无法正常回收时，就会导致内存不够用，最终导致内存溢出。</p><p> 内存溢出：OOM</p><p> |-1.  指程序申请内存时，没有足够的内存供申请者使用1M     实际要占用 2M内存，就说分配的内存不够，导致内存溢出</p><p> |-2.  给了你一块存储<br> int类型数据的存储空间，但是你却存储long类型的数据，</p><p> |-3.  长期出现内存泄漏，导致系统内存越用越少，最终导致内存不够用，导致系统崩溃，出现<br> OOM</p></li></ol></li><li><h3 id="吞吐量与吞吐率跟负载有什么关系？"><a href="#吞吐量与吞吐率跟负载有什么关系？" class="headerlink" title="吞吐量与吞吐率跟负载有什么关系？"></a>吞吐量与吞吐率跟负载有什么关系？</h3><ol><li><p>吞吐量&#x2F;率和负载之间的关系：</p><p> ①上升阶段：吞吐量随着负载的增加而增加，吞吐量和负载成正比；</p><p> ②平稳阶段：吞吐量随着负载的增加而保持稳定，无太大变化或波动；</p><p> ③下降阶段：吞吐量随着负载的增加而下降，吞吐量和负载成反比； 总结：吞吐量&#x2F;率干不过负载！！！</p></li></ol></li><li><h3 id="当你服务器满了之后，你们吞吐量和响应时间怎么变化的"><a href="#当你服务器满了之后，你们吞吐量和响应时间怎么变化的" class="headerlink" title="当你服务器满了之后，你们吞吐量和响应时间怎么变化的"></a>当你服务器满了之后，你们吞吐量和响应时间怎么变化的</h3><ol><li>吞吐量会所有下降，响应时间会变长</li></ol></li><li><h3 id="你们的TPS的指标是什么估算的？"><a href="#你们的TPS的指标是什么估算的？" class="headerlink" title="你们的TPS的指标是什么估算的？"></a>你们的<strong>TPS</strong>的指标是什么估算的？</h3><ol><li><p>答：我们系统的 TPS 当时是根据PV 值来计算的，就是通过查看系统访问日志来获取每个业务功能每天高峰期的 PV 值（也就是每天高峰期的时间段，有多少服务器的客户请求）。</p><p> 当时的 PV 值大概在 5000 多</p><p> 然后按照二八原则，即 80％的业务在 20%的时间内完成，TPS&#x3D;（PV<em>80%)&#x2F;(时间</em>20%)。算出来大概在110kb&#x2F;s</p><p> 【具体的指标都是SE跟测试主管他们经过分析出来给到我们的。他们开会的时候大概跟我们说过估算方式，差不多是这样的          】</p></li></ol></li><li><h3 id="每人说一个项目接口，你设置多少并发"><a href="#每人说一个项目接口，你设置多少并发" class="headerlink" title="每人说一个项目接口，你设置多少并发"></a>每人说一个项目接口，你设置多少并发</h3><ol><li><p>答：就拿登录接口来讲吧。</p><p> 我们的并发数是根据注册用户数量及每天在线用户数综合来估算的，我们系统当时注册用户数量大概是在70多万的样子，不过这里其实有一些僵尸用户，真正的用户大概在 60%的样子，也就是差不多，46万多一点，通过查看系统访问日志，高峰期的时候每天在线数用户数量大概差不多在 52000多点吧，按 52000 估算，每个用户停留时间大概在 20分钟左右，大概平均每天同时在线用户数量在:2145多。其中登录业务的占比大概在 10%的样子，同时在登录的大概<br> 80%的比例计算，登录接口大概设置的并发数在 172多的样子，查询业务的占比大概在 30%，查询接口大概设置的并发数在 510的样子，下单业务大概占比在<br> 20%，下单接口的并发数设定在 345的样子。</p><p> 【具体的指标都是SE跟测试主管他们经过分析出来给到我们的。他们开会的时候大概跟我们说过估算方式，差不多是这样的          】</p></li></ol></li><li><h3 id="你们吞吐量是多少，响应时间是多少，你设置了多少并发"><a href="#你们吞吐量是多少，响应时间是多少，你设置了多少并发" class="headerlink" title="你们吞吐量是多少，响应时间是多少，你设置了多少并发"></a>你们吞吐量是多少，响应时间是多少，你设置了多少并发</h3><ol><li>登录：吞吐率大概在 95KB&#x2F;sec,响应时间&lt;1s，设置的并发数 180 个并发数。查询：吞吐率大概在 120&#x2F;sec,响应时间&lt;3s，设置的并发数 500 个并发数。下单：吞吐率大概在 115&#x2F;sec,响应时间&lt;3s，设置的并发数 350 个并发。</li></ol></li><li><h3 id="做并发你们一般cpu和内存是多少"><a href="#做并发你们一般cpu和内存是多少" class="headerlink" title="做并发你们一般cpu和内存是多少"></a>做并发你们一般<strong>cpu</strong>和内存是多少</h3><ol><li>cpu 大概在 60%多点，内存大概占比在 65%的样子。</li></ol></li><li><p>有没有做过稳定性测试</p><ol><li><p>部分接口有做过稳定性测试。</p><p> 稳定性测试主要就是看某个业务在高并发情况下是否能持续稳定运行嘛，当时大部分的核心业务都有做过稳定性的，这个需是把并发数设置为峰值，然后循环次数设置为永远，例外要开启调度器，调度器中的持续时间设定为 3600 秒，让它持续压测 1 个小时。看下接口的各项性能指标的变化，是否在预期的指标范围之内。</p></li></ol></li><li><h3 id="压测返回数据报错，你怎么去定位的"><a href="#压测返回数据报错，你怎么去定位的" class="headerlink" title="压测返回数据报错，你怎么去定位的"></a>压测返回数据报错，你怎么去定位的</h3><p> 1、如果是所有请求的数据报错，那肯定是脚本问题，认真检查脚本参数。</p><p> 2、如果只是部分请求报错，那估计是性能问题了。</p></li><li><p><a href="../../../04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/17_Jmeter%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/">性能测试篇 ：Jmeter监控服务器性能</a></p></li><li><h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ol><li><strong>宕机（挂机）</strong></li></ol></li><li><p>性能测试</p><ol><li><p>分析方法</p><ol><li>结果比较法</li><li>最优化分析法</li></ol></li><li><p>调优方法</p><ol><li>应用程序诊断</li><li>系统调优</li></ol></li></ol></li><li><p>常见性能瓶颈</p><ol><li><p>硬件上的瓶颈</p><ol><li>一般指的是CPU\RAM的问题，分为服务器硬件瓶颈、网络瓶颈、操作系统瓶颈（参数配置）、中间件瓶颈（参数配置、数据库、web服务器等）</li></ol></li><li><p>应用软件上的瓶颈</p><ol><li>一般值得是应用服务器、web服务器等应用软件，还包括数据库系统</li></ol></li><li><p>应用程序上的性能瓶颈</p><ol><li>一般指的是开发人员新开发出来的应用程序</li></ol></li><li><p>操作系统上的 性能瓶颈</p><ol><li>一般指的是Linux windows  unix 等操作系统的某些配置</li></ol></li><li><p>网络设备上的性能瓶颈</p><ol><li>一般指的是防火墙、动态负载生成器、交换机等设备</li></ol></li></ol></li><li><p>地铁模型<br> 假设：<br> 某地铁站进站只有3个刷卡机。<br> 人少的情况下，每位乘客很快就可以刷卡进站，假设进站需要1s。<br> 乘客耐心有限，如果等待超过30min，就暴躁、唠叨，甚至放弃。</p><p> 场景一：只有1名乘客进站时，这名乘客可以在1s的时间内完成进站，且只利用了一台刷卡机，剩余2台等待着。</p><p> 场景二：只有2名乘客进站时，2名乘客仍都可以在1s的时间内完成进站，且利用了2台刷卡机，剩余1台等待着。</p><p> 场景三：只有3名乘客进站时，3名乘客还能在1s的时间内完成进站，且利用了3台刷卡机，资源得到充分利用。</p><p> 场景四：A、B、C三名乘客进站，同时D、E、F乘客也要进站，因为A、B、C先到，所以D、E、F乘客需要排队。<br> 那么，A、B、C乘客进站时间为1s，而D、E、F乘客必须等待1s，所以他们3位在进站的时间是2s。</p><p> 场景五：假设这次进站一次来了9名乘客，有3名的“响应时间”为1s，有3名的“响应时间”为2s（等待1s+进站1s）， 还有3名的“响应时间”为3s（等待2s+进站1s）。</p><p> 场景六：如果地铁正好在火车站，每名乘客都拿着大小不同的包，包太大导致卡在刷卡机堵塞，每名乘客的进站时 间就会又不一样。刷卡机有加宽的和正常宽度的两种类型，那么拿大包的乘客可以通过加宽的刷卡机快速进站（增 加带宽）。</p><p> 场景七：进站的乘客越来越多，3台刷卡机已经无法满足需求，为了减少人流的积压，需要再多开几个刷卡机，增 加进站的人流与速度（提升TPS、增大连接数）。</p><p> 场景八：到了上班高峰时间了，乘客数量上升太快，现有的进站措施已经无法满足，越来越多的人开始抱怨、 拥挤，情况越来越糟。单单增加刷卡机已经不行了，此时的乘客就相当于“请求”，乘客不是在地铁进站排队，就是 在站台排队等车，已经造成严重的“堵塞”，那么增加发车频率（加快应用服务器、数据库的处理速度）、增加车厢数量（增加内存、增大吞吐量）、增加线路（增加服务的线程）、限流、分流等多种措施便应需而生。</p> <br /></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 性能测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/05_cookie/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/05_cookie/</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie是什么，有什么用，为什么要用到Cookie"><a href="#Cookie是什么，有什么用，为什么要用到Cookie" class="headerlink" title="Cookie是什么，有什么用，为什么要用到Cookie"></a><strong>Cookie是什么，有什么用，为什么要用到Cookie</strong></h1><p>请看Fish Li 写的【<a href="http://www.cnblogs.com/fish-li/archive/2011/07/03/2096903.html">细说<strong>Cookie】</strong></a></p><h1 id="Cookie的分类"><a href="#Cookie的分类" class="headerlink" title="Cookie的分类"></a><strong>Cookie的分类</strong></h1><p>可以大致把Cookie分为2类： 回话cookie和持久cookie</p><p>会话cookie: 是一种临时的cookie，它记录了用户访问站点时的设置和偏好，关闭浏览器，会话cookie就被删除了</p><p>持久cookie: 存储在硬盘上，（不管浏览器退出，或者电脑重启，持久cookie都存在）， 持久cookie有过期时间</p><h1 id="Cookie存在哪里"><a href="#Cookie存在哪里" class="headerlink" title="Cookie存在哪里"></a><strong>Cookie存在哪里</strong></h1><p>Cookie是存在硬盘上，  IE存cookie的地方和Firefox存cookie的地方不一样。  不同的操作系统也可能存cookie的地方不一样。</p><p>不同的浏览器会在各自的独立空间存放Cookie, 互不干涉</p><p>以我的windows7， IE8为例，  cookie存在这： C:\Users\xiaoj\AppData\Local\Microsoft\Windows\Temporary Internet Files</p><p>注意： 缓存文件和cookie文件，是存在一起的, 都在这个目录下。</p><p>你也可以这样找, 打开IE，点击Tools-&gt;Internet Options-&gt;General Tab下的-&gt;Browsing history下的Setting按钮，弹出的对话框中点击View files.</p><p><img src="/assets/wps7EA5.tmp-20211222151419-fbxtpyw.png"><img src="/assets/wps7EA6.tmp-20211222151419-olwgxkx.jpg"></p><p>不同的网站会有不同的cookie文件</p><p><img src="/assets/wps7EA7.tmp-20211222151419-qi8mr5o.png"><img src="/assets/wps7EA8.tmp-20211222151419-zru7a1f.jpg"></p><h1 id="使用和禁用Cookie"><a href="#使用和禁用Cookie" class="headerlink" title="使用和禁用Cookie"></a><strong>使用和禁用Cookie</strong></h1><p>IE:   工具-&gt;Internet 选项 -&gt; 隐私</p><p><img src="/assets/wps7EA9.tmp-20211222151419-ptu9ut9.png"><img src="/assets/wps7EAA.tmp-20211222151419-aop8gqr.jpg"></p><h1 id="Fiddler查看HTTP中的Cookie"><a href="#Fiddler查看HTTP中的Cookie" class="headerlink" title="Fiddler查看HTTP中的Cookie"></a><strong>Fiddler查看HTTP中的Cookie</strong></h1><p>浏览器把cookie通过HTTP Request 中的“Cookie: header”发送给Web服务器</p><p>Web服务器通过HTTP Response中的”Set-Cookie: header”把cookie发送给浏览器</p><p>使用Fiddler可以清楚地看到cookie在HTTP中传递。 Fiddler工具中可以清晰的看到Http Request 中的Cookie， 和Http Response中的cookie</p><p>实例： 启动Fiddler,  启动浏览器访问一些购物网站，就可以看到。</p><p><img src="/assets/wps7EAB.tmp-20211222151419-2d6q7ul.png"> <img src="/assets/wps7EAC.tmp-20211222151419-zvo47bs.jpg"></p><h1 id="网站自动登陆的原理"><a href="#网站自动登陆的原理" class="headerlink" title="网站自动登陆的原理"></a><strong>网站自动登陆的原理</strong></h1><p>我们以”博客园自动登陆“的例子，来说明cookie是如何传递的。</p><p>大家知道博客园是可以自动登陆的。 如下图，这个是什么原理呢?</p><p><img src="/assets/wps7EAD.tmp-20211222151419-onffgyw.png"><img src="/assets/wps7EAE.tmp-20211222151419-7eoj92p.jpg"></p><p>假如我已经在登陆页面输入了用户名，密码，选择了保存密码，登陆。</p><p>（这时候，其实在你的机器上保存好了登陆的cookie, 不信你可以按照上节介绍方法去你的电脑上找下博客园的cookie）</p><p>当我下次访问博客园流程如下。</p><ol><li>用户打开IE浏览器，在地址栏上输入<a href="http://www.cnblogs.com/">www.cnblogs.com</a>.</li><li>IE首先会在硬盘中查找关于cnblogs.com的cookie. 然后把cookie放到HTTP Request中，再把Request发给Web服务器。</li><li>Web服务器返回博客园首页（你会看到你已经登陆了）。</li></ol><p><img src="/assets/wps7EAF.tmp-20211222151419-vob6ewr.png"><img src="/assets/wps7EB0.tmp-20211222151419-w1gki0n.jpg"></p><h1 id="截获Cookie，冒充别人身份"><a href="#截获Cookie，冒充别人身份" class="headerlink" title="截获Cookie，冒充别人身份"></a><strong>截获Cookie，冒充别人身份</strong></h1><p>通过上面这个例子，可以看到cookie是很重要的，识别是否是登陆用户，就是通过cookie。  假如截获了别人的cookie是否可以冒充他人的身份登陆呢？  当然可以， 这就是一种黑客技术叫Cookie欺骗。</p><p>利用Cookie 欺骗， 不需要知道用户名密码。就可以直接登录，使用别人的账户做坏事。</p><p>我知道有两种方法可以截获他人的cookie，</p><ol><li>通过XSS脚步攻击， 获取他人的cookie. 具体原理可以看 [<a href="http://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html">Web安全性测试之XSS</a>]</li><li>想办法获取别人电脑上保存的cookie文件（这个比较难）</li></ol><p>拿到cookie后，就可以冒充别人的身份了。 这个过程我就不演示了。</p><h1 id="Cookie和文件缓存的区别"><a href="#Cookie和文件缓存的区别" class="headerlink" title="Cookie和文件缓存的区别"></a><strong>Cookie和文件缓存的区别</strong></h1><p>很多人会把cookie和文件缓存弄混淆， 这两个完全是不一样的东西。唯一的相同之处可能是它们俩都存在硬盘上，而且是存在同一个文件夹下。</p><p>关于HTTP缓存请看这 【<a href="http://www.cnblogs.com/TankXiao/archive/2012/11/28/2793365.html">HTTP协议之缓存</a>】</p><p>我们在IE中可以选择分别删除Cookie和缓存文件</p><p><img src="/assets/wps7EC1.tmp-20211222151419-9749lqa.png"> <img src="/assets/wps7EC2.tmp-20211222151419-x09ud12.jpg"></p><h1 id="Cookie-泄露隐私"><a href="#Cookie-泄露隐私" class="headerlink" title="Cookie 泄露隐私"></a><strong>Cookie 泄露隐私</strong></h1><p>2013年央视的315晚会上， 曝光了很多不法公司利用Cookie跟踪并采集用户的个人信息，并转卖给网络广告商，形成了一条窃取用户信息的灰色产业链。从而实现广告准确投放。严重干扰了用户的正常网络应用，侵害了个人的隐私和利益。</p><p>我经常就在门户网站上发现广告位上显示的是我在电商网站上流量过的商品。  这就是我的cookie被泄露了。</p><p>目前在欧洲， 已经对Cookie立法， 如果网站需要保存用户的cookie, 必须弹出一个对话框，要用户确认后才能保存Cookie.</p><h1 id="P3P协议"><a href="#P3P协议" class="headerlink" title="P3P协议"></a><strong>P3P协议</strong></h1><p>从上面看来， Cookie 是一个比较容易泄露用户隐私和危险的东西。  有没有办法保护个人用户隐私呢？    那就是P3P协议</p><p>P3P是一种被称为个人隐私安全平台项目（the Platform for Privacy Preferences）的标准，能够保护在线隐私权，使Internet冲浪者可以选择在浏览网页时，是否被第三方收集并利用自己的个人信息。如果一个 站点不遵守P3P标准的话，那么有关它的Cookies将被自动拒绝，并且P3P还能够自动识破多种Cookies的嵌入方式。p3p是由全球资讯联盟网 所开发的。</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> cookie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态码</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/04_%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/04_%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是HTTP状态码"><a href="#什么是HTTP状态码" class="headerlink" title="什么是HTTP状态码"></a><strong>什么是HTTP状态码</strong></h1><p>HTTP状态码的作用是：Web服务器用来告诉客户端，发生了什么事。</p><p>状态码位于HTTP Response 的第一行中，会返回一个”三位数字的状态码“和一个“状态消息”。 ”三位数字的状态码“便于程序进行处理， “状态消息”更便于人理解。</p><p>如下图，  当客户端请求一个不存在的URL的时候， Web服务器会返回 “HTTP&#x2F;1.1 404 Not Found” 告诉浏览器客户端。 服务器无法找到所请求的URL。</p><p><img src="/assets/wps58D2.tmp-20211222151316-t1cgk41.jpg"></p><h1 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a><strong>状态码分类</strong></h1><p>HTTP状态码被分为五大类， 目前我们使用的HTTP协议版本是1.1， 支持以下的状态码。随着协议的发展，HTTP规范中会定义更多的状态码。</p><p>小技巧：  假如你看到一个状态码518， 你并不知道具体518是什么意思。 这时候你只要知道518是属于（5XX，服务器错误就可以了）</p><table><thead><tr><th></th><th>已定义范围</th><th>分类</th></tr></thead><tbody><tr><td>1XX</td><td>100-101</td><td>信息提示</td></tr><tr><td>2XX</td><td>200-206</td><td>成功</td></tr><tr><td>3XX</td><td>300-305</td><td>重定向</td></tr><tr><td>4XX</td><td>400-415</td><td>客户端错误</td></tr><tr><td>5XX</td><td>500-505</td><td>服务器错误</td></tr></tbody></table><h1 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a><strong>常见的状态码</strong></h1><p>一般人只需要了解以下常见的状态码就够了， 如果你想了解更多， 请继续往下看。</p><table><thead><tr><th>200 OK 服务器成功处理了请求（这个是我们见到最多的）</th></tr></thead><tbody><tr><td>301&#x2F;302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td></tr><tr><td>304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存</td></tr><tr><td>404 Not Found 未找到资源</td></tr><tr><td>501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</td></tr></tbody></table><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="1XX-信息性状态码"><a href="#1XX-信息性状态码" class="headerlink" title="1XX 信息性状态码"></a><strong>1XX 信息性状态码</strong></h1><p>这些状态码是HTTP 1.1引入的。 对于这些状态码的价值还存在争论 （我个人从来没见过这些状态码， 也没有理解这些状态码。）</p><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>100</td><td>Continue(继续)</td><td>收到了请求的起始部分，客户端应该继续请求</td><td></td></tr><tr><td>101</td><td>Switching Protocols（切换协议）</td><td>服务器正根据客户端的指示将协议切换成Update Header列出的协议</td><td></td></tr></tbody></table><h1 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a><strong>2XX 成功状态码</strong></h1><p>客户端发起请求时， 这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。</p><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>服务器成功处理了请求（这个是我们见到最多的）</td><td><a href="#code200">HTTP协议详解-200</a></td></tr><tr><td>201</td><td>Created（已创建）</td><td>对于那些要服务器创建对象的请求来说，资源已创建完毕。</td><td></td></tr><tr><td>202</td><td>Accepted（已接受）</td><td>请求已接受，但服务器尚未处理</td><td></td></tr><tr><td>203</td><td>Non-Authoritative Information（非权威信息）</td><td>服务器已将事务成功处理，只是实体Header包含的信息不是来自原始服务器，而是来自资源的副本。</td><td></td></tr><tr><td>204</td><td>No Content(没有内容)</td><td>Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）</td><td><a href="#code204">状态码204</a></td></tr><tr><td>205</td><td>Reset Content(重置内容)</td><td>另一个主要用于浏览器的代码。意思是浏览器应该重置当前页面上所有的HTML表单。</td><td></td></tr><tr><td>206</td><td>Partial Content（部分内容）</td><td>部分请求成功</td><td><a href="#code206">状态码206</a></td></tr></tbody></table><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a><strong>3XX 重定向状态码</strong></h1><p>重定向状态码用来告诉浏览器客户端，它们访问的资源已被移动， Web服务器发送一个重定向状态码和一个可选的Location Header, 告诉客户端新的资源地址在哪。</p><p>浏览器客户端会自动用Location中提供的地址，重新发送新的Request。 这个过程对用户来说是透明的。</p><p>301和302 非常相似，  一个是永久转移，一个是临时转移。</p><p>（SEO中，搜索引擎如果碰到301， 比如网页A用301重定向到网页B，搜索引擎可以肯定网页A永久性改变地址，就会把网页B当做唯一有效目标）</p><p>302，303，307 是一样。  这是因为302是HTTP 1.0定义的， HTTP1.1中使用303,307. 同时又保留了302.  （但在现实中，我们还是用302，我是没见过303和307）</p><p>所以这一节， 我们只需要掌握302， 304 就可以了。</p><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices（多项选择）</td><td>客户端请求了实际指向多个资源的URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望的选项了</td><td></td></tr><tr><td>301</td><td>Moved Permanently（永久移除)</td><td>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td><td><a href="#code301">状态码301</a></td></tr><tr><td>302</td><td>Found（已找到）</td><td>与状态码301类似。但这里的移除是临时的。 客户端会使用Location中给出的URL，重新发送新的HTTP request</td><td><a href="#Found302">HTTP协议详解-302</a></td></tr><tr><td>303</td><td>See Other（参见其他）</td><td>类似302</td><td></td></tr><tr><td>304</td><td>Not Modified（未修改）</td><td>客户的缓存资源是最新的，要客户端使用缓存</td><td><a href="#lastModify">HTTP协议之缓存-304</a></td></tr><tr><td>305</td><td>Use Proxy（使用代理）</td><td>必须通过代理访问资源，代理的地址在Response 的Location中</td><td></td></tr><tr><td>306</td><td>未使用</td><td>这个状态码当前没使用</td><td></td></tr><tr><td>307</td><td>Temporary Redirect（临时重定向</td><td>类似302</td><td></td></tr></tbody></table><h1 id="4XX客户端错误状态码"><a href="#4XX客户端错误状态码" class="headerlink" title="4XX客户端错误状态码"></a><strong>4XX客户端错误状态码</strong></h1><p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的Request, 或者最常见的是， 请求一个不存在的URL。</p><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>400</td><td>Bad Request（坏请求）</td><td>告诉客户端，它发送了一个错误的请求。</td><td><a href="#code400">状态码400</a></td></tr><tr><td>401</td><td>Unauthorized（未授权）</td><td>需要客户端对自己认证</td><td><a href="#guocheng">HTTP协议之基本认证-401</a></td></tr><tr><td>402</td><td>Payment Required（要求付款）</td><td>这个状态还没被使用，保留给将来用</td><td></td></tr><tr><td>403</td><td>Forbidden（禁止）</td><td>请求被服务器拒绝了</td><td><a href="#code403">状态码403</a></td></tr><tr><td>404</td><td>Not Found（未找到）</td><td>未找到资源</td><td><a href="#code404">HTTP协议详解-404</a></td></tr><tr><td>405</td><td>Method Not Allowed（不允许使用的方法）</td><td>不支持该Request的方法。</td><td><a href="#code405">状态码405</a></td></tr><tr><td>406</td><td>Not Acceptable（无法接受）</td><td></td><td></td></tr><tr><td>407</td><td>Proxy Authentication Required(要求进行代理认证)</td><td>与状态码401类似， 用于需要进行认证的代理服务器</td><td><a href="#proxyAuth">HTTP协议之代理-407</a></td></tr><tr><td>408</td><td>Request Timeout（请求超时）</td><td>如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接</td><td></td></tr><tr><td>409</td><td>Conflict（冲突）</td><td>发出的请求在资源上造成了一些冲突</td><td></td></tr><tr><td>410</td><td>Gone（消失了）</td><td>服务器曾经有这个资源，现在没有了，与状态码404类似</td><td></td></tr><tr><td>411</td><td>Length Required（要求长度指示）</td><td>服务器要求在Request中包含Content-Length。</td><td><a href="#code411">状态码411</a></td></tr><tr><td>412</td><td>Precondition Failed（先决条件失败）</td><td></td><td></td></tr><tr><td>413</td><td>Request Entity Too Large（请求实体太大）</td><td>客户端发送的实体主体部分比服务器能够或者希望处理的要大</td><td><a href="#code413">状态码413</a></td></tr><tr><td>414</td><td>Request URI Too Long（请求URI太长）</td><td>客户端发送的请求所携带的URL超过了服务器能够或者希望处理的长度</td><td><a href="#code414">状态码414</a></td></tr><tr><td>415</td><td>Unsupported Media Type（不支持的媒体类型）</td><td>服务器无法理解或不支持客户端所发送的实体的内容类型</td><td></td></tr><tr><td>416</td><td>Requested Range Not Satisfiable（所请求的范围未得到满足）</td><td></td><td></td></tr><tr><td>417</td><td>Expectation Failed（无法满足期望）</td><td></td><td></td></tr></tbody></table><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><h1 id="5XX服务器错误状态码"><a href="#5XX服务器错误状态码" class="headerlink" title="5XX服务器错误状态码"></a><strong>5XX服务器错误状态码</strong></h1><p>有时候客户端发送了一条有效Request, Web服务器自身却出错了。 可能是Web服务器运行出错了， 或者网站都挂了。  5XX就是用来描述服务器错误的。</p><table><thead><tr><th>状态码</th><th>状态消息</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error(内部服务器错误)</td><td>服务器遇到一个错误，使其无法为请求提供服务</td><td><a href="#code500">状态码500</a></td></tr><tr><td>501</td><td>Not Implemented（未实现）</td><td>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码。</td><td><a href="#code501">状态码501</a></td></tr><tr><td>502</td><td>Bad Gateway（网关故障）</td><td>代理使用的服务器遇到了上游的无效响应</td><td><a href="#code502">状态码502</a></td></tr><tr><td>503</td><td>Service Unavailable（未提供此服务）</td><td>服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</td><td></td></tr><tr><td>504</td><td>Gateway Timeout（网关超时）</td><td>与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时</td><td></td></tr><tr><td>505</td><td>HTTP Version Not Supported（不支持的HTTP版本）</td><td>服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本</td><td><a href="#code505">状态码505</a></td></tr></tbody></table><h1 id="204-No-Content-没有内容"><a href="#204-No-Content-没有内容" class="headerlink" title="204 No Content(没有内容)"></a><strong>204 No Content(没有内容)</strong></h1><p>返回的Response中只有一些Header和一个状态行， 没有实体的主题内容（没有response body）</p><p>204状态码的作用在于： 1. 在不获取资源的情况下了解资源的情况（比如判断其类型）</p><ol start="2"><li>通过查看Response中的状态码， 看看某个对象是否存在</li><li>通过查看Header, 测试资源是否被修改了。</li></ol><p>实例：先打开Fiddler, 然后启动浏览器访问ditu.google.cn,  你会捕获到很多204</p><p><img src="/assets/wps58E3.tmp-20211222151316-3psm9de.png"></p><h1 id="206-Partial-Content-部分内容"><a href="#206-Partial-Content-部分内容" class="headerlink" title="206 Partial Content(部分内容)"></a><strong>206 Partial Content(部分内容)</strong></h1><p>206状态码代表服务器已经成功处理了部分GET请求（只有发送GET 方法的request, web服务器才可能返回206），</p><p>应用场景：</p><ol><li>FlashGet, 迅雷或者HTTP下载工具都是使用206状态码来实现断点续传</li><li>将以个大文档分解为多个下载段同时下载 比如，在线看视频</li></ol><p>实例：　一些流媒体技术比如在线视频，可以边看边下载。　就是使用206来实现的。</p><p>打开Fiddler， 然后用浏览器打开“搜狐视频中的绿箭侠” <a href="http://tv.sohu.com/20121011/n354681393.shtml">http://tv.sohu.com/20121011/n354681393.shtml</a>    然后你在Fiddler中就能看到一堆的206</p><ol><li>浏览器发送一个Get 方法的request.  header中包含 Range: bytes&#x3D;5303296-5336063. (意思就是请求得到5303296-5336063这个范围的数据)。</li><li>Web服务器返回一个206 的Response. header中包含Content-Range: bytes 5303296-5336063&#x2F;12129376(表明这次返回的内容范围)</li></ol><p><img src="/assets/wps58E4.tmp-20211222151316-tq4eq8y.jpg"></p><h1 id="301-Moved-Permanently（永久移除"><a href="#301-Moved-Permanently（永久移除" class="headerlink" title="301 Moved Permanently（永久移除)"></a><strong>301 Moved Permanently（永久移除)</strong></h1><p>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</p><p>例如：  1.  浏览器客户端访问 <a href="http://map.google.cn/">http://map.google.cn</a></p><ol start="2"><li>Web服务器返回Response 301，Location&#x3D;<a href="http://titu.google.cn/">http://titu.google.cn</a>  （告诉客户端我们的资源位于这里， ）</li><li>浏览器客户端会自动再发送一个Request 去访问<a href="http://titu.google.cn/">http://titu.google.cn</a></li></ol><p><img src="/assets/wps58E5.tmp-20211222151316-23pq1a5.png"></p><h1 id="400-Bad-Request（坏请求"><a href="#400-Bad-Request（坏请求" class="headerlink" title="400 Bad Request（坏请求)"></a><strong>400 Bad Request（坏请求)</strong></h1><p>发送的Request中的数据有错误(比如：表单有错误，Cookie有错误)，  这个我们也经常见到。</p><p>实例： 还没想到， 想到了再贴个实例上来。</p><h1 id="403-Forbidden-禁止"><a href="#403-Forbidden-禁止" class="headerlink" title="403 Forbidden(禁止)"></a><strong>403 Forbidden(禁止)</strong></h1><p>Web客户端发送的请求被Web服务器拒绝了， 如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态码通常是服务器不想说明拒绝原因。</p><p>访问下面的URL， 会被服务器拒绝. 并且返回403状态码</p><p><a href="http://t2.baidu.com/it/u=1791561788,200960144&fm=0&gp=0.jpg">http://t2.baidu.com/it/u=1791561788,200960144&fm=0&gp=0.jpg</a></p><h1 id="404-Page-not-Found-请求的资源不存在"><a href="#404-Page-not-Found-请求的资源不存在" class="headerlink" title="404 Page not Found (请求的资源不存在)"></a><strong>404 Page not Found (请求的资源不存在)</strong></h1><p>这个大家都懂的， 值得一提的是：　腾讯把404页面做成了“寻找被拐儿童”</p><p><img src="/assets/wps58E6.tmp-20211222151316-qyq8gno.png"></p><h1 id="405-Method-Not-Allowed-不允许使用的方法"><a href="#405-Method-Not-Allowed-不允许使用的方法" class="headerlink" title="405 Method Not Allowed(不允许使用的方法)"></a><strong>405 Method Not Allowed(不允许使用的方法)</strong></h1><p>405是指Web服务器不支持Request中的方法。</p><p>我个人认为状态码405Method Not Allowed和501 Not Implemented 是一样的意思。都是不支持Request的方法。 （目前我还不知道这两个的区别）</p><p>实例:  发送一个是trace方法的Request 给<a href="http://www.google.com/">www.google.com</a></p><p><img src="/assets/wps58E7.tmp-20211222151316-g6wvu4u.png"></p><p><img src="/assets/wps58E8.tmp-20211222151316-5dizdq9.png"></p><h1 id="411-Length-Required（要求长度指示）"><a href="#411-Length-Required（要求长度指示）" class="headerlink" title="411 Length Required（要求长度指示）"></a><strong>411 Length Required（要求长度指示）</strong></h1><p>服务器要求在Request中包含Content-Length。</p><p>当浏览器使用Post方法，发送数据给Web服务器时， 必须要有Content-Length。这样Web服务器才知道你要发送多少数据，否则Web服务器会返回411状态码</p><p>实例： 发送一个Post方法的Request 给<a href="http://www.google.com/">www.google.com</a>.   Request中没有Content-Length</p><p><img src="/assets/wps58F9.tmp-20211222151316-iql1y7y.png"></p><p><img src="/assets/wps58FA.tmp-20211222151316-gdysfe6.png"></p><h1 id="413-Request-Entity-Too-Large（请求实体太大）"><a href="#413-Request-Entity-Too-Large（请求实体太大）" class="headerlink" title="413 Request Entity Too Large（请求实体太大）"></a><strong>413 Request Entity Too Large（请求实体太大）</strong></h1><p>作用：客户端发送的实体主体部分比服务器能够或者希望处理的要大。  一般情况下我们看不到这个状态码。 因为浏览器不会发送太大的数据给网站，但是机器人可能会。</p><p>实例: 用post方法发送一个大文件(100MB以上)给<a href="http://www.google.com/">www.google.com</a></p><p><img src="/assets/wps58FB.tmp-20211222151316-qtpckvt.png"></p><p><img src="/assets/wps58FC.tmp-20211222151316-fin7xes.png"></p><h1 id="414-Request-URI-Too-Long-请求URI太长"><a href="#414-Request-URI-Too-Long-请求URI太长" class="headerlink" title="414 Request URI Too Long(请求URI太长)"></a><strong>414 Request URI Too Long(请求URI太长)</strong></h1><p>就是说Request URI太长， 一般浏览器本身对URI的长度就会有限制，所以不会发送URI很长的Request. 我们平常是根本看不到414错误的。 但是机器人可以发送很长URI。</p><p>例如：我们用Fiddler Composer发送一个很长的URI给Google, 比如 “<a href="http://www.google.com/?q">www.google.com?q</a>&#x3D;asdfasdasf..”  q&#x3D;后面的参数很长。 就可以看到414了</p><p><img src="/assets/wps58FD.tmp-20211222151316-ai45r9x.png"></p><p><img src="/assets/wps58FE.tmp-20211222151316-k42ksdg.png"></p><h1 id="500-Internal-Server-Error-内部服务器错误"><a href="#500-Internal-Server-Error-内部服务器错误" class="headerlink" title="500 Internal Server Error(内部服务器错误)"></a><strong>500 Internal Server Error(内部服务器错误)</strong></h1><p>这个太常见了， 我们开发网站的时候，当我们的程序出错了时，就会返回500错误。</p><p>实例：ASP.NET 程序出错</p><p><img src="/assets/wps58FF.tmp-20211222151316-hapybyl.png"></p><p> <img src="/assets/wps5900.tmp-20211222151316-u3y9rl9.png"></p><h1 id="501-Not-Implemented-未实现"><a href="#501-Not-Implemented-未实现" class="headerlink" title="501 Not Implemented(未实现)"></a><strong>501 Not Implemented(未实现)</strong></h1><p>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码）。  一般的Web服务器只支持GET和POST方法。</p><p>实例： 使用Fiddler Composer 给<a href="http://www.qq.com/">www.qq.com</a>,  发送一个OPTIONS 方法的Request.   服务器就能返回501了。</p><p><img src="/assets/wps5901.tmp-20211222151316-l7a5n1g.jpg"></p><p><img src="/assets/wps5902.tmp-20211222151316-jpgi2af.jpg"></p><h1 id="502-Bad-Gateway（网关故障）"><a href="#502-Bad-Gateway（网关故障）" class="headerlink" title="502 Bad Gateway（网关故障）"></a><strong>502 Bad Gateway（网关故障）</strong></h1><p>代理使用的服务器遇到了上游的无效响应。</p><p>Fiddler本身就是代理服务器。  当我们访问<a href="http://www.facebook.com,这网站被我们天朝屏蔽了./">www.facebook.com，这网站被我们天朝屏蔽了。</a> 所以我们可以得到502</p><p><img src="/assets/wps5903.tmp-20211222151316-xc9razj.png"></p><h1 id="505-HTTP-Version-Not-Supported-不支持的HTTP版本"><a href="#505-HTTP-Version-Not-Supported-不支持的HTTP版本" class="headerlink" title="505 HTTP Version Not Supported(不支持的HTTP版本)"></a><strong>505 HTTP Version Not Supported(不支持的HTTP版本)</strong></h1><p>表示Web服务器不支持此HTTP协议的版本。</p><p>众所周知我们现在使用的HTTP协议版本是HTTP&#x2F;1.1， 如果我们发送一个HTTP&#x2F;2.0 的request 给博客园， 博客园肯定不能支持HTTP&#x2F;2.0，所以会返回505</p><p>想要发送这样的request, 可以使用Fiddler工具中的Composer来发送自定义的request, 如下图。</p><p><img src="/assets/wps5904.tmp-20211222151316-986ruis.png"></p><p><img src="/assets/wps5905.tmp-20211222151316-egcdh5j.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 状态码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/02_%E7%BC%93%E5%AD%98/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/02_%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存的概念"><a href="#缓存的概念" class="headerlink" title="缓存的概念"></a><strong>缓存的概念</strong></h1><p>缓存这个东西真的是无处不在， 有浏览器端的缓存， 有服务器端的缓存，有代理服务器的缓存， 有ASP.NET页面缓存，对象缓存。 数据库也有缓存， 等等。</p><p>http中具有缓存功能的是浏览器缓存，以及缓存代理服务器。</p><p>http缓存的是指:当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。</p><h1 id="缓存的好处"><a href="#缓存的好处" class="headerlink" title="缓存的好处"></a><strong>缓存的好处</strong></h1><p>缓存的好处是显而易见的， 好处有，</p><ol><li>减少了冗余的数据传输，节省了网费。</li><li>减少了服务器的负担， 大大提高了网站的性能</li><li>加快了客户端加载网页的速度</li></ol><h1 id="Fiddler可以方便地查看缓存的header"><a href="#Fiddler可以方便地查看缓存的header" class="headerlink" title="Fiddler可以方便地查看缓存的header"></a><strong>Fiddler可以方便地查看缓存的header</strong></h1><p>Fiddler中把header都分门别类的放在一起，这样方便查看。</p><p><img src="/assets/wpsE155.tmp-20211222151127-949mku1.png"></p><h1 id="如何判断缓存新鲜度"><a href="#如何判断缓存新鲜度" class="headerlink" title="如何判断缓存新鲜度"></a><strong>如何判断缓存新鲜度</strong></h1><p>Web服务器通过2种方式来判断浏览器缓存是否是最新的。</p><p>第一种， 浏览器把缓存文件的最后修改时间通过 header ”If-Modified-Since“来告诉Web服务器。</p><p>第二种， 浏览器把缓存文件的ETag, 通过header “If-None-Match”, 来告诉Web服务器。</p><h1 id="通过最后修改时间-来判断缓存新鲜度"><a href="#通过最后修改时间-来判断缓存新鲜度" class="headerlink" title="通过最后修改时间, 来判断缓存新鲜度"></a><strong>通过最后修改时间, 来判断缓存新鲜度</strong></h1><ol><li>浏览器客户端想请求一个文档，  首先检查本地缓存，发现存在这个文档的缓存，  获取缓存中文档的最后修改时间，通过： If-Modified-Since， 发送Request给Web服务器。</li><li>Web服务器收到Request，将服务器的文档修改时间（Last-Modified）: 跟request header 中的，If-Modified-Since相比较， 如果时间是一样的， 说明缓存还是最新的， Web服务器将发送304 Not Modified给浏览器客户端， 告诉客户端直接使用缓存里的版本。如下图。</li></ol><p><img src="/assets/wpsE156.tmp-20211222151127-4a40jej.jpg"></p><ol start="3"><li>假如该文档已经被更新了。Web服务器将发送该文档的最新版本给浏览器客户端， 如下图。</li></ol><p><img src="/assets/wpsE157.tmp-20211222151127-uyh67po.jpg"></p><p>实例： 打开Fiddler, 然后打开博客园首页。然后F5刷新几次浏览器。 你会看到博客园首页也用了缓存。</p><p><img src="/assets/wpsE158.tmp-20211222151127-etqucwh.jpg"></p><h1 id="与缓存有关的header"><a href="#与缓存有关的header" class="headerlink" title="与缓存有关的header"></a><strong>与缓存有关的header</strong></h1><p>我们来看看每个header的具体含义。</p><p>Request</p><table><thead><tr><th>Cache-Control: max-age&#x3D;0</th><th>以秒为单位</th></tr></thead><tbody><tr><td>If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT</td><td>缓存文件的最后修改时间。</td></tr><tr><td>If-None-Match: “0693f67a67cc1:0”</td><td>缓存文件的Etag值</td></tr><tr><td>Cache-Control: no-cache</td><td>不使用缓存</td></tr><tr><td>Pragma: no-cache</td><td>不使用缓存</td></tr><tr><td></td><td></td></tr></tbody></table><p>Response</p><table><thead><tr><th>Cache-Control: public</th><th>响应被缓存，并且在多用户间共享，（<a href="#publicAndPrivate">公有缓存和私有缓存的区别，请看另一节</a>）</th></tr></thead><tbody><tr><td>Cache-Control: private</td><td>响应只能作为私有缓存，不能在用户之间共享</td></tr><tr><td>Cache-Control:no-cache</td><td>提醒浏览器要从服务器提取文档进行验证</td></tr><tr><td>Cache-Control:no-store</td><td>绝对禁止缓存（用于机密，敏感文件）</td></tr><tr><td>Cache-Control: max-age&#x3D;60</td><td>60秒之后缓存过期（相对时间）</td></tr><tr><td>Date: Mon, 19 Nov 2012 08:39:00 GMT</td><td>当前response发送的时间</td></tr><tr><td>Expires: Mon, 19 Nov 2012 08:40:01 GMT</td><td>缓存过期的时间（绝对时间）</td></tr><tr><td>Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT</td><td>服务器端文件的最后修改时间</td></tr><tr><td>ETag: “20b1add7ec1cd1:0”</td><td>服务器端文件的Etag值</td></tr></tbody></table><p>如果同时存在cache-control和Expires怎么办呢？<br>浏览器总是优先使用cache-control，如果没有cache-control才考虑Expires</p><h1 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><strong>ETag</strong></h1><p>ETag是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。</p><p>ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。</p><p>为什么使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。</p><ol><li>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</li><li>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</li><li>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</li></ol><p>实例， 打开Fiddler, 打开博客园首页。  你可以看到很多图片，或者CSS文件都是用了缓存。 这些都是通过比较ETag的值，来判断文件是否更新了。</p><p><img src="/assets/wpsE159.tmp-20211222151127-o57jc2l.jpg"></p><h1 id="浏览器不使用缓存"><a href="#浏览器不使用缓存" class="headerlink" title="浏览器不使用缓存"></a><strong>浏览器不使用缓存</strong></h1><p>CTRL+F5强制刷新浏览器，或者设置IE。  可以让浏览器不使用缓存。</p><ol><li>浏览器发送Http request, 给Web 服务器， header中带有Cache-Control: no-cache.   明确告诉Web服务器，客户端不使用缓存。</li><li>Web服务器将把最新的文档发送给浏览器客户端.</li></ol><p>实例:</p><p>打开Fiddler, 打开博客园首页， 然后按CTRL+F5强制刷新浏览器，你将看到</p><p><img src="/assets/wpsE15A.tmp-20211222151127-xzmycng.jpg"></p><p>Pragma: no-cache的作用和Cache-Control: no-cache一模一样。 都是不使用缓存。</p><p>Pragma: no-cache 是HTTP 1.0中定义的， 所以为了兼容HTTP 1.0. 所以会同时使用Pragma: no-cache和Cache-Control: no-cache</p><h1 id="直接使用缓存，不去服务器验证"><a href="#直接使用缓存，不去服务器验证" class="headerlink" title="直接使用缓存，不去服务器验证"></a><strong>直接使用缓存，不去服务器验证</strong></h1><p>按F5刷新浏览器和在地址栏里输入网址然后回车。 这两个行为是不一样的。</p><p>按F5刷新浏览器， 浏览器会去Web服务器验证缓存。</p><p>如果是在地址栏输入网址然后回车，浏览器会”直接使用有效的缓存”, 而不会发http request 去服务器验证缓存，这种情况叫做缓存命中，如下图</p><p><img src="/assets/wpsE15B.tmp-20211222151127-vlk8i3m.jpg"></p><p>实例： 比较第一次访问博客园主页和第二次博客园主页</p><ol><li>启动Fiddler, 用firefox打开博客园主页， 发现有50多个session。</li><li>按CTRL+X将Fiddler中的所有session删除。 关闭firefox,重新打开一个firefox，打开博客园主页。   发现只有30多个session.</li></ol><p>分析；  少了的session是因为firefox直接用了缓存，而没有发http request。</p><p><img src="/assets/wpsE15C.tmp-20211222151127-owy880x.jpg"></p><h1 id="如何设置IE不使用缓存"><a href="#如何设置IE不使用缓存" class="headerlink" title="如何设置IE不使用缓存"></a><strong>如何设置IE不使用缓存</strong></h1><p>打开IE。点击工具栏上的， 工具-&gt;Internet选项-&gt;常规-&gt;浏览历史记录 设置. 选择“从不”。然后保存。</p><p>然后点击“删除”  把Internet临时文件都删掉 （IE缓存的文件就是Internet临时文件）。</p><p><img src="/assets/wpsE15D.tmp-20211222151127-tnxmonf.jpg"></p><h1 id="公有缓存和私有缓存的区别"><a href="#公有缓存和私有缓存的区别" class="headerlink" title="公有缓存和私有缓存的区别"></a><strong>公有缓存和私有缓存的区别</strong></h1><p>Cache-Control: public 指可以公有缓存， 可以是数千名用户共享的。</p><p>Cache-Control: private 指只支持私有缓存， 私有缓存是单个用户专用的。</p><p><img src="/assets/wpsE16E.tmp-20211222151127-uql8c7i.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/03_%E4%BB%A3%E7%90%86/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/03_%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是代理服务器"><a href="#什么是代理服务器" class="headerlink" title="什么是代理服务器"></a><strong>什么是代理服务器</strong></h1><p>Web代理（proxy）服务器是网络的中间实体。 代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。</p><p>HTTP的代理服务器即是Web服务器又是Web客户端。</p><p><img src="/assets/wpsDF5D.tmp-20211222151232-ddixl0r.jpg"></p><h1 id="Fiddler就是个典型的代理"><a href="#Fiddler就是个典型的代理" class="headerlink" title="Fiddler就是个典型的代理"></a><strong>Fiddler就是个典型的代理</strong></h1><p>Fiddler 是以代理web服务器的形式工作的,它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler退出的时候它会自动注销代理，这样就不会影响别的程序。</p><p><img src="/assets/wpsDF5E.tmp-20211222151232-3k0fozh.jpg"></p><p><img src="/assets/wpsDF5F.tmp-20211222151232-8omms3m.jpg"></p><h1 id="代理的作用一，-FQ"><a href="#代理的作用一，-FQ" class="headerlink" title="代理的作用一， FQ"></a><strong>代理的作用一， FQ</strong></h1><p>很多人都喜欢用Facebook， 看youTube。但是我们在天朝，天朝有The Great of Wall(长城防火墙)，屏蔽了这些好网站。  怎么办?   通过代理来跳墙，就可以访问了。</p><p>自己去寻找代理服务器很麻烦， 一般都是用FQ软件来自动发现代理服务器的。</p><p><img src="/assets/wpsDF60.tmp-20211222151232-96nhbdt.jpg"></p><h1 id="代理的作用二，-匿名访问"><a href="#代理的作用二，-匿名访问" class="headerlink" title="代理的作用二， 匿名访问"></a><strong>代理的作用二， 匿名访问</strong></h1><p>经常听新闻，说”某某某“在网络上发布帖子，被跨省追缉了。   假如他使用匿名的代理服务器，就不容易暴露自己的身份了。</p><p>http代理服务器的匿名性是指： HTTP代理服务器通过删除HTTP报文中的身份特性（比如客户端的IP地址， 或cookie,或URI的会话ID）， 从而对远端服务器隐藏原始用户的IP地址以及其他细节。 同时HTTP代理服务器上也不会记录原始用户访问记录的log(否则也会被查到)。</p><h1 id="代理的作用三，-通过代理上网"><a href="#代理的作用三，-通过代理上网" class="headerlink" title="代理的作用三， 通过代理上网"></a><strong>代理的作用三， 通过代理上网</strong></h1><p>比如局域网不能上网， 只能通过局域网内的一台代理服务器上网。</p><h1 id="代理的作用四，-通过代理缓存，加快上网速度"><a href="#代理的作用四，-通过代理缓存，加快上网速度" class="headerlink" title="代理的作用四， 通过代理缓存，加快上网速度"></a><strong>代理的作用四， 通过代理缓存，加快上网速度</strong></h1><p>大部分代理服务器都具有缓存的功能，就好像一个大的cache， 它有很大的存储空间，它不断将新取得数据存储到它本地的存储器上， 如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传给用户的浏览器，这样就能显著提高浏览速度。</p><h1 id="代理的作用五：儿童过滤器"><a href="#代理的作用五：儿童过滤器" class="headerlink" title="代理的作用五：儿童过滤器"></a><strong>代理的作用五：儿童过滤器</strong></h1><p>很多教育机构， 会利用过滤器代理来阻止学生访问成人内容。</p><p><img src="/assets/wpsDF61.tmp-20211222151232-ipw4fkt.jpg"></p><h1 id="IE代理设置：手动设置代理"><a href="#IE代理设置：手动设置代理" class="headerlink" title="IE代理设置：手动设置代理"></a><strong>IE代理设置：手动设置代理</strong></h1><p>IE浏览器可以手动设置代理， 很简单，指定一个IP地址和端口就可以了。 如下图。</p><p>工具 -＞ Internet选项 -&gt; 连接 -&gt; 局域网设置 （快捷键）</p><p><img src="/assets/wpsDF62.tmp-20211222151232-t1rz1e9.jpg"></p><p>假如代理服务器的IP地址改变了，或者端口号改变了。 难道要几百个客户端的浏览器去修改浏览器设置？ Impossable  这太难维护了。  下面还有一种更高级点的方法。</p><h1 id="IE代理设置：使用自动配置脚本（PAC）"><a href="#IE代理设置：使用自动配置脚本（PAC）" class="headerlink" title="IE代理设置：使用自动配置脚本（PAC）"></a><strong>IE代理设置：使用自动配置脚本（PAC）</strong></h1><p> 手动配置代理很简单，但是不灵活。 只能指定一个代理服务器，而且不支持故障转移。</p><p>在大公司里一般都使用PAC文件来配置。只需要指定PAC文件的URL就可以了， 如图：</p><p><img src="/assets/wpsDF63.tmp-20211222151232-0ylxvbu.jpg"></p><p>PAC（Proxy Auto Config）文件是一个小型的JavaScript程序的文本文件，后缀为.dat。</p><p>当浏览器访问网络的时候，会根据PAC文件中的JavaScript函数来选择恰当的代理服务器。</p><p>sample_pac.dat文件的内容</p><p><img src="/assets/wpsDF64.tmp-20211222151232-tfzfr8d.png"></p><p>function FindProxyForURL(url, host) {</p><pre><code>if (url.substring(0, 5) == &quot;http:&quot;) &#123;    // 应该使用指定的代理    return &quot;PROXY proxy:80&quot;;&#125;else if (url.substring(0, 4) == &quot;ftp:&quot;) &#123;    return &quot;PROXY fproxy:80&quot;;&#125;else if (url.substring(0, 7) == &quot;gopher:&quot;) &#123;    return &quot;PROXY gproxy&quot;;&#125;else if (url.substring(0, 6) == &quot;https:&quot;) &#123;    return &quot;PROXY secproxy:8080&quot;;&#125;else &#123;    // 直连，不经过任何代理    return &quot;DIRECT&quot;;&#125;</code></pre><p>}</p><p><img src="/assets/wpsDF65.tmp-20211222151232-x67d5mc.png"></p><h1 id="IE代理设置：自动探测设置（WPAD）"><a href="#IE代理设置：自动探测设置（WPAD）" class="headerlink" title="IE代理设置：自动探测设置（WPAD）"></a><strong>IE代理设置：自动探测设置（WPAD）</strong></h1><p> 浏览器只要选中“自动检测设置”， 就可以使用WPAD协议， WPAD会自动找到PAC文件的URL。  WPAD会使用一系列的资源发现技术（DHCP,DNS等）去寻找PAC文件。</p><p><img src="/assets/wpsDF66.tmp-20211222151232-u1fechv.jpg"></p><h1 id="代理认证，和407状态码"><a href="#代理认证，和407状态码" class="headerlink" title="代理认证，和407状态码"></a><strong>代理认证，和407状态码</strong></h1><p>代理服务器也可以需要权限认证， HTTP定义了一种名为代理认证（Proxy authentication）的机制。 这种机制可以阻止对内容的请求。</p><p>当浏览器访问需要认证的代理时， 代理服务器会返回407 Authorization Required,告诉浏览器输入用户名和密码。</p><p>代理认证跟HTTP基本认证是一样的机制， 如需了解代理认证的机制，请看<a href="http://www.cnblogs.com/TankXiao/archive/2012/09/26/2695955.html">[HTTP协议基本认证]</a></p><p><img src="/assets/wpsDF67.tmp-20211222151232-n3wbdm6.jpg"></p><h1 id="使用代理服务器的安全问题"><a href="#使用代理服务器的安全问题" class="headerlink" title="使用代理服务器的安全问题"></a><strong>使用代理服务器的安全问题</strong></h1><p>代理服务器和抓包工具（比如Fiddler）都能看到http request中的数据。 如果我们发送的request中有敏感数据，比如用户名，密码，信用卡号码。这些信息都会被代理服务器看到。所以非常危险。 所以我们一般都是用HTTPS来加密Http request.  这样代理服务器就看不到里面的数据了。</p><h1 id="如何搭建代理服务器"><a href="#如何搭建代理服务器" class="headerlink" title="如何搭建代理服务器"></a><strong>如何搭建代理服务器</strong></h1><p>可以使用CCproxy, 和Squid 来搭建代理服务器。</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议详解</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/01_HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/01_HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a><strong>什么是HTTP协议</strong></h1><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</p><p>目前我们使用的是HTTP&#x2F;1.1 版本</p><h1 id="Web服务器，浏览器-代理服务器"><a href="#Web服务器，浏览器-代理服务器" class="headerlink" title="Web服务器，浏览器,代理服务器"></a><strong>Web服务器，浏览器,代理服务器</strong></h1><p>当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？</p><p>实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示</p><p><img src="/assets/wps81FC.tmp-20211222150430-3fflmhm.png"></p><p>我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。</p><p>过程如下图所示</p><p><img src="/assets/wps820D.tmp-20211222150430-jrbyasx.jpg"></p><p>代理服务器就是网络信息的中转站，有什么功能呢？</p><ol><li>提高访问速度， 大多数的代理服务器都有缓存功能。</li><li>突破限制， 也就是FQ了</li><li>隐藏身份。</li></ol><h1 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a><strong>URL详解</strong></h1><p> URL(Uniform Resource Locator) 地址用于描述一个网络上的资源,  基本格式如下</p><p>schema:&#x2F;&#x2F;host[:port#]&#x2F;path&#x2F;…&#x2F;[?query-string][#anchor]</p><p>scheme               指定低层使用的协议(例如：http, https, ftp)</p><p>host                   HTTP服务器的IP地址或者域名</p><p>port#                 HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/">http://www.cnblogs.com:8080/</a></p><p>path                   访问资源的路径</p><p>query-string       发送给http服务器的数据</p><p>anchor-             锚</p><p>URL 的一个例子</p><p><img src="/assets/wps820E.tmp-20211222150430-vxxzzyy.png"></p><p><a href="http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff">http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</a></p><p>Schema:                 http<br>host:                   <a href="http://www.mywebsite.com/">www.mywebsite.com</a><br>path:                   &#x2F;sj&#x2F;test&#x2F;test.aspx<br>Query String:           name&#x3D;sviergn&amp;x&#x3D;true<br>Anchor:                 stuff</p><p><img src="/assets/wps820F.tmp-20211222150430-que97w7.png"></p><h1 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a><strong>HTTP协议是无状态的</strong></h1><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p><h1 id="打开一个网页需要浏览器发送很多次Request"><a href="#打开一个网页需要浏览器发送很多次Request" class="headerlink" title="打开一个网页需要浏览器发送很多次Request"></a><strong>打开一个网页需要浏览器发送很多次Request</strong></h1><ol><li>当你在浏览器输入URL <a href="http://www.cnblogs.com/">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com/">http://www.cnblogs.com</a> 的html.  服务器把Response发送回给浏览器.</li><li>浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。</li><li>浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</li><li>等所有的文件都下载成功后。 网页就被显示出来了。</li></ol><h1 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a><strong>HTTP消息的结构</strong></h1><p>先看Request 消息的结构,   Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图</p><p><img src="/assets/wps8210.tmp-20211222150430-r1erjah.jpg"></p><p>第一行中的Method表示请求方法,比如”POST”,”GET”,  Path-to-resoure表示请求的资源， Http&#x2F;version-number 表示HTTP协议的版本号</p><p>当使用的是”GET” 方法的时候， body是为空的</p><p>比如我们打开博客园首页的request 如下</p><p>GET <a href="http://www.cnblogs.com/">http://www.cnblogs.com/</a> HTTP&#x2F;1.1<br>Host: <a href="http://www.cnblogs.com/">www.cnblogs.com</a></p><p>抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response.</p><p>下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息，   如下图</p><p><img src="/assets/wps8211.tmp-20211222150430-ey18q0p.jpg"></p><p>我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行,  结构如下图</p><p><img src="/assets/wps8212.tmp-20211222150430-vl2gmcd.jpg"></p><p>HTTP&#x2F;version-number表示HTTP协议的版本号，  status-code 和message 请看下节[<a href="#statecode">状态代码</a>]的详细解释.</p><p>我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息，   如下图</p><p><img src="/assets/wps8213.tmp-20211222150430-4yjwq5a.jpg"></p><h1 id="Get和Post方法的区别"><a href="#Get和Post方法的区别" class="headerlink" title="Get和Post方法的区别"></a><strong>Get和Post方法的区别</strong></h1><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息.</p><p>我们看看GET和POST的区别</p><ol><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456.  POST方法是把提交的数据放在HTTP包的Body中.</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li></ol><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><strong>状态码</strong></h1><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p><p>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p><p>HTTP&#x2F;1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p><p>1XX  提示信息 - 表示请求已被成功接收，继续处理</p><p>2XX  成功 - 表示请求已被成功接收，理解，接受</p><p>3XX  重定向 - 要完成请求必须进行更进一步的处理</p><p>4XX  客户端错误 -  请求有语法错误或请求无法实现</p><p>5XX  服务器端错误 -   服务器未能实现合法的请求</p><p>看看一些常见的状态码</p><p>200 OK</p><p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p><p>如下图， 打开博客园首页</p><p><img src="/assets/wps8214.tmp-20211222150430-lm5mp15.jpg"></p><p>302 Found</p><p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request</p><p>例如在IE中输入， <a href="http://www.google.com/">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p><p><img src="/assets/wps8215.tmp-20211222150430-s198i48.jpg"></p><p>304 Not Modified</p><p>代表上次的文档已经被缓存了， 还可以继续使用，</p><p>例如打开博客园首页, 发现很多Response 的status code 都是304</p><p><img src="/assets/wps8216.tmp-20211222150430-xzo1alf.jpg"></p><p>提示：　如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面</p><p>400 Bad Request  客户端请求与语法错误，不能被服务器所理解</p><p>403 Forbidden 服务器收到请求，但是拒绝提供服务</p><p>404 Not Found</p><p>请求资源不存在（输错了URL）</p><p>比如在IE中输入一个错误的URL， <a href="http://www.cnblogs.com/tesdf.aspx">http://www.cnblogs.com/tesdf.aspx</a></p><p><img src="/assets/wps8217.tmp-20211222150430-14s4kkp.jpg"></p><p>500 Internal Server Error 服务器发生了不可预期的错误</p><p>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><h1 id="HTTP-Request-header"><a href="#HTTP-Request-header" class="headerlink" title="HTTP Request header"></a><strong>HTTP Request header</strong></h1><p>使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers  如下图所示.</p><p><img src="/assets/wps8218.tmp-20211222150430-dika77y.jpg"></p><p>header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p><h2 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a><strong>Cache 头域</strong></h2><p>If-Modified-Since</p><p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p><p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</p><p>实例如下图</p><p><img src="/assets/wps8229.tmp-20211222150430-tgwstoq.jpg"></p><p>If-None-Match</p><p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能</p><p>例如: If-None-Match: “03f2b33c0bfcc1:0”</p><p>实例如下图</p><p><img src="/assets/wps822A.tmp-20211222150430-hxee3yt.jpg"></p><p>Pragma</p><p>作用： 防止页面被缓存， 在HTTP&#x2F;1.1版本中，它和Cache-Control:no-cache作用一模一样</p><p>Pargma只有一个用法， 例如： Pragma: no-cache</p><p>注意: 在HTTP&#x2F;1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p><p>Cache-Control</p><p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p><p>Cache-Control:Public   可以被任何缓存所缓存（）</p><p>Cache-Control:Private     内容只缓存到私有缓存中</p><p>Cache-Control:no-cache  所有内容都不会被缓存</p><p>还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料</p><h2 id="Client-头域"><a href="#Client-头域" class="headerlink" title="Client 头域"></a><strong>Client 头域</strong></h2><p>Accept</p><p>作用： 浏览器端可以接受的媒体类型,</p><p>例如：  Accept: text&#x2F;html  代表浏览器可以接受服务器回发的类型为 text&#x2F;html  也就是我们常说的html文档,</p><p>如果服务器无法返回text&#x2F;html类型的数据,服务器应该返回一个406错误(non acceptable)</p><p>通配符 * 代表任意类型</p><p>例如  Accept: <em>&#x2F;</em>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p><p>Accept-Encoding：</p><p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;</p><p>例如： Accept-Encoding: gzip, deflate</p><p>Accept-Language</p><p>作用： 浏览器申明自己接收的语言。</p><p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p><p>例如： Accept-Language: en-us</p><p>User-Agent</p><p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p><p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p><p>例如： User-Agent: Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p><p>Accept-Charset</p><p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</p><p>例如：</p><h2 id="Cookie-x2F-Login-头域"><a href="#Cookie-x2F-Login-头域" class="headerlink" title="Cookie&#x2F;Login 头域"></a><strong>Cookie&#x2F;Login 头域</strong></h2><p>Cookie:</p><p>作用： 最重要的header, 将cookie的值发送给HTTP 服务器</p><h2 id="Entity头域"><a href="#Entity头域" class="headerlink" title="Entity头域"></a><strong>Entity头域</strong></h2><p>Content-Length</p><p>作用：发送给HTTP服务器数据的长度。</p><p>例如： Content-Length: 38</p><p>Content-Type</p><p>作用：</p><p>例如：Content-Type: application&#x2F;x-www-form-urlencoded</p><h2 id="Miscellaneous-头域"><a href="#Miscellaneous-头域" class="headerlink" title="Miscellaneous 头域"></a><strong>Miscellaneous 头域</strong></h2><p>Referer:</p><p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p><p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p><h2 id="Transport-头域"><a href="#Transport-头域" class="headerlink" title="Transport 头域"></a><strong>Transport 头域</strong></h2><p>Connection</p><p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p><p>Host（发送请求时，该报头域是必需的）</p><p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p><p>例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html">http://www.guet.edu.cn/index.html</a></p><p>浏览器发送的请求消息中，就会包含Host请求报头域，如下：</p><p>Host：<a href="http://www.guet.edu.cn/">http://www.guet.edu.cn</a></p><p>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p><h1 id="HTTP-Response-header"><a href="#HTTP-Response-header" class="headerlink" title="HTTP Response header"></a><strong>HTTP Response header</strong></h1><p>同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers  如下图所示</p><p><img src="/assets/wps822B.tmp-20211222150430-rnrd88w.jpg"></p><p> 我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p><h2 id="Cache头域"><a href="#Cache头域" class="headerlink" title="Cache头域"></a><strong>Cache头域</strong></h2><p>Date</p><p>作用:  生成消息的具体时间和日期</p><p>例如：　Date: Sat, 11 Feb 2012 11:35:14 GMT</p><p>Expires</p><p>作用: 浏览器会在指定过期时间内使用本地缓存</p><p>例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</p><p>Vary</p><p>作用：</p><p>例如: Vary: Accept-Encoding</p><h2 id="Cookie-x2F-Login-头域-1"><a href="#Cookie-x2F-Login-头域-1" class="headerlink" title="Cookie&#x2F;Login 头域"></a><strong>Cookie&#x2F;Login 头域</strong></h2><p>P3P</p><p>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p><p>例如: P3P: CP&#x3D;CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p><p>Set-Cookie</p><p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p><p>例如: Set-Cookie: sc&#x3D;4c31523a; path&#x3D;&#x2F;; domain&#x3D;.acookie.taobao.com</p><p><img src="/assets/wps822C.tmp-20211222150430-bknlpw2.jpg"></p><h2 id="Entity头域-1"><a href="#Entity头域-1" class="headerlink" title="Entity头域"></a><strong>Entity头域</strong></h2><p>ETag</p><p>作用:  和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p><p>例如: ETag: “03f2b33c0bfcc1:0”</p><p>Last-Modified:</p><p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p><p>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p><p>Content-Type</p><p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p><p>例如:</p><p>Content-Type: text&#x2F;html; charset&#x3D;utf-8</p><p>Content-Type:text&#x2F;html;charset&#x3D;GB2312</p><p>Content-Type: image&#x2F;jpeg</p><p>Content-Length</p><p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p><p>例如: Content-Length: 19847</p><p>Content-Encoding</p><p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p><p>例如：Content-Encoding：gzip</p><p>Content-Language</p><p>作用： WEB服务器告诉浏览器自己响应的对象的语言者</p><p>例如： Content-Language:da</p><h2 id="Miscellaneous-头域-1"><a href="#Miscellaneous-头域-1" class="headerlink" title="Miscellaneous 头域"></a><strong>Miscellaneous 头域</strong></h2><p>Server:</p><p>作用：指明HTTP服务器的软件信息</p><p>例如:Server: Microsoft-IIS&#x2F;7.5</p><p>X-AspNet-Version:</p><p>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本</p><p>例如: X-AspNet-Version: 4.0.30319</p><p>X-Powered-By:</p><p>作用：表示网站是用什么技术开发的</p><p>例如： X-Powered-By: ASP.NET</p><h2 id="Transport头域"><a href="#Transport头域" class="headerlink" title="Transport头域"></a><strong>Transport头域</strong></h2><p>Connection</p><p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p><h2 id="Location头域"><a href="#Location头域" class="headerlink" title="Location头域"></a><strong>Location头域</strong></h2><p>Location</p><p>作用： 用于重定向一个新的位置, 包含新的URL地址</p><p> 实例请看304状态实例</p><h1 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a><strong>HTTP协议是无状态的和Connection: keep-alive的区别</strong></h1><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p><p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p><p>从HTTP&#x2F;1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p><p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> HTTP协议详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/04_%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/04_%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<ul><li><p>TCP协议</p><ul><li><p>定义</p><ul><li>TCP（Transmission Control Protocol），传输控制协议，顾名思义，就是要对数据的传输进行一定的控制</li></ul></li><li><p>TCP协议头部组成部分</p><ul><li><p><img src="/assets/image-20211120135744-9acv70f.png" alt="image.png"></p></li><li><p>序号</p><ul><li>sequence number</li><li>编号：TCP数据包过大，需分段（10段）—（到达目的主机）按照顺序重组，</li></ul></li><li><p>确认号</p><ul><li><p>acknowledge number</p></li><li><p>服务器能否回应？—存在于确认消息里</p></li><li><p>跟序号有什么关系</p><ul><li>依据序号生成   序号+1    表示服务器期望收到你的下一个包的序号</li></ul></li></ul></li><li><p>状态控制码（code control flag）1 or 0（1表示打开，0表示关闭（表示数据包的类型））</p></li></ul></li><li><p>备注</p><ul><li>实现原理过程：HTTP,HTTPS协议—-基于TCP协议；client —百度服务器：TCP协议–交互和连接 —HTTP,HTTPS协议交互</li></ul></li><li><p>TCP协议连接</p><ul><li><p>TCP连接请求：TCP三次握手过程（新建连接），TCP四次挥手（断开连接）</p></li><li><p>TCP三次握手</p><ul><li><p><img src="/assets/image-20211120135957-moi5rq0.png" alt="image.png"></p></li><li><p>例</p><ul><li><img src="/assets/image-20211120140009-m2lc65n.png" alt="image.png"></li></ul></li></ul></li><li><p>TCP四次挥手</p><ul><li><p><img src="/assets/image-20211120140016-u5m759r.png" alt="image.png"></p></li><li><p>例</p><ul><li><img src="/assets/image-20211120140027-yydd5yd.png" alt="image.png"></li></ul></li></ul></li><li><p>抓包</p><ul><li>wireshark</li></ul></li></ul></li></ul></li><li><p>UDP协议</p><ul><li><p>定义</p><ul><li><p>UDP（User Datageam Protocol）用户数据报协议</p></li><li><p><img src="/assets/image-20211120140103-wikw2g0.png" alt="image.png"></p></li><li><p>没有 序号，确认号（重传）标志 等</p></li><li><p>UDP协议不会建立连接–无连接传输协议-不可靠的协议，容易丢包</p></li><li><p>UDP场景</p><ul><li><p>1。不需要可靠机制，只要求速度快—UDP协议</p></li><li><p>2.流媒体，多媒体游戏，IP电话     </p><ul><li>UDP协议封装</li></ul></li><li><p>3.资源消耗特别小</p></li></ul></li><li><p>UDP应用协议</p><ul><li>DNS(域名解析协议),SNMP(简单网络管理协议)，DHCP(动态获取IP),RIP  –UDP协议</li></ul></li><li><p>TCP应用协议</p><ul><li>HTTP,HTTPS,FTP</li></ul></li><li><p>实操</p><ul><li><p>结合cmd+wireshark</p><ul><li>cmd：ping <a href="http://www.baidu,com/">www.baidu,com</a></li><li>wireshark: 抓取dns（UDP）包</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="/assets/image-20211122192010-wrkiio4.png" alt="image.png"></p><ol><li>tcp是面向连接的，所有tcp三次握手和四次挥手的过程 —-|||—-udp无连接协议</li><li>tcp因为有可靠的连接机制&#x3D;&#x3D;&#x3D;可靠协议—-|||—-udp没有连接和确认机制&#x3D;&#x3D;会丢包会出错 不可靠的协议</li><li>tcp协议：数据量很大，防止丢包正确重传对数据的正确性很关心—-|||—-udp量小</li><li>速度：tcp协议速度很慢—-|||—-udp速度很快，传输效率很高</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 传输层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/05_%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/05_%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<ul><li><p>HTTP</p><ul><li><p>HTTP定义</p><ul><li>HTTP协议  （Hyper Text Transfer Protocol） 超文本传输协议</li><li>HTTP协议是基于TCP协议，默认是80端口—可靠的协议</li><li>功能：用来规定客户端和服务端的数据传输格式</li><li>特点：基于请求和响应模式的、无状态、无连接的应用层协议</li><li><img src="/assets/image-20211120140426-37e7idv.png" alt="image.png"></li></ul></li><li><p>HTTP请求（基于请求和响应模式）</p><ul><li><p>请求行</p><ul><li><img src="/assets/image-20211120140500-njj9r9v.png" alt="image.png"></li></ul></li><li><p>HTTP请求的方法</p><ul><li><img src="/assets/image-20211120140507-qxa6kew.png" alt="image.png"></li></ul></li><li><p>HTTP请求头内容</p><ul><li><img src="/assets/image-20211120140514-odif7ya.png" alt="image.png"></li></ul></li><li><p>HTTP响应行</p><ul><li><img src="/assets/image-20211120140522-1oq96m8.png" alt="image.png"></li></ul></li><li><p>HTTP响应头</p><ul><li><img src="/assets/image-20211120140528-ufuwkma.png" alt="image.png"></li></ul></li></ul></li><li><p>HTTP协议–无连接应用协议</p><ul><li><p>定义</p><ul><li>无状态应用协议解释：<br>1.对事物处理没有记忆功能，服务器不知道客户端是什么状态，给服务器发送http请求之后，服务器回应之后，不会有任何记录；<br>2.每次请求都是独立的<br>特点：服务器处理后续请求-前面的请求信息–重传</li><li>优点：释放了服务器的压力</li><li>缺点：数据重传–重复的内容，增大数据传输量，资源浪费</li><li>动态交互：淘宝：购物车功能–商品信息      登录：login–后续操作（充值）<br>—cookies<br>—session</li><li>限制每次连接只处理一个请求</li><li>服务器处理完客户的请求，并收到客户的应答后，即断开连接</li></ul></li><li><p>初衷</p><ul><li>用户量（十万、上百万）页面请求，单个用户间歇性大（突发性，瞬时性），数据没有关联性，—资源浪费&#x3D;&#x3D;&#x3D;设计：释放连接</li><li>问题：网页越来越复杂，–图片–效率低&#x3D;&#x3D;&#x3D;头部信息keep-alive 放在connection中</li></ul></li><li><p>keep-alive设置</p><ul><li><p>1。开启：connection：keep-alive ，会发起keep-alive的连接请求–长链接。http1.1-默认打开的</p><ul><li>不需要重新建立连接<br /></li></ul></li><li><p>2。关闭：在http请求头中设置connection：close，即可关闭</p></li><li><p>3。设置连接时间：</p><ul><li>在http header中设置keep-alive：timeout&#x3D;5，max&#x3D;1000<br>timeout是超时时间，单位秒，超过这个时间后就会断开–释放<br>max是最多的连接次数，若超过这个次数就强制断开连接<br /></li></ul></li></ul></li><li><p>cookies</p><ul><li>将前面请求信息保存成一个临时文件–cookies值，—存放在浏览器里，如淘宝购物车：写进入cookies；<br>登录：充值 先登录在充值，从login获取登录的账号信息保留到cookies值中</li><li>关闭浏览器会被删除</li><li>清除缓存会被删除</li></ul></li><li><p>session</p><ul><li>永久的ciikies值</li><li>session ID（会话编号）–保存在服务器上–传给客户端。客户端浏览器保存在内存里</li><li>问题：资源占用。设置session超时时间–可清除sessionID</li></ul></li><li><p>http协议问题</p><ul><li>发送数据都是明文，第三方窃听，窃取数据包，伪装客户端    对数据包进行篡改数据-服务器不知道<br>存在安全隐患<br>解决方法</li></ul></li></ul></li></ul></li><li><p>HTTPS</p><ul><li><p>概念：HTTPS（Hypertext Transfer Protocol Secure）超文本传输安全协议，是以安全为目的HTTP通道，简单讲是HTTP的安全版本。<br>它加密数据并确保其机密性–加密，数据密文；<br>可保护用户在与网站交互时免于窃取个人信息和计费信息数据–身份认证；<br>防止信息被篡改–完整性–安全保障</p></li><li><p><img src="/assets/image-20211120140837-24axt48.png" alt="image.png"></p><ul><li><p>http+加密+身份认证+完整性保护&#x3D;HTTPS</p><ul><li>过程原理（交互）</li><li><img src="/assets/image-20211120141019-dohg0nx.png" alt="image.png"></li><li><img src="/assets/image-20211120141023-o1pbp6b.png" alt="image.png"></li><li><img src="/assets/image-20211122192944-z4bp9fx.png" alt="image.png"></li></ul></li><li><p>wireshark实例</p><ul><li><p>追踪流-TLS流</p><ul><li>看到完整ssl交互的过程</li></ul></li><li><p>客户端加密套件（支持的列表）</p><ul><li><img src="/assets/image-20211120141054-sbng2g0.png" alt="image.png"></li></ul></li><li><p>服务端加密套件（支持的）</p><ul><li><img src="/assets/image-20211120141101-l8s4ytc.png" alt="image.png"></li></ul></li><li><p>服务端发送证书</p><ul><li><img src="/assets/image-20211120141111-mdx3djr.png" alt="image.png"></li></ul></li></ul></li><li><p>总结</p><ul><li><p>tls是ssl协议的版本</p><ul><li>sslv3，tls1.0，tls1.2</li></ul></li><li><p>加密：–秘钥+身份认证+证书（权威机构颁发（申请）&#x3D;&#x3D;双向认证）+完整性保护（哈希算法–计算一个hash值，验证消息的完整性）<br /></p></li></ul></li></ul></li></ul></li><li><p>HTTP协议VS  HTTPS 协议</p><ul><li><img src="/assets/image-20211120141142-x6tlrun.png" alt="image.png"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark介绍</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/02_wireshark%E4%BB%8B%E7%BB%8D/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/02_wireshark%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>wireshark的官方下载网站： <a href="http://www.wireshark.org/">http://www.wireshark.org/</a></p><p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。</p><p>wireshark是开源软件，可以放心使用。 可以运行在Windows和Mac OS上。</p><p>使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。</p><h1 id="Wireshark不能做的"><a href="#Wireshark不能做的" class="headerlink" title="Wireshark不能做的"></a><strong>Wireshark不能做的</strong></h1><p>为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p><h1 id="Wireshark-VS-Fiddler"><a href="#Wireshark-VS-Fiddler" class="headerlink" title="Wireshark VS Fiddler"></a><strong>Wireshark VS Fiddler</strong></h1><p>Fiddler是在windows上运行的程序，专门用来捕获HTTP，HTTPS的。</p><p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容</p><p>总结，如果是处理HTTP,HTTPS 还是用Fiddler,  其他协议比如TCP,UDP 就用wireshark</p><h1 id="同类的其他工具"><a href="#同类的其他工具" class="headerlink" title="同类的其他工具"></a><strong>同类的其他工具</strong></h1><p>微软的network monitor</p><p>sniffer</p><h1 id="什么人会用到wireshark"><a href="#什么人会用到wireshark" class="headerlink" title="什么人会用到wireshark"></a><strong>什么人会用到wireshark</strong></h1><ol><li>网络管理员会使用wireshark来检查网络问题</li><li>软件测试工程师使用wireshark抓包，来分析自己测试的软件</li><li>从事socket编程的工程师会用wireshark来调试</li><li>听说，华为，中兴的大部分工程师都会用到wireshark。</li></ol><p>总之跟网络相关的东西，都可能会用到wireshark.</p><h1 id="wireshark-开始抓包"><a href="#wireshark-开始抓包" class="headerlink" title="wireshark 开始抓包"></a><strong>wireshark 开始抓包</strong></h1><p>开始界面</p><p><img src="/assets/wps223.tmp-20211222150251-4msi772.jpg"></p><p>wireshark是捕获机器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要选择一个网卡。</p><p>点击Caputre-&gt;Interfaces.. 出现下面对话框，选择正确的网卡。然后点击”Start”按钮, 开始抓包</p><p><img src="/assets/wps224.tmp-20211222150251-8mp50nu.jpg"></p><h1 id="Wireshark-窗口介绍"><a href="#Wireshark-窗口介绍" class="headerlink" title="Wireshark 窗口介绍"></a><strong>Wireshark 窗口介绍</strong></h1><p><img src="/assets/wps225.tmp-20211222150251-8ptmq5c.jpg"></p><p>WireShark 主要分为这几个界面</p><ol><li>Display Filter(显示过滤器)，  用于过滤</li><li>Packet List Pane(封包列表)， 显示捕获到的封包， 有源地址和目标地址，端口号。 颜色不同，代表</li><li>Packet Details Pane(封包详细信息), 显示封包中的字段</li><li>Dissector Pane(16进制数据)</li><li>Miscellanous(地址栏，杂项)</li></ol><h1 id="Wireshark-显示过滤"><a href="#Wireshark-显示过滤" class="headerlink" title="Wireshark 显示过滤"></a><strong>Wireshark 显示过滤</strong></h1><p><img src="/assets/wps226.tmp-20211222150251-ih9fas3.jpg"></p><p>使用过滤是非常重要的， 初学者使用wireshark时，将会得到大量的冗余信息，在几千甚至几万条记录中，以至于很难找到自己需要的部分。搞得晕头转向。</p><p>过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。</p><p>过滤器有两种，</p><p>一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录</p><p>一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。 在Capture -&gt; Capture Filters 中设置</p><h1 id="保存过滤"><a href="#保存过滤" class="headerlink" title="保存过滤"></a><strong>保存过滤</strong></h1><p>在Filter栏上，填好Filter的表达式后，点击Save按钮， 取个名字。比如”Filter 102”,</p><p><img src="/assets/wps227.tmp-20211222150251-vuhqcm5.jpg"></p><p>Filter栏上就多了个”Filter 102” 的按钮。</p><p><img src="/assets/wps228.tmp-20211222150251-vqp495b.jpg"></p><h1 id="过滤表达式的规则"><a href="#过滤表达式的规则" class="headerlink" title="过滤表达式的规则"></a><strong>过滤表达式的规则</strong></h1><p>表达式规则</p><ol><li>协议过滤</li></ol><p>比如TCP，只显示TCP协议。</p><ol start="2"><li>IP 过滤</li></ol><p>比如 ip.src &#x3D;&#x3D;192.168.1.102 显示源地址为192.168.1.102，</p><p>ip.dst&#x3D;&#x3D;192.168.1.102, 目标地址为192.168.1.102</p><ol start="3"><li>端口过滤</li></ol><p>tcp.port &#x3D;&#x3D;80,  端口为80的</p><p>tcp.srcport &#x3D;&#x3D; 80,  只显示TCP协议的愿端口为80的。</p><ol start="4"><li>Http模式过滤</li></ol><p>http.request.method&#x3D;&#x3D;”GET”,   只显示HTTP GET方法的。</p><ol start="5"><li>逻辑运算符为 AND&#x2F; OR</li></ol><p>常用的过滤表达式</p><table><thead><tr><th>过滤表达式</th><th>用途</th></tr></thead><tbody><tr><td>http</td><td>只查看HTTP协议的记录</td></tr><tr><td>ip.src &#x3D;&#x3D;192.168.1.102 or ip.dst&#x3D;&#x3D;192.168.1.102</td><td>源地址或者目标地址是192.168.1.102</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="封包列表-Packet-List-Pane"><a href="#封包列表-Packet-List-Pane" class="headerlink" title="封包列表(Packet List Pane)"></a><strong>封包列表(Packet List Pane)</strong></h1><p>封包列表的面板中显示，编号，时间戳，源地址，目标地址，协议，长度，以及封包信息。 你可以看到不同的协议用了不同的颜色显示。</p><p>你也可以修改这些显示颜色的规则，  View -&gt;Coloring Rules.</p><p><img src="/assets/wps229.tmp-20211222150251-4lpd7s0.jpg"></p><h1 id="封包详细信息-Packet-Details-Pane"><a href="#封包详细信息-Packet-Details-Pane" class="headerlink" title="封包详细信息 (Packet Details Pane)"></a><strong>封包详细信息 (Packet Details Pane)</strong></h1><p>这个面板是我们最重要的，用来查看协议中的每一个字段。</p><p>各行信息分别为</p><p>Frame:   物理层的数据帧概况</p><p>Ethernet II: 数据链路层以太网帧头部信息</p><p>Internet Protocol Version 4: 互联网层IP包头部信息</p><p>Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP</p><p>Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议</p><h1 id="wireshark与对应的OSI七层模型"><a href="#wireshark与对应的OSI七层模型" class="headerlink" title="wireshark与对应的OSI七层模型"></a><strong>wireshark与对应的OSI七层模型</strong></h1><p><img src="/assets/wps22A.tmp-20211222150252-f5a714s.jpg"></p><h1 id="TCP包的具体内容"><a href="#TCP包的具体内容" class="headerlink" title="TCP包的具体内容"></a><strong>TCP包的具体内容</strong></h1><p> 从下图可以看到wireshark捕获到的TCP包中的每个字段。</p><p><img src="/assets/wps22B.tmp-20211222150252-ful58qc.jpg"></p><h1 id="实例分析TCP三次握手过程"><a href="#实例分析TCP三次握手过程" class="headerlink" title="实例分析TCP三次握手过程"></a><strong>实例分析TCP三次握手过程</strong></h1><p>看到这， 基本上对wireshak有了初步了解， 现在我们看一个TCP三次握手的实例</p><p> 三次握手过程为</p><p><img src="/assets/wps22C.tmp-20211222150252-2d6j1q0.jpg"></p><p>这图我都看过很多遍了， 这次我们用wireshark实际分析下三次握手的过程。</p><p>打开wireshark, 打开浏览器输入 <a href="http://www.cnblogs.com/tankxiao">http://www.cnblogs.com/tankxiao</a></p><p>在wireshark中输入http过滤， 然后选中GET &#x2F;tankxiao HTTP&#x2F;1.1的那条记录，右键然后点击”Follow TCP Stream”,</p><p>这样做的目的是为了得到与浏览器打开网站相关的数据包，将得到如下图</p><p><img src="/assets/wps22D.tmp-20211222150252-oq4qbxm.jpg"></p><p>图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。</p><p>第一次握手数据包</p><p>客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图</p><p><img src="/assets/wps22E.tmp-20211222150252-ozixvlj.jpg"></p><p>第二次握手的数据包</p><p>服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1&#x3D;1, 如下图</p><p><img src="/assets/wps22F.tmp-20211222150252-6x3zq2e.jpg"></p><p>第三次握手的数据包</p><p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图:</p><p><img src="/assets/wps230.tmp-20211222150252-1xrltr9.jpg"></p><p> 就这样通过了TCP三次握手，建立了连接</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> wireshark介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/03_%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/03_%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<ul><li><p>ARP协议</p><ul><li><p>ARP–定义</p><ul><li>ARP–地址解析协议（Address Resolution Protocol），实现通过对方IP地址（域名）寻找对方的MAC地址– ARP的功能</li></ul></li><li><p>例</p><ul><li><img src="/assets/image-20211120113425-tvawmj4.png" alt="image.png"></li><li><img src="/assets/image-20211120113433-gnbk314.png" alt="image.png"></li></ul></li><li><p>ARP协议的工作流程</p><ul><li>1.主机A首先查看自己的ARP表，如果找到了的主机B的MAC地址，则直接对IP数据包进行帧封装，发送给主机B</li><li>2.如果主机A在ARP表中找不到主机B的MAC地址，则将缓存改数据报文，然后以广播的方式发送一个ARP请求报文，ARP请求报文中带上源IP地址和MAC地址（主机A），目标IP地址和目标MAC地址为主机B的IP和全0的MAC地址。广播，该网段上的所有主机都可以接受到该请求，但只有被请求的主机（即主机B）会对该请求进行处理</li><li>3.主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中，之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MA地址。</li><li>4.主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去</li></ul></li><li><p>应用</p><ul><li><p>电脑打开cmd</p><ul><li>arp-a        查看表中连接信息</li><li>arp -d *    删除ARP缓存列表的命令</li></ul></li><li><p>抓包</p><ul><li><p>wireshark    选中对应的网卡，点击开始抓包</p><ul><li><img src="/assets/image-20211120113803-tfdrmv8.png" alt="image.png"></li><li>fram 物理层<br>Ethernet II 数据链路层<br>address resolution protocol</li></ul></li></ul></li></ul></li></ul></li><li><p>IP协议</p><ul><li><p>定义</p><ul><li><p>IP（Internet Protocol），分配给用户上网使用国际协议的设备的数字标签，分为两大类：IPV4 和IPV6</p></li><li><p>分别</p><ul><li><p>IPV4</p><ul><li>32位，<br>二进制:11000000.10101000.00000001.00000001，<br>十进制：192.168.1.1</li></ul></li><li><p>IPV6</p><ul><li>目的为了弥补IPV4地址池不够的缺陷–IPV4 数量有限<br>128位–有更多的IP地址<br>16进制:2001:ffdd:asdf:asde</li></ul></li></ul></li></ul></li><li><p>IP地址的组成</p><ul><li>IP地址由32bit组成，分为4段并用，使用“.”分隔：192.168.1.1</li><li><img src="/assets/image-20211120114039-rhuojhj.png" alt="image.png"></li></ul></li><li><p>子网掩码</p><ul><li><p>前置</p><ul><li>IP 没有办法进行判断，不能确定子网掩码</li><li>子网掩码表示子网</li></ul></li><li><p>作用</p><ul><li>用来标识子网，必须跟IP地址一起存在</li></ul></li><li><p>组成</p><ul><li>子网掩码跟IP地址一样，也是由连续的1和0组成，连续的1表示网络地址，连续的0表示主机地址，只有网络地址相同的主机在同一子网，才能直接通信</li></ul></li><li><p>表示方法</p><ul><li>255.255.255.0，或者&#x2F;24.</li><li>二进制   11111111.11111111.11111111.00000000</li></ul></li></ul></li><li><p>案例</p><ul><li><img src="/assets/image-20211120114205-k6z43al.png" alt="image.png"></li></ul></li></ul></li><li><p>路由协议</p><ul><li><p>前置   不在一个子网，怎么通信？–路由协议完成</p></li><li><p>定义</p><ul><li><p>路由协议（Routing protocol），指定数据包转送方式的网上协议</p></li><li><p>分类</p><ul><li><p>静态路由协议</p><ul><li>指定目的地址—指定下一跳<br>默认路由（0.0.0.0.0.0.0.0-匹配所有）（主机–默认网关–做详细的路由选择）</li></ul></li><li><p>动态路由协议（RIP（V1 V2）,OSPF,BGP）</p><ul><li>动态路由协议，配置之后，动态学习路由条目–路由表</li></ul></li></ul></li><li><p>cmd命令</p><ul><li>route print   打开路由表</li><li>网络目标   目的地址</li><li>网络掩码</li><li>网关     下一跳</li><li>接口</li><li>跃点数      路由的优先级   跳跃数越小优先级越高</li><li><img src="/assets/image-20211122191712-ani9owc.png" alt="image.png"></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络技术</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/01_%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/01_%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>网络技术（TCP&#x2F;UDP）</p><p>原理图</p><p><img src="/assets/image-20211120110955-m8jreyh.png" alt="image.png"></p><pre><code>课程目标    osi 七层模型以及数据传输过程    网络层协议重点协议--ARP，IP，路由协议    传输层重点协议--TCP,UDP    应用层重点协议--HTTP    应用层重点协议--HTTPS    抓包工具wireshark的使用  ：((20211120111353-joikthh &quot;安装&quot;))        前期是为了实现两台机器互联，规范--同意标准实现通信    ![image.png](assets/image-20211120112125-q8unjrt.png)</code></pre><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><h2 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h2><p>通过定义各种应用协议规范数据格式：http协议，https协议，ftp协议，dns协议，smtp协议等等<br /></p><h2 id="表示层："><a href="#表示层：" class="headerlink" title="表示层："></a>表示层：</h2><p>翻译工作，提供一种公共语言，通信<br /></p><h2 id="会话层："><a href="#会话层：" class="headerlink" title="会话层："></a>会话层：</h2><p>1.可以从校验点继续恢复数据进行重传。2.自动收发包，自动寻址的功能网络中大文件数据传输，相当于续传</p><h2 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h2><p>1.对发送数据进行封装，—TCP,UDP协议，一个一个按顺序依次发送2.两个应用程序（QQ–QQ0），定义端口的概念，寻找到对应程序，进行数据处理</p><h2 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h2><p>1.怎么知道对方的MAC地址—-ARP (ADDRESS RESOLUTION PROTOCOL),通过IP地址知晓MAC;–包<br>2.判断是否在同一个子网，—-IP协议</p><p>3.怎么选择最优路径 —- 一组协议 路由协议 静态路由 动态路由 （RIP,OSPF,BGP）。</p><h2 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h2><p>1.比特流进行处理：分组。8位一组–一个字节，依次按顺序发送数据—帧2.MAC地址。–网卡-身份证（唯一性）。寄件人地址+收件人地址</p><h2 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h2><p>互联物理链路，物理介质。网线（双绞线），光纤，无线电波–可实现基本连接<br>存在形式：计算机语言（010010101110001）二进制，–电信号–在网络中叫比特流</p><h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>1.实现两台机器互联，及其与机器之间通信–物理层<br>2.0101010比特流其实是没有什么意义的数据，变成有意义的数据–数据链路层<br>3.主机A-B，C,D,E-主机F    – 路径有很多条，怎么选择最优路径，要怎么知道反对方的MAC地址–网络层<br>4.发送数据特别多，数据包很大，需要长时间，中间网络中断，重传？？ —传输层<br>5.断点续传功能—会话层实现<br>6.操作系统，windows10，macos，linux，语法是不一样的，不同的系统之间进行通信–表示层<br>7.字节流的格式，不好识别，不好操作，浏览器操作–应用层操作</p><p>TCP&#x2F;IP四层模型    VS    ISO七层模型<br>        <img src="/assets/image-20211120112647-ybjw1zn.png" alt="image.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code>数据传输过程</code></pre><p><img src="/assets/image-20211120112150-l4p7m20.png" alt="image.png"></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 网络技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<ol><li><h3 id="网络技术"><a href="#网络技术" class="headerlink" title="网络技术"></a><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/01_%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></h3></li><li><h4 id="wireshark介绍"><a href="#wireshark介绍" class="headerlink" title="wireshark介绍"></a><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/02_wireshark%E4%BB%8B%E7%BB%8D/">wireshark介绍</a></h4></li><li><h2 id="网络协议的定义："><a href="#网络协议的定义：" class="headerlink" title="网络协议的定义："></a>网络协议的定义：</h2><ol><li>通常地说网络协议就是网络之间交流的桥梁，只有相同的网络协议的计算机才能进行信息的沟通与交流，这就好比人与人之间的交流所使用的各种语言，只有使用相同的语言才能正常的顺利进行交流，从专业角度定义：网络协议是计算机在网络中实现通信时必须遵守的约定，也即通信协议，主要是对信息传输的速率，传输的代码 代码结构，传输控制步骤，出错控制等作出规定制定标准</li></ol></li><li><h2 id="TCP-x2F-ip-ipv4"><a href="#TCP-x2F-ip-ipv4" class="headerlink" title="TCP&#x2F;ip ipv4"></a>TCP&#x2F;ip ipv4</h2><ol><li><p>网络接口层：公网达到局域网后需要转化为对应的MAC地址，交换机解析判断数据要发给MAC地址对应的那台电脑，使用的是arp协议（地址解析协议）</p></li><li><p><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/03_%E7%BD%91%E7%BB%9C%E5%B1%82.md">网络层</a>：寻找最佳网络路径（比如我们浏览其他的服务器会留下记录）</p></li><li><p><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/04_%E4%BC%A0%E8%BE%93%E5%B1%82.md">传输层</a>：设备和设备之间进行传送比特流数据</p></li><li><p><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/05_%E5%BA%94%E7%94%A8%E5%B1%82.md">应用层</a>：应用层是所有用户做面向的应用程序的统称</p></li><li><p>FTP文件传输协议，有两个端口  20 用于传输数据   21 用于传输控制信息通常用FTP协议把网页或者程序传到web服务器上，由于FTP传输效率非常高，在网络上传输大的文件时一般也采用该协议</p><p> oracle数据库 默认端口号：1521</p><p> sqlserver数据库  默认端口号：1433</p><p> mysql数据库 默认端口号：3306</p></li></ol></li><li><h2 id="应用层有哪些协议："><a href="#应用层有哪些协议：" class="headerlink" title="应用层有哪些协议："></a>应用层有哪些协议：</h2><ol><li><p>http（80）   https（443） ftp(21)  ssh(22) telnet(23) tcp  udp  arp 等</p><p> ftp文件传输协议     </p><p> ssh    linux系统安全连接协议</p><p> http协议：超文本传输协议      </p><p> https协议：加密超文本传输协议</p></li></ol></li><li><h2 id="SSH（安全外壳协议）"><a href="#SSH（安全外壳协议）" class="headerlink" title="SSH（安全外壳协议）"></a>SSH（安全外壳协议）</h2><ol><li>ssh为建立在应用层基础上的安全协议，ssh是目前较可靠，专为远程登录回话和其他网络服务提供安全性协议，利用ssh协议可以有效防止远程管理过程中的信息泄露的问题，ssh最初始unix系统上的一个程序，后来又迅速扩展到其他操作平台，ssh在正确使用时可弥补网络中的罗东，ssh客户端使用于多种平台，数据  端口号 22</li></ol></li><li><h2 id="Telnet（远程登录协议）"><a href="#Telnet（远程登录协议）" class="headerlink" title="Telnet（远程登录协议）"></a>Telnet（远程登录协议）</h2><ol><li>telnet 协议是tcp&#x2F;ip协议族中的一员，是internet远程登录服务的标准协议和主要方式，它为用户提供了在本地计算机上完成远程主句工作的能录，在终端使用者的电脑上使用Telnet程序，用它连接到服务器，终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行就像直接在服务器的控制台上输入一样，可以在本地就能控制服务器，要开始一个telnet会晤，必须输入用户名和密码来登录服务器数据端口号23</li></ol></li><li><h2 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP(地址解析协议)"></a>ARP(地址解析协议)</h2><ol><li>通过一致的ip寻找主机的mac地址（物理地址）硬件地址用来定义网络设备的位置，一个主机只有一个mac地址</li><li>RARP是反向的地址解析协议，通过mac地址确定ip地址</li></ol></li><li><h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ol><li>tcp是面向有链接的协议，提供可靠的报文传输和对上层应用的连接服务</li><li>udp是面向无链接的不可靠的传输协议，主要用于需要tcp的排序和流量 控制等功能的应用程序</li><li>tcp是一种可靠的传输协议，有请求有响应，规定接受端必须发回确认并且假如分组丢失，必须重新发送</li><li>udp则不具备这些，知识把数据包从客户端传输给服务端，至于服务端是否真实收到则不做判断</li></ol></li><li><h2 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI  七层协议"></a>OSI  七层协议</h2><ol><li><p>1.物理层   2.数据链路层  3.网络层  4. 传输层   5.会话层    6. 表示层   7.应用层</p><ol><li><p>物理层：两个硬件之间怎么进行通信，一个硬件发送比特流，另一个硬件成功进行接受</p><p> 物理层定义：定义物理层设备的标准比如光纤，网络，各种传输介质，出阿叔速度；</p><p> 主要关注：1和0之间的数模转换和模数转换（数模：用合适的数学模型，教数公式表达方便；魔术：设置一定的规则进行应用）</p></li><li><p>数据链路层：在数据的传输过程中识别传输比特流数据的正确性，</p><ol><li>主要关注：规范数据传输的格式，校验数据的正确性</li></ol></li><li><p>传输层：设备和设备之间进行传比特流数据</p><ol><li>tcp：面向有链接的协议请求，有请求有相应</li><li>udp：面向无链接的协议请求，有请求无响应</li></ol></li><li><p>网络层：寻找最佳网络路径（比如我们浏览其他的服务器会留下记录）</p></li><li><p>会话层：根据以上协议自动进行发送对应的数据</p></li><li><p>表示层：不同系统之间交互的通道（作用相当于我们的翻译）</p><ol><li>windows 运行软件  .exe</li><li>linux   运行软件   .sh</li></ol></li><li><p>应用层：贴近我们的日常生活，能够直观看到的</p><ol><li><img src="/assets/image-20211122140653-z9ls60r.png" alt="image.png"></li></ol></li></ol></li></ol></li><li><h2 id="osi-7层协议解释说明"><a href="#osi-7层协议解释说明" class="headerlink" title="osi 7层协议解释说明"></a>osi 7层协议解释说明</h2><ol><li>物理层（physical layer） 主要是处理机械的电器的过程的接口，以及物理层下的物理传输介质等</li><li>数据链路层（data link layer） 的任务是加强吴立成的功能 使其对网络层显示为一条无错的线路</li><li>网络层（network layer） 确定分组从源端到目的端的路由选择，路由可以选用网络中固定的静态路由表，也可以在每一次会化时决定，还可以根据当前的网络负载状态，灵活的为每一个分组分别决定</li><li>传输层（transport layer） 从会话层接受数据，并传给网络层，同时确保到达目的端的各段信息正确无误，而且使会话层不受硬件变化的影响</li><li>会话层（session layer） 允许不同的机器上的用户之间建立绘画关系，即可以进行类似传输层的数据传输，也可以被用于与远程登录到不同系统或者在两个机器间传递文件</li><li>表示层（presentation layer） 用于完成一些特定的功能，这些功能由于经常被请求，因人们希望有通用的解决方法，而不是由每个用户各自实现</li><li>应用层（application layer） 中包含了大量人们普遍需要的协议，如qq、浏览器等部分软件均在应用层</li></ol></li><li><h3 id="是否了解三次握手，四次挥手？"><a href="#是否了解三次握手，四次挥手？" class="headerlink" title="是否了解三次握手，四次挥手？"></a>是否了解三次握手，四次挥手？</h3><ol><li><h5 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h5><ol><li><p>第一次握手：建立连接时，客户端发送SYN包到服务器，并进入SYN-SEND（发送）状态，等待服务器确认。</p></li><li><p>第二次握手：服务器收到SYN包，必须确认客户的SYN，同时自己也发送一个syn包。即syn+ack（确认字符）包，此时服务器进入syn-recv（接受）状态</p></li><li><p>第三次握手：客户端收到服务器syn+ack包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入established（确认）状态，完成三次握手</p></li></ol></li><li><h5 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h5><ol><li><p>第一次挥手：客户端给服务器发送FIN包，用来关闭客户端到服务器的数据传送</p></li><li><p>第二次挥手：服务器收到FIN包，发送一个确认信号ACK</p></li><li><p>第三次挥手：服务器发送FIN包，请求关闭服务器到客户端的数据传送</p></li><li><p>第四次挥手：客户端收到服务器发送的FIN包之后，发回ACK包确认</p></li></ol></li></ol></li><li><h2 id="长连接和短连接的区别"><a href="#长连接和短连接的区别" class="headerlink" title="长连接和短连接的区别"></a>长连接和短连接的区别</h2><ol><li><p>短连接：指socket连接后发送，接受完数据后马上断开（比如发短信）</p><pre><code> &lt;短连接：连接-数据传输-关闭连接（安全性比较高）&gt;</code></pre><p> 长连接：指socket连接后不管是否传输都保持连接，单安全性比较低（比如打电话，视频通信）</p><pre><code> &lt;长连接：连接-数据传输-保持连接-数据传输-关闭连接（安全性比较低）&gt;</code></pre></li></ol></li><li><h3 id="对协议这块是否熟悉了解，大概给我简单介绍下http协议？"><a href="#对协议这块是否熟悉了解，大概给我简单介绍下http协议？" class="headerlink" title="对协议这块是否熟悉了解，大概给我简单介绍下http协议？"></a>对协议这块是否熟悉了解，大概给我简单介绍下<strong>http</strong>协议？</h3><ol><li><p>对于协议这块，我们做接口测试一定要熟悉协议，而且我们所有接口都是 http 接口，所以对于 http 协议还算比较熟悉。</p><p> 其实http协议是一个超文本传输协议—- &gt;可以传输文字&#x2F;文本，图片，音频，视频等</p><p> HTTP<br> 是一个基于 TCP&#x2F;IP 通信协议来传递数据，目前有 1.0，1.1 两个版本，现在主要用的 1.1 版本协议。HTTP 协议工作于客户端-服务端架构为上一种协议。他的原理是这样的：浏览器作为 HTTP 客户端通过URL 向<br> HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。</p><p> 这个协议其实就是通过请求，响应的形式来进行数据传输的一种模式。</p><p> http 协议比较简单，传输速度比较快，例外，它是一种面向无状态，无连接的协议，同时支持<br> B&#x2F;S 及C&#x2F;S</p><p> 模式。它没有记忆能力，每次要获取数据都必须要重新发送请求。</p></li><li><p><img src="/assets/image-20211203174202-7p53c90.png" alt="image.png"></p></li></ol></li><li><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><ol><li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/01_HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">HTTP协议详解</a></li><li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/02_%E7%BC%93%E5%AD%98/">缓存</a></li><li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/03_%E4%BB%A3%E7%90%86/">代理</a></li><li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/04_%E7%8A%B6%E6%80%81%E7%A0%81/">状态码</a></li><li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/05_cookie/">cookie</a></li></ol></li><li><h3 id="http协议的报文"><a href="#http协议的报文" class="headerlink" title="http协议的报文"></a><strong>http</strong>协议的报文</h3><ol><li><p>哦，对于 http 的报文，由于它是通过请求，响应的方式在客户端与服务端进行数据传输的模式，所以它的报文分为请求报文和响应报文。</p><p> Http 的请求报文包含以下 4 个部分：请求行，请求头，空行，请求数据&#x2F;参数。</p><p> 我们其实一般最关注的主要是请求头及请求数据&#x2F;参数。尤其在做接口测试的时候我们需要关注这两个部分。例外，对于请求行里面，一般包含有：请求方式，请求地址&#x2F;URL，端口，协议版本等信息。</p><p> 而 http 的响应报文包含以下 4 个部分：响应行，响应头，空行，响应的数据</p><p> 对于响应，我们一般重点关注的是：响应头，响应的数据。例外，响应行中包含有：协议版本，状态（本次数据传输的状态），提示信息。还有就是，请求头中也有些比较关键的信息，比如用来做鉴权的<br> cookie 或着 token 的值，我们后面可能会需要用到。 而响应具体数据中包含：错误码，具体数据内容，一般具体的数据内容的格式有：json,xml,html。对于 Web端一般传输的是 html格式，而 app端一般传输的<br> json 格式居多。</p><blockquote><p>POST</p><p><a href="http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWwucJRFNxUfImKSQTQAgTEpzCOgh">http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWw</a> <a href="http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWwucJRFNxUfImKSQTQAgTEpzCOgh">ucJRFNxUfImKSQTQAgTEpzCOgh </a>HTTP&#x2F;1.1 请求行</p><p>Host: localhost 请求头</p><p>Connection: keep-alive Content-Length: 169</p><p>Accept: application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01 Origin: <a href="http://localhost/">http://localhost</a></p><p>X-Requested-With: XMLHttpRequest</p><p>User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;73.0.3683.103 Safari&#x2F;537.36</p><p>Content-Type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8 Referer: <a href="http://localhost/fw/">http://localhost/fw/</a></p><p>Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q&#x3D;0.9</p><p>Cookie: PHPSESSID&#x3D;1995aff9a42398edb17cd80bb76a5a5f</p><p>空行</p><p>email&#x3D;jason&amp;user_pwd&#x3D;WVRnSk1kS1hneW9RYkNxVmpTR1VVQmN1bHN3SlR4ekdEQkVIYlFIRmlZUnFW</p><p>cHBSYWElMjV1NjVCOSUyNXU3RUY0emdwMTIzNDU2JTI1dThGNkYlMjV1NEVGNg%3D%3D&amp;auto_login&#x3D;0</p><p>&amp;ajax&#x3D;1 请求参数&#x2F;数据</p></blockquote><blockquote><p>HTTP&#x2F;1.1 200 OK 响应行</p><p>Date: Thu, 25 Apr 2019 05:45:21 GMT 响应头</p><p>Server: Apache&#x2F;2.2.11 (Win32) DAV&#x2F;2 mod_ssl&#x2F;2.2.11 OpenSSL&#x2F;0.9.8i PHP&#x2F;5.2.9 X-Powered-By: PHP&#x2F;5.2.9</p><p>Expires: Thu, 19 Nov 1981 08:52:00 GMT</p><p>Cache-Control: no-store, no-cache, must-revalidate, post-check&#x3D;0, pre-check&#x3D;0 Pragma: no-cache</p><p>Content-Length: 262</p><p>Keep-Alive: timeout&#x3D;5, max&#x3D;100 Connection: Keep-Alive</p><p>Content-Type: text&#x2F;html; charset&#x3D;utf-8</p><p>空行</p><p>{“status”:2,”info”:”\u672c\u7ad9\u9700\u7ed1\u5b9a\u7b2c\u4e09\u65b9\u6258\u7ba1\ u8d26\u6237\uff0c\u662f\u5426\u9a6c\u4e0a\u53bb\u7ed1\u5b9a”,”data”:null,”jump”:”</p><p>/fw/index.php”,”jump1”:”/fw/index.php?ctl&#x3D;collocation&amp;act&#x3D;CreateNewAcct&amp;user_</p><p>type&#x3D;0&amp;user_id&#x3D;33”}响应的具体内容</p></blockquote></li></ol></li><li><h3 id="常用的-http协议的状态码？"><a href="#常用的-http协议的状态码？" class="headerlink" title="常用的 http协议的状态码？"></a>常用的 http协议的状态码？</h3><ol><li><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><ol><li>1xx：指示信息–表示请求已接收，继续处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li>5xx：服务器端错误–服务器未能实现合法的请求</li></ol></li><li><p>200 OK服务器成功处理了请求（这个是我们见到最多的） </p><p> 301&#x2F;302 MovedPermanently（重定向）请求的URL已移走。Response中应该包含一个Location URL,说明资源现在所处的位置 </p><p> 304 Not Modified（未修改）客户的缓存资源是最新的，要客户端使用缓存</p><p> 404 Not Found未找到资源 </p><p> 401Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </p><p> 400 Bad Request客户端请求与语法错误，不能被服务器所理解 </p><p> 403Forbidden服务器收到请求，但是拒绝提供服务 </p><p> 500InternalServerError服务器发生了不可预期的错误 </p><p> 501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务 </p><p> 503 Server Unavailable服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p></li></ol></li><li><p><strong>http</strong>协议的请求方式，<strong>Get</strong>请求与 <strong>Post</strong>请求的区别？</p><ol><li><p>我们常用的请求方式一般是:get 请求，post 请求</p><ol><li>GET提交，请求的数据会附在<br> URL之后（就是把数据放置在 HTTP协议头中），以?分割 URL和传输数据，多个参数用&amp;连接；如果传输的数据是中文&#x2F;其他字符，一般则直接把字符串用 BASE64加密。</li></ol><p> POST 提交：把提交的数据放置在是 HTTP 包的包体中</p><p> 因此，GET 提交的数据会在地址栏中显示出来，而<br> POST 提交，地址栏不会改变</p><ol start="2"><li>传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</li></ol><p> 而在实际开发中存在的限制主要有：</p><p> GET:特定浏览器和服务器对 URL长度有限制，例如 IE对URL长度的限制是 2083字节(2K+35)。对于其他浏览器，如 Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系<br> 统的支持。</p><p> 因此对于 GET 提交时，传输数据就会受到 URL 长度的限制。</p><p> POST:由于不是通过URL 传值，理论上数据不受限。</p><ol start="3"><li>POST的安全性要比 GET的安全性高。比如：通过 GET提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 GET<br> 提交数据还可能会造成Cross-siterequest<br> forgery攻击（数据篡改）</li></ol></li></ol></li><li><h3 id="http协议与-https协议的区别"><a href="#http协议与-https协议的区别" class="headerlink" title="http协议与 https协议的区别"></a><strong>http</strong>协议与 <strong>https</strong>协议的区别</h3><ol><li><p>https 所用的端口号是 443 端口</p><p> http 所用的端口是 80 端口</p><p> HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用HTTP 协议传输隐私信息非常不安全， 为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p><p> https 通信的优点：</p><p> 1） 客户端产生的密钥只有客户端和服务器端能得到；</p><p> 2） 加密的数据只有客户端和服务器端才能得到明文；</p><p> 3） 客户端到服务端的通信是安全的。</p><p> 区别：</p><p> (1) https 协议需要ca 申请证书，并且大多数证书都是收费的。</p><p> (2) http 以明文的形式传输信息，https 则是具有安全性的ssl 加密传输协议。</p><p> (3) http 和https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80（有时是8080），后者是443。</p><p> (4) http 的连接简单，无状态；HTTPS 协议是在HTTP 协议的基础上，加上由SSL 层，构建的可进行加密传输、身份认证的网络协议，比http 协议安全。</p></li></ol></li><li><h4 id="tcp与udp的区别"><a href="#tcp与udp的区别" class="headerlink" title="tcp与udp的区别"></a>tcp与udp的区别</h4><ol><li><p>tcp是面向有链接的协议，提供可靠的报文传输和对上层应用的连接服务</p><p> udp是面向无链接的不可靠的传输协议，主要用于需要tcp的排序和流量 控制等功能的应用程序</p><p> tcp是一种可靠的传输协议，有请求有响应，规定接受端必须发回确认并且假如分组丢失，必须重新发送</p><p> udp则不具备这些，知识把数据包从客户端传输给服务端，至于服务端是否真实收到则不做判断</p></li></ol></li></ol><p>短连接：指socket连接后发送，接受完数据后马上断开（比如发短信）</p><pre><code>&lt;短连接：连接-数据传输-关闭连接（安全性比较高）&gt;</code></pre><p>长连接：指socket连接后不管是否传输都保持连接，单安全性比较低（比如打电话，视频通信）</p><pre><code>&lt;长连接：连接-数据传输-保持连接-数据传输-关闭连接（安全性比较低）&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引文献</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/08_%E7%B4%A2%E5%BC%95%E6%96%87%E7%8C%AE/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/08_%E7%B4%A2%E5%BC%95%E6%96%87%E7%8C%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>一、引言</strong></p><p>对数据库索引的关注从未淡出我的们的讨论，那么数据库索引是什么样的？聚集索引与非聚集索引有什么不同？希望本文对各位同仁有一定的帮助。有不少存疑的地方，诚心希望各位不吝赐教指正，共同进步。[最近首页之争沸沸扬扬，也不知道这个放在这合适么，苦劳？功劳？……]</p><p> <strong>二、</strong> <strong>B-Tree</strong></p><p>我们常见的数据库系统，其索引使用的数据结构多是B-Tree或者B+Tree。例如，MsSql使用的是B+Tree，Oracle及Sysbase使用的是B-Tree。所以在最开始，简单地介绍一下B-Tree。</p><p>B-Tree不同于Binary Tree（二叉树，最多有两个子树），一棵M阶的B-Tree满足以下条件：<br>1）每个结点至多有M个孩子；<br>2）除根结点和叶结点外，其它每个结点至少有M&#x2F;2个孩子；<br>3）根结点至少有两个孩子（除非该树仅包含一个结点）；<br>4）所有叶结点在同一层，叶结点不包含任何关键字信息；<br>5）有K个关键字的非叶结点恰好包含K+1个孩子；</p><p>另外，对于一个结点，其内部的关键字是从小到大排序的。以下是B-Tree（M&#x3D;4）的样例：</p><p> <img src="/assets/wpsC22B.tmp-20211222153838-2v6kwd8.jpg"></p><p>对于每个结点，主要包含一个关键字数组Key[]，一个指针数组（指向儿子）Son[]。在B-Tree内，查找的流程是：使用顺序查找（数组长度较短时）或折半查找方法查找Key[]数组，若找到关键字K，则返回该结点的地址及K在Key[]中的位置；否则，可确定K在某个Key[i]和Key[i+1]之间，则从Son[i]所指的子结点继续查找，直到在某结点中查找成功；或直至找到叶结点且叶结点中的查找仍不成功时，查找过程失败。</p><p>接着，我们使用以下图片演示如何生成B-Tree（M&#x3D;4，依次插入1~6）：<br>从图可见，当我们插入关键字4时，由于原结点已经满了，故进行分裂，基本按一半的原则进行分裂，然后取出中间的关键字2，升级（这里是成为根结点）。其它的依类推，就是这样一个大概的过程。</p><p> <img src="/assets/wpsC22C.tmp-20211222153838-ib1g6d3.jpg"></p><p><strong>三、数据库索引</strong></p><p> <strong>1</strong> <strong>．什么是索引</strong></p><p>在数据库中，索引的含义与日常意义上的“索引”一词并无多大区别（想想小时候查字典），它是用于提高数据库表数据访问速度的数据库对象。<br>A）索引可以避免全表扫描。多数查询可以仅扫描少量索引页及数据页，而不是遍历所有数据页。<br>B）对于非聚集索引，有些查询甚至可以不访问数据页。<br>C）聚集索引可以避免数据插入操作集中于表的最后一个数据页。<br>D）一些情况下，索引还可用于避免排序操作。</p><p>当然，众所周知，虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要同时更新索引。</p><p> <strong>2.</strong> <strong>索引的存储</strong></p><p>一条索引记录中包含的基本信息包括：键值（即你定义索引时指定的所有字段的值）+逻辑指针（指向数据页或者另一索引页）。</p><p> <img src="/assets/wpsC22D.tmp-20211222153838-d0fj2jo.jpg"></p><p>当你为一张空表创建索引时，数据库系统将为你分配一个索引页，该索引页在你插入数据前一直是空的。此页此时既是根结点，也是叶结点。每当你往表中插入一行数据，数据库系统即向此根结点中插入一行索引记录。当根结点满时，数据库系统大抵按以下步骤进行分裂：<br>A）创建两个儿子结点<br>B）将原根结点中的数据近似地拆成两半，分别写入新的两个儿子结点<br>C）根结点中加上指向两个儿子结点的指针</p><p>通常状况下，由于索引记录仅包含索引字段值（以及4-9字节的指针），索引实体比真实的数据行要小许多，索引页相较数据页来说要密集许多。一个索引页可以存储数量更多的索引记录，这意味着在索引中查找时在I&#x2F;O上占很大的优势，理解这一点有助于从本质上了解使用索引的优势。</p><p> <strong>3</strong> <strong>．索引的类型</strong></p><p>A）聚集索引，表数据按照索引的顺序来存储的。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。<br>B）非聚集索引，表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致。</p><p>在一张表上只能创建一个聚集索引，因为真实数据的物理顺序只可能是一种。如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加的表的末尾位置。</p><p> <strong>4</strong> <strong>．聚集索引</strong></p><p>在聚集索引中，叶结点也即数据结点，所有数据行的存储顺序与索引的存储顺序一致。</p><p> <img src="/assets/wpsC22E.tmp-20211222153838-ulh98xw.jpg"></p><p>1）聚集索引与查询操作</p><p>如上图，我们在名字字段上建立聚集索引，当需要在根据此字段查找特定的记录时，数据库系统会根据特定的系统表查找的此索引的根，然后根据指针查找下一个，直到找到。例如我们要查询“Green”，由于它介于[Bennet,Karsen]，据此我们找到了索引页1007，在该页中“Green”介于[Greane, Hunter]间，据此我们找到叶结点1133（也即数据结点），并最终在此页中找以了目标数据行。</p><p>此次查询的IO包括3个索引页的查询（其中最后一次实际上是在数据页中查询）。这里的查找可能是从磁盘读取(Physical Read)或是从缓存中读取(Logical Read)，如果此表访问频率较高，那么索引树中较高层的索引很可能在缓存中被找到。所以真正的IO可能小于上面的情况。</p><p>2）聚集索引与插入操作</p><p>最简单的情况下，插入操作根据索引找到对应的数据页，然后通过挪动已有的记录为新数据腾出空间，最后插入数据。</p><p>如果数据页已满，则需要拆分数据页（页拆分是一种耗费资源的操作，一般数据库系统中会有相应的机制要尽量减少页拆分的次数，通常是通过为每页预留空间来实现）：<br>A）在该使用的数据段（extent）上分配新的数据页，如果数据段已满，则需要分配新段。<br>B）调整索引指针，这需要将相应的索引页读入内存并加锁。<br>C）大约有一半的数据行被归入新的数据页中。<br>D）如果表还有非聚集索引，则需要更新这些索引指向新的数据页。</p><p>特殊情况：<br>A）如果新插入的一条记录包含很大的数据，可能会分配两个新数据页，其中之一用来存储新记录，另一存储从原页中拆分出来的数据。<br>B）通常数据库系统中会将重复的数据记录存储于相同的页中。<br>C）类似于自增列为聚集索引的，数据库系统可能并不拆分数据页，页只是简单的新添数据页。</p><p>3）聚集索引与删除操作</p><p>删除行将导致其下方的数据行向上移动以填充删除记录造成的空白。</p><p>如果删除的行是该数据页中的最后一行，那么该数据页将被回收，相应的索引页中的记录将被删除。如果回收的数据页位于跟该表的其它数据页相同的段上，那么它可能在随后的时间内被利用。如果该数据页是该段的唯一一个数据页，则该段也被回收。</p><p>对于数据的删除操作，可能导致索引页中仅有一条记录，这时，该记录可能会被移至邻近的索引页中，原索引页将被回收，即所谓的“索引合并”。</p><p> <strong>5</strong> <strong>．非聚集索引</strong></p><p>非聚集索引与聚集索引相比：<br>A）叶子结点并非数据结点<br>B）叶子结点为每一真正的数据行存储一个“键-指针”对<br>C）叶子结点中还存储了一个指针偏移量，根据页指针及指针偏移量可以定位到具体的数据行。<br>D）类似的，在除叶结点外的其它索引结点，存储的也是类似的内容，只不过它是指向下一级的索引页的。</p><p>聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。</p><p>对于根与中间级的索引记录，它的结构包括：<br>A）索引字段值<br>B）RowId（即对应数据页的页指针+指针偏移量）。在高层的索引页中包含RowId是为了当索引允许重复值时，当更改数据时精确定位数据行。<br>C）下一级索引页的指针</p><p>对于叶子层的索引对象，它的结构包括：<br>A）索引字段值<br>B）RowId</p><p> <img src="/assets/wpsC23F.tmp-20211222153838-ccyibjj.jpg"></p><p>1）非聚集索引与查询操作</p><p>针对上图，如果我们同样查找“Green”，那么一次查询操作将包含以下IO：3个索引页的读取+1个数据页的读取。同样，由于缓存的关系，真实的IO实际可能要小于上面列出的。</p><p>2）非聚集索引与插入操作</p><p>如果一张表包含一个非聚集索引但没有聚集索引，则新的数据将被插入到最末一个数据页中，然后非聚集索引将被更新。如果也包含聚集索引，该聚集索引将被用于查找新行将要处于什么位置，随后，聚集索引、以及非聚集索引将被更新。</p><p>3）非聚集索引与删除操作</p><p>如果在删除命令的Where子句中包含的列上，建有非聚集索引，那么该非聚集索引将被用于查找数据行的位置，数据删除之后，位于索引叶子上的对应记录也将被删除。如果该表上有其它非聚集索引，则它们叶子结点上的相应数据也要删除。</p><p>如果删除的数据是该数所页中的唯一一条，则该页也被回收，同时需要更新各个索引树上的指针。</p><p>由于没有自动的合并功能，如果应用程序中有频繁的随机删除操作，最后可能导致表包含多个数据页，但每个页中只有少量数据。</p><p> <strong>6</strong> <strong>．索引覆盖</strong></p><p>索引覆盖是这样一种索引策略：当某一查询中包含的所需字段皆包含于一个索引中，此时索引将大大提高查询性能。</p><p>包含多个字段的索引，称为复合索引。索引最多可以包含31个字段，索引记录最大长度为600B。如果你在若干个字段上创建了一个复合的非聚集索引，且你的查询中所需Select字段及Where,Order By,Group By,Having子句中所涉及的字段都包含在索引中，则只搜索索引页即可满足查询，而不需要访问数据页。由于非聚集索引的叶结点包含所有数据行中的索引列值，使用这些结点即可返回真正的数据，这种情况称之为“索引覆盖”。</p><p>在索引覆盖的情况下，包含两种索引扫描：<br>A）匹配索引扫描<br>B）非匹配索引扫描</p><p>1）匹配索引扫描</p><p>此类索引扫描可以让我们省去访问数据页的步骤，当查询仅返回一行数据时，性能提高是有限的，但在范围查询的情况下，性能提高将随结果集数量的增长而增长。</p><p>针对此类扫描，索引必须包含查询中涉及的的所有字段，另外，还需要满足：Where子句中包含索引中的“引导列”（Leading Column），例如一个复合索引包含A,B,C,D四列，则A为“引导列”。如果Where子句中所包含列是BCD或者BD等情况，则只能使用非匹配索引扫描。</p><p>2）非配置索引扫描</p><p>正如上述，如果Where子句中不包含索引的导引列，那么将使用非配置索引扫描。这最终导致扫描索引树上的所有叶子结点，当然，它的性能通常仍强于扫描所有的数据页。</p><p> <strong>[</strong>  <strong>参考</strong> <strong>]</strong><br>[1]<a href="http://manuals.sybase.com/onlinebooks/group-asarc/asg1200e/aseperf/@Generic__BookTextView/3358">http:&#x2F;&#x2F;manuals.sybase.com&#x2F;onlinebooks&#x2F;group-asarc&#x2F;asg1200e&#x2F;aseperf&#x2F;@Generic__BookTextView&#x2F;3358</a><br>[2] <a href="http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.adref.doc/adref235.htm">http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.adref.doc/adref235.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 索引文献 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/09_%E7%A3%81%E7%9B%98/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/09_%E7%A3%81%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>硬盘基础知识</p><ol><li><p><img src="/assets/image-20211214105741-2bd570s.png" alt="image.png"><img src="/assets/image-20211214110050-dyzj8it.png" alt="image.png"><img src="/assets/image-20211214110131-aoec4ll.png" alt="image.png"><img src="/assets/image-20211214110109-jox8ouv.png" alt="image.png"></p></li><li><p>磁盘读响应时间</p><ol><li><img src="/assets/image-20211214110347-bnejtrz.png" alt="image.png"></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 磁盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主键</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/06_%E4%B8%BB%E9%94%AE/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/06_%E4%B8%BB%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<ul><li><p>数据的完整性</p><ul><li>数据的完整性指存储在数据库中的数据应该保持准确性和可靠性。</li><li>如出现学号相同的数据就是不准确的</li></ul></li><li><p>实体完整性</p><ul><li>实体完整性是对关系中的记录唯一性</li><li>定义表中的多有行能唯一的标识</li><li>表中主属性（字段）不能为Null且不能有相同值</li><li>一般用主键、唯一索引、unique关键字来实现</li><li>目的：在表中至少有一个唯一的标识，主属性字段中，不能为空，不能重复</li></ul></li><li><p>实体完整性–主键约束</p><ul><li><p>主键约束</p><ul><li>主关键字（primary key）是表中一个或者多个字段，它的值用于唯一地标识表中某一条记录</li><li>唯一，不重复，不能为空， primary key</li><li><ol><li><p>创建表的铜焊丝创建主键约束</p></li><li><p><img src="/assets/image-20220301110120-f1jylt6.png" alt="image.png"></p><p> a. CREATE  TABLE t_user（user_id INT（10） PRIMARY KEY）;</p><p> b. CREATE TABLE  t-user(user_id(user_id INT(10),user_name varchar(30),consttaint pk_id_name primary key(user_id,user_name));</p><p> c. CREATE TABLE t_user(user_id INT(10),PRIMARY KEY(USER_ID));</p></li><li><p>针对已存在的表，添加主键约束</p><ol><li>ALTER TABLE t_user MODIFY user_id INT(10) PRIMARY KEY;</li><li>ALTER TABLE t_user ADD  PRIMARY KEY(user_id);</li><li>ALTER TABLE t_user ADD  CONSTRAINT PK_ID PRIMARY KEY(user_id);</li></ol></li><li><p>删除主键约束</p><ol><li>ALTER TABLE t_user DROP PRIMARY KEY;</li></ol></li></ol></li></ul></li><li><p>唯一约束</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 主键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>explain详解</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/07_explain%E8%AF%A6%E8%A7%A3/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/07_explain%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p><pre><code>-- 实际SQL，查找用户名为Jefabc的员工select * from emp where name = &#39;Jefabc&#39;;-- 查看SQL是否使用索引，前面加上explain即可explain select * from emp where name = &#39;Jefabc&#39;;</code></pre><p><img src="https://images2018.cnblogs.com/blog/512541/201808/512541-20180803142201303-545775900.png"></p><p>expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</p><p><strong>概要描述：</strong><br>id:选择标识符<br>select_type:表示查询的类型。<br>table:输出结果集的表<br>partitions:匹配的分区<br>type:表示表的连接类型<br>possible_keys:表示查询时，可能使用的索引<br>key:表示实际使用的索引<br>key_len:索引字段的长度<br>ref:列与索引的比较<br>rows:扫描出的行数(估算的行数)<br>filtered:按表条件过滤的行百分比<br>Extra:执行情况的描述和说明</p><p><strong>下面对这些字段出现的可能进行解释：</strong></p><p>一、 <strong>id</strong></p><p>SELECT识别符。这是SELECT的查询序列号</p><p><strong>我的理解是SQL执行的顺序的标识，SQL从大到小的执行</strong></p><ol><li>id相同时，执行顺序由上至下</li><li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li></ol><pre><code>-- 查看在研发部并且名字以Jef开头的员工，经典查询explain select e.no, e.name from emp e left join dept d on e.dept_no = d.no where e.name like &#39;Jef%&#39; and d.name = &#39;研发部&#39;;</code></pre><p><img src="https://images2018.cnblogs.com/blog/512541/201808/512541-20180803143413064-173136748.png"></p><p><strong>二、select_type</strong></p><p>**      <strong>示查询中每个select子句的类型</strong>**</p><p>(1) SIMPLE(简单SELECT，不使用UNION或子查询等)</p><p>(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p><p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p><p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p><p>(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p><p>(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p><p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p><p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p><p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p><p><strong>三、table</strong></p><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p><p><strong>四、type</strong></p><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p><p>常用的类型有： ** ALL、index、range、 ref、eq_ref、const、system、** <strong>NULL（从左到右，性能从差到好）</strong></p><p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p><p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p><p>range:只检索给定范围的行，使用一个索引来选择行</p><p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p><p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p><p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p><p><strong>五、possible_keys</strong></p><p><strong>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</strong></p><p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p><p><strong>六、Key</strong></p><p><strong>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</strong></p><p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p><p><strong>七、key_len</strong></p><p><strong>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</strong></p><p>不损失精确性的情况下，长度越短越好** **</p><p><strong>八、ref</strong></p><p><strong>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</strong></p><p><strong>九、rows</strong></p><p> <strong>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</strong></p><p><strong>十、Extra</strong></p><p><strong>该列包含MySQL解决查询的详细信息,有以下几种情况：</strong></p><p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p><p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p><p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p><pre><code>-- 测试Extra的filesortexplain select * from emp order by name;</code></pre><p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p><p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p><p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p><p>No tables used：Query语句中使用from dual 或不含任何from子句</p><pre><code>-- explain select now() from dual;</code></pre><p><strong>总结</strong>:<br><em>• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况<br>• EXPLAIN不考虑各种Cache<br>• EXPLAIN不能显示MySQL在执行查询时所作的优化工作<br>• 部分统计信息是估算的，并非精确值<br>• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</em></p><p>通过收集统计信息不可能存在结果</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> explain详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/05_%E7%B4%A2%E5%BC%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/05_%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<ol><li><p>索引底层原理</p><ol><li><p>语句：</p><ol><li><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/07_explain%E8%AF%A6%E8%A7%A3/">explain详解</a></li><li>explain +sql语句   查看读取数据的信息</li></ol></li><li><p>什么是索引</p><ol><li><a href="https://www.tutorialspoint.com/mysql/mysql-indexes.htm">MySQL - INDEXES (tutorialspoint.com)</a></li><li>A database index is a data structure that improves the speed of operations in a table</li></ol></li><li><p>怎么创建索引</p><ol><li>数据库管理工具-添加</li><li>命令行添加：create index index_name  on tablename;</li></ol></li><li><p>为什么需要索引</p><ol><li>能够改善数据库的性能瓶颈问题，体现在服务端的磁盘IO的消耗</li><li>减少存储引擎需要扫描的数据量</li><li>减少使用临时表的概率</li><li>将随机的IO转换成为顺序的IO</li></ol></li><li><p>索引的类型有哪些</p><ol><li><p>从存储结构上划分： BTree索引、Hash索引、全文索引、空间索引</p><ol><li>使用最多的为BTree索引</li></ol></li><li><p>从应用层次来划分： 普通索引（单列索引、多列索引）、唯一索引（具有唯一性，允许为空值）、复合索引（组合索引，多个列建立一个索引）</p></li><li><p>从表记录的排列顺序是否与索引的排列顺序是否一致：聚集索引、非聚集索引</p></li></ol></li><li><p>索引是怎么工作的</p><ol><li><p>内存、 <a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/09_%E7%A3%81%E7%9B%98/">磁盘</a></p><ol><li><p>磁盘：硬盘、软盘– 保存数据信息的一个载体</p></li><li><p>读取磁盘IO 的时间：寻道时间（3-15ms，主流：5ms）+旋转延迟（1&#x2F;（7200&#x2F;60）&#x2F;2 &#x3D;4.17ms）+传输时间（0.n ms，忽略不计） &#x3D; 9ms</p></li><li><p>2.4GHZ:5亿条指令&#x2F;秒</p></li><li><p>解决磁盘IO消耗：</p><ol><li><p>系统自带的处理方式（按页读取-4kb，8kb，局部性原理）</p></li><li><p>降低了磁盘IO消耗的数量级：mysql存储引擎：innodb，  索引：B+Tree     eg： 传统查询无索引：逐条遍历</p><ol><li><img src="/assets/image-20211222164141-65arjxu.png" alt="image.png"></li></ol></li><li><p>B+tree  校验网址：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p></li><li><p>查看表的索引情况</p><ol><li>show  index from  表名</li><li>其他： reset  query  cache</li></ol></li></ol></li></ol></li></ol></li></ol></li></ol><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/08_%E7%B4%A2%E5%BC%95%E6%96%87%E7%8C%AE/">索引文献</a></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 索引 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库其他连接工具</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/04_%E5%85%B6%E4%BB%96%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/04_%E5%85%B6%E4%BB%96%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<pre><code>   工欲善其事，必先利其器。开发者在开发一个项目时，必定要选择一款合适的数据库，而数据库管理工具则可以帮助开发者轻松搞定很多难题。   任何Web软件和应用程序都需要强大的数据库来做后盾，目前，网上有无数个数据库管理工具，而开发者选择一款适合自己的尤为重要。为大家介绍10款免费的数据库管理工具，开发者可以使用它们进行SQL操作、多链接、多数据库引擎操作等等。</code></pre><ol><li>Open KeyVal<br> Open KeyVal是一款开源免费的键值数据库管理工具，基于Web，并且基于PHP开发，其目标是用最简单的方法来管理Web应用程序数据。用户只需发送一个POST请求就可以存储任何类型的数据，它是以JSON的格式来响应请求的。</li><li>DBV<br> DBV顾名思义，是数据库版本管理工具，基于PHP开发。用户在安装后，它可以自动跟踪记录，并且用户还可以把这些记录以SQL文件的形式导出。MySQL数据库默认情况下自动支持DBV，并且允许多用户连接。</li><li>DBeaver<br> DBeaver是一个通用的数据库管理工具和SQL客户端，支持MySQL、PostgreSQL、Oracle、DB2、MSSQL、Sybase、Mimer、HSQLDB、Derby以及其他兼容JDBC的数据库。基于Java开发。DBeaver提供一个图形界面用来查看数据库结构、执行SQL查询和脚本，浏览和导出数据，处理BLOB&#x2F;CLOB 数据，修改数据库结构等等。</li><li>DBNinja<br> DBNinja是一款基于Web的MySQL数据库管理工具，使用PHP开发，类似桌面应用的接口，可连接多个远程和本地的数据库。它支持所有的新功能包括：触发、事件、视图、存储程序和外键。</li><li>MyWebSQL<br> MyWebSql是一个基于Web的MySQL数据库管理客户端，支持多种语言。它除了操作表格数据外，MyWebSql 还可以对包括视图，存储过程，触发器和函数在内的对象进行控制。支持数据和查询结果的导入导出。MyWebSql还内置一个带语法着色功能的SQL编辑器。</li><li>Genghis<br> Genghis自称是单文件的MongoDB管理应用程序，它可以高效地管理多个数据库、甚至可以帮助用户收集、管理数据库和文档的服务器。</li><li>MyDB Studio<br> MyDB Studio是一个免费的MySQL数据库管理程序，它几乎拥有你所期望的所有功能特性。它可以同时连接没有数量限制的任意多的数据库。如果这些数据库位于防火墙后面或他们是本地数据库，该工具也提供SSH通道访问的支持来解决这些问题。</li><li>HeidiSQL<br> HeidiSQL是一款基于Windows的数据库管理软件，意味着它可以管理Microsoft SQL数据库和MySQL。它的功能非常强大，它可以浏览和编辑数据，创建和编辑表格、视图、存储过程、触发器和安排日程。另外，还可以导出结构和数据SQL文件。<br> 它是德国程序员Ansgar Becker和几个Delphi程序员开发的一个开源工具。要通过HeidiSQL来管理数据库，用户应该用有效地凭证登陆到MySQL服务器，创建一个会话。HeidiSQL最大的特色就是操作方便，界面设计合理，功能都是最实用的，尤其适合DBA，它更加强调了对MySQL运行时的参数设置和性能监控等。</li><li>SQLite Manager<br> SQLite Manager是开源的SQLite管理工具，用来管理本地电脑上的SQLite数据库，可以独立运行（以XULRunner方式），也可以作为Firefox、Thunderbird、Seamonkey、Songbird、Komodo、Gecko等的插件运行。</li><li>Sequel.js<br> Sequel.js是一个轻量级JavaScript库，使用它可以轻松进行SQL查询，它既可以在浏览器上运行，也可以在所有标准的SQL查询上运行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 数据库其他连接工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库语句优化</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/03_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/03_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在MySQL数据库怎么加快查询速度，优化查询效率，主要原则就是应尽量避免全表扫描，应该考虑在where及order by 涉及的列上建立索引。</p><p>　　建立索引不是建的越多越好，原则是：</p><p>　　第一：一个表的索引不是越多越好，也没有一个具体的数字，根据以往的经验，一个表的索引最多不能超过6个，因为索引越多，对update和insert操作也会有性能的影响，涉及到索引的新建和重建操作。</p><p>　　第二：建立索引的方法论为：</p><p>　　多数查询经常使用的列；<br>　　很少进行修改操作的列；<br>　　索引需要建立在数据差异化大的列上<br>　　利用以上的基础我们讨论一下如何优化sql.</p><p>1、MySQY语句模型结构优化指导</p><p>　　　　a. ORDER BY + LIMIT组合的索引优化</p><p>　　　　　　如果一个SQL语句形如：SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort] LIMIT [offset],[LIMIT];</p><p>　　　　　　这个SQL语句优化比较简单，在[sort]这个栏位上建立索引即可。</p><p>　　　　b. WHERE + ORDER BY + LIMIT组合的索引优化</p><p>　　　　　　如果一个SQL语句形如：SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] &#x3D; [VALUE] ORDER BY [sort] LIMIT [offset],[LIMIT];</p><p>　　　　　　这个语句，如果你仍然采用第一个例子中建立索引的方法，虽然可以用到索引，但是效率不高。更高效的方法是建立一个联合索引(columnX,sort)</p><p>　　　　c. WHERE+ORDER BY多个栏位+LIMIT</p><p>　　　　　　 如果一个SQL语句形如：SELECT * FROM [table] WHERE uid&#x3D;1 ORDER x,y LIMIT 0,10;</p><p>　　　　　　 对于这个语句，大家可能是加一个这样的索引:(x,y,uid)。但实际上更好的效果是(uid,x,y)。这是由MySQL处理排序的机制造成的。</p><p>　　2、复合索引(形如(x,y,uid)索引的索引)</p><p>　　　　先看这样一条语句这样的：select* from users where area &#x3D;’beijing’ and age&#x3D;22;</p><p>　　 　 如果我们是在area和age上分别创建索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果area，age两列上创建复合索引的话将带来更高的效率。</p><pre><code>　　  在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</code></pre><p>　　　 例如我们建立了一个这样的索引（area,age,salary），那么其实相当于创建了（area,age,salary）,(area,age),(area)三个索引，这样称为最佳左前缀特性。</p><p>　　3、like语句优化</p><p>　　　　SELECT id FROM A WHERE name like ‘%abc%’<br> 　　　　　　由于abc前面用了“%”，因此该查询必然走全表查询，除非必要，否则不要在关键词前加%，优化成如下</p><p>　　　　SELECT id FROM A WHERE name like ‘abc%’<br> 　　4、where子句使用 ！&#x3D; 或 &lt;&gt; 操作符优化</p><p>　　　　　在where子句中使用 ！&#x3D; 或 &lt;&gt;操作符，索引将被放弃使用，会进行全表查询。</p><p> 　　　　如SQL:SELECT id FROM A WHERE ID !&#x3D; 5 优化成：SELECT id FROM A WHERE ID&gt;5 OR ID&lt;5</p><p>　　5、where子句中使用 IS NULL 或 IS NOT NULL 的优化</p><p>　　　　在where子句中使用 IS NULL 或 IS NOT NULL 判断，索引将被放弃使用，会进行全表查询。</p><p>　　 　　如SQL:SELECT id FROM A WHERE num IS NULL 优化成num上设置默认值0，确保表中num没有null值，然后SQL为：SELECT id FROM A WHERE num&#x3D;0</p><p>　　6、where子句使用or的优化</p><p>　　　　很多时候使用union all 或 nuin(必要的时候)的方式替换“or”会得到更好的效果。where子句中使用了or,索引将被放弃使用。</p><p>　　 　　如SQL:SELECT id FROM A WHERE num &#x3D;10 or num &#x3D; 20 优化成：SELECT id FROM A WHERE num &#x3D; 10 union all SELECT id FROM A WHERE num&#x3D;20</p><p>　　7、where子句使用IN 或 NOT IN的优化</p><p>　　　　in和not in 也要慎用，否则也会导致全表扫描。</p><p>　　 　　方案一：between替换in</p><p>　　 　　　　如SQL:SELECT id FROM A WHERE num in(1,2,3) 优化成：SELECT id FROM A WHERE num between 1 and 3</p><p>　　 　　方案二：exist替换in</p><p>　　 　　　　如SQL:SELECT id FROM A WHERE num in(select num from b ) 优化成：SELECT num FROM A WHERE num exists(select 1 from B where B.num &#x3D; A.num)</p><p>　　 　　方案三：left join替换in</p><p>　　　　　　如SQL:SELECT id FROM A WHERE num in(select num from B) 优化成：SELECT id FROM A LEFT JOIN B ON A.num &#x3D; B.num</p><p>　　8、where子句中对字段进行表达式操作的优化</p><p>　　　　不要在where子句中的“&#x3D;”左边进行函数、算数运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>　　 　　如SQL:SELECT id FROM A WHERE num&#x2F;2 &#x3D; 100 优化成：SELECT id FROM A WHERE num &#x3D; 100*2</p><p>　　 　　如SQL:SELECT id FROM A WHERE datediff(day,createdate,’2016-11-30’)&#x3D;0 优化成：SELECT id FROM A WHERE createdate&gt;&#x3D;’2016-11-30’ and createdate&lt;’2016-12-1’</p><p>　　 　　如SQL:SELECT id FROM A WHERE year(addate) &lt;2016 优化成：SELECT id FROM A where addate&lt;’2016-01-01’</p><p>　　9、任何地方都不要用 select * from table ，用具体的字段列表替换”*”，不要返回用不到的字段　　</p><p>　　10、使用“临时表”暂存中间结果</p><p>　　　　采用临时表暂存中间结果好处：</p><p>　　　　　　（1）避免程序中多次扫描主表，减少程序执行“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p><p>　　　　　　（2）尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>　　　　　　（3）避免频繁创建和删除临时表，以减少系统资源的浪费。</p><p>　　　　　　（4）尽量避免向客户端返回大数据量，若数据量过大，应考虑相应需求是否合理。</p><p>　　11、limit分页优化</p><p>　　　　　　总数据有500万左右，以下例子</p><p>   　　　　　　select * from wl_tagindex where byname&#x3D;’f’ order by id limit 300000,10 执行时间是 3.21s</p><p>　　　　　　优化后：</p><p>　　　　　　　　select * from (</p><p>   　　　　　　　　　　select id from wl_tagindex</p><p>　　　　　　　　　　where byname&#x3D;’f’ order by id limit 300000,10</p><p>　　　　　　　　) a</p><p>　　　　　　　　left join wl_tagindex b on a.id&#x3D;b.id</p><p>   　　　　　　执行时间为 0.11s 速度明显提升</p><p>   　　　　　　这里需要说明的是 我这里用到的字段是 byname ,id 需要把这两个字段做复合索引，否则的话效果提升不明显</p><p>　　12、批量插入优化</p><p>　　　　　　INSERT into person(name,age) values(‘A’,14)<br>　　　　　　INSERT into person(name,age) values(‘B’,14)<br>　　　　　　INSERT into person(name,age) values(‘C’,14)<br>　　　　可优化为：</p><p>　　　　　　INSERT into person(name,age) values(‘A’,14),(‘B’,14),(‘C’,14),<br>　　13、利用limit 1 、top 1 取得一行，<br>　　　　但是需要注意的是，Top关键字只能在SQL Server数据库中可以使用，而在MySQL数据库中就要使用具有同样功能的LIMIT函数</p><p>　　　　有时要查询一张表时，你知道只需要看一条记录，你可能去查询一条特殊的记录。可以使用limit 1 或者 top 1 来终止数据库索引继续扫描整个表或索引。</p><p>　　　　如SQL：SELECT id FROM A LIKE ‘abc%’ 优化为：SELECT id FROM A LIKE ‘abc%’ limit 1</p><p>　　14、尽量不要使用 BY RAND()命令</p><p>　　　　BY RAND()是随机显示结果，这个函数可能会为表中每一个独立的行执行BY RAND()命令，这个会消耗处理器的处理能力。</p><p>　　　　如SQL：SELECT * FROM A order by rand() limit 10 优化为：SELECT * FROM A WHERE id &gt;&#x3D; ((SELECT MAX(id) FROM A)-(SELECT MIN(id) FROM A)) * RAND() + (SELECT MIN(id) FROM A) LIMIT 10</p><p>　　15、排序的索引问题　</p><p>　　 　Mysql查询只是用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求情况下不要使用排序操作；</p><p>　　　尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><p>　　16、尽量用 union all 替换 union</p><p>　　　union和union all的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的cpu运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用union all而不是union</p><p>　　17、避免类型转换</p><p>　　　这里所说的“类型转换”是指where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换。人为的上通过转换函数进行转换，直接导致mysql无法使用索引。如果非要转型，应该在传入参数上进行转换。</p><pre><code>   　例如utime 是datetime类型，传入的参数是“2016-07-23”，在比较大小时通常是 date（utime）&gt;&quot;2016-07-23&quot;,可以优化为utime&gt;&quot;2016-07-23 00：00：00&quot;</code></pre><p>　　18、尽可能使用更小的字段　　　　　　 　　</p><p>　　　　MySQL从磁盘读取数据后是存储到内存中的，然后使用cpu周期和磁盘I&#x2F;O读取它，这意味着越小的数据类型占用的空间越小，从磁盘读或打包到内存的效率都更好，但也不要太过执着减小数据类型，要是以后应用程序发生什么变化就没有空间了。</p><p>　　　　修改表将需要重构，间接地可能引起代码的改变，这是很头疼的问题，因此需要找到一个平衡点。</p><p>　　19、Inner join 和 left join、right join、子查询</p><p>　　第一：inner join内连接也叫等值连接是，left&#x2F;rightjoin是外连接。</p><p>　　　　 SELECT A.id,A.name,B.id,B.name FROM A LEFT JOIN B ON A.id &#x3D;B.id;</p><p>　　　　 SELECT A.id,A.name,B.id,B.name FROM A RIGHT JOIN ON B A.id&#x3D; B.id;</p><p>　　　　 SELECT A.id,A.name,B.id,B.name FROM A INNER JOIN ON A.id &#x3D;B.id;</p><p>　　 　　经过来之多方面的证实inner join性能比较快，因为inner join是等值连接，或许返回的行数比较少。但是我们要记得有些语句隐形的用到了等值连接，如：</p><p>　　　　SELECT A.id,A.name,B.id,B.name FROM A,B WHERE A.id &#x3D; B.id;</p><p>　　　　推荐：能用inner join连接尽量使用inner join连接</p><p>　　 第二：子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。</p><p>　　　　Select* from A where exists (select * from B where id&gt;&#x3D;3000 and A.uuid&#x3D;B.uuid);</p><p>　　　　A表的数据为十万级表，B表为百万级表，在本机执行差不多用2秒左右，我们可以通过explain可以查看到子查询是一个相关子查询(DEPENDENCE SUBQUERY);Mysql是先对外表A执行全表查询，然后根据uuid逐次执行子查询，如果外层表是一个很大的表，我们可以想象查询性能会表现比这个更加糟糕。</p><pre><code>  　　一种简单的优化就是用innerjoin的方法来代替子查询，查询语句改为：</code></pre><p>  　　　Select* from A inner join B ON A.uuid&#x3D;B.uuid using(uuid) where b.uuid&gt;&#x3D;3000;  这个语句执行测试不到一秒；</p><p>　　第三：使用JOIN时候，应该用小的结果驱动打的结果（left join 左边表结果尽量小，如果有条件应该放到左边先处理，right join同理反向），同时尽量把牵涉到多表联合的查询拆分多个query (多个表查询效率低，容易锁表和阻塞)。如：</p><p>　　Select * from A left join B A.id&#x3D;B.ref_id where  A.id&gt;10;可以优化为：select * from (select * from A wehre id &gt;10) T1 left join B on T1.id&#x3D;B.ref_id;</p><p>　　20、exist 代替 in</p><p>SELECT * from A WHERE idin (SELECT id from B)<br>SELECT * from A WHERE id EXISTS(SELECT 1 from A.id&#x3D; B.id)<br>　　in 是在内存中遍历比较</p><p>　　exist 需要查询数据库，所以当B的数据量比较大时，exists效率优于in.</p><p>　　in()只执行一次，把B表中的所有id字段缓存起来，之后检查A表的id是否与B表中的id相等，如果id相等则将A表的记录加入到结果集中，直到遍历完A表的所有记录。</p><p>　　In 操作的流程原理如同一下代码</p><p>　　　　List resultSet&#x3D;{};<br>　　　　Array A&#x3D;(select * from A);<br>　　　　Array B&#x3D;(select id from B);<br>　　　　for(int i&#x3D;0;i&lt;A.length;i++) {<br>　　　　　　for(int j&#x3D;0;j&lt;B.length;j++) {<br>　　　　　　　　if(A[i].id&#x3D;&#x3D;B[j].id) {<br>　　　　　　　　　　resultSet.add(A[i]);<br>　　　　　　　　　　break;<br>　　　　　　　　}<br>　　　　　　}<br>　　　　}<br>　　　return resultSet;</p><p>　　可以看出，当B表数据较大时不适合使用in()，因为它会B表数据全部遍历一次</p><p>　　如：A表有10000条记录，B表有1000000条记录，那么最多有可能遍历10000*1000000次，效率很差。</p><p>　　再如：A表有10000条记录，B表有100条记录，那么最多有可能遍历10000*100次，遍历次数大大减少，效率大大提升。</p><p>　　结论：in()适合B表比A表数据小的情况</p><p>　　exist()会执行A.length()次，执行过程代码如下</p><p>　　　　List resultSet&#x3D;{};<br>　　　　Array A&#x3D;(select * from A);<br>　　　　for(int i&#x3D;0;i&lt;A.length;i++) {<br>　　　　　　if(exists(A[i].id) { &#x2F;&#x2F;执行select 1 from B where B.id&#x3D;A.id是否有记录返回<br>　　　　　　　　resultSet.add(A[i]);<br>　　　　　　}<br>　　　　}<br>　　　　return resultSet;</p><p>　　当B表比A表数据大时适合使用exists()，因为它没有那么多遍历操作，只需要再执行一次查询就行。</p><p>　　如：A表有10000条记录，B表有1000000条记录，那么exists()会执行10000次去判断A表中的id是否与B表中的id相等。</p><p>　　如：A表有10000条记录，B表有100000000条记录，那么exists()还是执行10000次，因为它只执行A.length次，可见B表数据越多，越适合exists()发挥效果。</p><p>　　再如：A表有10000条记录，B表有100条记录，那么exists()还是执行10000次，还不如使用in()遍历10000*100次，因为in()是在内存里遍历比较，而exists()需要查询数据库，</p><p>　　我们都知道查询数据库所消耗的性能更高，而内存比较很快。</p><p>　　结论：exists()适合B表比A表数据大的情况</p><p>　　 当A表数据与B表数据一样大时，in与exists效率差不多，可任选一个使用。</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 数据库语句优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础知识</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/01_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/01_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>查询语句的执行过程</p><p><img src="/assets/image-20211214111304-o4w9uqm.png" alt="image.png"></p><p>专业术语</p><p><img src="/assets/image-20211214111328-gt0i4os.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 数据库基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库命令行操作</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/02_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/02_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="查看服务器mysql服务有没有开启"><a href="#查看服务器mysql服务有没有开启" class="headerlink" title="查看服务器mysql服务有没有开启:"></a>查看服务器mysql服务有没有开启:</h3><p>ps -ef | grep mysql</p><p><img src="/assets/image-20211120233959-4dpkuvo.png" alt="image.png"></p><hr><h3 id="登录到MySQL"><a href="#登录到MySQL" class="headerlink" title="登录到MySQL:"></a><strong>登录到MySQL:</strong></h3><p>mysql -h 主机名 -u 用户名 -p</p><p>-h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略;<br>-u : 所要登录的用户名;<br>-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。</p><p><img src="/assets/image-20211120234007-btx7xmn.png" alt="image.png"></p><hr><h2 id="一-查看数据库、表、数据字段、数据"><a href="#一-查看数据库、表、数据字段、数据" class="headerlink" title="一 查看数据库、表、数据字段、数据"></a>一 查看数据库、表、数据字段、数据</h2><h3 id="查看当前所有的数据库："><a href="#查看当前所有的数据库：" class="headerlink" title="查看当前所有的数据库："></a>查看当前所有的数据库：</h3><pre><code>  show  databases；</code></pre><p><img src="/assets/image-20211120234015-huoyybn.png" alt="image.png"></p><hr><h3 id="选择（进入）-数据库："><a href="#选择（进入）-数据库：" class="headerlink" title="选择（进入） 数据库："></a>选择（进入） 数据库：</h3><pre><code> use   数据库名；</code></pre><p><img src="/assets/image-20211120234022-bbmujsd.png" alt="image.png"></p><hr><h3 id="查看当前数据库所有的表："><a href="#查看当前数据库所有的表：" class="headerlink" title="查看当前数据库所有的表："></a>查看当前数据库所有的表：</h3><pre><code>show tables；</code></pre><p><img src="/assets/image-20211120234028-ue71c2x.png" alt="image.png"></p><hr><h3 id="查看-某个表的字段结构-："><a href="#查看-某个表的字段结构-：" class="headerlink" title="查看 某个表的字段结构 ："></a>查看 某个表的字段结构 ：</h3><pre><code> desc  表名；</code></pre><p><img src="/assets/image-20211120234037-6qr8p92.png" alt="image.png"></p><hr><h3 id="查询表数据："><a href="#查询表数据：" class="headerlink" title="查询表数据："></a>查询表数据：</h3><pre><code> select * from  表名；</code></pre><p><img src="/assets/image-20211120234046-g3smurz.png" alt="image.png"></p><pre><code>    SELECT user_qq AS &#39;玩家QQ&#39;,user_name AS &#39;玩家昵称&#39;  FROM users    //显示中文别名    SELECT DISTINCT user_qq  FROM scores    //消除重复行    SELECT * FROM users LIMIT 2,3           //从下标为2的记录开始，显示3条数据（3-5条数据）</code></pre><hr><h2 id="二-新建数据库、数据表（表）、数据（添加数据）"><a href="#二-新建数据库、数据表（表）、数据（添加数据）" class="headerlink" title="二 新建数据库、数据表（表）、数据（添加数据）"></a>二 新建数据库、数据表（表）、数据（添加数据）</h2><h3 id="新建数据库："><a href="#新建数据库：" class="headerlink" title="新建数据库："></a>新建数据库：</h3><pre><code>create  database  数据库名；</code></pre><p><img src="/assets/image-20211120234057-lksi10b.png" alt="image.png"></p><hr><h3 id="新建表："><a href="#新建表：" class="headerlink" title="新建表："></a>新建表：</h3><pre><code>CREATE TABLE 表名 &lt;    字段名字   数据类型  修饰,    ... &gt;; </code></pre><p>注意至少要有一个字段 修饰与数据类型在这里不再详细说明 关键字大写 字段间用，隔开 最后一行不用</p><p><img src="/assets/image-20211120234057-lksi10b.png" alt="image.png"></p><hr><h3 id="添加数据："><a href="#添加数据：" class="headerlink" title="添加数据："></a>添加数据：</h3><pre><code>insert into 表名 valuse（值，值）；</code></pre><p><img src="/assets/image-20211120234114-73elez8.png" alt="image.png"></p><hr><h2 id="三-修改数据表，修改数据"><a href="#三-修改数据表，修改数据" class="headerlink" title="三 修改数据表，修改数据"></a>三 修改数据表，修改数据</h2><h3 id="修改数据表："><a href="#修改数据表：" class="headerlink" title="修改数据表："></a>修改数据表：</h3><pre><code>alter table 表名 add 字段名 类型 修饰【加的列在表的最后面】</code></pre><p><img src="/assets/image-20211120234120-uqqruem.png" alt="image.png"></p><pre><code>alter table 表名 add 字段名  类型 修饰 after 某列【把新列加在某列后面】</code></pre><p><img src="/assets/image-20211120234125-0wyw6yo.png" alt="image.png"></p><hr><h3 id="修改数据："><a href="#修改数据：" class="headerlink" title="修改数据："></a>修改数据：</h3><pre><code> update user set name=新值 where</code></pre><p><img src="/assets/image-20211120234131-u9lqob9.png" alt="image.png"></p><hr><h2 id="四-删除数据库，数据表，数据"><a href="#四-删除数据库，数据表，数据" class="headerlink" title="四 删除数据库，数据表，数据"></a>四 删除数据库，数据表，数据</h2><h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><pre><code>drop database 数据库名；</code></pre><p><img src="/assets/image-20211120234137-i3k1y62.png" alt="image.png"></p><hr><h3 id="删除数据表："><a href="#删除数据表：" class="headerlink" title="删除数据表："></a>删除数据表：</h3><pre><code> drop  table  表名;</code></pre><p><img src="/assets/image-20211120234143-v4gn8sk.png" alt="image.png"></p><hr><h3 id="删除列："><a href="#删除列：" class="headerlink" title="删除列："></a><strong>删除列：</strong></h3><pre><code>alter table 表名 drop 列名称;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/assets/image-20211120234151-ilexh3g.png" alt="image.png"></h3><hr><h3 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h3><pre><code> delete  from  表名 where；</code></pre><p><img src="/assets/image-20211120234158-ibmm67v.png" alt="image.png"></p><hr><h3 id="MySQL有三大类数据类型"><a href="#MySQL有三大类数据类型" class="headerlink" title="MySQL有三大类数据类型"></a>MySQL有三大类数据类型</h3><p>分别为 <strong>数字</strong> 、 <strong>日期\时间</strong> 、 <strong>字符串</strong> 。这三大类中又更细致的划分了许多子类型:</p><p><strong>整数:</strong> tinyint、smallint、mediumint、int、bigint<br>浮点数: float、double、real、decimal</p><p>日期和时间: date、time、datetime、timestamp、year</p><p>字符串: char、varchar<br><strong>文本:</strong> tinytext、text、mediumtext、longtext<br> <strong>二进制</strong> (可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob</p><hr><p><strong>End</strong></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 数据库命令行操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/01_%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/01_%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<ol><li><h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/01_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">数据库基础知识</a></h2></li><li><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><ol><li>数据库按时存放数据的仓库，只是以某种有组织存储方式储存数据的集合</li></ol></li><li><h2 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h2><ol><li><p>数据库分为关系型数据库和非关系型数据库</p><ol><li><p>关系型数据库：mysql、oracle、sqlserver、db2、past、gresql</p><ol><li>是数据库里面有存在一定的关系</li></ol></li><li><p>非关系型数据库：mogodb、redis、hbase、memchedb</p><ol><li>数据与数据之间没有任何关系，只有输入和输出</li></ol></li></ol></li></ol></li><li><h3 id="数据库命令行操作"><a href="#数据库命令行操作" class="headerlink" title="数据库命令行操作"></a><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/02_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/">数据库命令行操作</a></h3><ol><li><p>快捷键： win+r   输入  cmd       打开dos窗口</p><p> 登录数据库命令：mysql  -h 主机ip      -u 用户名   -p   回车— 输入密码    回车</p><p> 退出：mysql &gt;exit;         或    mysql &gt;quit;           或      mysql &gt;\q;</p><p> show databases; 查看所有数据库</p><p> use +数据库名    使用数据库</p><p> show  tables;  查看数据库中表的信息</p></li><li><p>基础的增删改查命令操作：</p><ol><li>增：insert  into 表名（列名） values（列名对应的值）</li><li>删：delete from 表名  where 列名 &#x3D; 对应列名的值</li><li>改：update  表名  set 修改的列名 &#x3D; 对应的值   where  列名 &#x3D; 对应列名的值</li><li>查：select  查询内容  from  表名   where 列名 &#x3D; 对应列名的值</li></ol></li></ol></li><li><h3 id="数据库连接工具"><a href="#数据库连接工具" class="headerlink" title="数据库连接工具"></a>数据库连接工具</h3><ol><li><p><a href="../../../../04_%E5%B7%A5%E5%85%B7/06_navicat/01_navicat%E5%AE%89%E8%A3%85/">navicat安装</a></p></li><li><p><a href="../../../../04_%E5%B7%A5%E5%85%B7/06_navicat/02_SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/">SQL语句练习</a></p><ol><li><p>增：inset  into 表名（列名） values（列名对应的值）</p></li><li><p>删：delete from 表名  where 列名 &#x3D; 对应列名的值</p></li><li><p>改：update  表名  set 修改的列名 &#x3D; 对应的值   where  列名 &#x3D; 对应列名的值</p></li><li><p>查：select  查询内容  from  表名   where 列名 &#x3D; 对应列名的值</p></li><li><p>运算符</p><ol><li>&lt;  小于号</li><li><blockquote><p>大于号</p></blockquote></li><li>&#x3D;  等于号</li><li>!&#x3D;   不等于</li><li>&lt;&gt;  不等于</li></ol></li><li><p>注释符</p><ol><li>–   +空格</li><li>井号</li><li>&#x2F;%      %&#x2F;</li></ol></li><li><p>精确查询：  条件用 &#x3D;</p></li><li><p>模糊查询：</p><ol><li>like   像</li><li>not  like    不像</li><li>%   代表一个或者多个字符</li><li>_   表示一个字符（占位符）</li></ol></li><li><p>同时查询两个条件：</p><ol><li>and   和&#x2F;且</li><li>or  或者</li><li>null  空的</li><li>distinct  去重</li><li>order by   排序   desc ：倒叙   asc  ：正序</li><li>group  by  分组</li><li>limit  n,m  n表示从n+1开始，m表示取值</li><li>between   and    在什么之间</li><li>not  between  and   不在什么之间</li><li>in  是什么的值</li><li>not  in   不是什么的值</li></ol></li><li><p>五大函数</p><ol><li>avg  平均值</li><li>max  最大值</li><li>min   最小值</li><li>sum   求和</li><li>count   统计</li></ol></li><li><p>嵌套</p><ol><li>SELECT  查询内容     FROM   表名      WHERE   列名  IN (SELECT  查询内容     FROM   表名      WHERE   列名 &#x3D; 对应列的值);</li></ol></li><li><p>多表联查</p><ol><li><p>SELECT 查询内容  FROM  表名1  JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</p></li><li><p>SELECT 查询内容  FROM  表名1  LEFT JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</p></li><li><p>SELECT 查询内容  FROM  表名1  RIGHT JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</p></li></ol></li><li><p>lianxi库:</p><ol><li>sql：<a href="assets/lianxi-20211206163641-2j5ye7z.sql">lianxi.sql</a></li><li>练习题</li></ol></li></ol></li><li><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/03_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/">数据库语句优化</a></p></li><li><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/04_%E5%85%B6%E4%BB%96%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7/">其他连接工具</a></p></li></ol></li><li><h2 id="mysql数据库的特点"><a href="#mysql数据库的特点" class="headerlink" title="mysql数据库的特点"></a>mysql数据库的特点</h2><ol><li>可以处理成千上万条记录的大型数据</li><li>支持常见的sql语句规范</li><li>可移植性高，安装简单小巧</li><li>良好的运行效率，丰富信息的网络支持</li><li>调试、管理、优化比较简单</li><li>开源免费，跨平台</li></ol></li><li><h2 id="索引与主键"><a href="#索引与主键" class="headerlink" title="索引与主键"></a>索引与主键</h2><ol><li><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/05_%E7%B4%A2%E5%BC%95/">索引</a></p><ol><li>优点： 加快查询速度<br> 特点：        1.大大加快数据的检查速度<br>           2.创建唯一性索引，保证数据库表中每行数据的唯一性<br>           3.加快了表与表之间的连接<br>           4.在使用分组和排序子句进行数据检查，可以明显减少查询中的分组和排序的时间<br> 缺点： 当对表进行新增，删除和修改的时候，索引也需要对修改的数据进行维护，降低了数据的维护速度</li></ol></li><li><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/06_%E4%B8%BB%E9%94%AE/">主键</a></p><ol><li><p>主关键字（primary key）是表中一个或者多个字段，它的值用于唯一标识表中某一条记录<br> 主键不能为空值，不可以重复，不可以修改</p><p> 主键不是必须的，在表中可以没有主键<br> 主键的特点：<br> 1.保证数据的完整性。<br> 2.加快数据的操作速度。<br> 3.在表中添加新纪录时，数据库会自动检查新纪录的主键，不允许更改值与其他记录的主键值重复<br> 4.数据库自动按照主键值得顺序显示记录，如果没有主键，则按照输入的记录顺序显示表中记录</p></li><li><p>外主键</p><ol><li>是主键的从属，表述了两个表之间的联系</li><li>作用：使用外键可以建立数据的关联，还可以避免冗余</li></ol></li></ol></li></ol></li><li><h4 id="oracle-mysql-SqlServer-的区别"><a href="#oracle-mysql-SqlServer-的区别" class="headerlink" title="oracle  mysql    SqlServer  的区别"></a>oracle  mysql    SqlServer  的区别</h4><ol><li>oracle 和 mysql 可以有命令登录   SqlServer 没有<br> oracle 属于大型数据库，而 mysql    SqlServer  属于中小型数据库<br />oracle 在增删改以后需要commit   而 mysql    SqlServer  不需要<br> oracle 支持并发大量访问  mysql    SqlServer   支持并发访问量没有oracle 大<br> oracle 安全性比 mysql    SqlServer  要高</li></ol></li><li><h4 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h4><ul><li>在sql中视图基于SQL语句的结果集的可视化类，视图包含行和列，就像一个真实的表，视图中的字段来源于数据库真实表的字段</li></ul></li><li><h2 id="什么时候查询数据库？"><a href="#什么时候查询数据库？" class="headerlink" title="什么时候查询数据库？"></a>什么时候查询数据库？</h2><ol><li>一般使用数据库时，我都需要数据库计算一些数据的百分比，查询一些数据库信息，还有我们小组人员要进行根性数据，方便以后的数据调用</li></ol></li><li><h2 id="表和视图的区别"><a href="#表和视图的区别" class="headerlink" title="表和视图的区别"></a>表和视图的区别</h2><ol><li>表是物理真实存在的，视图是虚拟的，表是真实的数据而视图不保存数据的</li></ol></li><li><h2 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h2><ol><li><p>定义</p><ol><li>MySQL 5.0 版本开始支持存储过程。</li><li>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</li><li>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</li><li>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</li></ol></li><li><p>优点</p><ol><li>重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</li><li>减少网络流量：存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</li><li>安全性：参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。</li></ol></li><li><p>缺点</p><ol><li>更改比较繁琐：如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则仍需要更新程序集中的代码以添加参数、更新 GetValue() 调用，等等，这时候估计比较繁琐。</li><li>可移植性差：由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如果应用程序的可移植性在您的环境中非常重要，则需要将业务逻辑封装在不特定于 RDBMS 的中间层中。</li></ol></li><li><p>操作</p><ol><li></li><li><p>定义存储过程（模板)</p><ol><li><p>DELIMITER&#x2F;&#x2F;</p></li><li><p>CREATE PROCEDURE 存储过程的名称()</p></li><li><p>BEGIN</p><p> –存储过程代码</p></li><li><p>END&#x2F;&#x2F;</p></li><li><p>DELIMITER;</p></li></ol></li><li><p>存储过程例子</p><p> DROP PROCEDURE  IF EXISTS get_maxsal()</p><p> DELIMITER&#x2F;&#x2F;</p><p> CREATE PROCEDURE get_maxsal()</p><pre><code> BEGIN      SELECT max(sal) from emp; END//</code></pre><p> CALL get_maxsal(); –调整存储过程</p></li><li><p>在存储过程中声明并使用变量</p><p> DROP PROCEDURE  IF EXISTS get_sal；</p><p> DELIMITER&#x2F;&#x2F;</p><p> CREATE PROCEDURE get_sal()</p><pre><code> BEGIN     DECLARE avgsal INT;     SELECT avg(sal) into avgsal  from   emp;     SELECT ename,sal FROM emp WHERE sal &gt; avgsal; END//</code></pre><p> CALL get_sal();</p></li><li><p>带参数的存储过程</p><ol><li><p>文字定义</p><ol><li>在MySQL中，参数有三种模式：IN, OUT,INOUT.</li><li>IN -是默认模式，在存储过程中定义IN参数时，调用存储过程时必须将参数传递给存储过程。另外IN参数的值被保护，也就是说IN参数的值在过程中不能被改变</li><li>OUT - 可以在存储过程中改变OUT 参数的值，并将其更改后的新值传递回调用程序。由于OUT 参数并没有被赋值，所有不能读取，只能复制</li><li>INOUT - INOUT参数是IN 和OUT 参数的组合，这意味着调用程序可以传递参数，并且存储过程可以修改INOUT参数并将心的值传递回调用程序。</li><li>语法：IN&#x2F;OUT&#x2F;INOUT  param_name param_type(param_size)</li></ol></li></ol><p> DROP PROCEDURE  IF EXISTS get_sal；</p><p> DELIMITER&#x2F;&#x2F;</p><p> CREATE PROCEDURE get_sal(IN empname VARTHAR(5),OUT  empsal INT)</p><pre><code> BEGIN     SELECT  sal INTO empsal  from emp WHERE ename = empname; END//</code></pre><p> – 在存储过程中定义的参数，会在mysql中自动生成一下划线命名的参数</p><p> CALL get_sal(‘BLAKE’,@_empsal);</p><p> SELECT @_empsal;</p></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令实操</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/02_linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%93%8D/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/02_linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<ol><li><p>find 基本语法参数如下：</p><ol><li><pre><code> find [PATH] [option] [action] # 与时间有关的参数： -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件； -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名； -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名； -newer file : 列出比file还要新的文件名 # 例如： find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件 # 与用户或用户组名有关的参数： -user name : 列出文件所有者为name的文件 -group name : 列出文件所属用户组为name的文件 -uid n : 列出文件所有者为用户ID为n的文件 -gid n : 列出文件所属用户组为用户组ID为n的文件 # 例如： find /home/hadoop -user hadoop # 在目录/home/hadoop中找出所有者为hadoop的文件 # 与文件权限及名称有关的参数： -name filename ：找出文件名为filename的文件 -size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件 -tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、              目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）； -perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755； -perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示 -perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示 # 例如： find / -name passwd # 查找文件名为passwd的文件 find . -perm 0755 # 查找当前目录中文件权限的0755的文件 find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</code></pre><p>  使用截图：</p><p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504211338122-1598976431.png"></p><p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504211629560-1737782460.png"></p><p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504212137576-1297477565.png"></p><ol start="2"><li>ls 命令，展示文件夹内内容，参数如下：</li></ol><pre><code>-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ -A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ -d ：仅列出目录本身，而不是列出目录内的档案数据 -f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) -F ：根据档案、目录等信息，给予附加数据结构，例如： *：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； -h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； -i ：列出 inode 位置，而非列出档案属性； -l ：长数据串行出，包含档案的属性等等数据； -n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) -r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； -R ：连同子目录内容一起列出来； -S ：以档案容量大小排序！ -t ：依时间排序 --color=never ：不要依据档案特性给予颜色显示； --color=always ：显示颜色 --color=auto ：让系统自行依据设定来判断是否给予颜色 --full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 --time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) 而非内容变更时间 (modification time)  例如：ls [-aAdfFhilRS] 目录名称 ls [--color=&#123;none,auto,always&#125;] 目录名称 ls [--full-time] 目录名称  </code></pre><p>  使用截图：</p><p> <img src="/assets/image-20211122224052-hv2w7p5.png" alt="image.png"></p><p> <img src="/assets/image-20211122224059-f0xzfu9.png" alt="image.png"></p><ol start="3"><li>cd 命令：</li></ol><pre><code>cd /root/Docements # 切换到目录/root/Docementscd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</code></pre><p> <img src="/assets/image-20211122224108-677n1g7.png" alt="image.png"></p><ol start="4"><li>tree命令，显示树形的层级目录结构，非原生命令，需要安装tree</li></ol><p> 使用示例：</p><p> <img src="/assets/image-20211122224115-492g23a.png" alt="image.png"></p><ol start="5"><li>cp 命令，作用复制，参数如下：</li></ol><pre><code>-a ：将文件的特性一起复制-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行-r ：递归持续复制，用于目录的复制行为-u ：目标文件与源文件有差异时才会复制</code></pre><p>  编辑示例：</p><p> <img src="/assets/image-20211122224122-kvzer3g.png" alt="image.png"></p><p> <img src="/assets/image-20211122224130-xstggsr.png" alt="image.png"></p><ol start="6"><li>rm命令作用为删除，参数：</li></ol><pre><code>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息-i ：互动模式，在删除前会询问用户是否操作-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</code></pre><p>  使用示例：</p><p> <img src="/assets/image-20211122224137-i3kptwv.png" alt="image.png"></p><ol start="7"><li>mv命令作用为移动文件：</li></ol><pre><code>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖-i ：若目标文件已经存在，就会询问是否覆盖-u ：若目标文件已经存在，且比目标文件新，才会更新</code></pre><p> <img src="/assets/image-20211122224143-iuk9wzn.png" alt="image.png"></p><ol start="8"><li>pwd命令，作用为查看”当前工作目录“的完整路径</li></ol><pre><code>pwd -P # 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</code></pre><p> 使用截图：</p><p> <img src="/assets/image-20211122224150-p71ji8z.png" alt="image.png"></p><ol start="9"><li>tar命令，用于压缩解压：</li></ol><pre><code>-c ：新建打包文件-t ：查看打包文件的内容含有哪些文件名-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中-j ：通过bzip2的支持进行压缩/解压缩-z ：通过gzip的支持进行压缩/解压缩-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来-f filename ：filename为要处理的文件-C dir ：指定压缩/解压缩的目录dir</code></pre><p> 缩略版…</p><pre><code>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称查询：tar -jtv -f filename.tar.bz2解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</code></pre><ol start="10"><li>mkdir命令创建目录：</li></ol><pre><code>mkdir [选项]... 目录...  -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;  -v, --verbose  每次创建新目录都显示信息</code></pre><p> <img src="/assets/image-20211122224158-z6hvsot.png" alt="image.png"></p><ol start="11"><li>rmdir 命令删除目录：</li></ol><pre><code>rmdir [选项]... 目录...-p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 -v --verbose  显示指令执行过程 </code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224205-ho83tya.png" alt="image.png"></p><ol start="12"><li>gzip 命令压缩文件或文件夹为 .gz文件：</li></ol><pre><code> gzip[参数][文件或者目录]-a or --ascii 　使用ASCII文字模式。 -c or --stdout or --to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 -d or --decompress or ----uncompress 　解开压缩文件。 -f or --force 　强行压缩文件。不理会文件名称 or 硬连接是否存在以及该文件是否为符号连接。 -h or --help 　在线帮助。 -l or --list 　列出压缩文件的相关信息。 -L or --license 　显示版本与版权信息。 -n or --no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 -N or --name 　压缩文件时，保存原来的文件名称及时间戳记。 -q or --quiet 　不显示警告信息。 -r or --recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 -S&lt;压缩字尾字符串&gt; or ----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 -t or --test 　测试压缩文件是否正确无误。 -v or --verbose 　显示指令执行过程。 -V or --version 　显示版本信息。 -num 用指定的数字num调整压缩的速度，-1 or --fast表示最快压缩方法（低压缩比），-9 or --best表示最慢压缩方法（高压缩比）。系统缺省值为6。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224214-u5sy61x.png" alt="image.png"></p><p> <strong>二. 进程相关命令：</strong></p><ol start="13"><li>ps 命令显示运行的进程，还会显示进程的一些信息如pid, cpu和内存使用情况等：</li></ol><pre><code>-A ：所有的进程均显示出来-a ：不与terminal有关的所有进程-u ：有效用户的相关进程-x ：一般与a参数一起使用，可列出较完整的信息-l ：较长，较详细地将PID的信息列出</code></pre><p>  使用示例：</p><p> <img src="/assets/image-20211122224220-7x3b7a0.png" alt="image.png"></p><ol start="14"><li>kill 命令用于终止进程，参数：</li></ol><pre><code>kill -signal PID1：SIGHUP，启动被终止的进程2：SIGINT，相当于输入ctrl+c，中断一个程序的进行9：SIGKILL，强制中断一个进程的进行15：SIGTERM，以正常的结束进程方式来终止进程17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224228-nl950hz.png" alt="image.png"></p><ol start="15"><li>killall 命令和参数：</li></ol><pre><code>killall [-iIe] [command name]-i ：交互式的意思，若需要删除时，会询问用户-e ：表示后面接的command name要一致，但command name不能超过15个字符-I ：命令名称忽略大小写# 例如：killall -SIGHUP syslogd # 重新启动syslogd</code></pre><p>  使用示例：</p><p> <img src="/assets/image-20211122224234-v7au6zb.png" alt="image.png"></p><ol start="16"><li>crontab命令是启动linux定时任务的服务</li></ol><pre><code>service cron start # 启动cronjobservice cron stop # 停止cronjobservice cron restart #  重启cronjobcrontab -e # 编辑cronjob任务</code></pre><p> 使用示例：打开crontab -e后通过vi方式编辑任务列表</p><p> <img src="/assets/image-20211122224241-dq8lpqb.png" alt="image.png"></p><ol start="17"><li>free 命令用于显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer：</li></ol><pre><code>free [参数]-b 　以Byte为单位显示内存使用情况。 -k 　以KB为单位显示内存使用情况。 -m 　以MB为单位显示内存使用情况。-g   以GB为单位显示内存使用情况。 -o 　不显示缓冲区调节列。 -s&lt;间隔秒数&gt; 　持续观察内存使用状况。 -t 　显示内存总和列。 -V 　显示版本信息。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224250-pjnkr61.png" alt="image.png"></p><ol start="18"><li>top 命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器：</li></ol><pre><code>top [参数]-b 批处理-c 显示完整的治命令-I 忽略失效过程-s 保密模式-S 累积模式-i&lt;时间&gt; 设置间隔时间-u&lt;用户名&gt; 指定用户名-p&lt;进程号&gt; 指定进程-n&lt;次数&gt; 循环显示的次数</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224256-wshssr0.png" alt="image.png"></p><p> <strong>三. 权限相关命令：</strong></p><ol start="19"><li>chmod命令：</li></ol><pre><code>chmod [-R] xyz 文件或目录-R：进行递归的持续更改，即连同子目录下的所有文件都会更改</code></pre><pre><code>#同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改，编号是各种权限的数字代码，示例：chmod 0755 file # 把file的文件权限改变为-rxwr-xr-xchmod g+w file # 向file的文件权限中加入用户组可写权限</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224304-fl7x0xb.png" alt="image.png"></p><ol start="20"><li>chown命令改变文件所有者：</li></ol><pre><code>chown [para]... [owner][:[group]] file...</code></pre><p>   -c 显示更改的部分的信息</p><p> 　-f 忽略错误信息</p><p> 　-h 修复符号链接</p><p> 　-R 处理指定目录以及其子目录下的所有文件</p><p> 　-v 显示详细的处理信息</p><p> 　-deference 作用于符号链接的指向，而不是链接文件本身</p><p>  使用示例：</p><p> <img src="/assets/image-20211122224310-6w1fr7l.png" alt="image.png"></p><ol start="21"><li>chgrp命令，改变文件所属组：</li></ol><pre><code>-c 当发生改变时输出调试信息-f 不显示错误信息-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细的处理信息--dereference 作用于符号链接的指向，而不是符号链接本身--no-dereference 作用于符号链接本身</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224318-udazx56.png" alt="image.png"></p><ol start="22"><li>useradd 命令建立用户账号：</li></ol><pre><code>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号]     -c #&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。　　　-d #&lt;登入目录&gt; 　指定用户登入时的启始目录。　　-D #　变更预设值．　　-e # &lt;有效期限&gt; 　指定帐号的有效期限。　　-f # &lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。　　-g # &lt;群组&gt; 　指定用户所属的群组。　　-G # &lt;群组&gt; 　指定用户所属的附加群组。　　-m # 自动建立用户的登入目录。　　-M # 不要自动建立用户的登入目录。　　-n # 取消建立以用户名称为名的群组．　　-r # 建立系统帐号。　　-s # 指定用户登入后所使用的shell。　　-u # 指定用户ID。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224326-axrl6j6.png" alt="image.png"></p><ol start="23"><li>usermod 修改用户信息：</li></ol><pre><code>usermod -husermod [options] LOGIN</code></pre><p>  -c #后面接账号的说明，即&#x2F;etc&#x2F;passwd第五栏的说明栏，可以加入一些账号的说明<br>  -d #后面接账号的家目录，即修改&#x2F;etc&#x2F;passwd的第六栏<br>  -e #后面接日期，格式是YYYY-MM-DD也就是在&#x2F;etc&#x2F;shadow内的第八栏<br>  -f #后面接天数，修改shadow的第七栏<br>  -g #后面接主群组，修改&#x2F;etc&#x2F;passwd的第四个字段，即是GID的字段<br>  -G #后面接附加群组，修改这个使用者能够支持的群组，修改的是&#x2F;etc&#x2F;group<br>  -a #与 -G 合用，可增加附加群组的支持而非设定<br>  -l #后面接账号名称。修改账号名称，&#x2F;etc&#x2F;passwd的第一栏<br>  -s #后面接Shell的文件，例如&#x2F;bin&#x2F;bash或&#x2F;bin&#x2F;csh等等<br>  -u #后面接 UID 数字，修改用户的UID &#x2F;etc&#x2F;passwd第三栏<br>  -L #暂时将用户的密码冻结，让他无法登入。其实就是在&#x2F;etc&#x2F;shadow的密码栏前面加上了“!”<br>  -U #将&#x2F;etc&#x2F;shadow 密码栏的“!”去掉</p><p> 使用示例：</p><p> <img src="/assets/image-20211122224335-lrs0c06.png" alt="image.png"></p><ol start="24"><li>userdel 删除用户：</li></ol><pre><code>userdel [options] LOGIN-f # 强制删除，包括用户的一切相关内容，这个参数是危险的参数，不建议大家使用。详细说明看MAN-r # 删除用户的家目录和用户的邮件池</code></pre><p> <img src="/assets/image-20211122224341-3cqfuie.png" alt="image.png"></p><ol start="25"><li>groupadd　命令用于将新组加入系统：</li></ol><pre><code>groupadd [－g gid] [－o]] [－r] [－f] groupname－g gid：指定组ID号。－o：允许组ID号，不必惟一。－r：加入组ID号，低于499系统账号。－f：加入已经有的组时，发展程序退出。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224347-bl46p38.png" alt="image.png"></p><ol start="26"><li>groupdel　命令删除组：</li></ol><pre><code>＃　用于删除不再需要的组，如果指定的组中包含用户，则必须先删除组里面的用户&gt;以后，才能删除组groupdel [options] GROUP</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224353-2gftldo.png" alt="image.png"></p><ol start="27"><li>sudo 用来以其他身份来执行命令，预设的身份为root:</li></ol><pre><code>sudo(选项)(参数)-b：在后台执行指令；-h：显示帮助；-H：将HOME环境变量设为新身份的HOME环境变量；-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。-l：列出目前用户可执行与无法执行的指令；-p：改变询问密码的提示符号；-s：执行指定的shell；-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；-v：延长密码有效期限5分钟；-V ：显示版本信息。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224353-2gftldo.png" alt="image.png"></p><ol start="28"><li>passwd 设置用户的密码：</li></ol><pre><code>passwd [OPTION...] &lt;accountName&gt;-k, --keep-tokens       keep non-expired authentication tokens-d, --delete            delete the password for the named account (root only)-l, --lock              lock the named account (root only)-u, --unlock            unlock the named account (root only)-f, --force             force operation-x, --maximum=DAYS      maximum password lifetime (root only)-n, --minimum=DAYS      minimum password lifetime (root only)-w, --warning=DAYS      number of days warning users receives before password expiration (root only)-i, --inactive=DAYS     number of days after password expiration when an account becomes disabled (root only)-S, --status            report password status on the named account (root)</code></pre><p> <img src="/assets/image-20211122224406-25bth2a.png" alt="image.png"></p><ol start="29"><li>groups 显示用户所属组：</li></ol><pre><code>groups # 默认显示当前用户的组groups hadoop2 # 显示hadoop2用户的组</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224412-5vhacar.png" alt="image.png"></p><p> <strong>四. 文本查看编辑等命令</strong></p><ol start="30"><li>vi&#x2F;vim 是使用vi编辑器的命令：</li></ol><pre><code>vi /var/log/aa.log # 打开 /var/log/aa.log文件并编辑</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224419-x1zt9xw.png" alt="image.png"></p><p> vi的操作命令比较复杂，就不在这里详细展开了。</p><ol start="31"><li>cat　用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。</li></ol><pre><code> cat [选项] [文件]...-A, --show-all           等价于 -vET-b, --number-nonblank    对非空输出行编号-e                       等价于 -vE-E, --show-ends          在每行结束处显示 $-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号-s, --squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行 -t                       与 -vT 等价-T, --show-tabs          将跳格字符显示为 ^I-u                       (被忽略)-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224426-8n5q9cp.png" alt="image.png"></p><ol start="32"><li>more 命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能：</li></ol><pre><code>more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 命令参数：+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉常用操作命令：Enter 向下n行，需要定义。默认为1行Ctrl+F 向下滚动一屏空格键 向下滚动一屏Ctrl+B 返回上一屏= 输出当前行的行号：f 输出文件名和当前行的行号V 调用vi编辑器!命令 调用Shell，并执行命令 q 退出more</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224434-a522j9k.png" alt="image.png"></p><ol start="33"><li>less　命令用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</li></ol><pre><code> less [参数]  文件 -b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页</code></pre><p> 使用示例：</p><p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507155949515-2041094265.png"></p><p> <img src="/assets/image-20211122224448-1w68car.png" alt="image.png"></p><ol start="34"><li>tail 命令</li></ol><pre><code>#从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. tail[必要参数][选择参数][文件]   -f 循环读取-q 不显示处理信息-v 显示详细的处理信息-c&lt;数目&gt; 显示的字节数-n&lt;行数&gt; 显示行数--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. -q, --quiet, --silent 从不输出给出文件名的首部 -s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 </code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224455-m4rxv5g.png" alt="image.png"></p><ol start="35"><li>head 命令用于显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行：</li></ol><pre><code>head [参数]... [文件]...  -q 隐藏文件名-v 显示文件名-c&lt;字节&gt; 显示字节数-n&lt;行数&gt; 显示的行数</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224502-vj0dcek.png" alt="image.png"></p><ol start="36"><li>diff 命令用于比较两个文件或目录的不同：</li></ol><pre><code> diff[参数][文件1或目录1][文件2或目录2]# diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的# 文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。-a or --text 　#diff预设只会逐行比较文本文件。-b or --ignore-space-change 　#不检查空格字符的不同。-B or --ignore-blank-lines 　#不检查空白行。-c 　#显示全部内文，并标出不同之处。-C or --context 　#与执行&quot;-c-&quot;指令相同。-d or --minimal 　#使用不同的演算法，以较小的单位来做比较。-D or ifdef 　#此参数的输出格式可用于前置处理器巨集。-e or --ed 　#此参数的输出格式可用于ed的script文件。-f or -forward-ed 　#输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。-H or --speed-large-files 　#比较大文件时，可加快速度。-l or --ignore-matching-lines 　#若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符 or 字符串，则不显示这两个文件的差异。-i or --ignore-case 　#不检查大小写的不同。-l or --paginate 　#将结果交由pr程序来分页。-n or --rcs 　#将比较结果以RCS的格式来显示。-N or --new-file 　#在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。-p 　#若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。-P or --unidirectional-new-file 　#与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。-q or --brief 　#仅显示有无差异，不显示详细的信息。-r or --recursive 　#比较子目录中的文件。-s or --report-identical-files 　#若没有发现任何差异，仍然显示信息。-S or --starting-file 　#在比较目录时，从指定的文件开始比较。-t or --expand-tabs 　#在输出时，将tab字符展开。-T or --initial-tab 　#在每行前面加上tab字符以便对齐。-u,-U or --unified= 　#以合并的方式来显示文件内容的不同。-v or --version 　#显示版本信息。-w or --ignore-all-space 　#忽略全部的空格字符。-W or --width 　#在使用-y参数时，指定栏宽。-x or --exclude 　#不比较选项中所指定的文件 or 目录。-X or --exclude-from 　#您可以将文件 or 目录类型存成文本文件，然后在=中指定此文本文件。-y or --side-by-side 　#以并列的方式显示文件的异同之处。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224509-vbbhrfp.png" alt="image.png"></p><p> <img src="/assets/image-20211122224514-2y6th4o.png" alt="image.png"></p><p> <strong>网络相关命令：</strong></p><ol start="37"><li>ping 用于确定主机与外部连接状态：</li></ol><pre><code>ping [参数] [主机名或IP地址]-d 使用Socket的SO_DEBUG功能。-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。-n 只输出数值。-q 不显示任何传送封包的信息，只显示最后的结果。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。-R 记录路由过程。-v 详细显示指令的执行过程。&lt;p&gt;-c 数目：在发送指定数目的包后停止。-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-I 网络界面：使用指定的网络界面送出数据包。-l 前置载入：设置在送出要求信息之前，先行发出的数据包。-p 范本样式：设置填满数据包的范本样式。-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。-t 存活数值：设置存活数值TTL的大小。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224521-kf8ed1z.png" alt="image.png"></p><ol start="38"><li>ssh 命令用于远程登录上Linux主机：</li></ol><pre><code>ssh [-l login_name] [-p port] [user@]hostname</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224527-ohj9izq.png" alt="image.png"></p><ol start="39"><li>scp 命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的：</li></ol><pre><code>scp [参数] [原路径] [目标路径]-1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224534-eahegc7.png" alt="image.png"></p><ol start="40"><li>telnet 命令用来远程登录操作：</li></ol><pre><code> telnet[参数][主机]-8 允许使用8位字符资料，包括输入与输出。-a 尝试自动登入远端系统。-b&lt;主机别名&gt; 使用别名指定远端主机名称。-c 不读取用户专属目录里的.telnetrc文件。-d 启动排错模式。-e&lt;脱离字符&gt; 设置脱离字符。-E 滤除脱离字符。-f 此参数的效果和指定&quot;-F&quot;参数相同。-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。-K 不自动登入远端主机。-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。-L 允许输出8位字符资料。-n&lt;记录文件&gt; 指定文件记录相关信息。-r 使用类似rlogin指令的用户界面。-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。-x 假设主机有支持数据加密的功能，就使用它。-X&lt;认证形态&gt; 关闭指定的认证形态。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224540-7uvwxi6.png" alt="image.png"></p><ol start="41"><li>wget 是从远程下载的工具：</li></ol><pre><code>wget [参数] [URL地址]启动参数：-V, –version 显示wget的版本后退出-h, –help 打印语法帮助-b, –background 启动后转入后台执行-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc记录和输入文件参数：-o, –output-file=FILE 把记录写到FILE文件中-a, –append-output=FILE 把记录追加到FILE文件中-d, –debug 打印调试输出-q, –quiet 安静模式(没有输出)-v, –verbose 冗长模式(这是缺省设置)-nv, –non-verbose 关掉冗长模式，但不是安静模式-i, –input-file=FILE 下载在FILE文件中出现的URLs-F, –force-html 把输入文件当作HTML格式文件对待-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀–sslcertfile=FILE 可选客户端证书–sslcertkey=KEYFILE 可选客户端证书的KEYFILE–egd-file=FILE 指定EGD socket的文件名下载参数：–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).-O –output-document=FILE 把文档写到FILE文件中-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀-c, –continue 接着下载没下载完的文件–progress=TYPE 设定进程条标记-N, –timestamping 不要重新下载文件除非比本地文件新-S, –server-response 打印服务器的回应–spider 不下载任何东西-T, –timeout=SECONDS 设定响应超时的秒数-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒–random-wait 在下载之间等待0…2*WAIT秒-Y, –proxy=on/off 打开或关闭代理-Q, –quota=NUMBER 设置下载的容量限制–limit-rate=RATE 限定下载输率目录参数：-nd –no-directories 不创建目录-x, –force-directories 强制创建目录-nH, –no-host-directories 不创建主机目录-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…–cut-dirs=NUMBER 忽略 NUMBER层远程目录HTTP 选项参数：–http-user=USER 设定HTTP用户名为 USER.–http-passwd=PASS 设定http密码为 PASS-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)-E, –html-extension 将所有text/html文档以.html扩展名保存–ignore-length 忽略 `Content-Length’头域–header=STRING 在headers中插入字符串 STRING–proxy-user=USER 设定代理的用户名为 USER–proxy-passwd=PASS 设定代理的密码为 PASS–referer=URL 在HTTP请求中包含 `Referer: URL’头-s, –save-headers 保存HTTP头到文件-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)–cookies=off 不使用 cookies–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中FTP 选项参数：-nr, –dont-remove-listing 不移走 `.listing’文件-g, –glob=on/off 打开或关闭文件名的 globbing机制–passive-ftp 使用被动传输模式 (缺省值).–active-ftp 使用主动传输模式–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)递归下载参数：-r, –recursive 递归下载－－慎用!-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)–delete-after 在现在完毕后局部删除文件-k, –convert-links 转换非相对链接为相对链接-K, –backup-converted 在转换文件X之前，将之备份为 X.orig-m, –mirror 等价于 -r -N -l inf -nr-p, –page-requisites 下载显示HTML文件的所有图片递归下载中的包含和不包含(accept/reject)：-A, –accept=LIST 分号分隔的被接受扩展名的列表-R, –reject=LIST 分号分隔的不被接受的扩展名的列表-D, –domains=LIST 分号分隔的被接受域的列表–exclude-domains=LIST 分号分隔的不被接受的域的列表–follow-ftp 跟踪HTML文档中的FTP链接–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表-H, –span-hosts 当递归时转到外部主机-L, –relative 仅仅跟踪相对链接-I, –include-directories=LIST 允许目录的列表-X, –exclude-directories=LIST 不被包含目录的列表-np, –no-parent 不要追溯到父目录wget -S –spider url 不下载只显示过程</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224550-6wlept6.png" alt="image.png"></p><ol start="42"><li>ifconfig　命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置：</li></ol><pre><code> ifconfig [网络设备] [参数]up 启动指定网络设备/网卡。down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。arp 设置指定网卡是否支持ARP协议。-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包-a 显示全部接口信息-s 显示摘要信息（类似于 netstat -i）add 给指定网卡配置IPv6地址del 删除指定网卡的IPv6地址&lt;硬件地址&gt; 配置网卡最大的传输单元mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。tunel 建立隧道dstaddr 设定一个远端地址，建立点对点通信-broadcast&lt;地址&gt; 为指定网卡设置广播协议-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议multicast 为网卡设置组播标志address 为网卡设置IPv4地址txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224557-cjhqx1y.png" alt="image.png"></p><ol start="43"><li>route</li></ol><pre><code> route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] -c  # 显示更多信息-n  # 不解析名字-v  # 显示详细的处理信息-F  # 显示发送信息-C # 显示路由缓存-f  # 清除所有网关入口的路由表。 -p # 与 add 命令一起使用时使路由具有永久性。</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224604-4lniowf.png" alt="image.png"></p><p> <strong>五. 搜索文件：</strong></p><ol start="44"><li>whereis 命令：</li></ol><pre><code># whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。  whereis [-bmsu] [BMS 目录名 -f ] 文件名</code></pre><p> 　-b 定位可执行文件。<br> 　-m 定位帮助文件。<br> 　-s 定位源代码文件。<br> 　-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。<br> 　-B 指定搜索可执行文件的路径。<br> 　-M 指定搜索帮助文件的路径。<br> 　-S 指定搜索源代码文件的路径。</p><p> 使用示例：</p><p> <img src="/assets/image-20211122224612-awkb0rj.png" alt="image.png"></p><ol start="45"><li>locate　命令</li></ol><pre><code>＃　locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)Locate [选择参数] [样式]-e   将排除在寻找的范围之外。-1  如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。-f   将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。-q  安静模式，不会显示任何错误讯息。-n 至多显示 n个输出。-r 使用正规运算式 做寻找的条件。-o 指定资料库存的名称。-d 指定资料库的路径-h 显示辅助讯息-V 显示程式的版本讯息</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224620-3i0tc39.png" alt="image.png"></p><ol start="46"><li>which 会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果：</li></ol><pre><code>which 可执行文件名称 -n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p 　与-n参数相同，但此处的包括了文件的路径。-w 　指定输出时栏位的宽度。-V 　显示版本信息</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224626-1ptxl30.png" alt="image.png"></p><p> <strong>六. 其他：</strong></p><ol start="47"><li>grep命令</li></ol><p> 该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，比如可以加在ps, tail, cat后面</p><p> 它的简单语法为</p><pre><code>grep [-acinv] [--color=auto] &#39;查找字符串&#39; filename</code></pre><p>  使用示例：</p><p> <img src="/assets/image-20211122224632-20ikszh.png" alt="image.png"></p><ol start="48"><li>clear 命令用于清除终端屏幕上现有的文字内容，将之上滚：</li></ol><p>  额，这条不需要啥示例，非常简单…用了以后就没有了…</p><ol start="49"><li>date 命令用于显示或设定时间：</li></ol><pre><code>date [参数]... [+格式]必要参数:%H 小时(以00-23来表示)。 %I 小时(以01-12来表示)。 %K 小时(以0-23来表示)。 %l 小时(以0-12来表示)。 %M 分钟(以00-59来表示)。 %P AM或PM。 %r 时间(含时分秒，小时以12小时AM/PM来表示)。 %s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 %S 秒(以本地的惯用法来表示)。 %T 时间(含时分秒，小时以24小时制来表示)。 %X 时间(以本地的惯用法来表示)。 %Z 市区。 %a 星期的缩写。 %A 星期的完整名称。 %b 月份英文名的缩写。 %B 月份的完整英文名称。 %c 日期与时间。只输入date指令也会显示同样的结果。 %d 日期(以01-31来表示)。 %D 日期(含年月日)。 %j 该年中的第几天。 %m 月份(以01-12来表示)。 %U 该年中的周数。 %w 该周的天数，0代表周日，1代表周一，异词类推。 %x 日期(以本地的惯用法来表示)。 %y 年份(以00-99来表示)。 %Y 年份(以四位数来表示)。 %n 在显示时，插入新的一行。 %t 在显示时，插入tab。 MM 月份(必要) DD 日期(必要) hh 小时(必要) mm 分钟(必要)ss 秒(选择性) 选择参数:-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。 -s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。 -u 　显示GMT。 </code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224640-37cec89.png" alt="image.png"></p><ol start="50"><li>ln 命令是为某一个文件在另外一个位置建立一个同步的链接</li></ol><pre><code>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。软链接：1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接:1.硬链接，以文件副本的形式存在。但不占用实际空间。2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建ln [参数][源文件或目录][目标文件或目录]必要参数:-b 删除，覆盖以前建立的链接-d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程选择参数:-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”</code></pre><p> 使用示例：</p><p> <img src="/assets/image-20211122224646-p8ocp5y.png" alt="image.png"></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> linux命令实操 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基本命令</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/01_Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/01_Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ol><li><p>常用的linux命令：</p><ol><li><p>ls 显示当前路径下的文件和文件夹（横向显示）</p></li><li><p>ll 显示当前路径下的文件和文件夹（纵向显示）</p></li><li><p>ls + 空格+ -a  显示当前路径下的所有隐藏文件</p><ol><li>-a  称为参数   a 为所有的意思</li></ol></li><li><p>mkdir + 文件夹名    新建文件夹</p></li><li><p>touch + 文件名   新建文件</p></li><li><p>clear  清除当前屏幕内容</p></li><li><p>rm  -rf     （-rf ：  r 递归    f  强制       - rf   强制性递归删除）</p></li><li><p>cp + 文件名 +路径    复制文件</p></li><li><p>mv+ 文件（文件夹）名  路径    移动文件&#x2F;文件夹</p></li><li><p>mv + 文件（文件夹）名  + 文件（文件夹）新名   修改文件名</p></li><li><p>pwd   查看当前文件夹路径</p></li><li><p>tar  -cvf    新建文件名（.tar） 要打压缩的文件</p></li><li><p>tar -xvf    解压的文件</p></li><li><p>tar  -zcvf    新建文件名（.tar.gz） 要打压缩的文件</p></li><li><p>tar -zxvf    解压的文件</p></li><li><p>zip     新建文件名（.zip） 要打压缩的文件</p></li><li><p>unzip 要解压的文件</p></li><li><p>vi  + 文件名    进入文件（且为命令状态）</p><ol><li><p>vi  进入文件命令模式</p></li><li><p>a    i    进入编辑模式</p></li><li><p>命令模式：</p><ol><li>x  小写x删除光标所在字符</li><li>X  大写X 删除光标所在字符位置前一个字符</li><li>s  小写s  删除光标所在位置并进入编辑状态</li><li>S  大写S 删除光标所在行并进入编辑状态</li><li>o  小写o 在当前光标所在行的下一行插入空的行，进入编辑状态</li><li>O  大写O  在当前光标所在行的上一行插入空的行，进入编辑状态</li><li>r  小写r 是替换当前光标所在字符</li><li>R 大写R 可以一直替换操作</li><li>backspace   键  可以进行返回替换操作， u 是退回上一步操作</li><li>dd  删除一行（不要删除直接按u就返回了）</li><li>set+nu 设置行号</li><li>shift：&#x2F;  esc    进入命令状态</li><li>wq！  强制保存退出   w 保存   q 退出   ！ 强制</li></ol></li></ol></li><li><p>cat  查看小的文件</p></li><li><p>find   -name   +文件&#x2F;文件夹名    查找文件&#x2F;文件夹</p></li><li><p>| grep  要过滤的字符</p></li><li><p>more 查看大的文件</p></li><li><p>less  查看文件</p></li><li><p>chmod  修改权限</p><ol><li><p>u 表示该用户拥有者</p></li><li><p>g  所属组</p></li><li><p>o 其他</p></li><li><p>a 表示以上三个都有</p></li><li><p>“-” 没有权限</p></li><li><p>r 表示可读</p></li><li><p>x表示可执行</p></li><li><p>w 表示可写</p><ol><li>chmod a +rwx  文件名   直接添加所有</li><li>chmod o - w    文件名   减权限</li><li>chmod a - rwx 文件名  直接减所有</li></ol></li><li><p>r 可读  4     w 可写  2     x可执行  1      -  没有权限  0</p><ol><li>chmod  42-    加权限</li></ol></li></ol></li><li><p>tail  查看动态日志</p><ol><li>tail  - 20 文件名   显示从末尾到20行</li></ol></li><li><p>head  查看静态日志</p><ol><li>head  -n 文件名</li></ol></li><li><p>ps 查看进程</p><ol><li>ps  查看所有用户的进程</li><li>ps -ef 查看所有用户的进程</li><li>ps   - aux 查看详细进程</li><li>ps - ef | grep       过虑</li></ol></li><li><p>kill -9  id  （进程的id）   不能用，真的删除了</p></li><li><p>netstat   - an   查看端口号</p></li><li><p>df  查看分区</p><ol><li>df  - h  以G的形式查看</li></ol></li><li><p>top 查看动态资源占有率</p></li><li><p>vmstat  查看静态资源占有率</p></li><li><p>su  切换用户</p></li><li><p>du  查看文件夹大小</p></li><li><p>du   - h    以G的形式显示</p></li><li><p>find   -name  查找文件</p></li><li><p>free  查看运行内存和交互内存</p></li><li><p>rz  从windows 上传文件到linux</p></li><li><p>sz  从linux下载文件到windows</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> linux基本命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/01_linux%E7%B3%BB%E7%BB%9F/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/01_linux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<ol><li><h2 id="Linux-在VMware安装步骤"><a href="#Linux-在VMware安装步骤" class="headerlink" title="Linux 在VMware安装步骤"></a><a href="../../../../04_%E5%B7%A5%E5%85%B7/04_VMware/04_VMware/">Linux 在VMware安装步骤</a></h2></li><li><h2 id="对-linux熟不熟悉，具体怎么用的？"><a href="#对-linux熟不熟悉，具体怎么用的？" class="headerlink" title="对 linux熟不熟悉，具体怎么用的？"></a>对 <strong>linux</strong>熟不熟悉，具体怎么用的？</h2><ol><li>监控一些系统资源的情况</li><li>linux 的话，我们在测试中也会经常用到基本的一些命令，主要就是搭建部署环境这块，一般开发完成一个新的版本的时候，都会给我们提供一个可测版本的源码包，我们需要把源码包部署到测试环境中。例外，当我们测试过程中发现问题的时候，需要协助开发去定位，分析，帮助开发查找具体的问题原因。这里我们经常需要去查看项目的日志文件，像这块，我们用得比较多的就是文件查看，信息过滤相关的命令，比如：cat ,tail -f,grep等其他的话，我们有时候也需要实时去关注项目的进程，端口的一些资源情况，这个我们需要用到 ps-ef,ps -aux, netstat -anp 等相关的命令。</li></ol></li><li><h2 id="Xshell使用教程"><a href="#Xshell使用教程" class="headerlink" title="Xshell使用教程"></a><a href="../../../../04_%E5%B7%A5%E5%85%B7/05_Xshell/05_Xshell/">Xshell使用教程</a></h2></li><li><h2 id="Linux-的常用命令？"><a href="#Linux-的常用命令？" class="headerlink" title="Linux 的常用命令？"></a>Linux 的常用命令？</h2><ol><li><p>提示：可借助第三方工具连接使用，我们使用xshell学习</p></li><li><p>常用命令：</p><ol><li><p>ls 显示当前路径下的文件和文件夹（横向显示）</p><p> ll 显示当前路径下的文件和文件夹（竖向显示）</p><p> ls +空格+  -a  显示当前路径下的所有隐藏文件（a称为参数，a为所有的意思）</p><p> D  rwx rwx rwx<br />3   peng</p><ul><li>rw- rw- r–<br />1   peng</li></ul><p> 首个D表示文件夹，第一个rwx 用户，第二组用户组，第三组表示其他</p><p> 首个 - 表示文件，文件类型，peng 用户，文件大小，日期，时间，文件名</p><p> Mkdir 新建文件夹</p><p> Mkdir + 空格 +新的文件夹名</p><p> Touch  新建文件</p><p> Touch + 空格 +新建的文件名</p><p> Clear  清除当前屏幕内容</p><p> Rm + 空格 + -f （r递归，f强制，-rf强制性递归删除）</p><p>  Cp+ 空格+ 文件名路径（复制文件）*表示所有</p><p> Mv移动</p><p> Head与cat的区别</p><p> 怎么查看日志</p></li></ol></li></ol></li><li><h4 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a><a href="../902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/01_Linux%E5%91%BD%E4%BB%A4.md">Linux命令</a></h4><h4 id="Linux命令实操"><a href="#Linux命令实操" class="headerlink" title="Linux命令实操"></a><a href="../902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/02_linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%93%8D.md">Linux命令实操</a></h4></li><li><h2 id="测试环境你是怎么搭建的？"><a href="#测试环境你是怎么搭建的？" class="headerlink" title="测试环境你是怎么搭建的？"></a>测试环境你是怎么搭建的？</h2><ol><li>我上一家公司的项目后台使用 PHP开发，数据库这块用的 mysql，web网络服务器用的apache,所有我们搭建的 LAMP 的测试环境。对环境搭建主要就是安装一些软件，像安装 apache,安装 Mysql,安装PHP的运行环境，然后把开发给到我们的测试版本的源码包部署到我们 apache中。（项目是部署在<br> apache 的 www&#x2F;html目录下），启动相应的服务（mysql,apache,php），例外需要修改数据库的配置文件，还有就是开发防火墙的端口，像数据库的端口（3306），apache的端口（80）都要进行开发，这里需要修改防火墙的配置文件。</li></ol></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> linux系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口测试</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/02_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/01_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/02_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/01_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li><h3 id="什么情况下会进行接口测试"><a href="#什么情况下会进行接口测试" class="headerlink" title="什么情况下会进行接口测试"></a>什么情况下会进行接口测试</h3><ol><li>版本一：后台开发出来，但前端页面还没有完成，需要对后台开发出来的功能进行测试</li><li>版本二：一般有需求就会做，后台的接口开发好，就可以开始测。例外，如果增加了新需求，也要做接口测试，还有就是开发对后台的接口做了修改，交互逻辑发生变化，我们也要重新对接口进行测试。</li></ol></li><li><h2 id="接口测试的目的-x2F-为什么要进行接口测试"><a href="#接口测试的目的-x2F-为什么要进行接口测试" class="headerlink" title="接口测试的目的&#x2F; 为什么要进行接口测试"></a>接口测试的目的&#x2F; 为什么要进行接口测试</h2><ol><li>可以前置测试时间，减少测试成本，提高测试效率，能够今早的定位缺陷尽早修复</li></ol></li><li><h2 id="接口测试的主要辅助工具—-gt-lt-桩模块-gt"><a href="#接口测试的主要辅助工具—-gt-lt-桩模块-gt" class="headerlink" title="接口测试的主要辅助工具—&gt;&lt;桩模块&gt;"></a>接口测试的主要辅助工具—&gt;&lt;桩模块&gt;</h2><ol><li>((20211207001347-5cgfdwh “postman “))</li><li>((20211207001354-7kz968b “jmeter”))</li><li>((20220311173215-4vqsrmj “soapUI”))</li><li>apipost：<a href="https://www.apipost.cn/">ApiPost - API 文档、调试、Mock、测试一体化协作平台</a></li><li>mock： 模拟数据，当前端开发出来，后端接口不能使用时可以模拟数据</li></ol></li><li><h2 id="什么是接口测试？"><a href="#什么是接口测试？" class="headerlink" title="什么是接口测试？"></a>什么是接口测试？</h2><ol><li>系统与系统，模块与模块之间数据的交互、调用</li><li>api是接口的通道，每个系统都有自己的格式</li><li>桩模块：模拟被测模块的上级模块，相当于镜子一样</li></ol></li><li><h2 id="接口的类型"><a href="#接口的类型" class="headerlink" title="接口的类型"></a>接口的类型</h2><ol><li><p>websever、MQ、scoket、http</p><ol><li><p>websever：通用型接口，主要用于网络的数据传输，格式xml</p></li><li><p>MQ：属于消息队列，适用于大型的软件架构，数据传输的速度快，量大，稳定   银行业务</p></li><li><p>scoket：既是接口类型又是协议，它可以自定义端到端的接口，采用的是tcp、udp通信协议</p></li><li><p>http：即是接口类型又是协议，属于超文本传输协议，他是开发定义好的，我们只是拿来直接使用</p><ol><li>http分为两个底层接口类型：soap、rest</li><li>soap：http中底层接口传输协议，格式xml，属于软件架构的风格</li><li>rest：http中底层接口传输协议，格式json，属于简单的访问对象</li></ol></li></ol></li></ol></li><li><h3 id="接口的格式"><a href="#接口的格式" class="headerlink" title="接口的格式"></a>接口的格式</h3><ol><li><p>json、xml、HTML、raw</p><ol><li>json表示：{}</li><li>xml表示：&lt;&gt;</li></ol></li></ol></li><li><h3 id="接口的请求方式"><a href="#接口的请求方式" class="headerlink" title="接口的请求方式"></a>接口的请求方式</h3><ol><li><h4 id="get、post、delete、put、head"><a href="#get、post、delete、put、head" class="headerlink" title="get、post、delete、put、head"></a>get、post、delete、put、head</h4><ol><li>get：从服务器获取信息</li><li>post：先上传信息，再从服务器获取信息</li></ol></li><li><h4 id="get与post的区别"><a href="#get与post的区别" class="headerlink" title="get与post的区别"></a>get与post的区别</h4><ol><li>从服务器来讲:  get比post安全，get只是从服务器上面获取信息而post可以修改服务器的信息</li><li>从客户端来讲：post比get安全，因为get的请求数据是加在url后面，而post是附加在请求包体里面的</li><li>传参大小不一样，get有字节限制(1024&#x2F;2048)，而post在理论上是没有限制的</li></ol></li></ol></li><li><h2 id="接口测试中职责的划分"><a href="#接口测试中职责的划分" class="headerlink" title="接口测试中职责的划分"></a>接口测试中职责的划分</h2><ol><li>测试的建立：开发人员、测试人员、数据库管理人员、系统的负责人</li><li>测试的执行：测试人员</li><li>测试结果的确认：开发组长、测试组长</li></ol></li><li><h2 id="接口测试的对象"><a href="#接口测试的对象" class="headerlink" title="接口测试的对象"></a>接口测试的对象</h2><ol><li><p>模块接口测试、web接口测试</p><pre><code> web接口测试：服务器接口测试     外部接口测试   模块接口测试：以单元测试为基础，适用于开发的异常的功能模块 服务端接口测试：客户端、服务端、浏览器 外部接口测试：调用第三方的接口</code></pre></li></ol></li><li><h2 id="接口测试的原则："><a href="#接口测试的原则：" class="headerlink" title="接口测试的原则："></a>接口测试的原则：</h2><ol><li>不同的接口参数覆盖不同的业务场景</li><li>参数能被运用到不同的场景中</li><li>测试的数据要与业务进行分离</li><li>尽量统一共用测试环境</li><li>测试完成后删除不必要的测试数据</li></ol><p> <strong>注释：接口测试是最简单的测试，但又是最严格的测试；还可以把接口测试称之为没有界面的功能测试</strong></p></li><li><h2 id="接口测试流程"><a href="#接口测试流程" class="headerlink" title="接口测试流程"></a>接口测试流程</h2><ol><li><p>首先跟开发要接口文档，对文档进行分析并编写测试用例，和开发进行用例评审，使用公司中的接口测试工具进行测试，关注：接口的协议、IP、端口号、路径、以及请求方式、请求参数，然后执行测试，关注：接口返回的格式、字段名、字段值的内容是否和添加的参数内容相照应</p><p> <strong>注释：不能和项目结合着说、登录的接口不要说&lt;太简单&gt;</strong></p></li></ol></li><li><h1 id="postman中如何连接两个接口"><a href="#postman中如何连接两个接口" class="headerlink" title="postman中如何连接两个接口"></a>postman中如何连接两个接口</h1><p> 1、获取上一个接口的返回值</p><p> 2、用一个环境变量或全局变量来接受这个返回值</p><p> 3、用此环境变量或者全局变量作为下一个接口的参数</p></li><li><h3 id="你们接口测试具体怎么做？"><a href="#你们接口测试具体怎么做？" class="headerlink" title="你们接口测试具体怎么做？"></a>你们接口测试具体怎么做？</h3><ol><li><p>一般开发把接口开发出来之后，会给到我们一个接口文档，首先要搞清楚这个接口的功能，它的作用是什么，请求方式，有哪些参数。参数有什么限制，类型是什么，是否必填，对于参数有不清楚的， 一般我们会问下开发，通过以上几个点去设计用例。</p><p> 设计好用例之后，我们利用工具进行检测，我们公司当时用的是 JMeter 来做接口测试的。</p><p> 首先我们要建立一个线程组,然后添加取样器（http 请求），然后填写接口的协议，地址，端口，请求方式，</p><p> 路径，及根据用例填写请求参数，添加一个监听器去查看接口返回的数据，然后执行，然后依据接口文档对比返回的数据是否与预期结果一致，</p><p> 对于返回的响应的数据的检查，我们主要关注以下几个点：状态码，提示信息，具体的正文内容，看与接口文档说明的是否一致，如果有问题，我们先大概分析下，看是否能定位出具体原因，实在不行就直接提 Bug给开发，让开发修复，之后最回归复测。</p></li></ol></li><li><h3 id="两个接口有关联，JMeter具体怎么做"><a href="#两个接口有关联，JMeter具体怎么做" class="headerlink" title="两个接口有关联，JMeter具体怎么做"></a>两个接口有关联，<strong>JMeter</strong>具体怎么做</h3><ol><li><p>另外两种问法：上个接口的返回值是下个接口的请求参数，这种如何处理？动态关联有没有了解过？</p><ol><li>这个涉及到动态关联，首先要搞清楚后一个接口需要用到上一个接口的什么数据，例外要看数据是在哪里取的，是在 head 还是在 body 里，然后如果要取的数据是 json 格式我会在发请求用 json 提取器去取这个数据，如果是其他格式的就用边界提取器或正则表达式去取数据。就拿我当时做的那个下单接口来说吧，因为下单接口需要先登录，需要用到登录接口的 cookies来做鉴权，首先就是把登录接口调试通过，然后在登录接口的http请求中添加一个边界值提取器或者也可以用正则表示式提取器去提取登录接口的响应头中的 cookies值，然后在下单接口中需要添加一个http cookies管理器，在http cookies管理器中引用登录接口提取出来的 cookies，这样就可以了。</li><li>如果是不同的线程组的话，那在登录接口中还得添加一个 Beanshell 取样器，在 BeanShell 取样器中， 利用函数助手中的 SetProperty()函数把提取出来的 cookies 设置为全局变量。然后在下单接口的 http cookies 管理器中利用函数助手中的Property()函数引用登录接口中设置的全局变量，这样就可以了。</li></ol></li></ol></li><li><h3 id="接口测试的工作流程"><a href="#接口测试的工作流程" class="headerlink" title="接口测试的工作流程"></a>接口测试的工作流程</h3><p> 1，首先分析开发给到的接口文档</p><p> 2，接口文档分析完成，编写测试用例</p><p> 3，然后借助接口测试工具去测试执行测试用例</p><p> 4，发现bug 提交 bug,并跟进 bug 修复。</p></li><li><h3 id="给你一个新的接口，你怎么去设计用例？"><a href="#给你一个新的接口，你怎么去设计用例？" class="headerlink" title="给你一个新的接口，你怎么去设计用例？"></a>给你一个新的接口，你怎么去设计用例？</h3><ol><li><p>首先要对于每个要测的接口都要先搞清楚这个接口的功能，它的作用是什么，熟悉这个业务功能需要用到什么协议，请求方式是什么，接口有哪些参数。对于每个参数的作用都要搞清楚，像数的类型，是否有约束限制，是否为必填的，长度，其他的限制等等，如果两个参数之间有关联我们还要考虑参数的组合场景，对于参数不理解的，一般都会跟开发沟通下，然后考虑返回数据的类型，返回数据中的返回码和返回信息是什么，通过以上几个点去提炼测试点，设计用例。</p><p> 最好拿一个具体的例子进行说明      比如：在方维的项目中当时做过的一个注册接口来说，这个注册接口总共有用户名，手机号码，密码，确认密码，推荐人 5 个主要的参数，而其中用户名，手机号码，密码，确认密码这几个参数是必填的，用户名要求在 3-15个字符之间，密码限制要求在长度在6~16 之间，只能包含字符、数字和下划线。其他的参数没有限制约束，而密码与确认密码两个参数是有关联的，我们需要考虑他们的组合场景。分析好接口的具体情况之后，我主要是通过等价类，边界值，判定表等方法来设计用例。对于这个注册接口我当时从以下几个点来设计用例的：</p><p> 文本框: </p><ol><li><pre><code>首先是用户名我主要考虑的点有：</code></pre></li><li><p>有效的用户名</p></li><li><p>无效的场景：等价类用户名小于 3 个字符用户名大于 15 个字符用户名等于 3 个字符用户名等 15 个字符</p></li><li><p>重复的用户名</p></li><li><p>空值</p></li><li><p>敏感字符的用户名比如：中国共产党</p></li><li><p>对于密码这块我会从以下几个方面去考虑设计用例：</p></li><li><p>考虑密码与确认密码一致</p></li><li><p>密码与确认密码不一致有效：</p></li><li><p>正确的密码无效：</p></li><li><p>密码小于 6 个字符</p></li><li><p>密码大于 16 个字符</p></li><li><p>密码等于 6 个字符</p></li><li><p>密码等于 16 个字符</p></li><li><p>密码包含了除字符，数字，下划线以外的字符</p></li><li><p>空值3.手机号码：</p></li><li><p>正确的手机号码</p></li><li><p>错误的手机号码</p></li></ol></li></ol></li><li><h3 id="接口文档主要包含哪些内容？"><a href="#接口文档主要包含哪些内容？" class="headerlink" title="接口文档主要包含哪些内容？"></a>接口文档主要包含哪些内容？</h3><ol><li><p>接口文档一般两种形式的，要不就是 word 版本的要不就是<br> html 的形式，具体内容</p><ol><li><p>URL（接口地址）</p></li><li><p>接口功能</p></li><li><p>请求方式：post</p></li><li><p>请求参数，以及接口中每个参数的详细说明，类型，是否为必填，约束条件啊等等</p></li><li><p>响应数据及格式， 返回码，返回码解释等等</p></li></ol></li></ol></li><li><h3 id="你怎么去检查接口，分析接口"><a href="#你怎么去检查接口，分析接口" class="headerlink" title="你怎么去检查接口，分析接口"></a>你怎么去检查接口，分析接口</h3><ol><li>我们主要是根据入参情况，去看接口的返回值，对于返回值，我主要关注的几个点：1. 状态码 2. 提示信息 3.  返回数据的具体内容。根据接口文档的说明去检查这个 3 个点是否满足接口需求文档，4、有些如果要检查数据库的，就连接数据库获取数据与返回的数据做对比。如果不满足就是有问题，如果满足则通过。如果有Bug,我们会先大概分析下，是什么原因，并进行复测，如果还是有问题，提交Bug 给开发，让开发修复，之后再回归。</li></ol></li><li><h3 id="依赖于第三方的接口如何测试"><a href="#依赖于第三方的接口如何测试" class="headerlink" title="依赖于第三方的接口如何测试"></a>依赖于第三方的接口如何测试</h3><p> 1，需要第三方接口的，接口文档</p><p> 2，发送请求到第三方接口，检查第三方接口返回的数据是否正确</p><p> 3，不正确的时候，要跟第三方接口联调，看是请求问题，还是第三方接口返回数据有误</p><p> 这个我们公司的第三方接口，我们都是打通的，比如电商，我们通过调用微信接口等等都是打通的，比如要测试下单第三支付，我们自己开店，收款设置我们自己的账号，然后通过商品设计 1 分钱，去测试的如果不打通的话，基本也只能抓包，主要保证我们发送出去的数据符合需求文档就行，然后真正的上线之前，我们会在预生产环境做一个联调测试，把各自系统连在一起，做一个联调测试没有问题了</p><p> 我们就可以上线，基本就这么做的</p><p> 联调测试怎么做的：</p><p> 其实联调测试就是数据拉通测试，两个子系统，连在一起，形成一个完整的系统，然后从上游下数据，</p><p> 下游接到数据，看传过来的数据是否符合下游的系统要求然后下游做了操作，把数据返回给上游，通知上游说数据返回了，上游看返回的数据是否符合要求，如果没有问题，就这个数据就拉通成功这个都是按照用例来执行，上游和下游一起出一份用例，两边都评审通过，然后按照测试用例执行，每条用例测试通过那么联调测就完成了</p></li><li><h3 id="接口工具-jmeter用到哪些组件，具体作用"><a href="#接口工具-jmeter用到哪些组件，具体作用" class="headerlink" title="接口工具 jmeter用到哪些组件，具体作用"></a>接口工具 <strong>jmeter</strong>用到哪些组件，具体作用</h3><ol><li><p>取样器：</p><p> http请求                                                                                    #向服务器发http请求</p><p> JDBCRequst                                                                                          # 向数据库发请求</p><p> DebugSampler                                                                                     #调试，看执行过程</p><p> BeanShell取 样器                                            #把某个变量设置定位全局变量</p><p> 后置处理器：</p><p> 正则表达式提取器                                                                 </p><p> #提取接口的响应内容或请求内容中的数据具体要提什么数据根据需求来，比如我们充值接口依赖登录接口，需要用到登录接口的cookie，需要提取cookie</p><p> 边界值提取器</p><p> JSON 提取器</p><p> BeanShellPostPrecessor                                                      #在请求结束之后需要做的某些事情，比如转码</p><p> 断言： #检验结果，验证本接口是否有问题响应断言</p><p> Json 断 言配置元件：</p><p> CSV<br> dataSetConfig                                                               # 读取 CSV文件，txt文件</p><p> JDBCConnectionConfiguration                                       # 连接数据库HTTPCookie管理器</p><p> HTTP信息头管理器用户定义的变量</p><p> 计数器定时器：同步定时器，主要用来设置集合点。监听器</p><p> 查看结果树</p></li></ol></li><li><h3 id="上传文件的接口用-JMeter怎么做"><a href="#上传文件的接口用-JMeter怎么做" class="headerlink" title="上传文件的接口用 JMeter怎么做"></a>上传文件的接口用 <strong>JMeter</strong>怎么做</h3><ol><li><p>例外一种问法：有没有做过文件上传的接口，具体怎么做？</p><p> 要测试上传文件的接口，在 JMeter 的http 请求这个组件中传递请求参数的栏目中专门提供了一个用来文件上传的，在这里面需要填写几个内容，一个就是文件的路径，还有一个就会参数名称，还有就是MIME 类型也就是指定要上传的文件的类型，这样就可以了。</p></li></ol></li><li><h3 id="对于POST请求，要求传递Json格式数据，JMeter怎么做"><a href="#对于POST请求，要求传递Json格式数据，JMeter怎么做" class="headerlink" title="对于POST请求，要求传递Json格式数据，JMeter怎么做"></a>对于<strong>POST</strong>请求，要求传递<strong>Json</strong>格式数据，JMeter怎么做</h3><ol><li>对于这个其实在 JMeter的 http请求这个组件中的参数配置栏目中，第二个栏目有一个消息体数据， 我们把需要上传的参数组装成 json格式，然后编写到 body data里面，然后，需要在http信息头管理其中，需要将数据格式设置为 json格式，这个就是设置 Content-Type为 application&#x2F;json;charset&#x3D;utf-8， 这样就可以了。</li></ol></li><li><h3 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h3><ul><li><p>Charles  ，抓包</p><ul><li>((20211120154039-ecok8wp “Charles安装”))</li><li><a href="https://www.charlesproxy.com/documentation/welcome/">官方文档</a></li></ul></li><li><p>Fiddler（windows好用）</p><ul><li>((20211204000051-egpcxr3 “fiddler安装、配置与使用”))</li></ul></li><li><p>wireshark</p><ul><li><a href="https://wireshark.en.softonic.com/">官网1</a></li><li><a href="https://www.wireshark.org/download.html">官网2</a></li><li><a href="https://www.wireshark.org/">官网3</a><br /></li></ul></li></ul></li><li><h3 id="没有接口文档的时候怎么做接口测试？"><a href="#没有接口文档的时候怎么做接口测试？" class="headerlink" title="没有接口文档的时候怎么做接口测试？"></a>没有接口文档的时候怎么做接口测试？</h3><ol><li>首先，做接口测试，有接口文档比没有接口文档的效率要高很多，所以在条件允许的情况下，还是尽可能的要搞一份接口文档出来。</li><li>其次，如果没有接口文档，但是系统已经集成接口，并且有UI界面，那么我们可以借助于抓包工具来抓取接口信息。启动并设置好抓包工具比如Fiddler，然后在UI界面进行操作，在Fiddler中就可以查看接口的请求和响应，根据请求和响应的相关信息，反推接口信息，比如请求的方法、地址、参数、响应报文等等。必要的时候，我们需要在UI界面做实验，以获取或者猜测接口信息。获取到接口信息后，就可以依据接口的要素信息设计测试用例，利用测试工具Jmeter等来对接口进行测试。这个过程相对来说多了一个收集接口信息的步骤，时间长，还可能出错，所以比有接口文档的测试效率，要低了很多。</li></ol></li><li><h3 id="postman-可直接下载安装"><a href="#postman-可直接下载安装" class="headerlink" title="postman  可直接下载安装"></a>postman  可直接下载安装</h3><ol><li><h6 id="官网"><a href="#官网" class="headerlink" title="官网"></a><a href="https://www.postman.com/">官网</a></h6></li><li>默认安装</li></ol></li><li><h2 id="jmeter是怎么安装的？"><a href="#jmeter是怎么安装的？" class="headerlink" title="jmeter是怎么安装的？"></a>jmeter是怎么安装的？</h2><ol><li>查看是否有jdk      打开cmd     输入java或者javac</li><li>没有则安装jdk</li><li>配置jdk环境变量</li><li>下载jmeter，解压，配置jmeter环境变量</li><li>打开bin 目录下的.bat文件运行jmeter</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 接口测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代模型</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a><strong>软件的生命周期</strong></h2><p>软件生命周期是软件的产生直到报废或停止使用的生命周期</p><p>软件生命周期内有问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等阶段。</p><p>软件开发模型</p><p><img src="/assets/wpsA7E5.tmp-20211120152251-qp0stk4.jpg"></p><p>瀑布模型是最早的开发模型</p><p>优点：有利于大型软件开发过程当中人员的组织与管理，提高软件开发的质量与效率</p><p>缺点：模型是线性的，增加开发的风险，例如需求分析时，已经出现错误，一直没有测试阶段，直到测试阶段才能发现问题。问题修改起来成本增加。另外 用户需求变化太快，前期调研在完善也抵不住用户的需求变更，跟不上市场变化的速度</p><p>衍生出敏捷开发</p><p><img src="/assets/wpsA7E6.tmp-20211120152251-x8q273s.jpg"></p><p>看板</p><p><img src="/assets/wpsA7E7.tmp-20211120152251-wbf6fok.jpg"></p><p>测试模型</p><p><img src="/assets/wpsA7E8.tmp-20211120152251-uf1al0p.jpg"></p><p>需求分析：首先要做的事，开发 测试 要做什么，分析</p><p>概要设计：架构的实现，开发做的事，搭建产品的架构</p><p>详细设计：在概要设计的基础上在每个模块内部实现的逻辑和方法在这个阶段设计好，</p><p>编码：</p><p>单元测试：最小测试单元进行测试</p><p>集成测试；</p><p>系统测试</p><p>验收测试</p><p>（中小型企业使用）</p><p><img src="/assets/wpsA7E9.tmp-20211120152251-xxg84iu.jpg"></p><p>W模型，在需求设计阶段增加了测试活动，开发测试同步进行（大型企业使用，对人员要求比较高）</p><p><img src="/assets/wpsA7EA.tmp-20211120152251-6i27xmg.jpg"></p><p>产品迭代，适合小型迭代，测试流程完全独立出来，测试就绪点，测试准入准则</p><p>一般小型企业使用，项目人员要了解整体情况</p><p>系统测试流程</p><p><img src="/assets/wpsA7EB.tmp-20211120152251-49ld7zq.jpg"></p><p>Bug管理流程</p><p><img src="/assets/wpsA7EC.tmp-20211120152251-2ssrp2b.jpg"></p><p>软件测试流程的价值</p><p>提高测试效率</p><p>提高产品质量</p><p>加强项目成员之间的沟通</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 基础 </category>
          
          <category> 迭代模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试报告</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/08_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/08_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 软件测试报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试概念总结</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ol><li><h3 id="你上家公司的测试流程是怎么样的？"><a href="#你上家公司的测试流程是怎么样的？" class="headerlink" title="你上家公司的测试流程是怎么样的？"></a>你上家公司的测试流程是怎么样的？</h3><ol><li><p>需求下来之后，我们会首先熟悉下，然后公司会做一个’需求交接’,这个过程中一般会开一个简单的’需求澄清会’,在会议上把自己对需求不清楚，不理解，或者有异议的地方都提出来，由产品给我们解答。澄清会结束然后就写测试计划，测试计划前期一般都是有我们主管写的，后期基本上是由我们各个测试人员轮流细的，测试计划主要就是安排进度以及任务的分配之后各自领取自己负责的模块，做需求分析，挖掘，同时写测试点，测试点写完后,就编写测试用例。’测试点，我们用的 xmind的写的，用例当时用的Excel 表格管理的’，等测试用例编写完，一般会有评审，对于评审，有时候就是简单组内评审下，如果大的功能可能会组织会议评审，如果是会议评审，相关的开发，跟产品基本都会到场，其实主要就是看下用例的覆盖率这块，例外就是看检查点有没有检查到位。评审了之后，然后会等项目版本出来，开发那边一般会先做单元测试(UT)，之后就开始提测，我们首先会搭建测试环境，做项目部署，之后做冒烟测试，然后去执行用例做系统测试，测试过程中发现 bug就指派给对应的开发，待开发修复完成之后，我们测试需要做复测，复测没有问题就关闭Bug,如果还是有问题，重新开启 Bug，直到改好了复测完没问题才可以关闭这个bug。<del>一般系统功能测试我们需要测试2-3轮</del>，保证所有Bug基本都修复完成，之后写测试报告，然后看是否达到上线标准，达到了上线标准的话，由 SE组织时间进行产品上线，上线之后我么会做一个做总结。</p></li><li><h3 id="产品如何上线？（标准，过程）"><a href="#产品如何上线？（标准，过程）" class="headerlink" title="产品如何上线？（标准，过程）"></a>产品如何上线？（标准，过程）</h3><ol><li><h4 id="上线标准"><a href="#上线标准" class="headerlink" title="上线标准"></a>上线标准</h4><ol><li>用例执行率 100%</li><li>1,2 级Bug 修复率100%</li><li>3,4 级Bug 修复率95%</li></ol></li><li><h4 id="上线时间"><a href="#上线时间" class="headerlink" title="上线时间"></a>上线时间</h4><ol><li><p>周二，周四晚上 一般都在 10 点之后 （用户少，影响不大） 产品，运维，开发，测试都要到场</p><p> SE 组织安排上时间，上线注意事项，人员等</p></li></ol></li><li><h4 id="上线的过程"><a href="#上线的过程" class="headerlink" title="上线的过程"></a>上线的过程</h4><ol><li>第一步：运维从 svn<br> 下载交付版本（测试好的版本）,部署到（线上&#x2F;生产环境）服务器上</li><li>第二步：部署完了，测试这个时候才扑上去执行测试，各自执行各自的用例（新需求，各自负责各自的模块都需要点一遍），这个时候发现问题，立马要修复，重新上线，（会不会执行用例？）还是会执行用例， 但是，主要执行主要用例，级别高的用例的。把每个功能模块的流程走一遍，保证没有问题</li><li>第三步：有问题？严重的，致命的，会影响客户使用的问题，一般要求当场修复，如果修复不了，第二天修复，直到修复为止，然后复测，再上线。一般的，普通，提示的问题，对于客户影响不大的，一般产品会决定，可以先上线，推迟到下一个版本在修复。能当场修复，修复完成重新上线</li><li>第四步：一般我们上线一周，会做一个简单的总结</li></ol></li></ol></li><li><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><ol><li>首先对需求进行评审，评审通过后，测试人员根据需求编写测试用例，再对用例进行评审，评审通过后，对测试版本进行测试，测试过程中发现bug提交给对应的开发人员进行修改，待开发修改完成后，我们进行返测，返测通过直接关闭，返测不通过打回让开发重新修改，直至项目中所有的bug关闭，编写写实报告，进行版本发布，编写测试总结</li></ol></li><li><h3 id="用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？"><a href="#用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？" class="headerlink" title="用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？"></a>用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？</h3><ol><li><p>用例包含哪些部分，你认为哪些比较重要？</p><ol><li>用例编号，模块，用例标题，重要级别，前置条件，输入数据，操作步骤，预期结果</li><li>级别一定定得合理</li><li>标题一定要简明扼要的阐述清楚</li><li>预期结果一定要检查到位（不仅要考虑前端显示问题，还有相关模块的影响，以及后台数据库的考虑）</li><li>操作步骤要尽量详细（以便用例执行者能正常执行）</li><li>测试数据要正确合理，前置条件要准确。</li></ol></li><li><p>用例设计方法有哪些</p><ol><li>用例方法主要有：等价类  边界值  判定表  流程分析法 正交表 因果图 状态迁移 错误推断法，异常分析法。其实我一般用得比较多一点就是等价类  边界值  判定表  流程分析法这几个，有时候会用下错误推断法等来补充用例。</li></ol></li><li><p><img src="/assets/image-20211203153323-8cht73v.png" alt="image.png"></p></li></ol></li><li><h3 id="等价类与边界值怎么理解？"><a href="#等价类与边界值怎么理解？" class="headerlink" title="等价类与边界值怎么理解？"></a>等价类与边界值怎么理解？</h3><ol><li><p>等价类分为，有效等价类，无效等价类，有效等价类其实就从正向去考虑，正常的场景，无效等价类，就是站异常的场景角度去考虑用例。一般主要用在对文本编辑框的用例设计，比如：注册用户名，用户名规定在 3-15个字符之间，那么我们在设计用例的时候就要考虑有效等价类：3-15中随机取一个值，无效等价来就是：小于3,大于15。</p><p> 边界值其实是对等价类的一种补充，它其实不能当成主要的用例方法，但是一定要考虑，因为很多问题都发生在边上。边界值一般有上点，离点，内点，比如刚才说的用户名，边界值就要考虑 3,15,2,16这几个点。</p></li><li><p><strong>注释：如果自己的项目中没有登录或者注册的用户名输入框，可以选择其他输入框，如商品名称、订单编号等</strong></p></li></ol></li><li><h3 id="怎么保证用例的质量，保证覆盖度达到100"><a href="#怎么保证用例的质量，保证覆盖度达到100" class="headerlink" title="怎么保证用例的质量，保证覆盖度达到100%"></a><strong>怎么保证用例的质量，保证覆盖度达到</strong>100%</h3><ol><li><p>仔细分析需求，仔细阅读需求文档，有可能 se需求文档里面的一个图片，需求文档里面的一个提示都是需求点，前期多和 SE沟通，把需求吃透特别隐含的需求，和这个需求关联模块啊，一般出问题都是些隐含需求和相关模块没有分析出来,另外最好能站在用户的角度多考虑一些其他场景。保证用例的覆盖度。</p></li><li><p>分析完成，我会核对我罗列的需求点是否覆盖需求文档的需求点，这个一条一条过，这样基本问题不大了，不会有需求遗漏，再组内评审下，更能保证质量</p></li><li><p>必须要熟悉业务，比如说，查询订单，订单接口输入参数数据都来源于订单表，如果不熟悉来源哪些表，订单有哪些状态，这些，你就不好分析执行，多考虑业务流程上的测试点，以及相关模块的测试点</p></li><li><p>用例这块，检查结果要覆盖每一个检查点，像数据库检查，相关模块检查都要覆盖到位，用例必须需要经过评审</p></li><li><p>后期不停的完善，添加，补充用例，以保证用例的覆盖度。</p></li></ol></li><li><h3 id="你们用例是怎么评审的，评审过程中主要关注什么问题？"><a href="#你们用例是怎么评审的，评审过程中主要关注什么问题？" class="headerlink" title="你们用例是怎么评审的，评审过程中主要关注什么问题？"></a>你们用例是怎么评审的，评审过程中主要关注什么问题？</h3><ol><li>主要还是看项目大小和复杂程度，我们公司一般都是会议评审，一般提前预定会议室，把产品、开发同事都叫上，一起会议室评审用例，假如有时候只有简单业务，就简单的组内评审就可以了。</li><li>主要是关注用例覆盖是不是完整，有已没有漏测的用例，另外就是预期结果是否合理，检查到不到位。</li></ol></li><li><h2 id="用例评审的目的"><a href="#用例评审的目的" class="headerlink" title="用例评审的目的"></a>用例评审的目的</h2><ol><li>评审有歧义，有冲突，有问题，目的是查漏补缺</li></ol></li><li><h3 id="你的测试用例是怎样管理的？"><a href="#你的测试用例是怎样管理的？" class="headerlink" title="你的测试用例是怎样管理的？"></a>你的测试用例是怎样管理的？</h3><ol><li>我们公司的用例都是用的禅道 来管理的，一般会把用例情况，包括通过率、执行率、阻塞率、未执行数量、已执行数量都做好记录，方便后续查看，也方便修改。</li><li>另外也要注意用例的及时更新，不需要的用例可以备注隐藏，以免后续要再次使用的时候可以不必重复编写用例。</li></ol></li><li><h3 id="如何保证软件质量"><a href="#如何保证软件质量" class="headerlink" title="如何保证软件质量"></a>如何保证软件质量</h3><ol><li>需求要吃透，多问，多去了解</li><li>严格按照测试流程去执行： 引入合适的测试用例设计方法、进行用例评审机制。</li><li>要有良好的测试执行：要求用例执行率达到 100%，多次的测试轮次、引入测试工具，让测试可以做得更深入（通过查看日志，查数据库）</li><li>有良好的缺陷写作和过 Bug 机制、引入合适的缺陷管理工具和缺陷管理流程，有良好的测试流程， 引入更合适的测试流程和测试方法，采用更多的非功能测试，不能把非功能忽略测试。</li><li>多进行评审，完善大家的测试思维点。</li><li>进行交叉测试，可以多个人，不同测试考虑点。</li></ol></li><li><h3 id="提（bug）单工具"><a href="#提（bug）单工具" class="headerlink" title="提（bug）单工具"></a>提（bug）单工具</h3><ol><li>禅道，jira，qc，bugfree，bugzilla</li><li>((20211203111708-liwjzmp “禅道介绍”))      ((20211203112034-mzpktpu ‘禅道介绍-提交bug’))</li><li>注释： <a href="http://192.168.1.2/object/zentaopms/www/index.php">禅道链接</a></li></ol></li><li><h3 id="bug流程"><a href="#bug流程" class="headerlink" title="bug流程"></a>bug流程</h3><ol><li>版本一：发现bug以后，先截图，详细记录重现步骤，通过bug工具提交给对应的开发人员，等待开发解决以后我们进行返测，通过就关闭，不通过打回去重现修改，直到项目中所得bug关闭</li><li>版本二：原来 bug 是用 禅道来管理的，原来我们公司 bug，提交 bug 直接给对应的开发人员，对应开发人员修复完成，交给测试复测，复测通过关闭 bug，不通过打回给对应开发重新修改</li></ol></li><li><h3 id="提交bug包含哪些内容"><a href="#提交bug包含哪些内容" class="headerlink" title="提交bug包含哪些内容"></a>提交<strong>bug</strong>包含哪些内容</h3><ol><li>所属产品，所属模块，所属项目，影响版本，指派人员,截止日期，严重程度，优先级，bug 类型，bug 环境，Bug 标题，重现步骤，附件</li></ol></li><li><h3 id="bug的状态"><a href="#bug的状态" class="headerlink" title="bug的状态"></a>bug的状态</h3><ol><li>提交-开发人员：已激活未确认-开发进行确认，状态变成已激活，已确认，开发修复完成-标注状态是已修复，测试人员复测通过，已关闭，打回给对应开发，已经激活</li></ol></li><li><h3 id="bug的级别"><a href="#bug的级别" class="headerlink" title="bug的级别"></a>bug的级别</h3><ol><li><p>致命、严重、一般、建议      1   2    3   4</p></li><li><p>定义</p><ol><li>致命：对业务有至关重要的影响，业务系统完全散失业务功能，工作无法再继续进行，或业务系统丢失了业务数据且无法恢复，影响公司运营的重要业务数据出错</li><li>严重：对业务有严重的影响，业务系统已经丧失可部分的重要的业务功能，或业务系统丢失了业务数据且可以恢复，一般业务数据出错。</li><li>一般：对业务有较小的影响，业务系统丧失了较少的业务，功能。例如：界面错误，打印或显示格式错误。</li><li>建议：对业务没有影响，不影响业务过程正常进行，例如：辅助说明描述不清楚，提示不明确的错误提示</li></ol></li><li><h4 id="致命Bug跟严重-Bug的区别？"><a href="#致命Bug跟严重-Bug的区别？" class="headerlink" title="致命Bug跟严重 Bug的区别？"></a>致命<strong>Bug</strong>跟严重 <strong>Bug</strong>的区别？</h4><ol><li>致命 Bug:导致系统崩溃，数据丢失，卡死，闪退，数据库死锁，一般这种类型的，我们都会标注为致命 Bug</li><li>严重 Bug:功能没有实现，主流程走不通，功能有严重问题不能正常使用，这种，我们一般会标注为严重 Bug</li></ol></li></ol></li><li><h3 id="bug的优先级"><a href="#bug的优先级" class="headerlink" title="bug的优先级"></a>bug的优先级</h3><ol><li>优先，高、中、低         &#x2F;      禅道中对应为 1、2、3、4</li><li>优先级别高的不一定优先处理，但是bug级别高的一定优先处理的</li></ol></li><li><h3 id="提-Bug需要注意哪些问题？"><a href="#提-Bug需要注意哪些问题？" class="headerlink" title="提 Bug需要注意哪些问题？"></a>提 <strong>Bug</strong>需要注意哪些问题？</h3><ol><li><p>不要急着提交，先做一下复现，进行证实，如果需要的话，也可以使用不用的版本测试对比一下</p></li><li><p>简单明了的概括 bug 标题，清晰的描述 bug 重现步骤，分析bug 和预期正确结果，附加 bug 的截图或者日志。描述 bug 的时候。</p></li><li><p>在不能确认该情况是否为bug 的时候，可以请教其他人。</p></li><li><p>提交完bug 以后，后面还要跟进bug。</p></li><li><p>bug单内容注意的地方:</p><ol><li>Bug标题要简明扼要的表述清楚</li><li>Bug的级别（严重级别，优先级别）</li><li>内容:操作步骤（一定要描述清楚，以便开发可以复现）,预期结果，实际结果</li><li>最好，把截图，日志相关的信息一并的提交（方便开发定位）</li><li>测试环境（如：浏览器google,华为手机上）</li><li>属于哪个产品，模块的</li></ol></li></ol></li><li><h3 id="测试过程中bug比较多的原因"><a href="#测试过程中bug比较多的原因" class="headerlink" title="测试过程中bug比较多的原因"></a>测试过程中bug比较多的原因</h3><ol><li>开发的经验不足</li><li>需求的不明确</li><li>程序本身的错误</li><li>人与人之间交流不够</li><li>需求的不断变化</li><li>工期紧、任务重、时间压力大</li><li>参与人员的过度自信</li></ol></li><li><h3 id="如果系统快上线了，临时发现了一个bug怎么处理？"><a href="#如果系统快上线了，临时发现了一个bug怎么处理？" class="headerlink" title="如果系统快上线了，临时发现了一个bug怎么处理？"></a>如果系统快上线了，临时发现了一个bug怎么处理？</h3><ol><li>首先看bug级别，如果不严重，影响不到项目功能的，先于组长沟通，等上线了再优化</li><li>如果是一个严重的bug 赶紧找自己的领导，让领导去找项目经理看项目经理的决定</li></ol></li><li><h3 id="在工作中遇到棘手的问题是怎么解决的？"><a href="#在工作中遇到棘手的问题是怎么解决的？" class="headerlink" title="在工作中遇到棘手的问题是怎么解决的？"></a>在工作中遇到棘手的问题是怎么解决的？</h3><ol><li>需求不完整：找产品进行确认需求，让他完善需求</li><li>bug不能被开发承认：先从需求中找证据，证明是一个bug，如果开发还是不承认，这时候再找产品确认（拉上产品与开发对接），还是不承认，反馈给测试组长</li></ol></li><li><h3 id="你提交的-Bug开发不认可的话，如何解决？提皮球，扯皮！"><a href="#你提交的-Bug开发不认可的话，如何解决？提皮球，扯皮！" class="headerlink" title="你提交的 Bug开发不认可的话，如何解决？提皮球，扯皮！"></a>你提交的 <strong>Bug</strong>开发不认可的话，如何解决？提皮球，扯皮！</h3><ol><li>首先我要了解开发不认可的原因，如果是需求理解不一致的问题，首先我会再看需求文档，是不是我的理解有误，如果是我对需求理解错的话我就去关闭 bug，如果还是觉得没有问题，那就找产品确认需求，然后再与开发沟通</li><li>如果是其他问题，一般会再去让身边的同看看听下他们的意见，然后自己先再三去复测，并且保存好截图和日志，确定这是一个 bug之后我就去跟开发说明白，并且给他看bug 重现的截图以及日志。如果开发还是不认可的话我就跟产品或项目经理说明白情况</li></ol></li><li><h3 id="和开发是怎么沟通的"><a href="#和开发是怎么沟通的" class="headerlink" title="和开发是怎么沟通的"></a>和开发是怎么沟通的</h3><ol><li>一般我在提 bug 的时候跟开发沟通最多，比如有一些不清晰的内容会去问开发，还有提完 bug 后会跟踪 bug 的进度，提醒开发尽快修复 bug，还有测接口的时候去找开发拿接口文档，其实我们的工作跟开发都是息息相关的所以都经常都会有沟通的</li></ol></li><li><h3 id="系统上线了发现了一个严重的bug怎么办？"><a href="#系统上线了发现了一个严重的bug怎么办？" class="headerlink" title="系统上线了发现了一个严重的bug怎么办？"></a>系统上线了发现了一个严重的bug怎么办？</h3><ol><li>回滚上个版本，再对这个版本进行测试，测试通过再发布</li></ol></li><li><h3 id="线上环境发现bug你们是怎么处理的"><a href="#线上环境发现bug你们是怎么处理的" class="headerlink" title="线上环境发现bug你们是怎么处理的"></a>线上环境发现<strong>bug</strong>你们是怎么处理的</h3><ol><li>第一步需要到测试环境里面重现一下，看下是环境配置不一致的问题，还是代码漏提交了，需要要到客户的操作场景和数据分析这个 bug的严重级别，影响范围，bug 比较严重，立马修复，修改后，测试回归验证通过，打补丁，bug影响不大，放到下一个版本修改</li></ol></li><li><h3 id="软件终止的标准"><a href="#软件终止的标准" class="headerlink" title="软件终止的标准"></a>软件终止的标准</h3><ol><li>公司倒闭</li><li>达到了规定的时间</li><li>开发过程中偏离了需求的定位</li><li>预算超出了规定的值</li><li>执行完了所有的测试用例</li></ol></li><li><h3 id="测试中有哪些风险（如何把控风险）"><a href="#测试中有哪些风险（如何把控风险）" class="headerlink" title="测试中有哪些风险（如何把控风险）"></a>测试中有哪些风险（如何把控风险）</h3><ol><li><p>测试人员需求理解上面有偏差</p></li><li><p>测试人员水平不够，测试人员覆盖点不全</p></li><li><p>测试人员时间不够，导致测试完不成</p></li><li><p>测试环境上面不足，导致测试点不能完全测试完成</p></li></ol></li><li><h3 id="测试计划主要包含哪些内容"><a href="#测试计划主要包含哪些内容" class="headerlink" title="测试计划主要包含哪些内容"></a>测试计划主要包含哪些内容</h3><ol><li><p>内容</p><ol><li>目的和范围</li><li>规程</li><li>测试方案和方法</li><li>测试的准入和准出</li><li>测试计划(流程、时间安排、对应人员)</li><li>测试的环境配置和人员安排</li><li>交付件</li></ol></li><li><p>例外一种回答：</p><ol><li>我们公司之前按照考核要求写过测试计划，不过后面老大觉得太耽误工作进度，后面一般都不再写测试计划，而是写版本计划。这个在版本计划， 每个人的任务列出来，负责人列出来，自己根据自己的情况分配时间，然后汇总，大家一起开个小会评审就可以了</li></ol></li><li><p>测试的范围，测试目标，人员分配，环境配置，里程碑，测试周期，测试策略，风险分析</p></li></ol></li><li><h3 id="测试计划制定"><a href="#测试计划制定" class="headerlink" title="测试计划制定"></a><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/">测试计划制定</a></h3></li><li><h3 id="有没有写过测试报告，测试报告主要包含哪些内容"><a href="#有没有写过测试报告，测试报告主要包含哪些内容" class="headerlink" title="有没有写过测试报告，测试报告主要包含哪些内容?"></a>有没有写过测试报告，测试报告主要包含哪些内容?</h3><ol><li>没有写过测试报告的，一般就是把整个测试过程的数据统计出来，做成报告，包括用例执行的情况，测试了哪些模块，用了多少用例，自动化用例的通过率，自动化跑了多少模块， 执行的用例是否全部通过，发现了多少 bug，bug 的严重程度，是否遗漏 bug，测试结论是什么这些。注意用例的执行要全部做完， 报告数据简洁明了，结论要描述全面。</li></ol></li><li><h3 id="开发怎么转测"><a href="#开发怎么转测" class="headerlink" title="开发怎么转测"></a>开发怎么转测</h3><ol><li>我们这边的话，是按模块的优先级来的，优先级高的先提测，首先开发做单元测试，测试通过后会把测试报告给我们，同时将源码上传到 SVN，我们确认单元报告没问题，再从 SVN 检出来，进行一轮冒烟测试，冒烟测试通过，就开始全量测试。</li></ol></li><li><h3 id="如果时间比较紧的话，你怎么安排你的工作"><a href="#如果时间比较紧的话，你怎么安排你的工作" class="headerlink" title="如果时间比较紧的话，你怎么安排你的工作"></a>如果时间比较紧的话，你怎么安排你的工作</h3><ol><li>首先要评估下风险，比如说，可能我根本做不完，风险太大，那么这个我首先要把风险提出来，给对应的领导，那么我会要求有人协助我完成，需要多少人力来完成</li><li>如果只是说，正常时间完不成，那么我可以提下加班，看加班这个时间段能否完成，如果可以，我会和老大商量，提出加班计划</li><li>如果是其他的，比如说我只需要把优先级高的工作完成，其他工作可以安排到下一个版本去做，那么我就做个计划，把计划给老大说</li></ol></li><li><h3 id="测试如何在各个阶段保证软件质量"><a href="#测试如何在各个阶段保证软件质量" class="headerlink" title="测试如何在各个阶段保证软件质量"></a>测试如何在各个阶段保证软件质量</h3><ol><li><p>需求分析阶段：</p><ol><li><p>需求要吃透，多问，多去了解</p></li><li><p>我们要做测试需求分析，并应用相对应的方法论，还要进行需求串讲</p></li><li><p>测试需求分析的方法：分解功能点，然后对每一个功能点进行需求规则的分析。分析的方法有：</p><ol><li>输入划分</li><li>质量模型分析（功能、性能、安全、易用性、稳定性等各个维度）</li><li>功能交互分析</li><li>用户关联图分析</li></ol></li></ol></li><li><p>测试计划</p><p> 计划影响的是执行，计划需要根据实际情况来做，计划一旦制定就需要尽量的按照这个计划执行。</p></li><li><p>用例设计</p><ol><li>所有功能点和需求规则都要被覆盖，</li><li>应多考虑业务层面的测试用例，安全、性能等各种非功能层面也应该考虑。</li><li>多考虑测试场景与结果检查</li><li>应对测试用例进行评审</li></ol></li><li><p>测试准备：</p><ol><li>测试环境应该要尽可能的接近真实环境</li><li>测试环境应该能够包含各种测试场景</li><li>测试数据应该尽可能真实，也包含了各种能够覆盖场景的测试数据</li></ol></li><li><p>测试执行：</p><ol><li>用例要 100%的执行，不能够放过任何一个测试用例或测试场景</li><li>测试的轮次安排，应安排</li><li>轮测试。每一轮测试重点应该不一样。</li><li>引用缺陷管理工具，标准化缺陷管理流程，规范开发与测试对缺陷的管理</li><li>及时跟踪Bug</li></ol></li><li><p>测试管理相关：</p><ol><li>编写测试日报，定期向团队汇报测试进展以及问题及风险</li><li>为了让文档的管理变得更规范，应引入SVN进行配置管理</li></ol></li></ol></li><li><h3 id="你怎样快速上手公司的项目"><a href="#你怎样快速上手公司的项目" class="headerlink" title="你怎样快速上手公司的项目"></a>你怎样快速上手公司的项目</h3><ol><li>熟悉数据流的走向</li><li>业务的逻辑</li><li>数据的验证</li></ol></li><li><h3 id="质量体系：cmmi模型，衡量公司级别"><a href="#质量体系：cmmi模型，衡量公司级别" class="headerlink" title="质量体系：cmmi模型，衡量公司级别"></a>质量体系：cmmi模型，衡量公司级别</h3><ol><li>初始级</li><li>可管理级</li><li>已定义级</li><li>量化管理级</li><li>优化管理级</li></ol><p> 一般公司都在3级，5级一般都是买的</p></li><li><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ol><li>公司中一次性开发的功能点比较多的时候，会分批次进行开发，这样的开发模式成为迭代</li><li>迭代的周期：1-2周&lt;小迭代&gt;   2-3月&lt;大迭代&gt;</li><li><h2 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h2><ol><li><h5 id="螺旋模型："><a href="#螺旋模型：" class="headerlink" title="螺旋模型："></a>螺旋模型：</h5><ol><li><img src="/assets/image-20211122114847-u3g4kke.png" alt="image.png"></li><li>1、需求开始，2、确认方案，3、支出风险并解决，4、评估方案，5、本阶段开发测试，6、计划下一阶段，7、进入下一阶段</li></ol></li><li><h5 id="V模型："><a href="#V模型：" class="headerlink" title="V模型："></a>V模型：</h5><ol><li><img src="/assets/image-20211203161103-lhdu2tl.png" alt="image.png"></li></ol></li><li><h5 id="瀑布模型以及其他：-迭代模型"><a href="#瀑布模型以及其他：-迭代模型" class="headerlink" title="瀑布模型以及其他： 迭代模型"></a>瀑布模型以及其他： <a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B/">迭代模型</a></h5></li></ol></li></ol></li><li><h3 id="敏捷测试"><a href="#敏捷测试" class="headerlink" title="敏捷测试"></a>敏捷测试</h3><ol><li><p>快速迭代，产品通过短期的迭代互通不断迭代产品</p></li><li><p>快速尝试，避免长时间的需求调研和分析</p></li><li><p>快速改进，产品上线后根据用户反馈的问题，进行快速的改进</p></li><li><p>充分交流：每天早上有一个简短的战略会，沟通一下工作的进展和安排</p></li><li><p>简化流程：丢掉一些形式的东西，使用简单应用的工具开始工作</p></li></ol></li><li><h3 id="软件架构：b-x2F-s-c-x2F-s"><a href="#软件架构：b-x2F-s-c-x2F-s" class="headerlink" title="软件架构：b&#x2F;s    c&#x2F;s"></a>软件架构：b&#x2F;s    c&#x2F;s</h3><ol><li><h5 id="b-x2F-s架构"><a href="#b-x2F-s架构" class="headerlink" title="b&#x2F;s架构"></a>b&#x2F;s架构</h5><ol><li>b表示浏览器；s表示服务器、展示以www形式</li><li>在浏览器中打开，不占用客户的资源</li><li>升级为自动升级</li><li>可以跨平台</li></ol></li><li><h5 id="c-x2F-s架构"><a href="#c-x2F-s架构" class="headerlink" title="c&#x2F;s架构"></a>c&#x2F;s架构</h5><ol><li>c表示客户端；s表示服务器   以图标形式展示</li><li>在电脑桌面中打开，占用客户的资源</li><li>升级为手动升级</li><li>不可以跨平台，只能在windows系统使用</li></ol></li></ol></li><li><h3 id="测试分为三轮："><a href="#测试分为三轮：" class="headerlink" title="测试分为三轮："></a>测试分为三轮：</h3><ol><li>第一轮：初级测试(冒烟测试)：针对开发出来的前端页面的主功能测试</li><li>第二轮：系统测试：细测，性能，安全，兼容性</li><li>第三轮：回归测试：对稳定性的测试；最后一个阶段bug相对比较少</li></ol></li><li><h3 id="是否了解SVN"><a href="#是否了解SVN" class="headerlink" title="是否了解SVN"></a>是否了解SVN</h3><ol><li><p>SVN管理项目中产生的所有文档：</p><ol><li>开发的代码，测试计划，测试用例，产品需求，bug单，测试报告，测试总结，（一个人一个账号，根据权限显示对应的内容）</li></ol></li><li><p>SVN的作用：数据的迁入迁出</p></li></ol></li><li><h3 id="抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler"><a href="#抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler" class="headerlink" title="抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler"></a>抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler</h3><ol><li>对于某些难以定位的一些问题，一般我利用 fiddler 的抓包工具，去抓取前后台的数据交互的过程， 通过分析请求的数据来判断是前端还是后台的问题</li><li>首先看发的请求是否有问题，请求的接口 url 是否有错误，参数是否有错误，如果 url 或传参有问题那就是前端 Bug</li><li>如果请求没有问题，看下后台返回的数据是否有问题，状态码 5 开头的基本都是后台问题，状态码为200，响应数据与预期不一致，那也是后台Bug。</li><li>返回的数据没有问题，请求参数，url 也没有问题，那可能是前端代码是否转换有问题，那就是前端 Bug。</li></ol></li><li><h3 id="你们上家公司的测试策略是怎么样的？"><a href="#你们上家公司的测试策略是怎么样的？" class="headerlink" title="你们上家公司的测试策略是怎么样的？"></a>你们上家公司的测试策略是怎么样的？</h3><ol><li>上一家公司的测试策略基本是这样的，系统已经做好的模块功能，要全测，先测优先级高的用例，上午发现的 bug，下午就要修改完成，回归通过，下午发现的bug，第二天上午就得回归通过,时间挺紧的， 而且第一轮测试还要把所有用例执行完，（如果有自动化，第一轮还要用自动化覆盖所有老用例，在测试环境上执行，而且自动化通过率至少要 90%以上）</li><li>第二轮测试呢，要把上轮测试未通过的，补充的用例重新测试，确认所有的缺陷都已经改正才行，然后就要把上一轮bug最多的功能再测一遍，自动化也要重新跑一遍，在测试环境上执行，通过率必须 100%， 就这么多了</li></ol></li><li><p>对于测试环境实际进行的测试内容为：</p><p> a.DEV环境：  Development environment   主体是开发厂商自己进行，包括了单元测试+接口集成测试+业务模块功能点的系统测试。</p><p> b.SIT环境：  SystemIntegrationTesting     可以是整体集成商牵头进行，包括接口集成测试+系统测试，但是全为黑盒测试。</p><p> c.UAT环境：  UserAcceptanceTesting      以甲方用户牵头进行，也是只进行系统测试，以端到端流程和业务场景驱动进行测试。</p><p> d.PRD&#x2F;PROD环境：线上环境，生产环境</p></li><li><h2 id="在工作中接触的文档"><a href="#在工作中接触的文档" class="headerlink" title="在工作中接触的文档"></a>在工作中接触的文档</h2><ol><li>需求文档   详设文档  测试用例   测试大纲  bug单   测试报告  测试总结  测试计划</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 测试概念总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>登录</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%99%BB%E5%BD%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<ul><li><p>需求</p><ul><li><img src="/assets/image-20211120214210-0675h05.png" alt="image.png"></li><li><img src="/assets/image-20211120214217-er5hgua.png" alt="image.png"></li></ul></li><li><p>xmind编写</p><ul><li><p>关闭按钮</p></li><li><p>账号密码登录</p><ul><li><p>正向功能验证</p><ul><li>正确的手机号+正确的密码+点击登录      登陆成功</li><li>正确的邮箱+正确的密码+点击登录        登陆成功</li></ul></li><li><p>头像</p><ul><li><p>展示</p><ul><li>账号空白时    展示默认头像</li><li>输入修改头像的已注册账号时     展示自定义头像</li><li>输入未注册账号时  展示默认头像</li><li>输入未修改头像已注册账号时  展示默认头像</li></ul></li></ul></li><li><p>账号</p><ul><li><p>手机号</p><ul><li>账号输入10位数字，输入符合要求的密码，点击登录 提示：手机号错误</li><li>账号输入12位数字，输入符合要求的密码，点击登录    提示：手机号错误</li><li>账号输入11位包含非数字，输入符合要求的密码，点击登录   提示：用户名或者密码错误</li><li>输入未注册的手机号+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li><li>输入空值+输入符合要求的密码+点击登录 提示：账号不能为空</li></ul></li><li><p>邮箱</p><ul><li>输入错误的邮箱格式+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li><li>输入没有注册的邮箱+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li></ul></li></ul></li><li><p>密码</p><ul><li>输入正确的账号+输入5位密码+点击登录   登录按钮置灰不可点击</li><li>输入正确的账号+输入7位密码+点击登录   提示：用户名或者密码错误</li></ul></li><li><p>忘记密码？</p></li><li><p>登录</p><ul><li>弱网    展示正在加载图标</li><li>断网      断网提示</li><li>频点登录    提示：频繁登录</li></ul></li><li><p>验证码快捷登录</p></li><li><p>海外手机号登录</p></li></ul></li><li><p>验证码快捷登录</p></li><li><p>第三方登录</p></li><li><p>海外手机号登录</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 登录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试执行</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/07_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/07_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 软件测试执行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试用例设计</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><p><a href="../03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">黑盒测试</a></p></li><li><p>测试用例是什么样的<br><img src="/assets/image-20211203142629-2n42d14.png" alt="测试用例是什么样的"></p></li><li><p>目的</p><ul><li>绕不过的面试题</li><li>测试人员必备技能</li></ul></li><li><p>测试用例</p><ul><li>测试用例是为了发现软件存在的问题编写的一组包含测试输入、执行条件以及预期结果的文档，用来核实软件产品是否满需求</li><li><img src="/assets/image-20211120151028-c13v85v.png" alt="image.png"></li></ul></li><li><p>测试用例的目的</p><ul><li>理清思路，避免漏测和重测</li><li>提高测试效率</li><li>跟进测试进度</li><li>告诉领导做过什么</li><li>跟进重复性工作</li><li>更好的记录问题，发现问题，复现问题</li></ul></li><li><p>测试用例的组成</p><ul><li>用例编号<br>模块<br>测试标题<br>前置条件<br>操作步骤<br>预期结果<br>实际结果</li></ul></li><li><p>测试用例编写工具</p><ul><li>ximnd：思维导图工具<br>插入子主题：tab<br>插入兄弟主题（后面）：enter<br>插入兄弟主题（前面）：shift+enter</li><li>Excel</li></ul></li><li><p>测试用例编写方法</p><ul><li>划分功能模块<br>正向功能验证：正确的操作功能是否实现<br>单个功能项验证：正向+异常<br>功能之间交互验证：模块之间的数据传递<br>隐形需求：熟悉业务</li></ul></li><li><p>输入项设计要点</p><ul><li>数据长度验证<br>数据类型验证<br>是否必填项验证<br>限制约束验证</li></ul></li><li><p><a href="../06_%E7%99%BB%E5%BD%95/">实战：登录</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 测试用例设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试种类划分</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%88%92%E5%88%86/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>软件测试方法种类繁多，记忆起来混乱， 如果把软件测试方法进行分类, 就会清晰很多。 我参考一些书籍和网上的资料， 把常用的软件测试方法列出来， 让大家对软件测试行业有个总体的看法。</p><h1 id="从测试设计方法分类"><a href="#从测试设计方法分类" class="headerlink" title="从测试设计方法分类"></a><strong>从测试设计方法分类</strong></h1><table><thead><tr><th>测试名称</th><th>测试内容</th></tr></thead><tbody><tr><td>Black box黑盒测试</td><td>把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试.</td></tr><tr><td>White box白盒测试</td><td>设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。</td></tr><tr><td>Gray box.灰盒测试</td><td>介于黑盒和白盒之间</td></tr></tbody></table><p>总结：   实际工作中，对系统的了解越多越好。目前大多数的测试人员都是做黑盒测试，很少有做白盒测试的。 因为白盒测试对软件测试人员的要求非常高，需要有很多编程经验。做.NET程序的白盒测试你要能看得懂.NET代码。做JAVA程序的测试，需要你能看懂JAVA的代码。 如果你都能看懂了，你还会做测试么</p><h1 id="从测试是手动还是自动上分类"><a href="#从测试是手动还是自动上分类" class="headerlink" title="从测试是手动还是自动上分类"></a><strong>从测试是手动还是自动上分类</strong></h1><table><thead><tr><th>测试名称</th><th>测试内容</th></tr></thead><tbody><tr><td>Manual Test手动测试</td><td>测试人员用鼠标去手动测试（测试GUI）</td></tr><tr><td>Automation自动化测试</td><td>用程序测试程序（测试API）</td></tr></tbody></table><p>对于项目来说， 手动测试和自动化测试同等重要，都是保障软件质量的方法。 目前大部分的项目组都是手动测试和自动化测试相结合。因为很多测试无法做成自动化，很多复杂的业务逻辑也很难自动化， 所以自动化测试无法取代手动测试。</p><p>对于软件测试人员个人发展来说， 做自动化测试是个挑战，也是测试人员发展的一个方向，  需要测试人员学习大量的开发知识（开发的知识真是学无止境啊）。 从长远角度来看，自动化测试肯定是越来越吃香的。</p><p>而手动测试比较适合刚工作不久的人，手动测试最大的缺点就是技术含量低，单调乏味，容易废人。</p><p>总的来说，手工测试胜在测试业务逻辑，而自动化测试胜在测试底层架构。</p><p>如果被测试的程序可测试性比较好， 很有必要做成自动化测试。 能做自动化的尽量做成自动化， 下面这些情形是可以做自动化的</p><ol><li>测试存储过程。  例如用C#去测试存储过程</li><li>测试Web servies. 例如： 用SoupUI工具，或者C#,Java 去测试Web servies。</li><li>界面和业务逻辑分离的系统，比如，MVC，MVP架构， 或者WPF 程序。 可以用测试脚本去测试这些程序的API。</li></ol><h1 id="从测试的目的分类"><a href="#从测试的目的分类" class="headerlink" title="从测试的目的分类"></a><strong>从测试的目的分类</strong></h1><p>功能测试</p><p>测试的范围从小到大，从内到外， 从程序开发人员（单元测试）到测试人员，到一般用户Alpha&#x2F;Beta测试</p><table><thead><tr><th>测试名称</th><th>测试内容</th></tr></thead><tbody><tr><td>Unit Test 单元测试</td><td>在最低的功能&#x2F;参数上验证程序的准确性,比如测试一个函数的正确性(开发人员做的)</td></tr><tr><td>Functional Test功能测试</td><td>验证模块的功能（测试人员做的）</td></tr><tr><td>Integration Test集成测试</td><td>验证几个互相有依赖关系的模块的功能（测试人员做的）</td></tr><tr><td>Scenario Test场景测试</td><td>验证几个模块是否能完成一个用户场景（测试人员做的）</td></tr><tr><td>System Test系统测试</td><td>对于整个系统功能的测试（测试人员做的）</td></tr><tr><td>Alpha测试</td><td>软件测试人员在真实用户环境中对软件进行全面的测试（测试人员做的）</td></tr><tr><td>Beta测试</td><td>真实的用户在真实的用户环境中进行的测试, 也叫公测   （最终用户做的）</td></tr></tbody></table><p> </p><p>非功能测试</p><p>一个软件除了基本功能之外，还有很多功能之外的特性，这些叫“Quality of Service requirement”服务质量需求。没有软件的功能，这些特性都无从表现出来，因此，我们要在软件开发的适当阶段-基本功能完成后做这些测试。</p><table><thead><tr><th>测试名称</th><th>测试内容</th></tr></thead><tbody><tr><td>Stress test压力测试</td><td>验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃</td></tr><tr><td>Load test负载测试</td><td>测试软件在负载情况下能否正常工作</td></tr><tr><td>Performance test性能测试</td><td>测试软件的效能，是否提供满意的服务质量</td></tr><tr><td>Accessibility test</td><td>软件辅助功能测试-测试软件是否向残疾用户提供足够的辅助功能</td></tr><tr><td>Localization&#x2F;Globalization</td><td>本地化&#x2F;全球化测试</td></tr><tr><td>Compatibility Test</td><td>兼容性测试</td></tr><tr><td>Configuration Test</td><td>配置测试-测试软件在各种配置下能否正常工作</td></tr><tr><td>Usability Test</td><td>可用性测试–测试软件是否好用</td></tr><tr><td>Security Test</td><td>软件安全性测试</td></tr></tbody></table><p>性能测试</p><p>性能测试要求测试人员熟练性能测试工具，比如QTP, LoadRunner, Jmeter。  Visual Studio也提供了很多性能测试的工具. 要求测试人员对低层协议非常理解和编写脚本</p><p>性能测试非常有技术含量， 很有发展前途， 是软件测试人员的一个职业发展方向。</p><p>安全性测试</p><p>安全性测试的内容很广， 非常有难度啊。 我只接触过XSS（跨站脚本攻击）和SQL注入攻击。</p><p>安全性测试非常有技术含量， 我认为也是软件测试人员的一个职业发展方向</p><p>按测试的时机和作用分类</p><p>在开发软件的过程中，不少测试起着“烽火台”的作用，它们告诉我们软件开发的流程是否畅通。</p><table><thead><tr><th>测试名称</th><th>测试内容</th></tr></thead><tbody><tr><td>Smoke Test</td><td>“冒烟”–如果测试不通过，则不能进行下一步工作</td></tr><tr><td>Build Verification Test（BVT）</td><td>验证构建是否通过基本测试。</td></tr><tr><td>Acceptance Test</td><td>验收测试，为了全面考核某功能&#x2F;特性而做的测试</td></tr></tbody></table><p>BVT测试是一种Smoke Test, 指Build生成好之后，自动运行的自动化测试脚本来检查这个Build的基本功能。 如果BVT测试失败了，需要开发人员马上修改，重新生成Build</p><p>按测试测策略分类。</p><table><thead><tr><th>测试名称</th><th>测试内容</th></tr></thead><tbody><tr><td>Regression Test回归测试</td><td>对一个新的版本，重新运行以往的测试用例，看看新版本和已知的版本相比是否有退化(regression)</td></tr><tr><td>Ad hoc Test探索性测试</td><td>随机进行的，探索性的测试。</td></tr><tr><td>Sanity Test</td><td>粗略的测试，只需要执行部分的测试用例</td></tr></tbody></table><p>Regression Test 回归测试：　　</p><p>对软件测试人员来说就是重复测试，所以回归测试最好是自动化的，　否则测试人员就要一遍又一遍地重复测试，　</p><ol><li>开发人员做些小改动，就需要测试人员做回归测试。确保现有的功能没有被破坏</li><li>Bug Fix 也需要回归测试，确保新的代码修复了Fix, 也确保现有的功能没有被破坏</li><li>项目后期，需要做一个完整回归测试， 确保所有的功能都是好的</li></ol><p>Ad hoc Test 探索性测试：</p><p>平常我最喜欢做随机测试了， 抛开test case.  自己按照自己的思路，随便点点。 如果测试GUI，Ad hoc能发现大量的bug.</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 基础 </category>
          
          <category> 测试种类划分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试的分类</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/wpsEE47.tmp-20211120145802-z73wzpx.jpg"></p><ul><li><p>按开发阶段分类</p><ul><li><p>单元测试</p><ul><li>模块测试，最小单位的测试</li></ul></li><li><p>集成测试</p><ul><li>把单元的小模块组合起来进行的测试</li><li>测试不同模块接口的测试</li></ul></li><li><p>系统测试 ———————–把系统看成一个整体进行的测试</p><ul><li>功能测试</li><li>兼容性测试</li><li>性能测试</li><li>安全测试</li></ul></li><li><p>验收测试</p><ul><li>α测试   内测的一个版本测试</li><li>β测试   公测的一个版本测试</li></ul></li></ul></li><li><p>按是否查看代码</p><ul><li>白盒测试</li><li><a href="../03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">黑盒测试</a></li><li>灰盒测试</li></ul></li><li><p>按测试执行方式</p><ul><li>静态测试</li><li>动态测试</li></ul></li><li><p>按是否手工执行划分</p><ul><li>手动测试</li><li>自动化测试</li></ul></li><li><p>其他分类</p><ul><li>冒烟测试     快速验证主要功能的测试</li><li>回归测试</li><li>随机测试</li><li>探索性测试    随机测试的升级版，测试的一种思维方式，强调遇到问题之后，改变测试策略，能够发现更加深入的问题，是未来测试发展的一个领域</li></ul></li></ul><p><a href="../04_%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%88%92%E5%88%86/">测试种类划分</a></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 基础 </category>
          
          <category> 软件测试的分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑盒测试</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul><li>定义：</li><li>目的</li><li>优点</li><li>测试用例</li></ul><h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><ul><li><p>定义</p><ul><li>黑盒测试是从一种从软件外部对软件实施的测试，也成功能测试</li><li>不考虑内部结构，只考虑输入与输出的测试</li><li><img src="/assets/image-20211120150914-c5nxlpa.png" alt="image.png"></li></ul></li><li><p>目的</p><ul><li>黑盒测试是从用户观点出发的测试，其目的是尽可能发现软件的外部行为错误。在已知软件产品功能的基础上：<br>检测软件功能能否按照需求文档的规定正常工作，是否有功能遗漏；<br>检测是否有人机交互错误，是否有数据结构和外部数据库访问错误，是否能恰当地接收数据并保持外部信息等的完整性<br>检测行为、性能等特性是否满足要求等；<br>检测程序初始化和终止方面的错误等；</li></ul></li><li><p>优点</p><ul><li>黑盒测试与软件具体实现无关，所以如果软件实现发生了变化，测试用例仍然可以使用；</li><li>设计黑盒测试用例可以和软件实现同时进行，因此可以压缩项目总的开发时间</li></ul></li><li><p>测试用例</p><ul><li><p>测试用例概念</p><ul><li>测试用例（testcase）是指对一项特定的软件进行测试任务的描述、体现测试方案、方法、技术和策略</li><li>简单地认为，测试用例是为了发现软件存在的问题编写的一组包含测试输入、执行条件以及预期结果的文档，用来核实软件产品是否满需求</li><li><img src="/assets/image-20211120151028-c13v85v.png" alt="image.png"></li></ul></li><li><p>测试用例的作用</p><ul><li><p>指导测试的实施</p></li><li><p>规划测试数据的准备</p></li><li><p>编写测试脚本的“设计规格说明书”</p></li><li><p>评估测试结果的度量基准</p></li><li><p>分析缺陷的标准</p><ul><li>bug</li></ul></li></ul></li><li><p>使用测试用例的好处</p><ul><li>避免盲目测试并提高测试效率</li><li>令软件测试的实施重点突出、目的明确</li><li>软件版本更新后只需修正少部分的测试用例便可展开测试工作</li><li>测试用例的通用化和复用化则会使软件测试易于开展</li></ul></li><li><p>测试用例的内容</p><ul><li>版本号<br>项目名称<br>模块名称<br>用例编号<br>用例名称<br>用例级别<br>前置条件<br>测试步骤<br>期望结果<br>测试结果<br>测试时间<br>测试人员</li></ul></li><li><p>((20211203110629-z3n01go “测试用例简介”))</p></li><li><p>输入内容的分类：字母+数字+特殊字符+汉字   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;   字符</p></li><li><p>常见黑盒测试用例设计方法</p><ul><li><p>等价类</p><ul><li><p>定义：等价类是指输入域的某个互不相交的子集集合，所有等价类的并集便是整个输入域</p></li><li><p>分类</p><ul><li>有效等价类      符合需求说明，合理地输入数据集合</li><li>无效等价类      不符合需求说明，无意义的输入数据的集合</li><li><img src="/assets/image-20211120151741-y3xtcn5.png" alt="image.png"></li></ul></li><li><p>等价类划分方法</p><ul><li><p>输入条件规定了取值范围或值的个数：确定一个有效等价类和两个无效等价类</p></li><li><p>输入条件规定了输入值的集合：确定一个有效等价类和一个无效等价类</p><ul><li><p>只允许输入汉字</p><ul><li>有效等价类：汉字</li><li>无效等价类：字母、数字、特殊字符</li></ul></li></ul></li><li><p>输入条件是一个布尔值：可以确定一个有效等价类和一个无效等价类   True&#x2F;FALSE（真&#x2F;假）</p></li><li><p>输入条件规定必须遵循某种规则：确定一个有效等价类和若干个无效等价类</p></li><li><p>在规定了输入数据的一组值（假定N个），并且程序要对每个输入值分别处理：可以确立N个有效等价类和一个无效等价类——-先不理解</p></li></ul></li><li><p>等价类划分用例设计步骤</p><ul><li>为每一个等价类规定一个唯一的编号</li><li>设计一个心得测试用例，尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步，直到测试用例覆盖了所有的有效等价类</li><li>设计一个新的测试用例，使其覆盖并只覆盖一个没有被覆盖的无效等价类。重复这一步，直至测试用例覆盖了所有的无效等价类</li></ul></li><li><p>练习</p><ul><li>问题：两位整数加法计数器<br>第一个数和第二个数都只能输入-99到99之间的整数<br>对于输入小于-99得数据或者大于99的数据，系统应该给出明确提示<br>对于输入小数、字符等非法数据，系统应该给出明确提示</li><li><img src="/assets/image-20211120151946-pg5vfr8.png" alt="image.png"></li><li><img src="/assets/image-20211120151957-ot0ftmq.png" alt="image.png"></li><li><img src="/assets/image-20211120152002-7y5g4a5.png" alt="image.png"></li></ul></li></ul></li><li><p>边界值</p><ul><li><p>定义：大量的软件测试时间证明，故障往往出现在定义域或值域的边界上，而不是在其内部</p></li><li><p>边界：是一些特殊情况，程序在处理大量中间数值时都是正确，但是在边界处可能出现错误，边界条件就是软件计划的操作界限所在的边缘条件</p></li><li><p>边界值选取方法</p><ul><li>选取正好等于、刚刚大于或者刚刚小于等价类边界值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据</li><li><img src="/assets/image-20211120152045-xkqwjfz.png" alt="image.png"></li></ul></li><li><p>边界值分析测试</p><ul><li>最小值（min）</li><li>稍大于最小值（min+）</li><li>域内任意值（nom）</li><li>稍小于最大值（max-）</li><li>最大值（max）</li></ul></li><li><p>健壮性边界值测试</p><ul><li>健壮性测试是边界值分析的一种扩展</li><li>变量除了取min、min+、nom、max-、max五个边界值外，还要考虑采用一个略超过最大值（max+）以及一个略小于最小值（min-）的取值，看看超过极限值时系统会出现什么情况</li></ul></li><li><p>边界值分析原则</p><ul><li>如果输入条件对取值范围进行了限定，则应以边界内部以及刚刚超出范围边界外的值作为测试用例</li><li>对于输入条件，同样可以应用上面提到的两条原则来进行测试用例设计</li><li>如果程序规格说明书中指明输入或者输出域是一个有序的集合，如顺序文件、表格等，则应注意选取有序集合中的第一个和最后一个元素作为测试用例</li></ul></li></ul></li><li><p>错误推断法</p><ul><li>定义： 指利用直觉和经验猜测出出错的可能类型，有针对性的列举出程序中所有可能的错误和容易发生错误的情况</li><li>列举出可能犯的错误或错误容易发生的清单，然后根据清单编写测试用例</li></ul></li><li><p>场景分析法</p></li><li><p>因果图</p></li><li><p>判定表</p></li><li><p>正交法</p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 基础 </category>
          
          <category> 黑盒测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试计划</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/image-20211120225648-gfkhwjd.png" alt="image.png"></p><h1 id="软件测试人员如何编写测试计划"><a href="#软件测试人员如何编写测试计划" class="headerlink" title="软件测试人员如何编写测试计划"></a>软件测试人员如何编写测试计划</h1><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>每个公司的测试计划都不尽相同，但每个测试计划包含的主要内容又只有这几点，那我们一起研究一下测试计划的主要内容有哪些？</p><h2 id="测试计划概念"><a href="#测试计划概念" class="headerlink" title="测试计划概念"></a><strong>测试计划概念</strong></h2><p><strong>测试计划（Testing plan）的定义：</strong></p><blockquote><p>描述了要进行的测试活动的范围、方法、资源和进度的文档；<br>是对整个信息系统应用软件组装测试和确认测试。<br>它确定测试项、被测特性、测试任务、谁执行任务、各种可能的风险。<br>测试计划可以有效预防计划的风险，保障计划的顺利实施。</p></blockquote><p><strong>测试计划的目的</strong></p><blockquote><p>（1）为测试各项活动制定一个现实可行的、综合的计划，包括每项测试活动的对象、范围、方法、进度和预期结果。<br>（2）为项目实施建立一个组织模型，并定义测试项目中每个角色的责任和工作内容。<br>（3）开发有效的测试模型，能正确地验证正在开发的软件系统。<br>（4）确定测试所需要的时间和资源，以保证其可获得性、有效性。<br>（5）确立每个测试阶段测试完成以及测试成功的标准、要实现的目标。<br>（6）识别出测试活动中各种风险，并消除可能存在的风险，降低由不可能消除的风险所带来的损失。</p></blockquote><p>编写测试计划，就是为了达到这些目的。</p><p>通过测试计划可以宏观的指导测试的后续工作</p><p><strong>测试计划由谁编写</strong></p><p>测试计划属于管理型文档，是由测试经理、测试主管或测试组长进行编写。</p><p><strong>测试计划编写的6个要素</strong></p><blockquote><p>1）why——为什么要进行这些测试；<br>2) what—测试哪些方面，不同阶段的工作内容；<br>3) when—测试不同阶段的起止时间；<br>4) where—相应文档，缺陷的存放位置，测试环境等；<br>5) who—项目有关人员组成，安排哪些测试人员进行测试<br>6) how—如何去做，使用哪些测试工具以及测试方法进行测试。</p></blockquote><h2 id="测试计划主要内容"><a href="#测试计划主要内容" class="headerlink" title="测试计划主要内容"></a><strong>测试计划主要内容</strong></h2><p><strong>1.项目简介</strong></p><p>项目简介分为项目背景和编写目的。</p><p>主要描述项目实施的背景和为什么要编写测试计划的目的。</p><p><strong>2.参考文档</strong></p><p>描述编写测试计划时的依据。可以用列表的形式梳理出来。</p><p>参考文档 备注</p><p>详细设计</p><p>概要设计</p><p>UI原型图</p><p>接口文档</p><p><strong>3.测试范围</strong></p><p>描述本次测试活动的测试范围。</p><p>可以分为总体的测试范围和主要测试的功能点二个部分。</p><p>例如，本次测试范围为登录模块和注册模块，其中以注册模块为主要测试功能模块。</p><p><strong>4.时间进度安排</strong></p><p>首先描述测试活动的总体时间。</p><p>再描述测试活动的每个不同阶段需要多长时间，具体可以以表格的形式输出。</p><p>例如</p><p>测试阶段 计划开始时间 计划完成时间 备注</p><p>需要分析 2017-11-10 2017-11-13</p><p>需要评审 2017-11-14 2017-11-15</p><p>…… …… ……</p><p><strong>5.资源</strong></p><p>描述本次测试活动需要的人力资源和软硬件资源。</p><p><img src="/assets/image-20211120225709-3ou6vsb.png" alt="image.png"></p><p><strong>6.风险评估</strong></p><p>描述本次测试活动中有可能会产生的风险和解决方案。</p><p>在风险评估中确定风险级别最高的测试对象，优先测试，同时需要考虑的要点有：</p><p>重要性、严重性、原因、可能性</p><p><strong>7.测试交付件</strong></p><p>描述本次测试活动完成后测试部需要输出的文档。</p><p>例如：测试计划，测试方案，用例执行情况表，缺陷，总结测试报告等等</p><p>以上七点在测试计划中需要完全包含，测试计划中包含的主要内容是七点，但由于每个公司的项目和业务都不相同，故测试计划中的实质性内容也不一样，虽然说测试计划可以理解为填空题，但是每个空的答案都不是一样的。</p><p>测试策略在测试计划中可有可无，一般来说测试策略是写测试方案中。这里列出了包含进测试计划的测试策略。</p><p>图片为测试策略包含的主要内容</p><p><img src="/assets/image-20211120225717-b9ur7v7.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 基础 </category>
          
          <category> 测试计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows与linux的区别</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/03_windows%E4%B8%8Elinux%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/03_windows%E4%B8%8Elinux%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Windows和Linux是完全不同的两种操作系统。 Windows是微软公司出的商业操作系统，在全球90%以上的电脑用的都是Windows的操作系统。 Linux是一款开源免费的操作系统，不用掏钱就能用。全球好多服务器用的是这个操作系统。</p><p>做为个人电脑使用，这两种系统对比有什么优缺点呢？ 首先说说Windows。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><img src="/assets/image-20211122224703-cy1k2rz.png" alt="image.png"></p><p>Windows 做为全球使用量第一的操作系统，要说没有优点那是不可能的。 不但有优点，而且还有很多优点，有些优点还是其他操作系统无论如何也追不上的。</p><h3 id="1-不用安装"><a href="#1-不用安装" class="headerlink" title="1. 不用安装"></a>1. 不用安装</h3><p>这个不用安装并不是说不用安装操作系统，而是除了Mac之外，99%以上的个人电脑都是在出厂的时候就安装好了Windows系统， 电脑到手直接使用就行，不用再担心还要安装系统的问题。</p><h3 id="2-容易维修"><a href="#2-容易维修" class="headerlink" title="2. 容易维修"></a>2. 容易维修</h3><p>正是因为Windows是全球使用量第一的操作系统， 所以几乎所有的电脑店里面都是以维修Windows电脑为主。 如果系统出的问题，基本随便到一个电脑店都能解决。</p><h3 id="3-软件和游戏数量极大"><a href="#3-软件和游戏数量极大" class="headerlink" title="3. 软件和游戏数量极大"></a>3. 软件和游戏数量极大</h3><p>Windows全球使用量第一，所以全球开发者数量也很高。 这就造成了Windows上面的软件数量非常非常之大，这点是Linux无论如何也追不上的。 像我们国内常用的QQ，微信等在Linux上就没有， 更不要说像英雄联盟，绝地求生这些游戏了。 在Linux中虽然也能通过Wine安装Windows软件， 但大部分软件都是不兼容的， 而且安装了Wine以后整个系统都不稳定了。</p><h3 id="4-硬件兼容性好"><a href="#4-硬件兼容性好" class="headerlink" title="4. 硬件兼容性好"></a>4. 硬件兼容性好</h3><p>很多硬件的驱动在Windows能很方便的安装，但在Linux的根本就没有。 比如我用的笔记本，在使用Windows系统，WiFi，蓝牙，各种硬件都正常， 但使用Linux系统WiFi是不能用的， 还要自己编译安装驱动程序。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><img src="/assets/image-20211122224710-34agwn3.png" alt="image.png"></p><p>Linux做为开源免费的操作系统，也有些优点是Windows无论如何也赶不上的。</p><h3 id="1-不用花钱"><a href="#1-不用花钱" class="headerlink" title="1. 不用花钱"></a>1. 不用花钱</h3><p>正版的Windows系统是要花钱购买的，而且价钱还不低（买笔记本带Windows系统其实系统钱是包含在里面的）。 而Linux是开源免费的，任何人不用花钱都可以下载使用，而且有多个发行版可供选择。</p><h3 id="2-稳定性-x2F-流畅度高"><a href="#2-稳定性-x2F-流畅度高" class="headerlink" title="2. 稳定性&#x2F;流畅度高"></a>2. 稳定性&#x2F;流畅度高</h3><p>使用Windows系统时不时会出现卡顿，不稳定的问题，但Linux不会。选择一个好的发行版做为个人电脑系统使用的话一般不会出现卡顿的情况。 而且Windows系统长时间使用的话要重启一下，不然可能就没有开机时流畅了。</p><p>在Windows中由于空间不够用都会安装一款清理垃圾文件的软件，Windows系统本身会占用很大的空间，随便安装几个软件系统盘也许就满了。 但在Linux中一般不需要，因为Linux系统本身不会占用多大的磁盘空间，安装软件也都是规范的位置，系统临时目录重启时会自动清理，不会占用大量的磁盘空间。</p><p>在我的使用体验中，Linux的流畅度是比Windows高的。比如我使用的编程软件IDEA，同一台电脑同一块硬盘，在Windows上打开一个项目要3到5秒， 但在Linux（Ubuntu 18.04）中打开同一个项目只要不到1秒。</p><h3 id="4-安全性高"><a href="#4-安全性高" class="headerlink" title="4. 安全性高"></a>4. 安全性高</h3><p>在Windows系统中是一定要安装杀毒软件的。就算你不安装，Windows系统自带的也会启动。但在Linux中不用，因为Linux是一个有严格权限控制的系统，平常使用的时候一般不会使用root用户，就算有恶意脚本也不至于对系统造成大破坏。而且Linux的病毒数量也极少。</p><h3 id="5-可定制性高"><a href="#5-可定制性高" class="headerlink" title="5. 可定制性高"></a>5. 可定制性高</h3><p>由于Linux系统是开源的， 所以每个人都可以下载其源代码进行定制。就算是已经存在的发行版桌面环境也都是可以换的。如果你有能力，可以把Linux系统改的它亲爹都不认识。</p><h3 id="6-性能高"><a href="#6-性能高" class="headerlink" title="6. 性能高"></a>6. 性能高</h3><p>Linux的开发都可能比使用者还要多，这就意味着Linux从内核到软件都是经过多次的优化的。性能高自然也是不奇怪。这个性能不仅表现在软件性能，现在还表现在游戏性能上，我在同一台电脑上在Windows系统中玩我的世界不限制帧率能跑800多帧，但在Linux里面使用同一个显卡，加载同一个游戏，同一个场景，能跑1000多帧。</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 基础 </category>
          
          <category> windows与linux的区别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows快捷键</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01_windows%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01_windows%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="win快捷键："><a href="#win快捷键：" class="headerlink" title="win快捷键："></a>win快捷键：</h5><p>单独按Windows：显示或隐藏 “开始”功能表<br>Windows+BREAK：显示“系统属性” 对话框<br>Windows+D：显示桌面或恢复桌面<br>Windows+M：最小化所有窗口<br>Windows+Shift+M：还原最小化的窗口<br>Ctrl+Shift+N：新建文件夹<br>Windows+E：打开”我的电脑”<br>Windows+F：查找文件或文件夹<br>Windows+CTRL+ F：查找电脑<br>Windows+F1：显示 Windows “帮助”<br>Windows+R：开启“运行” 对话框<br>Windows+U：开启 “公用程序管理器”<br>Windows+L：锁定计算机（Windows XP新功能）<br>Windows按住不动+Tab：打开的应用程序切换，立体效果（win7系统支持）<br>windows +alt +F4：windows 关机窗口</p><h5 id="Ctr快捷键（文本编辑使用较多）"><a href="#Ctr快捷键（文本编辑使用较多）" class="headerlink" title="Ctr快捷键（文本编辑使用较多）"></a>Ctr快捷键（文本编辑使用较多）</h5><p>Ctrl+S 保存<br>Ctrl+W 关闭程序<br>Ctrl+N 新建<br>Ctrl+O 打开<br>Ctrl+Z 撤销<br>Ctrl+F 查找<br>Ctrl+P 打印文档<br>Ctrl+X 剪切<br>Ctrl+C 复制<br>Ctrl+V 粘贴<br>Ctrl+A全选<br>Ctrl+B 粗体<br>Ctrl+I 斜体<br>Ctrl+U 下划线<br>Ctrl+Shift输入法切换<br>Ctrl+ 空格 中英文切换<br>Ctrl+Home 光标快速移到文件头<br>Ctrl+End 光标快速移到文件尾<br>Ctrl+Esc 显示开始菜单<br>Ctrl+Shift+&lt; 快速缩小文字<br>Ctrl+Shift+&gt; 快速放大文字<br>Ctrl+F5 在IE中强行刷新<br>Ctrl+拖动文件 复制文件<br>Ctrl+Backspace 启动\关闭输入法<br>Ctrl+Alt+A 截屏(QQ的截屏）<br>shift + Alt + Print Screen(选中要截屏的地方，然后按这三个键，然后打开图画或者word，粘贴即可)<br>拖动文件时按住Ctrl+Shift 创建快捷方式<br>Ctrl+Tab+shift在打开的应用程序中以反方向切换</p><h5 id="ALT快捷键"><a href="#ALT快捷键" class="headerlink" title="ALT快捷键"></a>ALT快捷键</h5><p>Alt+F4 关闭当前程序<br>Alt+空格+C 关闭窗口<br>Alt+空格+N 最小化当前窗口<br>Alt+空格+R 恢复最大化窗口<br>Alt+空格+X 最大化当前窗口<br>Alt+空格+M 移动窗口<br>Alt+空格+S 改变窗口大小<br>Alt+u+v word全屏视图<br>Alt+F 打开文件菜单<br>Alt+V 打开视图菜单<br>Alt+E 打开编辑菜单<br>Alt+I 打开插入菜单<br>Alt+O 打开格式菜单<br>Alt+T 打开工具菜单<br>Alt+A 打开表格菜单<br>Alt+W 打开窗口菜单<br>Alt+H 打开帮助菜单<br>Alt+回车 查看文件属性<br>Alt+双击文件 查看文件属性<br>Alt+Tab在打开的应用不同窗口间进行切换</p><h5 id="shift快捷键"><a href="#shift快捷键" class="headerlink" title="shift快捷键"></a>shift快捷键</h5><p>Shift+空格 半\全角切换<br>Shift+F10 选中文件的右菜单<br>Shift+Del 永久删除</p><h5 id="FN快捷键"><a href="#FN快捷键" class="headerlink" title="FN快捷键"></a>FN快捷键</h5><p>F1 帮助<br>F2 重命名<br>F3 在windows中搜索文件<br>F5 刷新<br>F6 在窗口或桌面上循环切换屏幕元素。<br>F7 DoS下专用功能<br>F8 Windows 启动选项<br>F9 Excel 中计算公式<br>F11 切换全屏<br>F12 Word 里另存文档</p><h5 id="常规快捷键"><a href="#常规快捷键" class="headerlink" title="常规快捷键"></a>常规快捷键</h5><p>拖动某一项时按 CTRL 复制所选项。<br>拖动某一项时按 CTRL + SHIFT 创建所选项目的快捷键。<br>F2 重新命名所选项目。<br>CTRL + 向右键 将插入点移动到下一个单词的起始处。<br>CTRL + 向左键 将插入点移动到前一个单词的起始处。<br>CTRL + 向下键 将插入点移动到下一段落的起始处。<br>CTRL + 向上键 将插入点移动到前一段落的起始处。<br>CTRL + SHIFT + 任何箭头键突出显示一块文本。<br>SHIFT + 任何箭头键 在窗口或桌面上选择多项，或者选中文档中的文本。<br>Ctrl + A 选中全部内容。<br>F3 同一浏览器中打开的窗口切换。<br>Alt + Enter 查看所选项目的属性。<br>Alt + F4 打开关机，待机，重启<br>Alt +空格键为当前窗口打开快捷菜单。<br>Alt + Tab 在打开的项目之间切换。<br>Alt + Esc 以项目打开的顺序循环切换。<br>Shift + F10 显示所选项的快捷菜单。<br>ALT + 菜单名中带下划线的字母 显示相应的菜单（ALT在写字板中）。<br>右箭头键 打开右边的下一菜单或者打开子菜单。<br>Ctrl+Alt+Home或ctrl+home 回到页首</p><h5 id="FN键"><a href="#FN键" class="headerlink" title="FN键"></a>FN键</h5><p>F1 帮助<br>F2 重命名<br>F3 在windows中搜索文件<br>F5 刷新<br>F6 在窗口或桌面上循环切换屏幕元素。<br>F7 DoS下专用功能<br>F8 Windows 启动选项<br>F9 Excel 中计算公式<br>F11 切换全屏<br>F12 Word 里另存文档<br>Enter 执行活选项动或按钮所对应的命令。<br>方向键 活选项动是一组选项按钮时，请选中某个按钮。<br>BackSpace 如果在“另存为”或“打开”对话框中选中了某个文件夹，则打开上一级文件夹</p><h5 id="END-显示当前窗口的底端。"><a href="#END-显示当前窗口的底端。" class="headerlink" title="END 显示当前窗口的底端。"></a>END 显示当前窗口的底端。</h5><p>Home 显示当前窗口的顶端。<br>NUM LOCK+数字键盘星号* 显示所选文件夹的所有子文件夹。<br>NUM LOCK+数字键盘加号+ 显示所选文件夹的内容。<br>NUM LOCK+数字键盘减号- 折叠所选的文件夹。<br>左方向键 光标左移<br>右方向键 光标右移<br>TAB 制表键</p>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> windows快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02_Linux%E7%B3%BB%E7%BB%9F/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02_Linux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="linux简介："><a href="#linux简介：" class="headerlink" title="linux简介："></a>linux简介：</h3><p>Linux 是一种自由和开放源码的类 UNIX 操作系统。<br>Linux 英文解释为 Linux is not Unix。<br>Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发。<br>本教程，我们将为大家介绍如何使用 Linux。</p><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。<br>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。<br>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h3 id="Linux-的发行版"><a href="#Linux-的发行版" class="headerlink" title="Linux 的发行版"></a>Linux 的发行版</h3><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p><p><img src="/assets/image-20211120104622-naz095z.png" alt="image.png"></p><h3 id="Linux-vs-Windows"><a href="#Linux-vs-Windows" class="headerlink" title="Linux vs Windows"></a>Linux vs Windows</h3><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下</p><table><thead><tr><th>比较</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>界面</td><td>界面统一，外壳程序固定所有Windows程序菜单几乎一致，快捷键也几乎相同</td><td>图形界面风格依发布版不同而不同，可能互不兼容。GNU&#x2F;Linux的终端机是从UNIX传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td>驱动程序</td><td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的Windows下的驱动，也会比较头痛。</td><td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td></tr><tr><td>使用</td><td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td><td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td></tr><tr><td>学习</td><td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td><td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td></tr><tr><td>软件</td><td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td><td>大部分软件都可以自由获取，同样功能的软件选择较少。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 基础 </category>
          
          <category> windows快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试理论概念</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E6%A6%82%E5%BF%B5/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<ol><li><h4 id="软件测试的定义，什么是软件测试"><a href="#软件测试的定义，什么是软件测试" class="headerlink" title="软件测试的定义，什么是软件测试"></a>软件测试的定义，什么是软件测试</h4><ol><li>使用人工或自动手段，来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。</li></ol></li><li><h4 id="软件测试的目的"><a href="#软件测试的目的" class="headerlink" title="软件测试的目的"></a>软件测试的目的</h4><ol><li><p>测试是程序的执行过程，目的在于发现错误。</p></li><li><p>确保产品完成了它所承诺或公布的功能</p></li><li><p>确保产品满足性能和效率的要求</p></li><li><p>确保产品是健壮的和适应用户环境的</p></li></ol></li><li><h4 id="是否了解二八定律？"><a href="#是否了解二八定律？" class="headerlink" title="是否了解二八定律？"></a>是否了解二八定律？</h4><ol><li>了解</li><li>80%的问题可以在20%的模块中发现，换句话来说，软件系统中的问题存在群集现象，大部分的问题会集中在少数的模块上。</li><li><h5 id="二八定律怎么避免"><a href="#二八定律怎么避免" class="headerlink" title="二八定律怎么避免"></a>二八定律怎么避免</h5><ul><li>在分析设计以及实现阶段的复审能够发现和避免80%的缺陷，</li><li>在系统测试中能够找到剩余的80%的错误，</li><li>最后剩余的4%只能在用户的大范围使用长时间积累爆发出来</li></ul></li></ol></li><li><h4 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB/">软件测试的分类</a></h4><ol><li><p><img src="/assets/image-20220109174021-s16k61v.png" alt="image.png"></p><p> 黑盒测试：不考虑程序运行本身的逻辑，只考虑输入与输出之间的关系的测试</p><p> 白盒测试：开发人员进行的测试，代码测试</p><p> 灰盒测试：介于黑盒与白盒之间的测试</p><p> α测试：使用真实的环境，用户参与，全部产品、开发、测试参与，现场操作发现问题及时解决</p><p> β测试：使用真实的环境用户不参与，部分产品、开发、测试参与，现场操作发现问题后期解决</p></li><li><p>软件测试分类关系图</p><ol><li><img src="/assets/475aa778a57237c7e6a571329668eb4-20220109175114-4ddp7g5.jpg" alt="475aa778a57237c7e6a571329668eb4.jpg"></li></ol></li><li><p>软件测试类型</p><ol><li>功能测试、性能测试、安全测试、自动化测试、渗透性测试、UI测试</li></ol></li></ol></li><li><h3 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h3><ol><li><p>所有的测试都应该追溯到需求</p></li><li><p>尽早参与测试</p></li><li><p>测试中80%的缺陷来源于20%的模块中</p></li><li><p>不做不准备不充分的测试</p></li><li><p>避免测试的随意性</p></li><li><p>要长期保存我们的测试用例，直到系统废弃</p></li></ol></li><li><h3 id="项目流程——-gt-gt-软件的生命周期"><a href="#项目流程——-gt-gt-软件的生命周期" class="headerlink" title="项目流程——-&gt;&gt;软件的生命周期"></a>项目流程——-&gt;&gt;软件的生命周期</h3><ol><li><p>首先有需求人员编写需求文档，提供产品模型，并对这个需求进行评审，开发根据自己得到的任务进行编写代码、详设文档，测试人员根据自己得到的任务编写测试用例，进行用例评审，开发编写完成后会提交一个测试版本，我们测试用编写的用例进行测试，测试过程中如果发现bug，找到对应的开发给予解决，等bug修改以后，我们进行返测，如果通过直接关闭，如果不通过打回重新修改，直到bug关闭为止，编写测试报告， 然后进行版本发布，编写测试总结</p></li><li><p><strong>是不是所有的bug都关闭才能发布版本？</strong></p><ol><li><strong>不一定，有不影响项目上线的bug是允许存在的，比如说提示类说明文字与需求不一致</strong></li></ol></li></ol></li><li><h3 id="测试平时工作的内容"><a href="#测试平时工作的内容" class="headerlink" title="测试平时工作的内容"></a>测试平时工作的内容</h3><ol><li>参与需求评审   编写测试用例  评审用例  搭建环境  执行测试   发现bug  协助开发定位问题  返测  版本发布    测试总结  测试报告</li></ol></li><li><h3 id="怎么把控软件的进度"><a href="#怎么把控软件的进度" class="headerlink" title="怎么把控软件的进度"></a>怎么把控软件的进度</h3><ol><li>通过测试计划，晨会，测试日报，里程碑</li></ol></li><li><h3 id="怎么把控软件质量"><a href="#怎么把控软件质量" class="headerlink" title="怎么把控软件质量"></a>怎么把控软件质量</h3><ol><li>需求文档明确</li><li>严格根据我们用例进行测试</li><li>保证用例的全面覆盖</li></ol></li><li><h3 id="一名优秀的测试人员应该具有的素质包括："><a href="#一名优秀的测试人员应该具有的素质包括：" class="headerlink" title="一名优秀的测试人员应该具有的素质包括："></a>一名优秀的测试人员应该具有的素质包括：</h3> 一  踏实细心和积极主动<br> 二  好奇心，怀疑一切<br> 三  与他人良好交流的能力<br> 四  持续不断的自我提高和总结能力<br> 五  强烈的责任感</li><li><h3 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/">测试计划</a></h3><ol><li>什么是测试计划？</li><li>测试计划的目的？</li><li>测试计划是由谁写的？</li></ol></li><li><h3 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/">测试用例设计</a></h3></li><li><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/07_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C/">软件测试执行</a> </li><li><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/08_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/">软件测试报告</a> </li><li><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/">软件测试概念总结</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 基础 </category>
          
          <category> 测试理论概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<ol><li><h3 id="练习打字：要求1000字的文章，平均一分钟35字"><a href="#练习打字：要求1000字的文章，平均一分钟35字" class="headerlink" title="练习打字：要求1000字的文章，平均一分钟35字"></a>练习打字：要求1000字的文章，平均一分钟35字</h3></li><li><h3 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h3><ol><li><p><a href="../901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01_windows%E5%BF%AB%E6%8D%B7%E9%94%AE/">windows快捷键</a></p><ol><li>win+r  —-&gt; cmd—-&gt; 输入  ipconfig   查看本机ip</li><li>win+r  —-&gt; cmd—-&gt; 输入ping + url（ip）  查看与对方url（ip）是否互通</li></ol></li><li><p><a href="../901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02_Linux%E7%B3%BB%E7%BB%9F/">Linux</a></p></li><li><p><a href="../901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/03_windows%E4%B8%8Elinux%E7%9A%84%E5%8C%BA%E5%88%AB/">windows与linux的区别</a></p></li></ol></li><li><h3 id="编程基础："><a href="#编程基础：" class="headerlink" title="编程基础："></a>编程基础：</h3><ol><li><p>什么是编程语言</p><ol><li>编程语言（programming language）可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。编程语言处在不断的发展和变化中，从最初的机器语言发展到如今的2500种以上的高级语言，每种语言都有其特定的用途和不同的发展轨迹。编程语言并不像人类自然语言发展变化一样的缓慢而又持久，其发展是相当快速的，这主要是计算机硬件、互联网和IT业的发展促进了编程语言的发展。</li><li><a href="https://www.runoob.com/">编码基础课程（所有）</a></li></ol></li></ol></li><li><h3 id="公司中常用的文件类型"><a href="#公司中常用的文件类型" class="headerlink" title="公司中常用的文件类型"></a>公司中常用的文件类型</h3><ol><li><p>.txt，.doc（word），.xls（excel），.ppt，.pdf,   .csv、.xmind</p><pre><code> 压缩文件：.rar格式，.zip格式，.tar格式 执行文件：.bat格式（windows），.sh格式（linux），.exe格式（windows） 日志文件：.log（一般是日志debug日志，系统日志，错误日志）</code></pre><ul><li><p>xmind 快捷键</p><ul><li><img src="/assets/image-20220215095739-lhdjz41.png" alt="image.png"></li></ul></li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课中 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习规则</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/06_%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/06_%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周    1. 打卡        1. 要求每天打卡四次：            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00    2. 教学规则        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）        2. 晚上10点准时休息        3. 学习期间不准酗酒        4. 无重大事件不准请假    3. 日报        1. 每日必填    4. 教学时间        1. 分为大小周教学    5. 教室、宿舍环境保证清洁卫生    6. 教室、宿舍禁止抽烟</code></pre><h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天2. 第二章 操作              -----------&gt; 6工作天3. 第三章 接口测试        -----------&gt; 5工作日4. 第四章 性能测试        -----------&gt; 3工作天5. 第五章 APP测试        -----------&gt; 2工作天6. 第六章 自动化测试    -----------&gt; 6工作天7. 第七章 安全测试       -----------&gt; 1工作天8. 第八章 项目             -----------&gt; 5工作天9. 简历编写                 -----------&gt; 1工作天10. 模拟面试题分析       -----------&gt; 2工作天11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 学习规则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试素质</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/05_%E6%B5%8B%E8%AF%95%E7%B4%A0%E8%B4%A8/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/05_%E6%B5%8B%E8%AF%95%E7%B4%A0%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<ol><li>对于软件 测试人员来说需要具备的素质，我觉得首先最重要的是要有一定的理论知识和 测试技能，这是测试工作的基础。那么我们 测试人员还应该具备哪些素质才能在工作当中被不断的认可呢？</li><li>一名优秀的测试人员应该具有的素质包括：</li></ol><h3 id="一、-踏实细心和积极主动"><a href="#一、-踏实细心和积极主动" class="headerlink" title="一、 踏实细心和积极主动"></a><strong>一、 踏实细心和积极主动</strong></h3><ol><li>我觉得作为一名测试人员首先要踏实细心。细心：这个不用多解释了吧。粗枝大叶的人是没法做好 软件测试的。 软件测试，特别是当前国内主流的手动黑盒 功能测试。基本上软件测试的工作就是一项重复劳动，需要有一定的耐心来保证不在枯燥的重复劳动中放过那些细小的 缺陷。测试人员每天都要面对着枯燥的程序，从事着大量的重复工作，还要尽量发现产品中的 bug。如果不踏实，你就坐不住，总想干别的，就无法净下心来想用户有可能怎么用， 需求对产品是怎么要求的，现在产品中是怎么做的，哪里可能存在问题。不细心，就特别容易一些产品中微笑的错误，而恰恰就是这些错误是最影响产品形象的问题。</li><li>至于积极主动就不多说了。这是每个人都应该具有</li></ol><h3 id="二、-好奇心，怀疑一切"><a href="#二、-好奇心，怀疑一切" class="headerlink" title="二、 好奇心，怀疑一切"></a><strong>二、 好奇心，怀疑一切</strong></h3><ol><li>测试人员，对于手上的项目，如果单单只是去运行它，这样是没法发现问题的。我们测试人员进行测试的主要目的就是发现软件存在缺陷，而不是证明它没有缺陷。如果不抱着怀疑一切的态度就不是一名合格的测试人员。经过你手测试的产品面对的是直接用户。你不认真负责，不抱着怀疑一切的态度。总想着这个功能本版没动应该没什么问题，认为一般人不会去这样操作它，这个功能没什么用户用不用认真测了。这样发出的产品，我是不敢让用户用。因为用户用起产品来是千奇百怪，有些用户的水平和对产品的理解比咱们还要深。所以一定要抱着怀疑一切的态度，从多个方面考虑，认为产品每个功能都可能有问题，多问一个「为什么」，「如果这样，行不行？」，认真地测试产品的每一个测试点。</li></ol><h3 id="三、-与他人良好交流的能力"><a href="#三、-与他人良好交流的能力" class="headerlink" title="三、 与他人良好交流的能力"></a><strong>三、 与他人良好交流的能力</strong></h3><ol><li><p>众所周知，测试的过程是一个发现问题并且跟踪解决问题的一个过程，在这个过程中，要意识到测试、 开发、需求是一个团队，一个整体。离了谁，产品的质量都无法保证。沟通能力作为一项特别重要的软技能，在工作中起着举足轻重的作用。作为一名测试人员，我们在提交问题的时候，要做到条理清晰，必要时配上图片以便别人理解，自己提交的问题只有自己能看懂这可不行。我们还需要和项目经理交流了解最新的客户需求，要和 开发人员沟通以便解决缺陷。之前看过一段幽默的开发人员和测试人员的对话：</p><ol><li><p>测试日常：</p><ol><li>开发：这不是软件的问题，我看了测试代码，这个地方有点问题，不该是这样测。</li><li>测试：真的吗？我看看…真的啊，稍等我提交一下…谢谢你帮我们找到这个bug。</li><li>开发：没事，不用谢…（感觉有什么不对）</li></ol></li><li><p>无论是和项目经理还是开发员人交流的时候，态度很重要，这里我说的态度不是低声下气，底气不足的跟她们交流，特别是和开发人员交流时，可能会因为一个bug，两人争执不下发生冲突，这时候我们测试人员要做到分析问题所在，同时也要听听开发人员的想法，心平气和进行交流，最后实在是两人都拿不定注意，可以请示上级。</p></li></ol></li></ol><h3 id="四、-持续不断的自我提高和总结能力"><a href="#四、-持续不断的自我提高和总结能力" class="headerlink" title="四、  持续不断的自我提高和总结能力"></a><strong>四、  持续不断的自我提高和总结能力</strong></h3><ol><li><p>我觉得无论是哪个行业，都不能停滞不前，自我提高是必须的，这样才不会被淘汰，那么作为一名优秀的测试人员如何提高自己的测试能力呢？</p><ol><li><strong>第一，首先提高自己的测试理论基础。</strong>所有的测试基础概念其实都是通用的：静态测试，动态测试， 测试用例，等等以及一些测试相关技术：等价类划分，边界值，相信这些方法所有的人每天都在用，但是未必所有的人都能说明白。所以为自己每天所做的测试行动找点理论基础，即有效率有与实践相结合，这也是职业发展的重要一步。</li><li><strong>第二，要对测试的整体流程有完整的概念。</strong>这个是目前很多初级测试人员所欠缺的。目前大多数人只知道自己测试的是什么东西，但是不知道自己执行的测试处于什么阶段，下一个阶段是什么，也许整个项目做完不知道；这对于一个产品来说是一个不负责任的行为，所以也就需要测试人员有端到端的测试意识和对测试流程的概念的认可，要有测试整体流程管理的概念。</li><li><strong>第三，在进行测试工作中要弄明白为什么要这么做，为什么要执行这样的案例，为什么要执行相关的测试工作。</strong>多问几个为什么。有一个问题要先讲清楚，就是有很多人还没有注意到这个问题，领导让怎么做就怎么做，也许真的做的很熟练了，但是一年后去问他为什么要这么做，相信他也说不出太多，反倒觉得就应该这么测。这样带来直接的弊端就是对自己的职业之路不负责任。</li><li>另外，我觉得作为一名合格的测试人员，一定要注意进行总结。通过总结可以对自己的工作进行一个回顾分析，看看那些做得不错，下次还继续这么做。那些工作还有改进的余地。对自己能力的提高是一个很好的帮助。</li></ol></li></ol><h3 id="五、-强烈的责任感"><a href="#五、-强烈的责任感" class="headerlink" title="五、  强烈的责任感"></a><strong>五、  强烈的责任感</strong></h3><ol><li>对于你测试的产品付责任，许多测试人员在早上来到办公室，完成自己的任务，然后晚上下班回家。当软件测试人员完成自己的任务，然后下班收拾东西回家，这种常规的工作方式听起来很正常吧？是的，不得不说，目前我们都是这样的一个状态。要完成一个高质量的产品，我们就要对它负责，那么怎么负责呢？</li><li>测试人员要对所测试的对象质量负责，要能保证测试的覆盖到每一需求点，同时要能保证功能都可以正确实现等或者达到了测试通过的标准。</li><li>对于测试人员漏测，毕竟人不是完美的，难免会出现错误，但是不能以漏测来做为质量考核。可以对其进行分类分析，究竟是哪个环节出现的问题，提出来进行改进。比如说需求描述不完整，导致理解错误；隐含性需求未考虑到；易用性方面考虑不周；实际环境与测试环境有差异；自身经验不足等多方面。</li><li>测试这项工作，是证明产品做了正确的事情，能满足用户的需求，用各种 测试方法来找出问题，是对质量的一种度量。好的质量是要靠高素质人员和好的过程来保证的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 测试素质 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多维度分析</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/03_%E5%A4%9A%E7%BB%B4%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/03_%E5%A4%9A%E7%BB%B4%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>2020年</p><p><img src="/assets/image-20211120103613-yl1kx4c.png" alt="image.png"></p><h2 id="1-从业人员分布情况"><a href="#1-从业人员分布情况" class="headerlink" title="1. 从业人员分布情况"></a>1. 从业人员分布情况</h2><p><strong>1. 性别分布</strong></p><p><img src="/assets/image-20211207164743-c3tffd4.png" alt="image.png"><br>随着社会大环境鼓励生育二胎，相信女性回归家庭的比例有所攀升，2020 年测试岗位男性比例再次回到超过 70%。<br>很多测试同学可能感觉联系实际情况，做测试的女生明明很多，为何调查结果是男生占比高呢？</p><p>其实很好理解，关注 TesterHome 的同学以测试开发人员为主，尤其是效能和工具平台建设，以及智能、大数据、物联网等方向的测试人员，男生比例高些，也符合感性的感觉。</p><p>欢迎大家来参加 2021 年即将在上海举办的中国互联网测试开发大会 MTSC2021 上海站现场感受。</p><h2 id="2-年龄分布"><a href="#2-年龄分布" class="headerlink" title="2. 年龄分布"></a>2. 年龄分布</h2><p><img src="/assets/image-20211207164749-0jqcixc.png" alt="image.png"><br>从调查结果来看，35+ 测试人员占与去年持平，各年龄段的分布连续三年也较稳定。最近几年大家讨论最多的关于年龄的话题就是 “35 周岁中年危机” 了，职场上 35 岁 + 的人都去哪了呢？<br>测试开发岗位只是万千行业岗位中的一个，若年龄到了一个阶段，经验没有继续增长，学习能力却降低，而薪水不能降低吧？</p><ul><li>用人成本考量上，公司一般会偏向年轻人</li><li>团队梯队建设上，会考虑新老搭档</li></ul><h2 id="3-所在地分布"><a href="#3-所在地分布" class="headerlink" title="3.所在地分布"></a>3.所在地分布</h2><p><img src="/assets/image-20211207164753-6qbj4yn.png" alt="image.png"></p><ul><li>与前两年一致，互联网测试从业人员主要依然是来自一二线城市，但可以看出二线城市的比例逐年增加，单从这个结果上可以有 2 个猜测：</li><li>更多来自二线城市的测试人员</li><li>测试人员从一线搬至二线城市定居了，可推测二线城市对测试人员需求增加</li></ul><h2 id="4-工作年限分布"><a href="#4-工作年限分布" class="headerlink" title="4. 工作年限分布"></a>4. 工作年限分布</h2><p><img src="/assets/image-20211207164759-nhnwdcl.png" alt="image.png"></p><ul><li>这个调查和年龄分布可对比看，年龄 30 周岁 + 的总占比与去年持平，但工作时间超过 10 年以上的人数占比却稳步提升。</li><li>工作 6-10 年的人数占比也显著增加，二者加起来就是工作 5 年以上人数占比 37.4%。</li></ul><h2 id="5-学历分布"><a href="#5-学历分布" class="headerlink" title="5. 学历分布"></a>5. 学历分布</h2><p><img src="/assets/image-20211207164806-sqad1w0.png" alt="image.png"></p><ul><li>本科一如既往占七成，硕士占比近十分之一，博士继去年零突破后继续增加了。</li><li>测试开发人员属于技术类人员，对学历有要求，相信与其他相关技术从业人员也一致。</li></ul><h2 id="6-进入测试行业的途径"><a href="#6-进入测试行业的途径" class="headerlink" title="6.进入测试行业的途径"></a>6.进入测试行业的途径</h2><p><img src="/assets/image-20211207164811-ivob3vp.png" alt="image.png"></p><ul><li>毕业即入行，依然是常规途径，比例超过一半。由此可见，各大公司持续将校园招聘作为主要招聘渠道。</li><li>通过培训机构入行的连续三年增长，今年超过 15%，一定程度上反映了当下测试培训的火爆。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 多维度分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薪资分析</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/04_%E8%96%AA%E8%B5%84%E5%88%86%E6%9E%90/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/04_%E8%96%AA%E8%B5%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、2021年软件测试的平均工资怎样？"><a href="#一、2021年软件测试的平均工资怎样？" class="headerlink" title="一、2021年软件测试的平均工资怎样？"></a>一、2021年软件测试的平均工资怎样？</h2><p>测试薪资，每个地方不太一样（后面会列上国内主要城市薪资），我们以北京为例，先来给大家看一下2020年的测试薪资，如下图所示：</p><p><img src="/assets/image-20211207164957-j4c2r0a.png" alt="image.png"></p><p> <strong>2021年又比2020年增加了3000多元。</strong> 最近这些年，测试薪资是一路往上涨的。</p><p>北京作为一线大城市，薪资肯定高，但很多小伙伴们未必是在北京工作，而是在自己的省会城市或其他一线城市，那他们的薪资如何呢？请继续往下看。</p><h2 id="二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？"><a href="#二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？" class="headerlink" title="二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？"></a>二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？</h2><p>看过了北京的薪资，再来看看其他城市的薪资。</p><p><img src="/assets/image-20211207165002-crnepas.png" alt="image.png"></p><h2 id="三、与编程开发相比，软件测试的薪资如何呢？"><a href="#三、与编程开发相比，软件测试的薪资如何呢？" class="headerlink" title="三、与编程开发相比，软件测试的薪资如何呢？"></a>三、与编程开发相比，软件测试的薪资如何呢？</h2><p>相信这个是很多由于到底是学编程还是测试的同学非常关注的。</p><p> <strong>给大家揭露一个非常有趣的现象：</strong> 以10年工龄为界，10年之内，同等工龄的开发岗位平均薪资要超过测试；<strong>但10年之后，软件测试的平均薪资却要反超编程开发。</strong></p><p>是不是这样呢？请狠狠点击下方链接查看直接证据：</p><p><a href="https://www.zhihu.com/question/33405392/answer/1649870187"><img src="/assets/image-20211207165006-ua3sb2o.png" alt="image.png"></a></p><h2 id="四、近10年来软件测试工资的波动状况，预测未来趋势"><a href="#四、近10年来软件测试工资的波动状况，预测未来趋势" class="headerlink" title="四、近10年来软件测试工资的波动状况，预测未来趋势"></a><strong>四、近10年来软件测试工资的波动状况，预测未来趋势</strong></h2><p>未来测试的薪资会怎样呢？老方法，回顾过去，才能展望未来，我们来看下近10年来测试平均薪资。为了能让趋势客观，仅选用北京测试薪资。</p><p><img src="/assets/image-20211207165010-h9cwmyo.png" alt="image.png"></p><p>刚刚我们看到了<strong>北京薪资2020年是15430，那么2019年是多少呢？请往下看14480元</strong></p><p><img src="/assets/image-20211207165015-lg94kmv.png" alt="image.png"></p><p>2018年，2017年，2015年，2014年……分别是多少呢？</p><p><img src="/assets/image-20211207165019-yvqzw61.png" alt="image.png"></p><p>从以上的薪资趋势可以看到，测试薪资10年来，已经从4460元跃升到15430元，薪资一路上涨。尤其是在2015年和2017年，涨薪幅度达到40%和34%。</p><p>为什么薪资能一路上涨，因为这10年来，互联网竞争越来越趋同质化， <strong>未来的互联网产品不仅是运营取胜，更是质量取胜，而测试人员就是保证质量的守门员，</strong> 这也是为何 <strong>2020是疫情之年，测试薪资仍比2019年上涨了1000元，2021年又比2020年增加了3000多元的根本原因。</strong> 所以未来测试薪资，不出意外， <strong>也将继续一路上扬</strong> 。</p><h2 id="五、测试各个岗位的薪资是怎样的？"><a href="#五、测试各个岗位的薪资是怎样的？" class="headerlink" title="五、测试各个岗位的薪资是怎样的？"></a>五、测试各个岗位的薪资是怎样的？</h2><p>测试按技术分，分支较多，有功能测试、接口测试、Ui自动化测试、性能测试、安全测试、测试开发….  各个岗位的薪资肯定是不一样的，带大家来看下</p><h3 id="1-功能测试（也叫手工测试）"><a href="#1-功能测试（也叫手工测试）" class="headerlink" title="1.功能测试（也叫手工测试）"></a><strong>1.功能测试（也叫手工测试）</strong></h3><p><img src="/assets/image-20211207165023-u0xwhox.png" alt="image.png"><br>2020年功能测试薪资</p><p><img src="/assets/image-20211207165027-3bpqrh8.png" alt="image.png"><br>2021年功能测试薪资，较2020上涨了2.6K</p><p>功能测试是其他测试工作的基础，是培养测试用例设计能力和建立测试思维的关键阶段。但是如果只是每天机械的进行“点点点”，想拿高薪是不太现实的。但是如果用例设计的非常牛，能够验证出系统中的绝大部分bug（尤其是关键的bug）；或者对某一行业的业务非常熟练也是可以拿到高薪的。</p><p>根据市场的实际情况来看，拿高薪的软件测试工程师一般都是具备良好的手工测试技能。<strong>所以手工测试虽然薪资是最低的，但是却是最核心的，千万不能忽视。</strong></p><h3 id="2-自动化测试"><a href="#2-自动化测试" class="headerlink" title="2 自动化测试"></a><strong>2 自动化测试</strong></h3><p><img src="/assets/image-20211207165031-gyq50kn.png" alt="image.png"><br>2020年自动化测试薪资截图</p><p><img src="/assets/image-20211207165035-dtga3sw.png" alt="image.png"><br>2021年自动化测试薪资，较2020增加2.5K</p><p>自动化测试主要包括接口自动化测试和UI自动化测试。</p><p><strong>为什么做接口自动化测试能拿高薪呢？</strong><br>因为现在的软件，都是前后端分离的，需要通过接口实现前后端数据的传递。所以接口自动化测试非常重要，大部分的公司都会做接口自动化测试的。</p><p><strong>为什么会UI自动化测试能拿高薪呢？</strong></p><p>通过手工方式实现项目回归测试既费时又费力，如果是已经写好的自动化测试脚本直接运行就可以了，可以实现真正的无人值守。<strong>UI自动化测试目前做的比较多的是Web自动化测试和APP自动化测试。</strong></p><p>所以做UI自动化测试一般都要具备一定的编程能力，而绝大部分测试人员是没有编程能力的，能拉开与别人之间的距离。</p><p>UI自动化测试比较适合功能比较稳定、回归测试比较频繁的项目，能很好的提高测试效率、节省手工验证的成本。</p><p><strong>3 性能测试</strong></p><p><img src="/assets/image-20211207165039-o2lhkgg.png" alt="image.png"><br>2020年性能测试薪资截图</p><p><img src="/assets/image-20211207165043-h5hcwvm.png" alt="image.png"><br>2021年性能测试薪资截图，较2020年上涨1.1K</p><p><strong>为什么说性能测试很有必要：</strong><br>人们对软件响应的速度也有很高的要求；但与之相对立的是用户访问量越大、数据量越多，软件产品的响应速度就会下降。所以每一个用户量较大的系统都面临着很大的挑战。作为一个测试人员，在产品交付客户上线之前就需要进行充分的性能测试，能够保证软件产品能够承受住实际用户访问的需求。</p><p><strong>为什么说做好性能测试不容易？</strong></p><p>要做好性能测试，除了最基本的会使用性能测试工具之外，还要对系统的架构、服务之间的调用非常清楚。性能测试的基本技能是性能测试脚本的编写，核心和难点是性能的瓶颈分析和性能调优。如果能把性能测试做好了，想拿高薪真的很容易！</p><p><strong>性能测试常用的工具有JMeter和Loadrunner。</strong></p><p><strong>4 安全测试</strong></p><p><img src="/assets/image-20211207165048-fwu6vzc.png" alt="image.png"><br>2020年安全测试薪资截图</p><p><img src="/assets/image-20211207165052-tyraktd.png" alt="image.png"><br>2021年薪资截图，较 2020年上涨2.2K</p><p>安全测试是测试中的一个专项测试，一般都是有专门的安全测试人员进行测试，专业技能要求比较高，但是 <strong>薪资待遇更是非常可观。</strong> 常见的安全测试有暴力破解、<a href="https://www.zhihu.com/search?q=%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1581863304%7D">越权漏洞</a>、命令注入、SQL注入、XSS、CSRF等等。</p><p><strong>5 测试开发</strong></p><p><img src="/assets/image-20211207165056-nyggkjx.png" alt="image.png"><br>2020年测试开发薪资截图</p><p><img src="/assets/image-20211207165100-b9slwms.png" alt="image.png"><br>2021年测试开发薪资截图，教上年增加2.5K</p><p>市场有大量测试开发岗位 打开BOSS直聘、智联招聘、拉勾等招聘平台，我们可以看到有很多测试开发的岗位。</p><p><img src="/assets/image-20211207165104-h3ogzke.png" alt="image.png"></p><p><strong>为什么说测试开发能拿高薪呢？</strong></p><p>测试开发岗位对软件测试工程师有更高的技能要求，不仅要有测试的技能，还要有开发的技能。永远都要相信当今社会不缺少高薪的岗位，只是缺少能拿高薪的人才。</p><p><strong>测试开发的主要工作是什么？</strong></p><p>目前测试开发的工作主要包括测试工具的开发、测试平台的开发、测试框架的搭建等。这些工作都能够服务于普通的测试人员，提高测试的效率，给公司创造价值。</p>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 薪资分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识软件测试</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/01_%E5%88%9D%E8%AF%86%E6%B5%8B%E8%AF%95/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/01_%E5%88%9D%E8%AF%86%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-首先介绍下我们要进入的行业"><a href="#1-首先介绍下我们要进入的行业" class="headerlink" title="1. 首先介绍下我们要进入的行业"></a>1. 首先介绍下我们要进入的行业</h2><ol><li>IT已经我们公认熟知的行业，那么软件测试作为IT行业的一员也应该被大家所熟知：<ol><li>什么是IT<ul><li>IT是Information Technology英文的缩写，全称含义为“信息技术”涵盖的范围很广，主要包括：现代计算机、网络通讯等信息领域的技术。</li></ul></li><li>IT分类：实际上有三个层次<ul><li>硬件： 主要指数据存储、处理和传输的主机和网络通信设备</li><li>软件： 包括可用来搜集、存储、检索、分析、应用、评估信息的各种软件，它包括我们通常所指的ERP(企业资源计划)、CRM(客户关系管理)、SCM(供应链管理)等商用管理软件，也包括用来加强流程管理的WF(工作流)管理软件、辅助分析的DW&#x2F;DM(数据仓库和数据挖掘)软件等</li><li>应用： 指搜集、存储、检索、分析、应用、评估使用各种信息，包括应用ERP、CRM、SCM等软件直接辅助决策，也包括利用其它决策分析模型或借助DW&#x2F;DM等技术手段来进一步提高分析的质量，辅助决策者作决策</li></ul></li></ol></li></ol><h2 id="2-在各个行业都会出现“测试”一词"><a href="#2-在各个行业都会出现“测试”一词" class="headerlink" title="2. 在各个行业都会出现“测试”一词"></a>2. 在各个行业都会出现“测试”一词</h2><ol><li>什么是测试？<ul><li>测试是具有试验性质的测量，即测量和试验的综合</li></ul></li><li>在IT行业测试职位是怎么称呼的？<ul><li>硬件————–&gt;&gt;&gt;&gt;&gt;   硬件测试工程师</li><li>软件————–&gt;&gt;&gt;&gt;&gt;   软件测试工程师</li><li>应用————–&gt;&gt;&gt;&gt;&gt;   应用测试工程师</li></ul></li></ol><h2 id="3-桐桐信息技术的教学目的"><a href="#3-桐桐信息技术的教学目的" class="headerlink" title="3. 桐桐信息技术的教学目的"></a>3. 桐桐信息技术的教学目的</h2><ul><li>我们所要做的就是塑造&#x2F;培养软件测试工程师</li><li>提升软件测试工程师的技术&#x2F;技能与认知</li><li>为我们本地培养高技能人才</li></ul><h2 id="4-什么是软件测试工程师"><a href="#4-什么是软件测试工程师" class="headerlink" title="4. 什么是软件测试工程师"></a>4. 什么是软件测试工程师</h2><ol><li>软件测试工程师（Software Testing Engineer）指理解产品的功能要求，并对其进行测试，检查软件有没有错误（Bug），测试软件是否具有稳定性（Robustness），写出相应的测试规范和测试用例的专门工作人员。</li><li>简而言之，软件测试工程师在一家软件企业中担当的是“质量管理”角色，及时发现软件问题并及时督促更正，确保产品的正常运作。</li></ol><h2 id="5-软件测试工程师的等级划分"><a href="#5-软件测试工程师的等级划分" class="headerlink" title="5. 软件测试工程师的等级划分"></a>5. 软件测试工程师的等级划分</h2><ol><li>初级测试工程师</li><li>中级测试工程师</li><li>高级测试工程师</li><li>测试管理人员</li><li>测试经理</li><li>测试总监</li></ol><h2 id="6-在桐桐信息技术培训人才技能范围"><a href="#6-在桐桐信息技术培训人才技能范围" class="headerlink" title="6. 在桐桐信息技术培训人才技能范围"></a>6. 在桐桐信息技术培训人才技能范围</h2><ol><li>中级测试工程师、高级测试工程师、测试管理人员</li></ol><h2 id="7-不同等级学习的技能范围"><a href="#7-不同等级学习的技能范围" class="headerlink" title="7. 不同等级学习的技能范围"></a>7. 不同等级学习的技能范围</h2><ul><li><p>中级测试工程师</p><ul><li>功能测试、接口测试、抓包技能、项目管理工具使用、查看日志、分析问题</li></ul></li><li><p>高级测试工程师</p><ul><li>在终极测试工程师的基础上、性能测试、安全测试、自动化测试</li></ul></li><li><p>测试管理人员</p><ul><li>在高级测试工程师基础上、管理技能（包括项目管理、人员管理）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 初识测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解软件测试行业</title>
      <link href="/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/02_%E6%B5%8B%E8%AF%95%E8%A1%8C%E4%B8%9A/"/>
      <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/02_%E6%B5%8B%E8%AF%95%E8%A1%8C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>随着中国IT行业的发展以及未来AI时代的到来。越来越多的人加入到IT行业，对于很多没有从事过IT工作的人来，或者对于很多专业跟IT扯不上关系的人来说。转行做软件测试是一个很好的选择。</p><p>软件开发起码要培训半年以上，才能胜任工作。 而软件测试只需要1个月。</p><h2 id="1-测试行业介绍"><a href="#1-测试行业介绍" class="headerlink" title="1 测试行业介绍"></a>1 测试行业介绍</h2><ul><li><p>目前IT企业也越来越重视软件产品的质量， 从软件，硬件到系统集成，几乎每个小中大IT企业，在产品发布之前都需要大量的测试工作。软件测试工程师，是目前IT行业非常短缺的人才，中国软件行业每年要新增几十万的测试岗位就业机会。但是学校培养出来的测试人才却不足需求量的十分之一。</p></li><li><p>目前软件测试行业的缺口非常大。 90%的测试人员是不会写代码的，但是薪资依然可观。基本上一个三年测试经验的人，薪资都在万元以上。未来的职业发展前景也非常广阔。</p></li></ul><h2 id="2-软件测试是做什么的"><a href="#2-软件测试是做什么的" class="headerlink" title="2 软件测试是做什么的"></a>2 软件测试是做什么的</h2><ul><li><p><img src="/assets/wpsC670.tmp-20211222145920-4awo4by.jpg"></p></li><li><p>软件测试，就是找出软件系统中的错误，并且确保软件开发人员修复这些错误， 最终移交一个质量好的软件，给客户使用。</p></li><li><p>比如下图，一个网页中的密码输入框中的字符不是用星号显示，而是明文显示。这就是一个软件的bug。软件测试就是要将这些bug找出来</p></li><li><p><img src="/assets/wpsC671.tmp-20211222145920-cq9ge46.jpg"></p></li><li><p>下图是一个功能性的Bug，这种Bug比较严重，会影响用户的使用，甚至会给用户造成损失，所以软件测试就是需要提前把这些Bug找出来，确保软件交付给用户使用后，没有问题。</p></li></ul><h2 id="3-入门门槛非常低"><a href="#3-入门门槛非常低" class="headerlink" title="3 入门门槛非常低"></a>3 入门门槛非常低</h2><ul><li><p>经常听想入行的朋友说，我想转软件测试，听说软件测试很简单。的确，软件测试入门是很简单。</p></li><li><p>IT行业中有几百个工种， 其中软件测试是入门门槛最低。普通人只要经过短期的培训，大概学一个月就能胜任响应的软件测试工作。软件测试人员起薪在7000元-10000元不等，工作三年后，月薪基本上能达到10000到15000。</p></li><li><p>软件测试入门虽然简单， 但是精通很难。</p></li></ul><h2 id="4-测试人员每天的日常工作"><a href="#4-测试人员每天的日常工作" class="headerlink" title="4 测试人员每天的日常工作"></a>4 测试人员每天的日常工作</h2><ul><li>大部分软件测试人员的工作可以简单的归为这几个字， “点点点，开Bug”。</li></ul><h2 id="5-一些转行实例"><a href="#5-一些转行实例" class="headerlink" title="5 一些转行实例"></a>5 一些转行实例</h2><ul><li><p>身边转行做测试的例子太多了， 我举几个实际的转行的例子。这些例子都是真实的。</p></li><li><p>我姑姑的儿子大学专科毕业，找不到工作，因为他们的学校一塌糊涂，大学的时候玩游戏，什么都没学到。本来他打算南下广东， 去进厂当流水线工人的。 我姑姑不甘心他儿子去进厂当流水线工人。 然后就拜托我帮帮忙。 后来我这弟弟就来到上海投奔我。 我培训了2个月软件测试。 弟弟很轻松的就进入了一家软件公司，到现在做了快5年了， 已经成长为一名高级测试工程师。</p></li><li><p>后来我就把好几个堂弟以及一些亲戚，都拉到上海来从事软件测试行业。目前家族中很多人都是从事软件测试行业。</p></li><li><p>JJO,  是96年的小姑娘， 今年24岁， 大专毕业后，一直在某酒店做前台工作人员， 月薪大概3000.， 做了2年了， 薪资只够自己开销，完全存不到钱，感觉到很迷茫。 偶然的机会由亲戚介绍，接触了软件测试。 开始跟人学习软件测试。学好出来后。</p></li><li><p>开始来到深圳做软件测试， 月薪一万。 越来越喜欢做软件测这份工作。</p></li><li><p>小明，男，大学毕业后，非常迷茫不知道做什么， 就去广东打工， 进了一个工厂，在流水线上工作，每个月也就4000多，不想做了后，又去一家鞋厂做。做了几个月，又不想做了。 觉得没有前途， 难道做到30岁，还是这么点工资吗？ 觉得自己需要改变， 后来机缘巧合，开始学习软件测试。 最终成功入行。    到现在50W一年的薪资。</p></li><li><p>小荣荣，女，大专毕业，今年30岁了，在上海一家公司做硬件检测8年了，月薪才4000多。有个女儿三岁了。 这点薪资完全不够用。后来决心赌一把，开始学习软件测试。学了大概1个月后，转行做软件测试，入行的时候薪水是1万。 工作后，又持续学习。还学了Python编程。到现在月薪已经超过2万多了。</p></li></ul><h2 id="6-哪些人适合转行"><a href="#6-哪些人适合转行" class="headerlink" title="6 哪些人适合转行"></a>6 哪些人适合转行</h2><ol><li><p>专业是计算机专业的毕业生</p><p> 一点问题没有， 只要不要辛苦，姿态放低一点。 很简单</p></li><li><p>非计算机专业的毕业生</p><p> 不是计算机专业的，从事软件测试完全没问题。</p></li><li><p>转行的人。</p><p> 目前软件测试行业，很多人都不是计算机专业的。 很多都是别的行业转行过来的。</p></li><li><p>在一些城市，薪资少于8000</p><p> 生活在一线城市，目前的薪资少于6000，并且在可遇见的未来几年，薪资不会有很大提升的职业。都可以选择转行做软件测试。</p></li></ol><h2 id="7-软件测试职业规划"><a href="#7-软件测试职业规划" class="headerlink" title="7 软件测试职业规划"></a>7 软件测试职业规划</h2><ul><li><p>本人从事软件8多年，认识的测试人员超过上千位，有很多工作超过10年的老测试，也有很多刚毕业刚进入测试行业的人。根据我认识的测试人员目前的情况，我大概列出以下软件测试的职业规划</p></li><li><p><img src="/assets/wpsC672.tmp-20211222145920-h98oqep.jpg"></p></li><li><p>就2018年上海地区来行情来说，一个刚毕业的本科生从事软件测试行业大概薪水是5000到7000左右， 3年测试经验薪水大概是9000-13000左右，5年测试经验的薪水大概在13000-20000左右。10年以上的老测试大概在30000以上。</p></li><li><p>根据行业的不同，薪资的差别也比较大。互联网和外企的薪水会较高。互联网的工作强度大，加班多。当然薪资要偏高。 外企要求英语好+技术好。 英语好和技术同时要好，属于复合型人才，这种人才比较稀缺。所以待遇也相应要好很多。</p></li><li><p>测试人员不但需要对软件的质量进行检测，还能接触到与软件相关的各行各业，项目管理、沟通协调、市场需求分析等能力都能得到很好的锻炼，从而为自己的多元化发展奠定了基础，经过实践几年后，很容易晋升到主管、项目经理等高级职位。</p></li></ul><h2 id="8-软件测试职业的优点"><a href="#8-软件测试职业的优点" class="headerlink" title="8 软件测试职业的优点"></a>8 软件测试职业的优点</h2><ul><li><p>个人觉得软件测试职业具备很多优点。</p><ol><li><p>优点1 非常适合女生</p><ul><li><p>女生具备很多优点，首先女生稍微细心，更容易发现Bug。女生的沟通能力比较好， 发现Bug后，找开发人员沟通的比较顺畅，90%的开发都是男的，会比较有风度。</p></li><li><p>大家会发现软件开发中女生占的比例是10%以下。而在软件测试中，女生占的比例有50%左右。</p></li><li><p>我身边很多从事软件测试的女生，生活都过得很好。很多女同事薪资都超过2W，老公的薪资更高。很多在上海生了二胎，买了二套房。</p></li><li><p>所以女生很适合做软件测试行业。</p></li></ul></li><li><p>优点2 适合平庸的人</p><ul><li><p>平常工作中接触过太多牛人了，很多刚毕业的人，写代码的水平相当高。可以独立开发很大的系统。接触了很多智商高的人。我深深的体会到，被碾压的感觉。</p></li><li><p>软件测试非常适合平庸的人。 因为不需要天才也能做。</p></li></ul></li><li><p>优点3 劳动强度和压力适中</p><ul><li><p>软件行业大家的压力都比较大， 尤其是开发人员的压力很大啊， 相比之下，软件测试的劳动强度和压力，都比软件开发小很多。  很适合女同学做。</p></li><li><p>开发人员在开发项目的时候，会碰到很多技术难题，很难保证一个全新的项目能否按时开发完。 测试就好很多，测试工作中的主要是工作量大的问题，大不了加班，不存在完不成的问题，心里压力要小很多。</p></li></ul></li></ol></li></ul><h2 id="9-软件测试职业的缺点"><a href="#9-软件测试职业的缺点" class="headerlink" title="9 软件测试职业的缺点"></a>9 软件测试职业的缺点</h2><ul><li><p>说了这么多优点，下面来说说缺点。</p><ol><li><p>缺点1：薪资比开发工程师低</p><ul><li>测试工程师的薪资普遍要比开发工程师低20%以上。这个其实是合理的。</li></ul></li><li><p>缺点2：没法创业和赚外快</p><ul><li><p>身边很多人创业，很多同事是边工作边赚外快，帮别人做网站，做APP，维护系统之类的。当外快的钱比上班的的钱还多之后，很多同事就辞职，全职创业了。</p></li><li><p>而软件测试就没有这样的机会，至少我没听说几个软件测试创业成功的。</p></li></ul></li></ol></li></ul><h2 id="10-传统的软件公司和互联网公司的区别"><a href="#10-传统的软件公司和互联网公司的区别" class="headerlink" title="10 传统的软件公司和互联网公司的区别"></a>10 传统的软件公司和互联网公司的区别</h2><ul><li><p>互联网公司需要大量的测试人员，那么什么样的公司才是互联网公司呢？</p><ol><li>传统软件公司的产品和服务依赖于特定的终端和相应的操作系统，而互联网公司产品和服务则依赖于浏览器和网络。</li><li>传统软件公司是卖软件给用户用，互联网公司是自己运营。</li><li>传统软件公司需求都是从真正用软件的用户那里间接得来的，需求经过收集，传递，分析，实现，测试，上线。整个过程很长。互联网公司一般都是自己开发自己用，有什么问题立刻改。</li><li>从用户角度看， 传统软件产品都是在本地，需要自己安装。而互联网公司的产品只需要通过互联网来访问。比如通过浏览器或者APP来使用。</li><li>传统软件公司上线周期长，可能要几个月才上线一个产品。 而互联网公司上线周期短，可能一个星期就上线一次，或者2次。所以测试会比较忙。</li><li>传统的软件公司有，苹果，小米，微软。</li></ol></li><li><p>互联网企业有， 谷歌，facebook,阿里，腾讯.还有比如说，网络游戏，直播。电子商务。</p></li><li><p>互联网企业众多，需要大量的测试人员。大部分的测试人员都是进入了互联网企业.</p></li></ul><h2 id="11-测试分两种"><a href="#11-测试分两种" class="headerlink" title="11 测试分两种"></a>11 测试分两种</h2><ul><li><p><img src="/assets/wpsC673.tmp-20211222145920-91n8oyg.png"><img src="/assets/wpsC674.tmp-20211222145920-rscndg4.jpg"></p></li><li><p>软件测试分为手动测试和自动化测试。手动测试工程师只要求像普通用户那样去使用软件，发现了问题，在Bug管理系统中，开一个Bug就可以了</p></li><li><p>而自动化测试工程师，是需要懂代码，了解Java或者Python， 会使用JMeter和Postman做接口测试，会使用Selenium做UI自动化测试。自动化测试是发展方向。三年以上的测试工程师都应该朝这个方向发展</p></li></ul><h2 id="12-B-x2F-S和C-x2F-S架构的区别"><a href="#12-B-x2F-S和C-x2F-S架构的区别" class="headerlink" title="12 B&#x2F;S和C&#x2F;S架构的区别"></a>12 B&#x2F;S和C&#x2F;S架构的区别</h2><ul><li><p>Browser&#x2F;Server架构（浏览器&#x2F;服务器架构），主要是指的是Web应用程序，比如淘宝网，以及各种网站。如下图</p></li><li><p>C&#x2F;S架构  是Client&#x2F;Server(客户端&#x2F;服务器)架构，主要是传统的桌面机的应用程序。如下图</p></li><li><p><img src="/assets/wpsC675.tmp-20211222145920-yxbq22w.jpg"></p></li><li><p>目前大概90%的系统都是采用B&#x2F;S架构，是未来的趋势。传统的C&#x2F;S架构的软件越来越少，C&#x2F;S的软件慢慢被淘汰。B&#x2F;S架构的优点是客户不需要安装软件，直接使用浏览器就可以访问了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课前 </category>
          
          <category> 测试行业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课前 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
