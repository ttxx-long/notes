<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello-world - 副本</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>初识软件测试</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/01_%E5%88%9D%E8%AF%86%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1-首先介绍下我们要进入的行业"><a href="#1-首先介绍下我们要进入的行业" class="headerlink" title="1. 首先介绍下我们要进入的行业"></a>1. 首先介绍下我们要进入的行业</h2><ol>
<li>IT已经我们公认熟知的行业，那么软件测试作为IT行业的一员也应该被大家所熟知：<ol>
<li>什么是IT<ul>
<li>IT是Information Technology英文的缩写，全称含义为“信息技术”涵盖的范围很广，主要包括：现代计算机、网络通讯等信息领域的技术。</li>
</ul>
</li>
<li>IT分类：实际上有三个层次<ul>
<li>硬件： 主要指数据存储、处理和传输的主机和网络通信设备</li>
<li>软件： 包括可用来搜集、存储、检索、分析、应用、评估信息的各种软件，它包括我们通常所指的ERP(企业资源计划)、CRM(客户关系管理)、SCM(供应链管理)等商用管理软件，也包括用来加强流程管理的WF(工作流)管理软件、辅助分析的DW&#x2F;DM(数据仓库和数据挖掘)软件等</li>
<li>应用： 指搜集、存储、检索、分析、应用、评估使用各种信息，包括应用ERP、CRM、SCM等软件直接辅助决策，也包括利用其它决策分析模型或借助DW&#x2F;DM等技术手段来进一步提高分析的质量，辅助决策者作决策</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-在各个行业都会出现“测试”一词"><a href="#2-在各个行业都会出现“测试”一词" class="headerlink" title="2. 在各个行业都会出现“测试”一词"></a>2. 在各个行业都会出现“测试”一词</h2><ol>
<li>什么是测试？<ul>
<li>测试是具有试验性质的测量，即测量和试验的综合</li>
</ul>
</li>
<li>在IT行业测试职位是怎么称呼的？<ul>
<li>硬件————–&gt;&gt;&gt;&gt;&gt;   硬件测试工程师</li>
<li>软件————–&gt;&gt;&gt;&gt;&gt;   软件测试工程师</li>
<li>应用————–&gt;&gt;&gt;&gt;&gt;   应用测试工程师</li>
</ul>
</li>
</ol>
<h2 id="3-桐桐信息技术的教学目的"><a href="#3-桐桐信息技术的教学目的" class="headerlink" title="3. 桐桐信息技术的教学目的"></a>3. 桐桐信息技术的教学目的</h2><ul>
<li>我们所要做的就是塑造&#x2F;培养软件测试工程师</li>
<li>提升软件测试工程师的技术&#x2F;技能与认知</li>
<li>为我们本地培养高技能人才</li>
</ul>
<h2 id="4-什么是软件测试工程师"><a href="#4-什么是软件测试工程师" class="headerlink" title="4. 什么是软件测试工程师"></a>4. 什么是软件测试工程师</h2><ol>
<li>软件测试工程师（Software Testing Engineer）指理解产品的功能要求，并对其进行测试，检查软件有没有错误（Bug），测试软件是否具有稳定性（Robustness），写出相应的测试规范和测试用例的专门工作人员。</li>
<li>简而言之，软件测试工程师在一家软件企业中担当的是“质量管理”角色，及时发现软件问题并及时督促更正，确保产品的正常运作。</li>
</ol>
<h2 id="5-软件测试工程师的等级划分"><a href="#5-软件测试工程师的等级划分" class="headerlink" title="5. 软件测试工程师的等级划分"></a>5. 软件测试工程师的等级划分</h2><ol>
<li>初级测试工程师</li>
<li>中级测试工程师</li>
<li>高级测试工程师</li>
<li>测试管理人员</li>
<li>测试经理</li>
<li>测试总监</li>
</ol>
<h2 id="6-在桐桐信息技术培训人才技能范围"><a href="#6-在桐桐信息技术培训人才技能范围" class="headerlink" title="6. 在桐桐信息技术培训人才技能范围"></a>6. 在桐桐信息技术培训人才技能范围</h2><ol>
<li>中级测试工程师、高级测试工程师、测试管理人员</li>
</ol>
<h2 id="7-不同等级学习的技能范围"><a href="#7-不同等级学习的技能范围" class="headerlink" title="7. 不同等级学习的技能范围"></a>7. 不同等级学习的技能范围</h2><ul>
<li><p>中级测试工程师</p>
<ul>
<li>功能测试、接口测试、抓包技能、项目管理工具使用、查看日志、分析问题</li>
</ul>
</li>
<li><p>高级测试工程师</p>
<ul>
<li>在终极测试工程师的基础上、性能测试、安全测试、自动化测试</li>
</ul>
</li>
<li><p>测试管理人员</p>
<ul>
<li>在高级测试工程师基础上、管理技能（包括项目管理、人员管理）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课前</category>
        <category>初识测试</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>了解软件测试行业</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/02_%E6%B5%8B%E8%AF%95%E8%A1%8C%E4%B8%9A/</url>
    <content><![CDATA[<p>随着中国IT行业的发展以及未来AI时代的到来。越来越多的人加入到IT行业，对于很多没有从事过IT工作的人来，或者对于很多专业跟IT扯不上关系的人来说。转行做软件测试是一个很好的选择。</p>
<p>软件开发起码要培训半年以上，才能胜任工作。 而软件测试只需要1个月。</p>
<h2 id="1-测试行业介绍"><a href="#1-测试行业介绍" class="headerlink" title="1 测试行业介绍"></a>1 测试行业介绍</h2><ul>
<li><p>目前IT企业也越来越重视软件产品的质量， 从软件，硬件到系统集成，几乎每个小中大IT企业，在产品发布之前都需要大量的测试工作。软件测试工程师，是目前IT行业非常短缺的人才，中国软件行业每年要新增几十万的测试岗位就业机会。但是学校培养出来的测试人才却不足需求量的十分之一。</p>
</li>
<li><p>目前软件测试行业的缺口非常大。 90%的测试人员是不会写代码的，但是薪资依然可观。基本上一个三年测试经验的人，薪资都在万元以上。未来的职业发展前景也非常广阔。</p>
</li>
</ul>
<h2 id="2-软件测试是做什么的"><a href="#2-软件测试是做什么的" class="headerlink" title="2 软件测试是做什么的"></a>2 软件测试是做什么的</h2><ul>
<li><p><img src="/assets/wpsC670.tmp-20211222145920-4awo4by.jpg"></p>
</li>
<li><p>软件测试，就是找出软件系统中的错误，并且确保软件开发人员修复这些错误， 最终移交一个质量好的软件，给客户使用。</p>
</li>
<li><p>比如下图，一个网页中的密码输入框中的字符不是用星号显示，而是明文显示。这就是一个软件的bug。软件测试就是要将这些bug找出来</p>
</li>
<li><p><img src="/assets/wpsC671.tmp-20211222145920-cq9ge46.jpg"></p>
</li>
<li><p>下图是一个功能性的Bug，这种Bug比较严重，会影响用户的使用，甚至会给用户造成损失，所以软件测试就是需要提前把这些Bug找出来，确保软件交付给用户使用后，没有问题。</p>
</li>
</ul>
<h2 id="3-入门门槛非常低"><a href="#3-入门门槛非常低" class="headerlink" title="3 入门门槛非常低"></a>3 入门门槛非常低</h2><ul>
<li><p>经常听想入行的朋友说，我想转软件测试，听说软件测试很简单。的确，软件测试入门是很简单。</p>
</li>
<li><p>IT行业中有几百个工种， 其中软件测试是入门门槛最低。普通人只要经过短期的培训，大概学一个月就能胜任响应的软件测试工作。软件测试人员起薪在7000元-10000元不等，工作三年后，月薪基本上能达到10000到15000。</p>
</li>
<li><p>软件测试入门虽然简单， 但是精通很难。</p>
</li>
</ul>
<h2 id="4-测试人员每天的日常工作"><a href="#4-测试人员每天的日常工作" class="headerlink" title="4 测试人员每天的日常工作"></a>4 测试人员每天的日常工作</h2><ul>
<li>大部分软件测试人员的工作可以简单的归为这几个字， “点点点，开Bug”。</li>
</ul>
<h2 id="5-一些转行实例"><a href="#5-一些转行实例" class="headerlink" title="5 一些转行实例"></a>5 一些转行实例</h2><ul>
<li><p>身边转行做测试的例子太多了， 我举几个实际的转行的例子。这些例子都是真实的。</p>
</li>
<li><p>我姑姑的儿子大学专科毕业，找不到工作，因为他们的学校一塌糊涂，大学的时候玩游戏，什么都没学到。本来他打算南下广东， 去进厂当流水线工人的。 我姑姑不甘心他儿子去进厂当流水线工人。 然后就拜托我帮帮忙。 后来我这弟弟就来到上海投奔我。 我培训了2个月软件测试。 弟弟很轻松的就进入了一家软件公司，到现在做了快5年了， 已经成长为一名高级测试工程师。</p>
</li>
<li><p>后来我就把好几个堂弟以及一些亲戚，都拉到上海来从事软件测试行业。目前家族中很多人都是从事软件测试行业。</p>
</li>
<li><p>JJO,  是96年的小姑娘， 今年24岁， 大专毕业后，一直在某酒店做前台工作人员， 月薪大概3000.， 做了2年了， 薪资只够自己开销，完全存不到钱，感觉到很迷茫。 偶然的机会由亲戚介绍，接触了软件测试。 开始跟人学习软件测试。学好出来后。</p>
</li>
<li><p>开始来到深圳做软件测试， 月薪一万。 越来越喜欢做软件测这份工作。</p>
</li>
<li><p>小明，男，大学毕业后，非常迷茫不知道做什么， 就去广东打工， 进了一个工厂，在流水线上工作，每个月也就4000多，不想做了后，又去一家鞋厂做。做了几个月，又不想做了。 觉得没有前途， 难道做到30岁，还是这么点工资吗？ 觉得自己需要改变， 后来机缘巧合，开始学习软件测试。 最终成功入行。    到现在50W一年的薪资。</p>
</li>
<li><p>小荣荣，女，大专毕业，今年30岁了，在上海一家公司做硬件检测8年了，月薪才4000多。有个女儿三岁了。 这点薪资完全不够用。后来决心赌一把，开始学习软件测试。学了大概1个月后，转行做软件测试，入行的时候薪水是1万。 工作后，又持续学习。还学了Python编程。到现在月薪已经超过2万多了。</p>
</li>
</ul>
<h2 id="6-哪些人适合转行"><a href="#6-哪些人适合转行" class="headerlink" title="6 哪些人适合转行"></a>6 哪些人适合转行</h2><ol>
<li><p>专业是计算机专业的毕业生</p>
<p> 一点问题没有， 只要不要辛苦，姿态放低一点。 很简单</p>
</li>
<li><p>非计算机专业的毕业生</p>
<p> 不是计算机专业的，从事软件测试完全没问题。</p>
</li>
<li><p>转行的人。</p>
<p> 目前软件测试行业，很多人都不是计算机专业的。 很多都是别的行业转行过来的。</p>
</li>
<li><p>在一些城市，薪资少于8000</p>
<p> 生活在一线城市，目前的薪资少于6000，并且在可遇见的未来几年，薪资不会有很大提升的职业。都可以选择转行做软件测试。</p>
</li>
</ol>
<h2 id="7-软件测试职业规划"><a href="#7-软件测试职业规划" class="headerlink" title="7 软件测试职业规划"></a>7 软件测试职业规划</h2><ul>
<li><p>本人从事软件8多年，认识的测试人员超过上千位，有很多工作超过10年的老测试，也有很多刚毕业刚进入测试行业的人。根据我认识的测试人员目前的情况，我大概列出以下软件测试的职业规划</p>
</li>
<li><p><img src="/assets/wpsC672.tmp-20211222145920-h98oqep.jpg"></p>
</li>
<li><p>就2018年上海地区来行情来说，一个刚毕业的本科生从事软件测试行业大概薪水是5000到7000左右， 3年测试经验薪水大概是9000-13000左右，5年测试经验的薪水大概在13000-20000左右。10年以上的老测试大概在30000以上。</p>
</li>
<li><p>根据行业的不同，薪资的差别也比较大。互联网和外企的薪水会较高。互联网的工作强度大，加班多。当然薪资要偏高。 外企要求英语好+技术好。 英语好和技术同时要好，属于复合型人才，这种人才比较稀缺。所以待遇也相应要好很多。</p>
</li>
<li><p>测试人员不但需要对软件的质量进行检测，还能接触到与软件相关的各行各业，项目管理、沟通协调、市场需求分析等能力都能得到很好的锻炼，从而为自己的多元化发展奠定了基础，经过实践几年后，很容易晋升到主管、项目经理等高级职位。</p>
</li>
</ul>
<h2 id="8-软件测试职业的优点"><a href="#8-软件测试职业的优点" class="headerlink" title="8 软件测试职业的优点"></a>8 软件测试职业的优点</h2><ul>
<li><p>个人觉得软件测试职业具备很多优点。</p>
<ol>
<li><p>优点1 非常适合女生</p>
<ul>
<li><p>女生具备很多优点，首先女生稍微细心，更容易发现Bug。女生的沟通能力比较好， 发现Bug后，找开发人员沟通的比较顺畅，90%的开发都是男的，会比较有风度。</p>
</li>
<li><p>大家会发现软件开发中女生占的比例是10%以下。而在软件测试中，女生占的比例有50%左右。</p>
</li>
<li><p>我身边很多从事软件测试的女生，生活都过得很好。很多女同事薪资都超过2W，老公的薪资更高。很多在上海生了二胎，买了二套房。</p>
</li>
<li><p>所以女生很适合做软件测试行业。</p>
</li>
</ul>
</li>
<li><p>优点2 适合平庸的人</p>
<ul>
<li><p>平常工作中接触过太多牛人了，很多刚毕业的人，写代码的水平相当高。可以独立开发很大的系统。接触了很多智商高的人。我深深的体会到，被碾压的感觉。</p>
</li>
<li><p>软件测试非常适合平庸的人。 因为不需要天才也能做。</p>
</li>
</ul>
</li>
<li><p>优点3 劳动强度和压力适中</p>
<ul>
<li><p>软件行业大家的压力都比较大， 尤其是开发人员的压力很大啊， 相比之下，软件测试的劳动强度和压力，都比软件开发小很多。  很适合女同学做。</p>
</li>
<li><p>开发人员在开发项目的时候，会碰到很多技术难题，很难保证一个全新的项目能否按时开发完。 测试就好很多，测试工作中的主要是工作量大的问题，大不了加班，不存在完不成的问题，心里压力要小很多。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="9-软件测试职业的缺点"><a href="#9-软件测试职业的缺点" class="headerlink" title="9 软件测试职业的缺点"></a>9 软件测试职业的缺点</h2><ul>
<li><p>说了这么多优点，下面来说说缺点。</p>
<ol>
<li><p>缺点1：薪资比开发工程师低</p>
<ul>
<li>测试工程师的薪资普遍要比开发工程师低20%以上。这个其实是合理的。</li>
</ul>
</li>
<li><p>缺点2：没法创业和赚外快</p>
<ul>
<li><p>身边很多人创业，很多同事是边工作边赚外快，帮别人做网站，做APP，维护系统之类的。当外快的钱比上班的的钱还多之后，很多同事就辞职，全职创业了。</p>
</li>
<li><p>而软件测试就没有这样的机会，至少我没听说几个软件测试创业成功的。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="10-传统的软件公司和互联网公司的区别"><a href="#10-传统的软件公司和互联网公司的区别" class="headerlink" title="10 传统的软件公司和互联网公司的区别"></a>10 传统的软件公司和互联网公司的区别</h2><ul>
<li><p>互联网公司需要大量的测试人员，那么什么样的公司才是互联网公司呢？</p>
<ol>
<li>传统软件公司的产品和服务依赖于特定的终端和相应的操作系统，而互联网公司产品和服务则依赖于浏览器和网络。</li>
<li>传统软件公司是卖软件给用户用，互联网公司是自己运营。</li>
<li>传统软件公司需求都是从真正用软件的用户那里间接得来的，需求经过收集，传递，分析，实现，测试，上线。整个过程很长。互联网公司一般都是自己开发自己用，有什么问题立刻改。</li>
<li>从用户角度看， 传统软件产品都是在本地，需要自己安装。而互联网公司的产品只需要通过互联网来访问。比如通过浏览器或者APP来使用。</li>
<li>传统软件公司上线周期长，可能要几个月才上线一个产品。 而互联网公司上线周期短，可能一个星期就上线一次，或者2次。所以测试会比较忙。</li>
<li>传统的软件公司有，苹果，小米，微软。</li>
</ol>
</li>
<li><p>互联网企业有， 谷歌，facebook,阿里，腾讯.还有比如说，网络游戏，直播。电子商务。</p>
</li>
<li><p>互联网企业众多，需要大量的测试人员。大部分的测试人员都是进入了互联网企业.</p>
</li>
</ul>
<h2 id="11-测试分两种"><a href="#11-测试分两种" class="headerlink" title="11 测试分两种"></a>11 测试分两种</h2><ul>
<li><p><img src="/assets/wpsC673.tmp-20211222145920-91n8oyg.png"><img src="/assets/wpsC674.tmp-20211222145920-rscndg4.jpg"></p>
</li>
<li><p>软件测试分为手动测试和自动化测试。手动测试工程师只要求像普通用户那样去使用软件，发现了问题，在Bug管理系统中，开一个Bug就可以了</p>
</li>
<li><p>而自动化测试工程师，是需要懂代码，了解Java或者Python， 会使用JMeter和Postman做接口测试，会使用Selenium做UI自动化测试。自动化测试是发展方向。三年以上的测试工程师都应该朝这个方向发展</p>
</li>
</ul>
<h2 id="12-B-x2F-S和C-x2F-S架构的区别"><a href="#12-B-x2F-S和C-x2F-S架构的区别" class="headerlink" title="12 B&#x2F;S和C&#x2F;S架构的区别"></a>12 B&#x2F;S和C&#x2F;S架构的区别</h2><ul>
<li><p>Browser&#x2F;Server架构（浏览器&#x2F;服务器架构），主要是指的是Web应用程序，比如淘宝网，以及各种网站。如下图</p>
</li>
<li><p>C&#x2F;S架构  是Client&#x2F;Server(客户端&#x2F;服务器)架构，主要是传统的桌面机的应用程序。如下图</p>
</li>
<li><p><img src="/assets/wpsC675.tmp-20211222145920-yxbq22w.jpg"></p>
</li>
<li><p>目前大概90%的系统都是采用B&#x2F;S架构，是未来的趋势。传统的C&#x2F;S架构的软件越来越少，C&#x2F;S的软件慢慢被淘汰。B&#x2F;S架构的优点是客户不需要安装软件，直接使用浏览器就可以访问了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>课前</category>
        <category>测试行业</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>多维度分析</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/03_%E5%A4%9A%E7%BB%B4%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>2020年</p>
<p><img src="/assets/image-20211120103613-yl1kx4c.png" alt="image.png"></p>
<h2 id="1-从业人员分布情况"><a href="#1-从业人员分布情况" class="headerlink" title="1. 从业人员分布情况"></a>1. 从业人员分布情况</h2><p><strong>1. 性别分布</strong></p>
<p><img src="/assets/image-20211207164743-c3tffd4.png" alt="image.png"><br>随着社会大环境鼓励生育二胎，相信女性回归家庭的比例有所攀升，2020 年测试岗位男性比例再次回到超过 70%。<br>很多测试同学可能感觉联系实际情况，做测试的女生明明很多，为何调查结果是男生占比高呢？</p>
<p>其实很好理解，关注 TesterHome 的同学以测试开发人员为主，尤其是效能和工具平台建设，以及智能、大数据、物联网等方向的测试人员，男生比例高些，也符合感性的感觉。</p>
<p>欢迎大家来参加 2021 年即将在上海举办的中国互联网测试开发大会 MTSC2021 上海站现场感受。</p>
<h2 id="2-年龄分布"><a href="#2-年龄分布" class="headerlink" title="2. 年龄分布"></a>2. 年龄分布</h2><p><img src="/assets/image-20211207164749-0jqcixc.png" alt="image.png"><br>从调查结果来看，35+ 测试人员占与去年持平，各年龄段的分布连续三年也较稳定。最近几年大家讨论最多的关于年龄的话题就是 “35 周岁中年危机” 了，职场上 35 岁 + 的人都去哪了呢？<br>测试开发岗位只是万千行业岗位中的一个，若年龄到了一个阶段，经验没有继续增长，学习能力却降低，而薪水不能降低吧？</p>
<ul>
<li>用人成本考量上，公司一般会偏向年轻人</li>
<li>团队梯队建设上，会考虑新老搭档</li>
</ul>
<h2 id="3-所在地分布"><a href="#3-所在地分布" class="headerlink" title="3.所在地分布"></a>3.所在地分布</h2><p><img src="/assets/image-20211207164753-6qbj4yn.png" alt="image.png"></p>
<ul>
<li>与前两年一致，互联网测试从业人员主要依然是来自一二线城市，但可以看出二线城市的比例逐年增加，单从这个结果上可以有 2 个猜测：</li>
<li>更多来自二线城市的测试人员</li>
<li>测试人员从一线搬至二线城市定居了，可推测二线城市对测试人员需求增加</li>
</ul>
<h2 id="4-工作年限分布"><a href="#4-工作年限分布" class="headerlink" title="4. 工作年限分布"></a>4. 工作年限分布</h2><p><img src="/assets/image-20211207164759-nhnwdcl.png" alt="image.png"></p>
<ul>
<li>这个调查和年龄分布可对比看，年龄 30 周岁 + 的总占比与去年持平，但工作时间超过 10 年以上的人数占比却稳步提升。</li>
<li>工作 6-10 年的人数占比也显著增加，二者加起来就是工作 5 年以上人数占比 37.4%。</li>
</ul>
<h2 id="5-学历分布"><a href="#5-学历分布" class="headerlink" title="5. 学历分布"></a>5. 学历分布</h2><p><img src="/assets/image-20211207164806-sqad1w0.png" alt="image.png"></p>
<ul>
<li>本科一如既往占七成，硕士占比近十分之一，博士继去年零突破后继续增加了。</li>
<li>测试开发人员属于技术类人员，对学历有要求，相信与其他相关技术从业人员也一致。</li>
</ul>
<h2 id="6-进入测试行业的途径"><a href="#6-进入测试行业的途径" class="headerlink" title="6.进入测试行业的途径"></a>6.进入测试行业的途径</h2><p><img src="/assets/image-20211207164811-ivob3vp.png" alt="image.png"></p>
<ul>
<li>毕业即入行，依然是常规途径，比例超过一半。由此可见，各大公司持续将校园招聘作为主要招聘渠道。</li>
<li>通过培训机构入行的连续三年增长，今年超过 15%，一定程度上反映了当下测试培训的火爆。</li>
</ul>
]]></content>
      <categories>
        <category>课前</category>
        <category>多维度分析</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>薪资分析</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/04_%E8%96%AA%E8%B5%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、2021年软件测试的平均工资怎样？"><a href="#一、2021年软件测试的平均工资怎样？" class="headerlink" title="一、2021年软件测试的平均工资怎样？"></a>一、2021年软件测试的平均工资怎样？</h2><p>测试薪资，每个地方不太一样（后面会列上国内主要城市薪资），我们以北京为例，先来给大家看一下2020年的测试薪资，如下图所示：</p>
<p><img src="/assets/image-20211207164957-j4c2r0a.png" alt="image.png"></p>
<p> <strong>2021年又比2020年增加了3000多元。</strong> 最近这些年，测试薪资是一路往上涨的。</p>
<p>北京作为一线大城市，薪资肯定高，但很多小伙伴们未必是在北京工作，而是在自己的省会城市或其他一线城市，那他们的薪资如何呢？请继续往下看。</p>
<h2 id="二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？"><a href="#二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？" class="headerlink" title="二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？"></a>二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？</h2><p>看过了北京的薪资，再来看看其他城市的薪资。</p>
<p><img src="/assets/image-20211207165002-crnepas.png" alt="image.png"></p>
<h2 id="三、与编程开发相比，软件测试的薪资如何呢？"><a href="#三、与编程开发相比，软件测试的薪资如何呢？" class="headerlink" title="三、与编程开发相比，软件测试的薪资如何呢？"></a>三、与编程开发相比，软件测试的薪资如何呢？</h2><p>相信这个是很多由于到底是学编程还是测试的同学非常关注的。</p>
<p> <strong>给大家揭露一个非常有趣的现象：</strong> 以10年工龄为界，10年之内，同等工龄的开发岗位平均薪资要超过测试；<strong>但10年之后，软件测试的平均薪资却要反超编程开发。</strong></p>
<p>是不是这样呢？请狠狠点击下方链接查看直接证据：</p>
<p><a href="https://www.zhihu.com/question/33405392/answer/1649870187"><img src="/assets/image-20211207165006-ua3sb2o.png" alt="image.png"></a></p>
<h2 id="四、近10年来软件测试工资的波动状况，预测未来趋势"><a href="#四、近10年来软件测试工资的波动状况，预测未来趋势" class="headerlink" title="四、近10年来软件测试工资的波动状况，预测未来趋势"></a><strong>四、近10年来软件测试工资的波动状况，预测未来趋势</strong></h2><p>未来测试的薪资会怎样呢？老方法，回顾过去，才能展望未来，我们来看下近10年来测试平均薪资。为了能让趋势客观，仅选用北京测试薪资。</p>
<p><img src="/assets/image-20211207165010-h9cwmyo.png" alt="image.png"></p>
<p>刚刚我们看到了<strong>北京薪资2020年是15430，那么2019年是多少呢？请往下看14480元</strong></p>
<p><img src="/assets/image-20211207165015-lg94kmv.png" alt="image.png"></p>
<p>2018年，2017年，2015年，2014年……分别是多少呢？</p>
<p><img src="/assets/image-20211207165019-yvqzw61.png" alt="image.png"></p>
<p>从以上的薪资趋势可以看到，测试薪资10年来，已经从4460元跃升到15430元，薪资一路上涨。尤其是在2015年和2017年，涨薪幅度达到40%和34%。</p>
<p>为什么薪资能一路上涨，因为这10年来，互联网竞争越来越趋同质化， <strong>未来的互联网产品不仅是运营取胜，更是质量取胜，而测试人员就是保证质量的守门员，</strong> 这也是为何 <strong>2020是疫情之年，测试薪资仍比2019年上涨了1000元，2021年又比2020年增加了3000多元的根本原因。</strong> 所以未来测试薪资，不出意外， <strong>也将继续一路上扬</strong> 。</p>
<h2 id="五、测试各个岗位的薪资是怎样的？"><a href="#五、测试各个岗位的薪资是怎样的？" class="headerlink" title="五、测试各个岗位的薪资是怎样的？"></a>五、测试各个岗位的薪资是怎样的？</h2><p>测试按技术分，分支较多，有功能测试、接口测试、Ui自动化测试、性能测试、安全测试、测试开发….  各个岗位的薪资肯定是不一样的，带大家来看下</p>
<h3 id="1-功能测试（也叫手工测试）"><a href="#1-功能测试（也叫手工测试）" class="headerlink" title="1.功能测试（也叫手工测试）"></a><strong>1.功能测试（也叫手工测试）</strong></h3><p><img src="/assets/image-20211207165023-u0xwhox.png" alt="image.png"><br>2020年功能测试薪资</p>
<p><img src="/assets/image-20211207165027-3bpqrh8.png" alt="image.png"><br>2021年功能测试薪资，较2020上涨了2.6K</p>
<p>功能测试是其他测试工作的基础，是培养测试用例设计能力和建立测试思维的关键阶段。但是如果只是每天机械的进行“点点点”，想拿高薪是不太现实的。但是如果用例设计的非常牛，能够验证出系统中的绝大部分bug（尤其是关键的bug）；或者对某一行业的业务非常熟练也是可以拿到高薪的。</p>
<p>根据市场的实际情况来看，拿高薪的软件测试工程师一般都是具备良好的手工测试技能。<strong>所以手工测试虽然薪资是最低的，但是却是最核心的，千万不能忽视。</strong></p>
<h3 id="2-自动化测试"><a href="#2-自动化测试" class="headerlink" title="2 自动化测试"></a><strong>2 自动化测试</strong></h3><p><img src="/assets/image-20211207165031-gyq50kn.png" alt="image.png"><br>2020年自动化测试薪资截图</p>
<p><img src="/assets/image-20211207165035-dtga3sw.png" alt="image.png"><br>2021年自动化测试薪资，较2020增加2.5K</p>
<p>自动化测试主要包括接口自动化测试和UI自动化测试。</p>
<p><strong>为什么做接口自动化测试能拿高薪呢？</strong><br>因为现在的软件，都是前后端分离的，需要通过接口实现前后端数据的传递。所以接口自动化测试非常重要，大部分的公司都会做接口自动化测试的。</p>
<p><strong>为什么会UI自动化测试能拿高薪呢？</strong></p>
<p>通过手工方式实现项目回归测试既费时又费力，如果是已经写好的自动化测试脚本直接运行就可以了，可以实现真正的无人值守。<strong>UI自动化测试目前做的比较多的是Web自动化测试和APP自动化测试。</strong></p>
<p>所以做UI自动化测试一般都要具备一定的编程能力，而绝大部分测试人员是没有编程能力的，能拉开与别人之间的距离。</p>
<p>UI自动化测试比较适合功能比较稳定、回归测试比较频繁的项目，能很好的提高测试效率、节省手工验证的成本。</p>
<p><strong>3 性能测试</strong></p>
<p><img src="/assets/image-20211207165039-o2lhkgg.png" alt="image.png"><br>2020年性能测试薪资截图</p>
<p><img src="/assets/image-20211207165043-h5hcwvm.png" alt="image.png"><br>2021年性能测试薪资截图，较2020年上涨1.1K</p>
<p><strong>为什么说性能测试很有必要：</strong><br>人们对软件响应的速度也有很高的要求；但与之相对立的是用户访问量越大、数据量越多，软件产品的响应速度就会下降。所以每一个用户量较大的系统都面临着很大的挑战。作为一个测试人员，在产品交付客户上线之前就需要进行充分的性能测试，能够保证软件产品能够承受住实际用户访问的需求。</p>
<p><strong>为什么说做好性能测试不容易？</strong></p>
<p>要做好性能测试，除了最基本的会使用性能测试工具之外，还要对系统的架构、服务之间的调用非常清楚。性能测试的基本技能是性能测试脚本的编写，核心和难点是性能的瓶颈分析和性能调优。如果能把性能测试做好了，想拿高薪真的很容易！</p>
<p><strong>性能测试常用的工具有JMeter和Loadrunner。</strong></p>
<p><strong>4 安全测试</strong></p>
<p><img src="/assets/image-20211207165048-fwu6vzc.png" alt="image.png"><br>2020年安全测试薪资截图</p>
<p><img src="/assets/image-20211207165052-tyraktd.png" alt="image.png"><br>2021年薪资截图，较 2020年上涨2.2K</p>
<p>安全测试是测试中的一个专项测试，一般都是有专门的安全测试人员进行测试，专业技能要求比较高，但是 <strong>薪资待遇更是非常可观。</strong> 常见的安全测试有暴力破解、<a href="https://www.zhihu.com/search?q=%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1581863304%7D">越权漏洞</a>、命令注入、SQL注入、XSS、CSRF等等。</p>
<p><strong>5 测试开发</strong></p>
<p><img src="/assets/image-20211207165056-nyggkjx.png" alt="image.png"><br>2020年测试开发薪资截图</p>
<p><img src="/assets/image-20211207165100-b9slwms.png" alt="image.png"><br>2021年测试开发薪资截图，教上年增加2.5K</p>
<p>市场有大量测试开发岗位 打开BOSS直聘、智联招聘、拉勾等招聘平台，我们可以看到有很多测试开发的岗位。</p>
<p><img src="/assets/image-20211207165104-h3ogzke.png" alt="image.png"></p>
<p><strong>为什么说测试开发能拿高薪呢？</strong></p>
<p>测试开发岗位对软件测试工程师有更高的技能要求，不仅要有测试的技能，还要有开发的技能。永远都要相信当今社会不缺少高薪的岗位，只是缺少能拿高薪的人才。</p>
<p><strong>测试开发的主要工作是什么？</strong></p>
<p>目前测试开发的工作主要包括测试工具的开发、测试平台的开发、测试框架的搭建等。这些工作都能够服务于普通的测试人员，提高测试的效率，给公司创造价值。</p>
]]></content>
      <categories>
        <category>课前</category>
        <category>薪资分析</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/06_%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>测试素质</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/01_%E8%AF%BE%E5%89%8D/05_%E6%B5%8B%E8%AF%95%E7%B4%A0%E8%B4%A8/</url>
    <content><![CDATA[<ol>
<li>对于软件 测试人员来说需要具备的素质，我觉得首先最重要的是要有一定的理论知识和 测试技能，这是测试工作的基础。那么我们 测试人员还应该具备哪些素质才能在工作当中被不断的认可呢？</li>
<li>一名优秀的测试人员应该具有的素质包括：</li>
</ol>
<h3 id="一、-踏实细心和积极主动"><a href="#一、-踏实细心和积极主动" class="headerlink" title="一、 踏实细心和积极主动"></a><strong>一、 踏实细心和积极主动</strong></h3><ol>
<li>我觉得作为一名测试人员首先要踏实细心。细心：这个不用多解释了吧。粗枝大叶的人是没法做好 软件测试的。 软件测试，特别是当前国内主流的手动黑盒 功能测试。基本上软件测试的工作就是一项重复劳动，需要有一定的耐心来保证不在枯燥的重复劳动中放过那些细小的 缺陷。测试人员每天都要面对着枯燥的程序，从事着大量的重复工作，还要尽量发现产品中的 bug。如果不踏实，你就坐不住，总想干别的，就无法净下心来想用户有可能怎么用， 需求对产品是怎么要求的，现在产品中是怎么做的，哪里可能存在问题。不细心，就特别容易一些产品中微笑的错误，而恰恰就是这些错误是最影响产品形象的问题。</li>
<li>至于积极主动就不多说了。这是每个人都应该具有</li>
</ol>
<h3 id="二、-好奇心，怀疑一切"><a href="#二、-好奇心，怀疑一切" class="headerlink" title="二、 好奇心，怀疑一切"></a><strong>二、 好奇心，怀疑一切</strong></h3><ol>
<li>测试人员，对于手上的项目，如果单单只是去运行它，这样是没法发现问题的。我们测试人员进行测试的主要目的就是发现软件存在缺陷，而不是证明它没有缺陷。如果不抱着怀疑一切的态度就不是一名合格的测试人员。经过你手测试的产品面对的是直接用户。你不认真负责，不抱着怀疑一切的态度。总想着这个功能本版没动应该没什么问题，认为一般人不会去这样操作它，这个功能没什么用户用不用认真测了。这样发出的产品，我是不敢让用户用。因为用户用起产品来是千奇百怪，有些用户的水平和对产品的理解比咱们还要深。所以一定要抱着怀疑一切的态度，从多个方面考虑，认为产品每个功能都可能有问题，多问一个「为什么」，「如果这样，行不行？」，认真地测试产品的每一个测试点。</li>
</ol>
<h3 id="三、-与他人良好交流的能力"><a href="#三、-与他人良好交流的能力" class="headerlink" title="三、 与他人良好交流的能力"></a><strong>三、 与他人良好交流的能力</strong></h3><ol>
<li><p>众所周知，测试的过程是一个发现问题并且跟踪解决问题的一个过程，在这个过程中，要意识到测试、 开发、需求是一个团队，一个整体。离了谁，产品的质量都无法保证。沟通能力作为一项特别重要的软技能，在工作中起着举足轻重的作用。作为一名测试人员，我们在提交问题的时候，要做到条理清晰，必要时配上图片以便别人理解，自己提交的问题只有自己能看懂这可不行。我们还需要和项目经理交流了解最新的客户需求，要和 开发人员沟通以便解决缺陷。之前看过一段幽默的开发人员和测试人员的对话：</p>
<ol>
<li><p>测试日常：</p>
<ol>
<li>开发：这不是软件的问题，我看了测试代码，这个地方有点问题，不该是这样测。</li>
<li>测试：真的吗？我看看…真的啊，稍等我提交一下…谢谢你帮我们找到这个bug。</li>
<li>开发：没事，不用谢…（感觉有什么不对）</li>
</ol>
</li>
<li><p>无论是和项目经理还是开发员人交流的时候，态度很重要，这里我说的态度不是低声下气，底气不足的跟她们交流，特别是和开发人员交流时，可能会因为一个bug，两人争执不下发生冲突，这时候我们测试人员要做到分析问题所在，同时也要听听开发人员的想法，心平气和进行交流，最后实在是两人都拿不定注意，可以请示上级。</p>
</li>
</ol>
</li>
</ol>
<h3 id="四、-持续不断的自我提高和总结能力"><a href="#四、-持续不断的自我提高和总结能力" class="headerlink" title="四、  持续不断的自我提高和总结能力"></a><strong>四、  持续不断的自我提高和总结能力</strong></h3><ol>
<li><p>我觉得无论是哪个行业，都不能停滞不前，自我提高是必须的，这样才不会被淘汰，那么作为一名优秀的测试人员如何提高自己的测试能力呢？</p>
<ol>
<li><strong>第一，首先提高自己的测试理论基础。</strong>所有的测试基础概念其实都是通用的：静态测试，动态测试， 测试用例，等等以及一些测试相关技术：等价类划分，边界值，相信这些方法所有的人每天都在用，但是未必所有的人都能说明白。所以为自己每天所做的测试行动找点理论基础，即有效率有与实践相结合，这也是职业发展的重要一步。</li>
<li><strong>第二，要对测试的整体流程有完整的概念。</strong>这个是目前很多初级测试人员所欠缺的。目前大多数人只知道自己测试的是什么东西，但是不知道自己执行的测试处于什么阶段，下一个阶段是什么，也许整个项目做完不知道；这对于一个产品来说是一个不负责任的行为，所以也就需要测试人员有端到端的测试意识和对测试流程的概念的认可，要有测试整体流程管理的概念。</li>
<li><strong>第三，在进行测试工作中要弄明白为什么要这么做，为什么要执行这样的案例，为什么要执行相关的测试工作。</strong>多问几个为什么。有一个问题要先讲清楚，就是有很多人还没有注意到这个问题，领导让怎么做就怎么做，也许真的做的很熟练了，但是一年后去问他为什么要这么做，相信他也说不出太多，反倒觉得就应该这么测。这样带来直接的弊端就是对自己的职业之路不负责任。</li>
<li>另外，我觉得作为一名合格的测试人员，一定要注意进行总结。通过总结可以对自己的工作进行一个回顾分析，看看那些做得不错，下次还继续这么做。那些工作还有改进的余地。对自己能力的提高是一个很好的帮助。</li>
</ol>
</li>
</ol>
<h3 id="五、-强烈的责任感"><a href="#五、-强烈的责任感" class="headerlink" title="五、  强烈的责任感"></a><strong>五、  强烈的责任感</strong></h3><ol>
<li>对于你测试的产品付责任，许多测试人员在早上来到办公室，完成自己的任务，然后晚上下班回家。当软件测试人员完成自己的任务，然后下班收拾东西回家，这种常规的工作方式听起来很正常吧？是的，不得不说，目前我们都是这样的一个状态。要完成一个高质量的产品，我们就要对它负责，那么怎么负责呢？</li>
<li>测试人员要对所测试的对象质量负责，要能保证测试的覆盖到每一需求点，同时要能保证功能都可以正确实现等或者达到了测试通过的标准。</li>
<li>对于测试人员漏测，毕竟人不是完美的，难免会出现错误，但是不能以漏测来做为质量考核。可以对其进行分类分析，究竟是哪个环节出现的问题，提出来进行改进。比如说需求描述不完整，导致理解错误；隐含性需求未考虑到；易用性方面考虑不周；实际环境与测试环境有差异；自身经验不足等多方面。</li>
<li>测试这项工作，是证明产品做了正确的事情，能满足用户的需求，用各种 测试方法来找出问题，是对质量的一种度量。好的质量是要靠高素质人员和好的过程来保证的。</li>
</ol>
]]></content>
      <categories>
        <category>课前</category>
        <category>测试素质</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world - 副本</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/05_%E5%85%B6%E4%BB%96/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hello-world - 副本</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/03_%E8%AF%BE%E5%90%8E/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hello-world - 副本</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li><h3 id="练习打字：要求1000字的文章，平均一分钟35字"><a href="#练习打字：要求1000字的文章，平均一分钟35字" class="headerlink" title="练习打字：要求1000字的文章，平均一分钟35字"></a>练习打字：要求1000字的文章，平均一分钟35字</h3></li>
<li><h3 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h3><ol>
<li><p><a href="../901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01_windows%E5%BF%AB%E6%8D%B7%E9%94%AE/">windows快捷键</a></p>
<ol>
<li>win+r  —-&gt; cmd—-&gt; 输入  ipconfig   查看本机ip</li>
<li>win+r  —-&gt; cmd—-&gt; 输入ping + url（ip）  查看与对方url（ip）是否互通</li>
</ol>
</li>
<li><p><a href="../901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02_Linux%E7%B3%BB%E7%BB%9F/">Linux</a></p>
</li>
<li><p><a href="../901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/03_windows%E4%B8%8Elinux%E7%9A%84%E5%8C%BA%E5%88%AB/">windows与linux的区别</a></p>
</li>
</ol>
</li>
<li><h3 id="编程基础："><a href="#编程基础：" class="headerlink" title="编程基础："></a>编程基础：</h3><ol>
<li><p>什么是编程语言</p>
<ol>
<li>编程语言（programming language）可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。编程语言处在不断的发展和变化中，从最初的机器语言发展到如今的2500种以上的高级语言，每种语言都有其特定的用途和不同的发展轨迹。编程语言并不像人类自然语言发展变化一样的缓慢而又持久，其发展是相当快速的，这主要是计算机硬件、互联网和IT业的发展促进了编程语言的发展。</li>
<li><a href="https://www.runoob.com/">编码基础课程（所有）</a></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="公司中常用的文件类型"><a href="#公司中常用的文件类型" class="headerlink" title="公司中常用的文件类型"></a>公司中常用的文件类型</h3><ol>
<li><p>.txt，.doc（word），.xls（excel），.ppt，.pdf,   .csv、.xmind</p>
<pre><code> 压缩文件：.rar格式，.zip格式，.tar格式

 执行文件：.bat格式（windows），.sh格式（linux），.exe格式（windows）

 日志文件：.log（一般是日志debug日志，系统日志，错误日志）
</code></pre>
<ul>
<li><p>xmind 快捷键</p>
<ul>
<li><img src="/assets/image-20220215095739-lhdjz41.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>测试理论概念</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ol>
<li><h4 id="软件测试的定义，什么是软件测试"><a href="#软件测试的定义，什么是软件测试" class="headerlink" title="软件测试的定义，什么是软件测试"></a>软件测试的定义，什么是软件测试</h4><ol>
<li>使用人工或自动手段，来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。</li>
</ol>
</li>
<li><h4 id="软件测试的目的"><a href="#软件测试的目的" class="headerlink" title="软件测试的目的"></a>软件测试的目的</h4><ol>
<li><p>测试是程序的执行过程，目的在于发现错误。</p>
</li>
<li><p>确保产品完成了它所承诺或公布的功能</p>
</li>
<li><p>确保产品满足性能和效率的要求</p>
</li>
<li><p>确保产品是健壮的和适应用户环境的</p>
</li>
</ol>
</li>
<li><h4 id="是否了解二八定律？"><a href="#是否了解二八定律？" class="headerlink" title="是否了解二八定律？"></a>是否了解二八定律？</h4><ol>
<li>了解</li>
<li>80%的问题可以在20%的模块中发现，换句话来说，软件系统中的问题存在群集现象，大部分的问题会集中在少数的模块上。</li>
<li><h5 id="二八定律怎么避免"><a href="#二八定律怎么避免" class="headerlink" title="二八定律怎么避免"></a>二八定律怎么避免</h5><ul>
<li>在分析设计以及实现阶段的复审能够发现和避免80%的缺陷，</li>
<li>在系统测试中能够找到剩余的80%的错误，</li>
<li>最后剩余的4%只能在用户的大范围使用长时间积累爆发出来</li>
</ul>
</li>
</ol>
</li>
<li><h4 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB/">软件测试的分类</a></h4><ol>
<li><p><img src="/assets/image-20220109174021-s16k61v.png" alt="image.png"></p>
<p> 黑盒测试：不考虑程序运行本身的逻辑，只考虑输入与输出之间的关系的测试</p>
<p> 白盒测试：开发人员进行的测试，代码测试</p>
<p> 灰盒测试：介于黑盒与白盒之间的测试</p>
<p> α测试：使用真实的环境，用户参与，全部产品、开发、测试参与，现场操作发现问题及时解决</p>
<p> β测试：使用真实的环境用户不参与，部分产品、开发、测试参与，现场操作发现问题后期解决</p>
</li>
<li><p>软件测试分类关系图</p>
<ol>
<li><img src="/assets/475aa778a57237c7e6a571329668eb4-20220109175114-4ddp7g5.jpg" alt="475aa778a57237c7e6a571329668eb4.jpg"></li>
</ol>
</li>
<li><p>软件测试类型</p>
<ol>
<li>功能测试、性能测试、安全测试、自动化测试、渗透性测试、UI测试</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h3><ol>
<li><p>所有的测试都应该追溯到需求</p>
</li>
<li><p>尽早参与测试</p>
</li>
<li><p>测试中80%的缺陷来源于20%的模块中</p>
</li>
<li><p>不做不准备不充分的测试</p>
</li>
<li><p>避免测试的随意性</p>
</li>
<li><p>要长期保存我们的测试用例，直到系统废弃</p>
</li>
</ol>
</li>
<li><h3 id="项目流程——-gt-gt-软件的生命周期"><a href="#项目流程——-gt-gt-软件的生命周期" class="headerlink" title="项目流程——-&gt;&gt;软件的生命周期"></a>项目流程——-&gt;&gt;软件的生命周期</h3><ol>
<li><p>首先有需求人员编写需求文档，提供产品模型，并对这个需求进行评审，开发根据自己得到的任务进行编写代码、详设文档，测试人员根据自己得到的任务编写测试用例，进行用例评审，开发编写完成后会提交一个测试版本，我们测试用编写的用例进行测试，测试过程中如果发现bug，找到对应的开发给予解决，等bug修改以后，我们进行返测，如果通过直接关闭，如果不通过打回重新修改，直到bug关闭为止，编写测试报告， 然后进行版本发布，编写测试总结</p>
</li>
<li><p><strong>是不是所有的bug都关闭才能发布版本？</strong></p>
<ol>
<li><strong>不一定，有不影响项目上线的bug是允许存在的，比如说提示类说明文字与需求不一致</strong></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="测试平时工作的内容"><a href="#测试平时工作的内容" class="headerlink" title="测试平时工作的内容"></a>测试平时工作的内容</h3><ol>
<li>参与需求评审   编写测试用例  评审用例  搭建环境  执行测试   发现bug  协助开发定位问题  返测  版本发布    测试总结  测试报告</li>
</ol>
</li>
<li><h3 id="怎么把控软件的进度"><a href="#怎么把控软件的进度" class="headerlink" title="怎么把控软件的进度"></a>怎么把控软件的进度</h3><ol>
<li>通过测试计划，晨会，测试日报，里程碑</li>
</ol>
</li>
<li><h3 id="怎么把控软件质量"><a href="#怎么把控软件质量" class="headerlink" title="怎么把控软件质量"></a>怎么把控软件质量</h3><ol>
<li>需求文档明确</li>
<li>严格根据我们用例进行测试</li>
<li>保证用例的全面覆盖</li>
</ol>
</li>
<li><h3 id="一名优秀的测试人员应该具有的素质包括："><a href="#一名优秀的测试人员应该具有的素质包括：" class="headerlink" title="一名优秀的测试人员应该具有的素质包括："></a>一名优秀的测试人员应该具有的素质包括：</h3> 一  踏实细心和积极主动<br> 二  好奇心，怀疑一切<br> 三  与他人良好交流的能力<br> 四  持续不断的自我提高和总结能力<br> 五  强烈的责任感</li>
<li><h3 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/">测试计划</a></h3><ol>
<li>什么是测试计划？</li>
<li>测试计划的目的？</li>
<li>测试计划是由谁写的？</li>
</ol>
</li>
<li><h3 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/">测试用例设计</a></h3></li>
<li><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/07_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C/">软件测试执行</a> </li>
<li><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/08_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/">软件测试报告</a> </li>
<li><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/">软件测试概念总结</a></li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>基础</category>
        <category>测试理论概念</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>接口测试</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/02_%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/01_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<ol>
<li><h3 id="什么情况下会进行接口测试"><a href="#什么情况下会进行接口测试" class="headerlink" title="什么情况下会进行接口测试"></a>什么情况下会进行接口测试</h3><ol>
<li>版本一：后台开发出来，但前端页面还没有完成，需要对后台开发出来的功能进行测试</li>
<li>版本二：一般有需求就会做，后台的接口开发好，就可以开始测。例外，如果增加了新需求，也要做接口测试，还有就是开发对后台的接口做了修改，交互逻辑发生变化，我们也要重新对接口进行测试。</li>
</ol>
</li>
<li><h2 id="接口测试的目的-x2F-为什么要进行接口测试"><a href="#接口测试的目的-x2F-为什么要进行接口测试" class="headerlink" title="接口测试的目的&#x2F; 为什么要进行接口测试"></a>接口测试的目的&#x2F; 为什么要进行接口测试</h2><ol>
<li>可以前置测试时间，减少测试成本，提高测试效率，能够今早的定位缺陷尽早修复</li>
</ol>
</li>
<li><h2 id="接口测试的主要辅助工具—-gt-lt-桩模块-gt"><a href="#接口测试的主要辅助工具—-gt-lt-桩模块-gt" class="headerlink" title="接口测试的主要辅助工具—&gt;&lt;桩模块&gt;"></a>接口测试的主要辅助工具—&gt;&lt;桩模块&gt;</h2><ol>
<li>((20211207001347-5cgfdwh “postman “))</li>
<li>((20211207001354-7kz968b “jmeter”))</li>
<li>((20220311173215-4vqsrmj “soapUI”))</li>
<li>apipost：<a href="https://www.apipost.cn/">ApiPost - API 文档、调试、Mock、测试一体化协作平台</a></li>
<li>mock： 模拟数据，当前端开发出来，后端接口不能使用时可以模拟数据</li>
</ol>
</li>
<li><h2 id="什么是接口测试？"><a href="#什么是接口测试？" class="headerlink" title="什么是接口测试？"></a>什么是接口测试？</h2><ol>
<li>系统与系统，模块与模块之间数据的交互、调用</li>
<li>api是接口的通道，每个系统都有自己的格式</li>
<li>桩模块：模拟被测模块的上级模块，相当于镜子一样</li>
</ol>
</li>
<li><h2 id="接口的类型"><a href="#接口的类型" class="headerlink" title="接口的类型"></a>接口的类型</h2><ol>
<li><p>websever、MQ、scoket、http</p>
<ol>
<li><p>websever：通用型接口，主要用于网络的数据传输，格式xml</p>
</li>
<li><p>MQ：属于消息队列，适用于大型的软件架构，数据传输的速度快，量大，稳定   银行业务</p>
</li>
<li><p>scoket：既是接口类型又是协议，它可以自定义端到端的接口，采用的是tcp、udp通信协议</p>
</li>
<li><p>http：即是接口类型又是协议，属于超文本传输协议，他是开发定义好的，我们只是拿来直接使用</p>
<ol>
<li>http分为两个底层接口类型：soap、rest</li>
<li>soap：http中底层接口传输协议，格式xml，属于软件架构的风格</li>
<li>rest：http中底层接口传输协议，格式json，属于简单的访问对象</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口的格式"><a href="#接口的格式" class="headerlink" title="接口的格式"></a>接口的格式</h3><ol>
<li><p>json、xml、HTML、raw</p>
<ol>
<li>json表示：{}</li>
<li>xml表示：&lt;&gt;</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口的请求方式"><a href="#接口的请求方式" class="headerlink" title="接口的请求方式"></a>接口的请求方式</h3><ol>
<li><h4 id="get、post、delete、put、head"><a href="#get、post、delete、put、head" class="headerlink" title="get、post、delete、put、head"></a>get、post、delete、put、head</h4><ol>
<li>get：从服务器获取信息</li>
<li>post：先上传信息，再从服务器获取信息</li>
</ol>
</li>
<li><h4 id="get与post的区别"><a href="#get与post的区别" class="headerlink" title="get与post的区别"></a>get与post的区别</h4><ol>
<li>从服务器来讲:  get比post安全，get只是从服务器上面获取信息而post可以修改服务器的信息</li>
<li>从客户端来讲：post比get安全，因为get的请求数据是加在url后面，而post是附加在请求包体里面的</li>
<li>传参大小不一样，get有字节限制(1024&#x2F;2048)，而post在理论上是没有限制的</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="接口测试中职责的划分"><a href="#接口测试中职责的划分" class="headerlink" title="接口测试中职责的划分"></a>接口测试中职责的划分</h2><ol>
<li>测试的建立：开发人员、测试人员、数据库管理人员、系统的负责人</li>
<li>测试的执行：测试人员</li>
<li>测试结果的确认：开发组长、测试组长</li>
</ol>
</li>
<li><h2 id="接口测试的对象"><a href="#接口测试的对象" class="headerlink" title="接口测试的对象"></a>接口测试的对象</h2><ol>
<li><p>模块接口测试、web接口测试</p>
<pre><code> web接口测试：服务器接口测试     外部接口测试  

 模块接口测试：以单元测试为基础，适用于开发的异常的功能模块

 服务端接口测试：客户端、服务端、浏览器

 外部接口测试：调用第三方的接口
</code></pre>
</li>
</ol>
</li>
<li><h2 id="接口测试的原则："><a href="#接口测试的原则：" class="headerlink" title="接口测试的原则："></a>接口测试的原则：</h2><ol>
<li>不同的接口参数覆盖不同的业务场景</li>
<li>参数能被运用到不同的场景中</li>
<li>测试的数据要与业务进行分离</li>
<li>尽量统一共用测试环境</li>
<li>测试完成后删除不必要的测试数据</li>
</ol>
<p> <strong>注释：接口测试是最简单的测试，但又是最严格的测试；还可以把接口测试称之为没有界面的功能测试</strong></p>
</li>
<li><h2 id="接口测试流程"><a href="#接口测试流程" class="headerlink" title="接口测试流程"></a>接口测试流程</h2><ol>
<li><p>首先跟开发要接口文档，对文档进行分析并编写测试用例，和开发进行用例评审，使用公司中的接口测试工具进行测试，关注：接口的协议、IP、端口号、路径、以及请求方式、请求参数，然后执行测试，关注：接口返回的格式、字段名、字段值的内容是否和添加的参数内容相照应</p>
<p> <strong>注释：不能和项目结合着说、登录的接口不要说&lt;太简单&gt;</strong></p>
</li>
</ol>
</li>
<li><h1 id="postman中如何连接两个接口"><a href="#postman中如何连接两个接口" class="headerlink" title="postman中如何连接两个接口"></a>postman中如何连接两个接口</h1><p> 1、获取上一个接口的返回值</p>
<p> 2、用一个环境变量或全局变量来接受这个返回值</p>
<p> 3、用此环境变量或者全局变量作为下一个接口的参数</p>
</li>
<li><h3 id="你们接口测试具体怎么做？"><a href="#你们接口测试具体怎么做？" class="headerlink" title="你们接口测试具体怎么做？"></a>你们接口测试具体怎么做？</h3><ol>
<li><p>一般开发把接口开发出来之后，会给到我们一个接口文档，首先要搞清楚这个接口的功能，它的作用是什么，请求方式，有哪些参数。参数有什么限制，类型是什么，是否必填，对于参数有不清楚的， 一般我们会问下开发，通过以上几个点去设计用例。</p>
<p> 设计好用例之后，我们利用工具进行检测，我们公司当时用的是 JMeter 来做接口测试的。</p>
<p> 首先我们要建立一个线程组,然后添加取样器（http 请求），然后填写接口的协议，地址，端口，请求方式，</p>
<p> 路径，及根据用例填写请求参数，添加一个监听器去查看接口返回的数据，然后执行，然后依据接口文档对比返回的数据是否与预期结果一致，</p>
<p> 对于返回的响应的数据的检查，我们主要关注以下几个点：状态码，提示信息，具体的正文内容，看与接口文档说明的是否一致，如果有问题，我们先大概分析下，看是否能定位出具体原因，实在不行就直接提 Bug给开发，让开发修复，之后最回归复测。</p>
</li>
</ol>
</li>
<li><h3 id="两个接口有关联，JMeter具体怎么做"><a href="#两个接口有关联，JMeter具体怎么做" class="headerlink" title="两个接口有关联，JMeter具体怎么做"></a>两个接口有关联，<strong>JMeter</strong>具体怎么做</h3><ol>
<li><p>另外两种问法：上个接口的返回值是下个接口的请求参数，这种如何处理？动态关联有没有了解过？</p>
<ol>
<li>这个涉及到动态关联，首先要搞清楚后一个接口需要用到上一个接口的什么数据，例外要看数据是在哪里取的，是在 head 还是在 body 里，然后如果要取的数据是 json 格式我会在发请求用 json 提取器去取这个数据，如果是其他格式的就用边界提取器或正则表达式去取数据。就拿我当时做的那个下单接口来说吧，因为下单接口需要先登录，需要用到登录接口的 cookies来做鉴权，首先就是把登录接口调试通过，然后在登录接口的http请求中添加一个边界值提取器或者也可以用正则表示式提取器去提取登录接口的响应头中的 cookies值，然后在下单接口中需要添加一个http cookies管理器，在http cookies管理器中引用登录接口提取出来的 cookies，这样就可以了。</li>
<li>如果是不同的线程组的话，那在登录接口中还得添加一个 Beanshell 取样器，在 BeanShell 取样器中， 利用函数助手中的 SetProperty()函数把提取出来的 cookies 设置为全局变量。然后在下单接口的 http cookies 管理器中利用函数助手中的Property()函数引用登录接口中设置的全局变量，这样就可以了。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口测试的工作流程"><a href="#接口测试的工作流程" class="headerlink" title="接口测试的工作流程"></a>接口测试的工作流程</h3><p> 1，首先分析开发给到的接口文档</p>
<p> 2，接口文档分析完成，编写测试用例</p>
<p> 3，然后借助接口测试工具去测试执行测试用例</p>
<p> 4，发现bug 提交 bug,并跟进 bug 修复。</p>
</li>
<li><h3 id="给你一个新的接口，你怎么去设计用例？"><a href="#给你一个新的接口，你怎么去设计用例？" class="headerlink" title="给你一个新的接口，你怎么去设计用例？"></a>给你一个新的接口，你怎么去设计用例？</h3><ol>
<li><p>首先要对于每个要测的接口都要先搞清楚这个接口的功能，它的作用是什么，熟悉这个业务功能需要用到什么协议，请求方式是什么，接口有哪些参数。对于每个参数的作用都要搞清楚，像数的类型，是否有约束限制，是否为必填的，长度，其他的限制等等，如果两个参数之间有关联我们还要考虑参数的组合场景，对于参数不理解的，一般都会跟开发沟通下，然后考虑返回数据的类型，返回数据中的返回码和返回信息是什么，通过以上几个点去提炼测试点，设计用例。</p>
<p> 最好拿一个具体的例子进行说明      比如：在方维的项目中当时做过的一个注册接口来说，这个注册接口总共有用户名，手机号码，密码，确认密码，推荐人 5 个主要的参数，而其中用户名，手机号码，密码，确认密码这几个参数是必填的，用户名要求在 3-15个字符之间，密码限制要求在长度在6~16 之间，只能包含字符、数字和下划线。其他的参数没有限制约束，而密码与确认密码两个参数是有关联的，我们需要考虑他们的组合场景。分析好接口的具体情况之后，我主要是通过等价类，边界值，判定表等方法来设计用例。对于这个注册接口我当时从以下几个点来设计用例的：</p>
<p> 文本框: </p>
<ol>
<li><pre><code>首先是用户名我主要考虑的点有：
</code></pre>
</li>
<li><p>有效的用户名</p>
</li>
<li><p>无效的场景：	等价类用户名小于 3 个字符用户名大于 15 个字符用户名等于 3 个字符用户名等 15 个字符</p>
</li>
<li><p>重复的用户名</p>
</li>
<li><p>空值</p>
</li>
<li><p>敏感字符的用户名比如：中国共产党</p>
</li>
<li><p>对于密码这块我会从以下几个方面去考虑设计用例：</p>
</li>
<li><p>考虑密码与确认密码一致</p>
</li>
<li><p>密码与确认密码不一致有效：</p>
</li>
<li><p>正确的密码无效：</p>
</li>
<li><p>密码小于 6 个字符</p>
</li>
<li><p>密码大于 16 个字符</p>
</li>
<li><p>密码等于 6 个字符</p>
</li>
<li><p>密码等于 16 个字符</p>
</li>
<li><p>密码包含了除字符，数字，下划线以外的字符</p>
</li>
<li><p>空值3.手机号码：</p>
</li>
<li><p>正确的手机号码</p>
</li>
<li><p>错误的手机号码</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口文档主要包含哪些内容？"><a href="#接口文档主要包含哪些内容？" class="headerlink" title="接口文档主要包含哪些内容？"></a>接口文档主要包含哪些内容？</h3><ol>
<li><p>接口文档一般两种形式的，要不就是 word 版本的要不就是<br> html 的形式，具体内容</p>
<ol>
<li><p>URL（接口地址）</p>
</li>
<li><p>接口功能</p>
</li>
<li><p>请求方式：post</p>
</li>
<li><p>请求参数，以及接口中每个参数的详细说明，类型，是否为必填，约束条件啊等等</p>
</li>
<li><p>响应数据及格式， 返回码，返回码解释等等</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="你怎么去检查接口，分析接口"><a href="#你怎么去检查接口，分析接口" class="headerlink" title="你怎么去检查接口，分析接口"></a>你怎么去检查接口，分析接口</h3><ol>
<li>我们主要是根据入参情况，去看接口的返回值，对于返回值，我主要关注的几个点：1. 状态码 2. 提示信息 3.  返回数据的具体内容。根据接口文档的说明去检查这个 3 个点是否满足接口需求文档，4、有些如果要检查数据库的，就连接数据库获取数据与返回的数据做对比。如果不满足就是有问题，如果满足则通过。如果有Bug,我们会先大概分析下，是什么原因，并进行复测，如果还是有问题，提交Bug 给开发，让开发修复，之后再回归。</li>
</ol>
</li>
<li><h3 id="依赖于第三方的接口如何测试"><a href="#依赖于第三方的接口如何测试" class="headerlink" title="依赖于第三方的接口如何测试"></a>依赖于第三方的接口如何测试</h3><p> 1，需要第三方接口的，接口文档</p>
<p> 2，发送请求到第三方接口，检查第三方接口返回的数据是否正确</p>
<p> 3，不正确的时候，要跟第三方接口联调，看是请求问题，还是第三方接口返回数据有误</p>
<p> 这个我们公司的第三方接口，我们都是打通的，比如电商，我们通过调用微信接口等等都是打通的，比如要测试下单第三支付，我们自己开店，收款设置我们自己的账号，然后通过商品设计 1 分钱，去测试的如果不打通的话，基本也只能抓包，主要保证我们发送出去的数据符合需求文档就行，然后真正的上线之前，我们会在预生产环境做一个联调测试，把各自系统连在一起，做一个联调测试没有问题了</p>
<p> 我们就可以上线，基本就这么做的</p>
<p> 联调测试怎么做的：</p>
<p> 其实联调测试就是数据拉通测试，两个子系统，连在一起，形成一个完整的系统，然后从上游下数据，</p>
<p> 下游接到数据，看传过来的数据是否符合下游的系统要求然后下游做了操作，把数据返回给上游，通知上游说数据返回了，上游看返回的数据是否符合要求，如果没有问题，就这个数据就拉通成功这个都是按照用例来执行，上游和下游一起出一份用例，两边都评审通过，然后按照测试用例执行，每条用例测试通过那么联调测就完成了</p>
</li>
<li><h3 id="接口工具-jmeter用到哪些组件，具体作用"><a href="#接口工具-jmeter用到哪些组件，具体作用" class="headerlink" title="接口工具 jmeter用到哪些组件，具体作用"></a>接口工具 <strong>jmeter</strong>用到哪些组件，具体作用</h3><ol>
<li><p>取样器：</p>
<p> http请求                                                                                    #向服务器发http请求</p>
<p> JDBCRequst                                                                                          # 向数据库发请求</p>
<p> DebugSampler                                                                                     #调试，看执行过程</p>
<p> BeanShell取 样器                                            #把某个变量设置定位全局变量</p>
<p> 后置处理器：</p>
<p> 正则表达式提取器                                                                 </p>
<p> #提取接口的响应内容或请求内容中的数据具体要提什么数据根据需求来，比如我们充值接口依赖登录接口，需要用到登录接口的cookie，需要提取cookie</p>
<p> 边界值提取器</p>
<p> JSON 提取器</p>
<p> BeanShellPostPrecessor                                                      #在请求结束之后需要做的某些事情，比如转码</p>
<p> 断言： #检验结果，验证本接口是否有问题响应断言</p>
<p> Json 断 言配置元件：</p>
<p> CSV<br> dataSetConfig                                                               # 读取 CSV文件，txt文件</p>
<p> JDBCConnectionConfiguration                                       # 连接数据库HTTPCookie管理器</p>
<p> HTTP信息头管理器用户定义的变量</p>
<p> 计数器定时器：同步定时器，主要用来设置集合点。监听器</p>
<p> 查看结果树</p>
</li>
</ol>
</li>
<li><h3 id="上传文件的接口用-JMeter怎么做"><a href="#上传文件的接口用-JMeter怎么做" class="headerlink" title="上传文件的接口用 JMeter怎么做"></a>上传文件的接口用 <strong>JMeter</strong>怎么做</h3><ol>
<li><p>例外一种问法：有没有做过文件上传的接口，具体怎么做？</p>
<p> 要测试上传文件的接口，在 JMeter 的http 请求这个组件中传递请求参数的栏目中专门提供了一个用来文件上传的，在这里面需要填写几个内容，一个就是文件的路径，还有一个就会参数名称，还有就是MIME 类型也就是指定要上传的文件的类型，这样就可以了。</p>
</li>
</ol>
</li>
<li><h3 id="对于POST请求，要求传递Json格式数据，JMeter怎么做"><a href="#对于POST请求，要求传递Json格式数据，JMeter怎么做" class="headerlink" title="对于POST请求，要求传递Json格式数据，JMeter怎么做"></a>对于<strong>POST</strong>请求，要求传递<strong>Json</strong>格式数据，JMeter怎么做</h3><ol>
<li>对于这个其实在 JMeter的 http请求这个组件中的参数配置栏目中，第二个栏目有一个消息体数据， 我们把需要上传的参数组装成 json格式，然后编写到 body data里面，然后，需要在http信息头管理其中，需要将数据格式设置为 json格式，这个就是设置 Content-Type为 application&#x2F;json;charset&#x3D;utf-8， 这样就可以了。</li>
</ol>
</li>
<li><h3 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h3><ul>
<li><p>Charles  ，抓包</p>
<ul>
<li>((20211120154039-ecok8wp “Charles安装”))</li>
<li><a href="https://www.charlesproxy.com/documentation/welcome/">官方文档</a></li>
</ul>
</li>
<li><p>Fiddler（windows好用）</p>
<ul>
<li>((20211204000051-egpcxr3 “fiddler安装、配置与使用”))</li>
</ul>
</li>
<li><p>wireshark</p>
<ul>
<li><a href="https://wireshark.en.softonic.com/">官网1</a></li>
<li><a href="https://www.wireshark.org/download.html">官网2</a></li>
<li><a href="https://www.wireshark.org/">官网3</a><br /></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="没有接口文档的时候怎么做接口测试？"><a href="#没有接口文档的时候怎么做接口测试？" class="headerlink" title="没有接口文档的时候怎么做接口测试？"></a>没有接口文档的时候怎么做接口测试？</h3><ol>
<li>首先，做接口测试，有接口文档比没有接口文档的效率要高很多，所以在条件允许的情况下，还是尽可能的要搞一份接口文档出来。</li>
<li>其次，如果没有接口文档，但是系统已经集成接口，并且有UI界面，那么我们可以借助于抓包工具来抓取接口信息。启动并设置好抓包工具比如Fiddler，然后在UI界面进行操作，在Fiddler中就可以查看接口的请求和响应，根据请求和响应的相关信息，反推接口信息，比如请求的方法、地址、参数、响应报文等等。必要的时候，我们需要在UI界面做实验，以获取或者猜测接口信息。获取到接口信息后，就可以依据接口的要素信息设计测试用例，利用测试工具Jmeter等来对接口进行测试。这个过程相对来说多了一个收集接口信息的步骤，时间长，还可能出错，所以比有接口文档的测试效率，要低了很多。</li>
</ol>
</li>
<li><h3 id="postman-可直接下载安装"><a href="#postman-可直接下载安装" class="headerlink" title="postman  可直接下载安装"></a>postman  可直接下载安装</h3><ol>
<li><h6 id="官网"><a href="#官网" class="headerlink" title="官网"></a><a href="https://www.postman.com/">官网</a></h6></li>
<li>默认安装</li>
</ol>
</li>
<li><h2 id="jmeter是怎么安装的？"><a href="#jmeter是怎么安装的？" class="headerlink" title="jmeter是怎么安装的？"></a>jmeter是怎么安装的？</h2><ol>
<li>查看是否有jdk      打开cmd     输入java或者javac</li>
<li>没有则安装jdk</li>
<li>配置jdk环境变量</li>
<li>下载jmeter，解压，配置jmeter环境变量</li>
<li>打开bin 目录下的.bat文件运行jmeter</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课前</category>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/05_%E7%AC%AC%E4%BA%94%E7%AB%A0%20APP%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/07_%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/07_%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/08_%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%A1%B9%E7%9B%AE/08_%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>学习规则</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>课前</category>
        <category>学习规则</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/01_jmeter/01_jmeter/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/02_postman/02_postman/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Xshell</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/05_Xshell/05_Xshell/</url>
    <content><![CDATA[<p><strong>Xshell 是一个强大的远程管理软件，它支持SSH，TELNET 协议。Xshell可以在Windows下访问远端服务器、路由器、网络机顶盒等，类似的常用软件还有putty，以及Windows下的Telnet。</strong></p>
<p><strong>下面简单介绍一下xshell软件。</strong></p>
<p><strong>Xshell的几个特点：</strong></p>
<p><strong>1、界面设计简洁、人性，使用方便。</strong></p>
<p><strong>2、支持标签，打开多个服务器时候很方便，点击标签切换。</strong></p>
<p><strong>3、可以保存密码，注意安全，尽量不要保存，除非个人电脑。</strong></p>
<p><strong>Xshell下载安装及基本使用方法：</strong></p>
<p><strong>1、从网上搜索下载，注意别下载错了，很多混有病毒的。我一般用来管理自己的路由器，本地局域网内，用的是xshell4绿色中文版的。</strong></p>
<p><strong>2、打开xshell。</strong></p>
<p><img src="/assets/image-20211122223946-4zmezpj.png" alt="image.png"></p>
<p><strong>3、个性化设置。设置好，用起来更顺手。经过这样设置，以后使用事半功倍。其他地方，根据自己的喜好，可以进行相关设置。</strong></p>
<p><img src="/assets/image-20211122223957-ut3oqle.png" alt="image.png"></p>
<p><strong>4、连接服务器或路由器。点击打开。</strong></p>
<p><img src="/assets/image-20211122224005-2ek1wc5.png" alt="image.png"></p>
<p><strong>5、点击左上角，新建</strong></p>
<p><img src="/assets/image-20211122224012-un6v0dw.png" alt="image.png"></p>
<p><strong>6、填写完，点击确定。其他高级参数，有需要可以填写。常用的主机或路由器，可以点击身份验证，填写用户名和密码，这样不需要输入就可以直接登录系统了。</strong></p>
<p><img src="/assets/image-20211122224019-r50vjsq.png" alt="image.png"></p>
<p><strong>7、第一次连接会出现提示，如下图。</strong></p>
<p><img src="/assets/image-20211122224026-fmhe8f2.png" alt="image.png"></p>
<p><strong>8、登录成功，可以输入相关命令，进行各种操作。</strong></p>
<p><img src="/assets/image-20211122224032-ktayq76.png" alt="image.png"></p>
<p><strong>xshell几个常用命令以及注意事项：</strong></p>
<p><strong>cd .. 回到上级目录</strong></p>
<p><strong>cd xx 进入xx目录</strong></p>
<p><strong>rm xx 删除文件xx</strong></p>
<p><strong>rm -rf 删除目录及其所包含的所有文件，</strong>高危命令，一定谨慎</p>
<p><strong>mkdir xx 创建目录xx</strong></p>
<p><strong>vi 查看&#x2F;编辑文件 按 i进入编辑模式；按Esc键退出编辑模式。按:q退出不保存； 按：wq保存退出。</strong></p>
<p><strong>更多命令可以搜索，不同系统命令可能有所区别。</strong></p>
<p><strong>以上就是对xshell软件的简单介绍，以及几点注意事项和个人的心得体会。</strong></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>Xshell</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>navicat  安装</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/06_navicat/01_navicat%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>1.Navicat 下载安装-破解</p>
<p>1）关闭所有的杀毒软件（很重要的步骤）</p>
<p>2）如果之前装过navicat,必须彻底删除navicat的残留文件</p>
<ul>
<li>卸载    点开windows设置，选择应用，找道navicat，点击选择卸载。</li>
<li>*为了安全起见，记得去 我的电脑里把文件夹删除，如果你是默认安装的路径，那么就在 C:\Program Files\PremiumSoft 下，<ul>
<li></li>
</ul>
</li>
<li>*如果不是默认的，就去找你当时安装的路径，删除 Navicat Premium  ，这个文件夹或者是你当初另外命名的文件夹<ul>
<li></li>
</ul>
</li>
<li>*删除注册表     win+r 输入 “regedit”，回车   *</li>
<li><em>在里面找到 HKEY_CURRENT_USER\Software\PremiumSoft 这个路径下的 Navicat 的相关注册表 删除(我是有几个删几个，从不慌)，</em></li>
</ul>
<p>2.1.Navicat 下载位置：<a href="https://www.navicat.com.cn/download/navicat-premium">Navicat | 下载 Navicat Premium 14 天免费 Windows、macOS 和 Linux 的试用版</a></p>
<p>注释：可按照电脑版本下载使用</p>
<p>2.2.安装Navicat Premium15</p>
<p><img src="/assets/image-20211120233620-y8dv58o.png" alt="image.png"></p>
<p><strong>然后一直傻瓜式操作就行，注意看一下自己的安装目录</strong></p>
<p><strong>利用注册机激活Navicat Premium15     破解文件在附件中（Navicat Keygen Patch v5.6.0 DFoX.exe）</strong></p>
<p><img src="/assets/image-20211120233626-ijrquw5.png" alt="image.png"></p>
<p>如果你是默认安装的话，你的navicat的安装路径是在C:\Program Files\PremiumSoft\Navicat Premium 15，</p>
<p>navicat破解工具：[Navicat Keygen Patch v5.6.0 DFoX.exe](assets&#x2F;Navicat Keygen Patch v5.6.0 DFoX-20211120233821-d5tl62s.exe)</p>
<p>然后将上述图片中的破解工具复制到C:\Program Files\PremiumSoft\Navicat Premium 15。</p>
<p>如果不是默认安装，就把破解工具放到你自定义的navicat的安装目录下</p>
<p><img src="/assets/image-20211120233634-ufire3z.png" alt="image.png"></p>
<h3 id="点击patch"><a href="#点击patch" class="headerlink" title="点击patch"></a>点击patch</h3><p><img src="/assets/image-20211120233641-lm58r9j.png" alt="image.png"></p>
<h3 id="等待出现navicat-exe-x64-gt-Cracked"><a href="#等待出现navicat-exe-x64-gt-Cracked" class="headerlink" title="等待出现navicat.exe -x64-&gt; Cracked!"></a>等待出现navicat.exe -x64-&gt; Cracked!</h3><p><img src="/assets/image-20211120233647-qm4cagp.png" alt="image.png"></p>
<h3 id="点击Generate"><a href="#点击Generate" class="headerlink" title="点击Generate"></a>点击Generate</h3><p><img src="/assets/image-20211120233654-iq1d694.png" alt="image.png"></p>
<h3 id="打开Navicat-Premium-15，点击注册"><a href="#打开Navicat-Premium-15，点击注册" class="headerlink" title="打开Navicat Premium 15，点击注册"></a>打开Navicat Premium 15，点击注册</h3><p><img src="/assets/image-20211120233700-0om93mu.png" alt="image.png"></p>
<h3 id="粘贴秘钥，然后点击激活按钮"><a href="#粘贴秘钥，然后点击激活按钮" class="headerlink" title="粘贴秘钥，然后点击激活按钮"></a>粘贴秘钥，然后点击<strong>激活</strong>按钮</h3><p><img src="/assets/image-20211120233722-y7g41tg.png" alt="image.png"></p>
<h3 id="在弹出的界面选择手动激活"><a href="#在弹出的界面选择手动激活" class="headerlink" title="在弹出的界面选择手动激活"></a>在弹出的界面选择手动激活</h3><p><img src="/assets/image-20211120233717-uuw1zk8.png" alt="image.png"></p>
<h3 id="将请求码粘贴到注册机Request-Code框中（完整过程看图）"><a href="#将请求码粘贴到注册机Request-Code框中（完整过程看图）" class="headerlink" title="将请求码粘贴到注册机Request Code框中（完整过程看图）"></a><em>将请求码粘贴到注册机Request Code框中（完整过程看图）</em></h3><p><img src="/assets/image-20211120233730-s4jcf0e.png" alt="image.png"></p>
<h3 id="点击激活页面的激活弹出（说明激活成功）"><a href="#点击激活页面的激活弹出（说明激活成功）" class="headerlink" title="点击激活页面的激活弹出（说明激活成功）"></a>点击激活页面的激活弹出（说明激活成功）</h3><p><img src="/assets/image-20211120233736-swj24yz.png" alt="image.png"></p>
<p><img src="/assets/image-20211120233741-8iiy4vj.png" alt="image.png"></p>
<p>到此navicat15安装和破解成功</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>navicat  安装</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/03_soap%20UI/03_soap%20UI/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>navicat  SQL语句练习</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/06_navicat/02_SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p><strong><a href="">SQL语句实例</a></strong></p>
<p><img src="/assets/image-20211120234345-rcfnit1.png" alt="image.png"></p>
<p><strong>表操作</strong></p>
<p><strong>例 1 对于表的教学管理数据库中的表 STUDENTS ，可以定义如下：</strong></p>
<p>CREATE TABLE STUDENTS</p>
<p>(SNO NUMERIC (6, 0) NOT NULL</p>
<p>SNAME CHAR (8) NOT NULL</p>
<p>AGE NUMERIC(3,0)</p>
<p>SEX CHAR(2)</p>
<p>BPLACE CHAR(20)</p>
<p>PRIMARY KEY(SNO))</p>
<p><strong>例 2 对于表的教学管理数据库中的表 ENROLLS ，可以定义如下：</strong></p>
<p>CREATE TABLE ENROLLS</p>
<p>(SNO NUMERIC(6,0) NOT NULL</p>
<p>CNO CHAR(4) NOT NULL</p>
<p>GRADE INT</p>
<p>PRIMARY KEY(SNO,CNO)</p>
<p>FOREIGN KEY(SNO) REFERENCES STUDENTS(SNO)</p>
<p>FOREIGN KEY(CNO) REFERENCES COURSES(CNO)</p>
<p>CHECK ((GRADE IS NULL) OR (GRADE BETWEEN 0 AND 100)))</p>
<p><strong>例 3 根据表的 STUDENTS 表，建立一个只包含学号、姓名、年龄的女学生表。</strong></p>
<p>CREATE TABLE GIRL</p>
<p>AS SELECT SNO, SNAME, AGE</p>
<p>FROM STUDENTS</p>
<p>WHERE SEX&#x3D;’ 女 ‘;</p>
<p><strong>例 4 删除教师表 TEACHER 。</strong></p>
<p>DROP TABLE TEACHER</p>
<p><strong>例 5 在教师表中增加住址列。</strong></p>
<p>ALTER TABLE TEACHERS</p>
<p>ADD (ADDR CHAR(50))</p>
<p><strong>例 6 把 STUDENTS 表中的 BPLACE 列删除，并且把引用 BPLACE 列的所有视图和约束也一起删除。</strong></p>
<p>ALTER TABLE STUDENTS</p>
<p>DROP BPLACE CASCADE</p>
<p><strong>例 7 补充定义 ENROLLS 表的主关键字。</strong></p>
<p>ALTER TABLE ENROLLS</p>
<p>ADD PRIMARY KEY (SNO,CNO) ；</p>
<p><strong>视图操作（虚表）</strong></p>
<p><strong>例 9 建立一个只包括教师号、姓名和年龄的视图 FACULTY 。 ( 在视图定义中不能包含 ORDER BY 子句 )</strong></p>
<p>CREATE VIEW FACULTY</p>
<p>AS SELECT TNO, TNAME, AGE</p>
<p>FROM TEACHERS</p>
<p><strong>例 10 从学生表、课程表和选课表中产生一个视图 GRADE_TABLE ， 它包括学生姓名、课程名和成绩。</strong></p>
<p>CREATE VIEW GRADE_TABLE</p>
<p>AS SELECT SNAME,CNAME,GRADE</p>
<p>FROM STUDENTS,COURSES,ENROLLS</p>
<p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND</p>
<p>COURSES.CNO&#x3D;ENROLLS.CNO</p>
<p><strong>例 11 删除视图 GRADE_TABLE</strong></p>
<p>DROP VIEW GRADE_TABLE RESTRICT</p>
<p><strong>索引操作</strong></p>
<p><strong>例 12 在学生表中按学号建立索引。</strong></p>
<p>CREATE UNIQUE INDEX ST</p>
<p>ON STUDENTS (SNO,ASC)</p>
<p><strong>例 13 删除按学号所建立的索引。</strong></p>
<p>DROP INDEX ST</p>
<p><strong>数据库模式操作</strong></p>
<p><strong>例 14 创建一个简易教学数据库的数据库模式 TEACHING_DB ，属主为 ZHANG 。</strong></p>
<p>CREATE SCHEMA TEACHING_DB AUTHRIZATION ZHANG</p>
<p><strong>例 15 删除简易教学数据库模式 TEACHING_DB 。（（ 1 ）选用 CASCADE ，即当删除数据库模式时，则本数据库模式和其下属的基本表、视图、索引等全部被删除。（ 2 ）选用 RESTRICT ，即本数据库模式下属的基本表、视图、索引等事先已清除，才能删除本数据库模式，否则拒绝删除。）</strong></p>
<p>DROP SCHEMA TEACHING_DB CASCADE</p>
<p><strong>单表操作</strong></p>
<p><strong>例 16 找出 3 个学分的课程号和课程名。</strong></p>
<p>SELECT CNO, CNAME</p>
<p>FROM 　 COURSES</p>
<p>WHERE 　 CREDIT ＝ 3</p>
<p><strong>例 17 查询年龄大于 22 岁的学生情况。</strong></p>
<p>SELECT *</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE ＞ 22</p>
<p><strong>例 18 找出籍贯为河北的男生的姓名和年龄。</strong></p>
<p>SELECT SNAME, AGE</p>
<p>FROM 　 STUDENTS</p>
<p>WHERE 　 BPLACE ＝ ‘ 河北 ‘ AND SEX ＝ ‘ 男 ‘</p>
<p><strong>例 19 找出年龄在 20 ～ 23 岁之间的学生的学号、姓名和年龄，并按年龄升序排序。 (ASC （升序）或 DESC （降序）声明排序的方式，缺省为升序。 )</strong></p>
<p>SELECT SNO, SNAME, AGE</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE BETWEEN 20 AND 23</p>
<p>ORDER BY AGE</p>
<p><strong>例 20 找出年龄小于 23 岁、籍贯是湖南或湖北的学生的姓名和性别。（条件比较运算符＝、＜ 和逻辑运算符 AND （与），此外还可以使用的运算符有：＞（大于）、＞＝（大于等于）、＜＝（小于等于）、＜＞（不等于）、 NOT （非）、 OR （或）等。</strong></p>
<p><strong>谓词 LIKE 只能与字符串联用，常常是 “ ＜列名＞ LIKE pattern” 的格式。特殊字符 “_” 和 “%” 作为通配符。</strong></p>
<p><strong>谓词 IN 表示指定的属性应与后面的集合（括号中的值集或某个查询子句的结果）中的某个值相匹配，实际上是一系列的 OR （或）的缩写。谓词 NOT IN 表示指定的属性不与后面的集合中的某个值相匹配。</strong></p>
<p><strong>谓词 BETWEEN 是 “ 包含于 … 之中 ” 的意思。）</strong></p>
<p>SELECT SNAME, SEX</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE ＜ 23 AND BPLACE LIKE’ 湖％ ‘</p>
<p>或</p>
<p>SELECT SNAME, SEX</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE ＜ 23 AND BPLACE IN （ ‘ 湖南 ‘ ， ‘ 湖北 ‘ ）</p>
<p><strong>例 22 找出学生表中籍贯是空值的学生的姓名和性别。（在 SQL 中不能使用条件：＜列名＞＝ NULL 。在 SQL 中只有一个特殊的查询条件允许查询 NULL 值：）</strong></p>
<p>SELECT SNAME, SEX</p>
<p>FROM STUDENTS</p>
<p>WHERE BPLACE IS NULL</p>
<p><strong>多表操作</strong></p>
<p><strong>例 23 找出成绩为 95 分的学生的姓名。（子查询）</strong></p>
<p>SELECT SNAME</p>
<p>FROM 　 STUDENTS</p>
<p>WHERE 　 SNO ＝</p>
<p>(SELECT SNO</p>
<p>FROM ENROLLS</p>
<p>WHERE GRADE ＝ 95)</p>
<p><strong>例 24 找出成绩在 90 分以上的学生的姓名。</strong></p>
<p>SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE SNO IN</p>
<p>(SELECT SNO</p>
<p>FROM ENROLLS</p>
<p>WHERE GRADE ＞ 90)</p>
<p>或</p>
<p>SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE SNO ＝ ANY</p>
<p>(SELECT SNO</p>
<p>FROM ENROLLS</p>
<p>WHERE GRADE ＞ 90)</p>
<p><strong>例 25 查询全部学生的学生名和所学课程号及成绩。（连接查询）</strong></p>
<p>SELECT SNAME, CNO, GRADE</p>
<p>FROM STUDENTS, ENROLLS</p>
<p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO</p>
<p><strong>例 26 找出籍贯为山西或河北，成绩为 90 分以上的学生的姓名、籍贯和成绩。（当构造多表连接查询命令时，必须遵循两条规则。第一，连接条件数正好比表数少 1 （若有三个表，就有两个连接条件 ) ；第二，若一个表中的主关键字是由多个列组成，则对此主关键字中的每一个列都要有一个连接条件（也有少数例外情况））</strong></p>
<p>SELECT SNAME, BPLACE, GRADE</p>
<p>FROM STUDENTS, ENROLLS</p>
<p>WHERE BPLACE IN (‘ 山西 ’ ， ‘ 河北 ’) AND GRADE ＞＝ 90 AND 　STUDENTS.SNO&#x3D;ENROLLS.SNO</p>
<p><strong>例 28 查出课程成绩在 80 分以上的女学生的姓名、课程名和成绩。（ FROM 子句中的子查询）</strong></p>
<p>SELECT SNAME,CNAME, GRADE</p>
<p>FROM (SELECT SNAME, CNAME , GRADE</p>
<p>FROM STUDENTS, ENROLLS,COURSES</p>
<p>WHERE SEX ＝ ‘ 女 ‘)</p>
<p>AS TEMP (SNAME, CNAME,GRADE)</p>
<p>WHERE GRADE ＞ 80</p>
<p><strong>表达式与函数的使用</strong></p>
<p><strong>例 29 查询各课程的学时数。（算术表达式由算术运算符＋、－、 * 、／与列名或数值常量所组成。）</strong></p>
<p>SELECT CNAME,COURSE_TIME ＝ CREDIT*16</p>
<p>FROM COURSES</p>
<p><strong>例 30 找出教师的最小年龄。（内部函数： SQL 标准中只使用 COUNT 、 SUM 、 AVG 、 MAX 、 MIN 函数，称之为聚集函数（ Set Function ）。 COUNT 函数的结果是该列统计值的总数目， SUM 函数求该列统计值之和， AVG 函数求该列统计值之平均值， MAX 函数求该列最大值， MIN 函数求该列最小值。）</strong></p>
<p>SELECT MIN(AGE)</p>
<p>FROM TEACHERS</p>
<p><strong>例 31 统计年龄小于等于 22 岁的学生人数。（统计）</strong></p>
<p>SELECT COUNT(*)</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE &lt; ＝ 22</p>
<p><strong>例 32 找出学生的平均成绩和所学课程门数。</strong></p>
<p>SELECT SNO, AVG(GRADE), COURSES ＝ COUNT(*)</p>
<p>FROM ENROLLS</p>
<p>GROUP BY SNO</p>
<p><strong>例 34 找出年龄超过平均年龄的学生姓名。</strong></p>
<p>SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE ＞</p>
<p>(SELECT AVG(AGE)</p>
<p>FROM STUDENTS)</p>
<p><strong>例 35 找出各课程的平均成绩，按课程号分组，且只选择学生超过 3 人的课程的成绩。（ GROUP BY 与 HAVING</strong></p>
<p><strong>GROUP BY 子句把一个表按某一指定列（或一些列）上的值相等的原则分组，然后再对每组数据进行规定的操作。</strong></p>
<p><strong>GROUP BY 子句总是跟在 WHERE 子句后面，当 WHERE 子句缺省时，它跟在 FROM 子句后面。</strong></p>
<p><strong>HAVING 子句常用于在计算出聚集之后对行的查询进行控制。）</strong></p>
<p>SELECT CNO, AVG(GRADE), STUDENTS ＝ COUNT(*)</p>
<p>FROM ENROLLS</p>
<p>GROUP BY CNO</p>
<p>HAVING COUNT(*) &gt;&#x3D; 3</p>
<p><strong>相关子查询</strong></p>
<p><strong>例 37 查询没有选任何课程的学生的学号和姓名。（当一个子查询涉及到一个来自外部查询的列时，称为相关子查询（ Correlated Subquery) 。相关子查询要用到存在测试谓词 EXISTS 和 NOT EXISTS ，以及 ALL 、 ANY （ SOME ）等。）</strong></p>
<p>SELECT SNO, SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE NOT EXISTS</p>
<p>(SELECT *</p>
<p>FROM ENROLLS</p>
<p>WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO)</p>
<p><strong>例 38 查询哪些课程只有男生选读。</strong></p>
<p>SELECT DISTINCT CNAME</p>
<p>FROM COURSES C</p>
<p>WHERE ‘ 男 ‘ ＝ ALL</p>
<p>(SELECT SEX</p>
<p>FROM ENROLLS ， STUDENTS</p>
<p>WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO AND</p>
<p>ENROLLS.CNO&#x3D;C.CNO)</p>
<p><strong>例 39 要求给出一张学生、籍贯列表，该表中的学生的籍贯省份，也是其他一些学生的籍贯省份。</strong></p>
<p>SELECT SNAME, BPLACE</p>
<p>FROM STUDENTS A</p>
<p>WHERE EXISTS</p>
<p>(SELECT *</p>
<p>FROM STUDENTS B</p>
<p>WHERE A.BPLACE&#x3D;B.BPLACE AND</p>
<p>A.SNO &lt; &gt; B.SNO)</p>
<p><strong>例 40 找出选修了全部课程的学生的姓名。</strong></p>
<p>本查询可以改为：查询这样一些学生，没有一门课程是他不选修的。</p>
<p>SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE NOT EXISTS</p>
<p>(SELECT *</p>
<p>FROM COURSES</p>
<p>WHERE NOT EXISTS</p>
<p>(SELECT *</p>
<p>FROM ENROLLS</p>
<p>WHERE ENROLLS.SNO ＝ STUDENTS.SNO</p>
<p>AND ENROLLS.CNO ＝ COURSES.CNO))</p>
<p><strong>关系代数运算</strong></p>
<p><strong>例 41 设有某商场工作人员的两张表：营业员表 SP_SUBORD 和营销经理表 SP_MGR ，其关系数据模式如下：</strong></p>
<p><strong>SP_SUBORD (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)</strong></p>
<p><strong>SP_MGR (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)</strong></p>
<p><strong>其中，属性 SALPERS_ID 为工作人员的编号 , SALPERS_NAME 为工作人员的姓名 , MANAGER_ID 为所在部门经理的编号 , OFFICE 为工作地点。</strong></p>
<p>若查询全部商场工作人员，可以用下面的 SQL 语句：</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p>UNION</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>或等价地用下面的 SQL 语句：</p>
<p>SELECT *</p>
<p>FROM (TABLE SP_SUBORD UNION TABLE SP_MGR)</p>
<p>（ 2 ） INTERSECT</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p>INTERSECT</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>或等价地用下面的 SQL 语句：</p>
<p>SELECT *</p>
<p>FROM (TABLE SP_SUBORD INTERSECT TABLE SP_MGR)</p>
<p>或用带 ALL 的 SQL 语句：</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p>INTERSECTALL</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>或</p>
<p>SELECT *</p>
<p>FROM (TABLE SP_SUBORD INTERSECT ALL TABLE SP_MGR)</p>
<p>（ 3 ） EXCEPT</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>EXCEPT</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p>或等价地用下面的 SQL 语句：</p>
<p>SELECT *</p>
<p>FROM (TABLE SP_MGR EXCEPT TABLE SP_ SUBORD)</p>
<p>或用带 ALL 的 SQL 语句：</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>EXCEPT ALL</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p><strong>例 42 查询籍贯为四川、课程成绩在 80 分以上的学生信息及其成绩。（自然连接）</strong></p>
<p>(SELECT * FROM STUDENTS</p>
<p>WHERE BPLACE&#x3D;‘ 四川 ’)</p>
<p>NATURAL JOIN</p>
<p>(SELECT * FROM ENROLLS</p>
<p>WHERE GRADE &gt;&#x3D;80)</p>
<p><strong>例3.43 列出全部教师的姓名及其任课的课程号、班级。</strong></p>
<p><strong>（外连接与外部并外连接允许在结果表中保留非匹配元组，空缺部分填以 NULL 。外连接的作用是在做连接操作时避免丢失信息。</strong></p>
<p><strong>外连接有 3 类：</strong></p>
<p><strong>（ 1 ）左外连接（ Left Outer Join ）。连接运算谓词为 LEFT [OUTER] JOIN ，其结果表中保留左关系的所有元组。</strong></p>
<p><strong>（ 2 ）右外连接（ Right Outer Join ）。连接运算谓词为 RIGHT [OUTER] JOIN ，其结果表中保留右关系的所有元组。</strong></p>
<p><strong>（ 3 ）全外连接（ Full Outer Join ）。连接运算谓词为 FULL [OUTER] JOIN ，其结果表中保留左右两关系的所有元组。）</strong></p>
<p>SELECT TNAME, CNO, CLASS</p>
<p>FROM TEACHERS LEFT OUTER JOIN TEACHING USING (TNO)</p>
<p><strong>SQL 的数据操纵</strong></p>
<p><strong>例 44 把教师李映雪的记录加入到教师表 TEACHERS 中。（插入）</strong></p>
<p>INSERT INTO TEACHERS</p>
<p>VALUES(1476 ， ‘ 李映雪 ‘ ， 44 ， ‘ 副教授 ‘)</p>
<p><strong>例 45 成绩优秀的学生将留下当教师。</strong></p>
<p>INSERT INTO TEACHERS (TNO ， TNAME)</p>
<p>SELECT DISTINCT SNO ， SNAME</p>
<p>FROM STUDENTS ， ENROLLS</p>
<p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO ANDGRADE ＞＝ 90</p>
<p><strong>例 47 把所有学生的年龄增加一岁。（修改）</strong></p>
<p>UPDATE STUDENTS</p>
<p>SET AGE ＝ AGE+1</p>
<p><strong>例 48 学生张春明在数据库课考试中作弊，该课成绩应作零分计。</strong></p>
<p>UPDATE ENROLLS</p>
<p>SET GRADE ＝ 0</p>
<p>WHERE CNO ＝ ‘C1’ AND</p>
<p>‘ 张春明 ‘ ＝</p>
<p>(SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE STUDENTS.SNO&#x3D;ENROLLS.SNO)</p>
<p><strong>例 49 从教师表中删除年龄已到 60 岁的退休教师的数据。（删除）</strong></p>
<p>DELETE FROM TEACHERS</p>
<p>WHERE AGE ＞＝ 60</p>
<p><strong>SQL 的数据控制</strong></p>
<p><strong>例 50 授予 LILI 有对表 STUDENTS 的查询权。（表／视图特权的授予</strong></p>
<p><strong>一个 SQL 特权允许一个被授权者在给定的数据库对象上进行特定的操作。授权操作的数据库对象包括：表 &#x2F; 视图、列、域等。授权的操作包括： INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 、 UNDER 、 USAGE 、 EXECUTE 等。其中 INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 有对表做相应操作的权限，故称为表特权。）</strong></p>
<p>GRANT SELECT ON STUDENTS</p>
<p>TO LILI</p>
<p>WITH GRANT OPTION</p>
<p><strong>例 51 取消 LILI 的存取 STUDENTS 表的特权。</strong></p>
<p>REVOKE ALL</p>
<p>ON STUDENTS</p>
<p>FROM LILI CASCADE</p>
<p>**不断补充中：</p>
<ol>
<li>模糊查找:<br> **它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。<br> 　　可使用以下通配字符：<br> 　　百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。<br> 　　下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。<br> 　　方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。[^]：其取值也[]相同，但它要求所匹配对象为指定字符以外的任一个字符。<br> 例如：<br> 　　限制以Publishing结尾，使用LIKE ‘%Publishing’<br> 　　限制以A开头：LIKE ‘[A]%’<br> 　　限制以A开头外：LIKE ‘[^A]%’</li>
</ol>
<p>**2.更改表格　**<br>ALTER TABLE table_name<br>ADD COLUMN column_name DATATYPE<br>说明：增加一个栏位（没有删除某个栏位的语法。)<br>ALTER TABLE table_name<br>ADD PRIMARY KEY (column_name)<br>说明：更改表得的定义把某个栏位设为主键。<br>ALTER TABLE table_name<br>DROP PRIMARY KEY (column_name)<br>说明：把主键的定义删除。</p>
<p><strong>3.group by</strong></p>
<p>在select 语句中可以使用group by 子句将行划分成较小的组，然后，使用聚组函数返回每一个组的汇总信息，另外，可以使用having子句限制返回的结果集。group by 子句可以将查询结果分组，并返回行的汇总信息Oracle 按照group by 子句中指定的表达式的值分组查询结果。</p>
<p>在带有group by 子句的查询语句中，在select 列表中指定的列要么是group by 子句中指定的列，要么包含聚组函数</p>
<p>select max(sal),job emp group byjob;<br>(注意max(sal),job的job并非一定要出现，但有意义)</p>
<p>查询语句的select 和group by ,having 子句是聚组函数唯一出现的地方，在where 子句中不能使用聚组函数。</p>
<p>select deptno,sum(sal) from empwhere sal&gt;1200 group by deptno having sum(sal)&gt;8500 order by deptno;</p>
<p>当在gropu by 子句中使用having 子句时，查询结果中只返回满足having条件的组。在一个sql语句中可以有where子句和having子句。having 与where 子句类似，均用于设置限定条件</p>
<p>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。<br>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</p>
<p>查询每个部门的每种职位的雇员数<br>select deptno,job,count(*) from emp group by deptno,job;</p>
<p><strong>4.外连接与内连接</strong></p>
<p>有时候，即使在连接的表中没有相应的行，用户可能想从一张表中看数据，Oracle提供了外连接实现该功能。<br>内连接是指连接查询只显示完全满足连接条件的记录，即等值连接，外连接的查询结果是内连接查询结果的扩展。外连接不仅返回满足连接条件的所有记录而且也返回了一个表中那些在另一个表中没有匹配行的记录。外连接的操作符是“+”。“+”号放在连接条件中信息不完全的那一边（即没有相应行的那一边）。运算符“+”影响NULL行的建立。建一行或多行NULL来匹配连接的表中信息完全的行。</p>
<p>外连接运算符“+”只能出现在where子句中表达式的一边。</p>
<p>假如在多张表之间有多个连接条件，外连接运算符不能使用or,in逻辑运算符与其它条件组合。</p>
<p>假如emp表中deptno&#x3D;10的ename为空值，dept表中deptno&#x3D;20的loc为空值：</p>
<ol>
<li></li>
</ol>
<p>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno(+)&#x3D;dept.deptno;</p>
<p>如果在dept.deptno中有的数值在emp.deptno中没有值，则在做外连接时，<br>结果中ename会产生一个空值。(emp.deptno&#x3D;10)</p>
<ol start="2">
<li></li>
</ol>
<p>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno&#x3D;dept.deptno(+);</p>
<p>如果在emp.deptno中有的数值在dept.deptno中没有值，则在做外连接时，<br>结果中loc会产生一个空值。。(dept.deptno&#x3D;20)</p>
<p><strong>5.自连接</strong></p>
<p>自连接是指同一张表的不同行间的连接。该连接不受其他表的影响。用自连接可以比较同一张表中不同行的某一列的值。因为自连接查询仅涉及到某一张表与其自身的连接。所以在from子句中该表名出现两次，分别用两个不同的别名表示，两个别名当作两张不同的表进行处理，与其它的表连接一样，别名之间也使用一个或多个相关的列连接。为了区分同一张表的不同行的列，在名前永别名加以限制。</p>
<p>select<br>worker.ename,<br>manager.ename manager<br>from<br>emp worker,<br>emp manager<br>where<br>work.mgr&#x3D;manager.empno;</p>
<p><strong>6.集合运算</strong></p>
<p>基合运算符可以用于从多张表中选择数据。</p>
<p>①UNION运算<br>用于求两个结果集合的并集（两个结果集合的所有记录），并自动去掉重复行。</p>
<p>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;</p>
<p>注：ename,sal 是必须一致的。</p>
<p>②UNION ALL运算<br>用于求两个结果集合的并集（两个结果集中的所有记录），并且不去掉重复行。</p>
<p>select ename,sal from account wheresal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;</p>
<p>③INTERSECT运算<br>intersect运算返回查询结果中相同的部分。</p>
<p>各部门中有哪些相同的职位？</p>
<p>select Job from account<br>intersect<br>select Job from research<br>intersect<br>select Job from sales;</p>
<p>④MINUS运算<br>minus返回两个结果集的差集。（在第一个结果集中存在的，而在第二个结果集中不存在的行。）</p>
<p>有那些职位是财务部中有，而在销售部门中没有？</p>
<p>select Job from account<br>minus<br>select Job from sales;</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>SQL语句练习</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/04_%E5%B7%A5%E5%85%B7/04_VMware/04_VMware/</url>
    <content><![CDATA[<p>1、准备工作<br>VMware Workstation虚拟机软件<br><a href="https://www.vmware.com/cn/products/workstation-pro.html">VMware Workstation官网</a><br>系统镜像 （使用ContOS 7示例）<br><a href="https://www.centos.org/download/">ContOS 官网下载地址</a><br>2.载入镜像</p>
<p><img src="/assets/image-20211221100125-tks1t19.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100132-b8cmgz5.png" alt="image.png"><img src="/assets/image-20211221100140-5a5rsrv.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100151-6mia1zl.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100156-57s3rzq.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100200-rjkr466.png" alt="image.png"><img src="/assets/image-20211221100205-72zrms0.png" alt="image.png"><img src="/assets/image-20211221100258-myh67of.png" alt="image.png"></p>
<p>到此，我们就成功把系统镜像文件载入虚拟机了。</p>
<p>3、 安装系统<br>经过第二步系统启动后，进入这个页面，点击黑框，这时候，我们就可以操作ContOS系统了，放向键选中第一项，回车。进入系统安装。</p>
<p><img src="/assets/image-20211221100333-h0d8ib5.png" alt="image.png"></p>
<p>然后等待系统跑就行了。</p>
<p><img src="/assets/image-20211221100341-akkmb09.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100348-scaymac.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100423-3m50yno.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100428-3lbq38z.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100435-0moq65v.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100452-rw65w8t.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100503-2y2amz0.png" alt="image.png"></p>
<p>同样的，选择完毕后，点击Done</p>
<p><img src="/assets/image-20211221100546-f5zr9tf.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100714-j9new7l.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100551-w3o49xy.png" alt="image.png"></p>
<p>这里我是选择设置root用户密码，毕竟是虚拟机，直接用root用户就好了。</p>
<p><img src="/assets/image-20211221100558-47d8cxr.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100604-6m9d9h9.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100609-km8hmf7.png" alt="image.png"></p>
<p><img src="/assets/image-20211221100615-nil4aae.png" alt="image.png"></p>
<p>接下来等待开机就行了,直到下图界面，才开始操作</p>
<p><img src="/assets/image-20211221100624-jn8575d.png" alt="image.png"></p>
<p>ok，到此完成全部安装操作<br>然后配置ip：vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</p>
<pre><code>    修改ONBOOT=no 为    ONBOOT=yes

                                                         重启系统
</code></pre>
]]></content>
      <categories>
        <category>课中</category>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/01_linux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ol>
<li><h2 id="Linux-在VMware安装步骤"><a href="#Linux-在VMware安装步骤" class="headerlink" title="Linux 在VMware安装步骤"></a><a href="../../../../04_%E5%B7%A5%E5%85%B7/04_VMware/04_VMware/">Linux 在VMware安装步骤</a></h2></li>
<li><h2 id="对-linux熟不熟悉，具体怎么用的？"><a href="#对-linux熟不熟悉，具体怎么用的？" class="headerlink" title="对 linux熟不熟悉，具体怎么用的？"></a>对 <strong>linux</strong>熟不熟悉，具体怎么用的？</h2><ol>
<li>监控一些系统资源的情况</li>
<li>linux 的话，我们在测试中也会经常用到基本的一些命令，主要就是搭建部署环境这块，一般开发完成一个新的版本的时候，都会给我们提供一个可测版本的源码包，我们需要把源码包部署到测试环境中。例外，当我们测试过程中发现问题的时候，需要协助开发去定位，分析，帮助开发查找具体的问题原因。这里我们经常需要去查看项目的日志文件，像这块，我们用得比较多的就是文件查看，信息过滤相关的命令，比如：cat ,tail -f,grep等其他的话，我们有时候也需要实时去关注项目的进程，端口的一些资源情况，这个我们需要用到 ps-ef,ps -aux, netstat -anp 等相关的命令。</li>
</ol>
</li>
<li><h2 id="Xshell使用教程"><a href="#Xshell使用教程" class="headerlink" title="Xshell使用教程"></a><a href="../../../../04_%E5%B7%A5%E5%85%B7/05_Xshell/05_Xshell/">Xshell使用教程</a></h2></li>
<li><h2 id="Linux-的常用命令？"><a href="#Linux-的常用命令？" class="headerlink" title="Linux 的常用命令？"></a>Linux 的常用命令？</h2><ol>
<li><p>提示：可借助第三方工具连接使用，我们使用xshell学习</p>
</li>
<li><p>常用命令：</p>
<ol>
<li><p>ls 显示当前路径下的文件和文件夹（横向显示）</p>
<p> ll 显示当前路径下的文件和文件夹（竖向显示）</p>
<p> ls +空格+  -a  显示当前路径下的所有隐藏文件（a称为参数，a为所有的意思）</p>
<p> D  rwx rwx rwx<br />3   peng</p>
<ul>
<li>rw- rw- r–<br />1   peng</li>
</ul>
<p> 首个D表示文件夹，第一个rwx 用户，第二组用户组，第三组表示其他</p>
<p> 首个 - 表示文件，文件类型，peng 用户，文件大小，日期，时间，文件名</p>
<p> Mkdir 新建文件夹</p>
<p> Mkdir + 空格 +新的文件夹名</p>
<p> Touch  新建文件</p>
<p> Touch + 空格 +新建的文件名</p>
<p> Clear  清除当前屏幕内容</p>
<p> Rm + 空格 + -f （r递归，f强制，-rf强制性递归删除）</p>
<p>  Cp+ 空格+ 文件名路径（复制文件）*表示所有</p>
<p> Mv移动</p>
<p> Head与cat的区别</p>
<p> 怎么查看日志</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a><a href="../902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/01_Linux%E5%91%BD%E4%BB%A4.md">Linux命令</a></h4><h4 id="Linux命令实操"><a href="#Linux命令实操" class="headerlink" title="Linux命令实操"></a><a href="../902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/02_linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%93%8D.md">Linux命令实操</a></h4></li>
<li><h2 id="测试环境你是怎么搭建的？"><a href="#测试环境你是怎么搭建的？" class="headerlink" title="测试环境你是怎么搭建的？"></a>测试环境你是怎么搭建的？</h2><ol>
<li>我上一家公司的项目后台使用 PHP开发，数据库这块用的 mysql，web网络服务器用的apache,所有我们搭建的 LAMP 的测试环境。对环境搭建主要就是安装一些软件，像安装 apache,安装 Mysql,安装PHP的运行环境，然后把开发给到我们的测试版本的源码包部署到我们 apache中。（项目是部署在<br> apache 的 www&#x2F;html目录下），启动相应的服务（mysql,apache,php），例外需要修改数据库的配置文件，还有就是开发防火墙的端口，像数据库的端口（3306），apache的端口（80）都要进行开发，这里需要修改防火墙的配置文件。</li>
</ol>
</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>课中</category>
        <category>linux系统</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/01_%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<ol>
<li><h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/01_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">数据库基础知识</a></h2></li>
<li><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><ol>
<li>数据库按时存放数据的仓库，只是以某种有组织存储方式储存数据的集合</li>
</ol>
</li>
<li><h2 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h2><ol>
<li><p>数据库分为关系型数据库和非关系型数据库</p>
<ol>
<li><p>关系型数据库：mysql、oracle、sqlserver、db2、past、gresql</p>
<ol>
<li>是数据库里面有存在一定的关系</li>
</ol>
</li>
<li><p>非关系型数据库：mogodb、redis、hbase、memchedb</p>
<ol>
<li>数据与数据之间没有任何关系，只有输入和输出</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="数据库命令行操作"><a href="#数据库命令行操作" class="headerlink" title="数据库命令行操作"></a><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/02_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/">数据库命令行操作</a></h3><ol>
<li><p>快捷键： win+r   输入  cmd       打开dos窗口</p>
<p> 登录数据库命令：mysql  -h 主机ip      -u 用户名   -p   回车— 输入密码    回车</p>
<p> 退出：mysql &gt;exit;         或    mysql &gt;quit;           或      mysql &gt;\q;</p>
<p> show databases; 查看所有数据库</p>
<p> use +数据库名    使用数据库</p>
<p> show  tables;  查看数据库中表的信息</p>
</li>
<li><p>基础的增删改查命令操作：</p>
<ol>
<li>增：insert  into 表名（列名） values（列名对应的值）</li>
<li>删：delete from 表名  where 列名 &#x3D; 对应列名的值</li>
<li>改：update  表名  set 修改的列名 &#x3D; 对应的值   where  列名 &#x3D; 对应列名的值</li>
<li>查：select  查询内容  from  表名   where 列名 &#x3D; 对应列名的值</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="数据库连接工具"><a href="#数据库连接工具" class="headerlink" title="数据库连接工具"></a>数据库连接工具</h3><ol>
<li><p><a href="../../../../04_%E5%B7%A5%E5%85%B7/06_navicat/01_navicat%E5%AE%89%E8%A3%85/">navicat安装</a></p>
</li>
<li><p><a href="../../../../04_%E5%B7%A5%E5%85%B7/06_navicat/02_SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/">SQL语句练习</a></p>
<ol>
<li><p>增：inset  into 表名（列名） values（列名对应的值）</p>
</li>
<li><p>删：delete from 表名  where 列名 &#x3D; 对应列名的值</p>
</li>
<li><p>改：update  表名  set 修改的列名 &#x3D; 对应的值   where  列名 &#x3D; 对应列名的值</p>
</li>
<li><p>查：select  查询内容  from  表名   where 列名 &#x3D; 对应列名的值</p>
</li>
<li><p>运算符</p>
<ol>
<li>&lt;  小于号</li>
<li><blockquote>
<p>大于号</p>
</blockquote>
</li>
<li>&#x3D;  等于号</li>
<li>!&#x3D;   不等于</li>
<li>&lt;&gt;  不等于</li>
</ol>
</li>
<li><p>注释符</p>
<ol>
<li>–   +空格</li>
<li>井号</li>
<li>&#x2F;%      %&#x2F;</li>
</ol>
</li>
<li><p>精确查询：  条件用 &#x3D;</p>
</li>
<li><p>模糊查询：</p>
<ol>
<li>like   像</li>
<li>not  like    不像</li>
<li>%   代表一个或者多个字符</li>
<li>_   表示一个字符（占位符）</li>
</ol>
</li>
<li><p>同时查询两个条件：</p>
<ol>
<li>and   和&#x2F;且</li>
<li>or  或者</li>
<li>null  空的</li>
<li>distinct  去重</li>
<li>order by   排序   desc ：倒叙   asc  ：正序</li>
<li>group  by  分组</li>
<li>limit  n,m  n表示从n+1开始，m表示取值</li>
<li>between   and    在什么之间</li>
<li>not  between  and   不在什么之间</li>
<li>in  是什么的值</li>
<li>not  in   不是什么的值</li>
</ol>
</li>
<li><p>五大函数</p>
<ol>
<li>avg  平均值</li>
<li>max  最大值</li>
<li>min   最小值</li>
<li>sum   求和</li>
<li>count   统计</li>
</ol>
</li>
<li><p>嵌套</p>
<ol>
<li>SELECT  查询内容     FROM   表名      WHERE   列名  IN (SELECT  查询内容     FROM   表名      WHERE   列名 &#x3D; 对应列的值);</li>
</ol>
</li>
<li><p>多表联查</p>
<ol>
<li><p>SELECT 查询内容  FROM  表名1  JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</p>
</li>
<li><p>SELECT 查询内容  FROM  表名1  LEFT JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</p>
</li>
<li><p>SELECT 查询内容  FROM  表名1  RIGHT JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</p>
</li>
</ol>
</li>
<li><p>lianxi库:</p>
<ol>
<li>sql：<a href="assets/lianxi-20211206163641-2j5ye7z.sql">lianxi.sql</a></li>
<li>练习题</li>
</ol>
</li>
</ol>
</li>
<li><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/03_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/">数据库语句优化</a></p>
</li>
<li><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/04_%E5%85%B6%E4%BB%96%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7/">其他连接工具</a></p>
</li>
</ol>
</li>
<li><h2 id="mysql数据库的特点"><a href="#mysql数据库的特点" class="headerlink" title="mysql数据库的特点"></a>mysql数据库的特点</h2><ol>
<li>可以处理成千上万条记录的大型数据</li>
<li>支持常见的sql语句规范</li>
<li>可移植性高，安装简单小巧</li>
<li>良好的运行效率，丰富信息的网络支持</li>
<li>调试、管理、优化比较简单</li>
<li>开源免费，跨平台</li>
</ol>
</li>
<li><h2 id="索引与主键"><a href="#索引与主键" class="headerlink" title="索引与主键"></a>索引与主键</h2><ol>
<li><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/05_%E7%B4%A2%E5%BC%95/">索引</a></p>
<ol>
<li>优点： 加快查询速度<br> 特点：        1.大大加快数据的检查速度<br>           2.创建唯一性索引，保证数据库表中每行数据的唯一性<br>           3.加快了表与表之间的连接<br>           4.在使用分组和排序子句进行数据检查，可以明显减少查询中的分组和排序的时间<br> 缺点： 当对表进行新增，删除和修改的时候，索引也需要对修改的数据进行维护，降低了数据的维护速度</li>
</ol>
</li>
<li><p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/06_%E4%B8%BB%E9%94%AE/">主键</a></p>
<ol>
<li><p>主关键字（primary key）是表中一个或者多个字段，它的值用于唯一标识表中某一条记录<br> 主键不能为空值，不可以重复，不可以修改</p>
<p> 主键不是必须的，在表中可以没有主键<br> 主键的特点：<br> 1.保证数据的完整性。<br> 2.加快数据的操作速度。<br> 3.在表中添加新纪录时，数据库会自动检查新纪录的主键，不允许更改值与其他记录的主键值重复<br> 4.数据库自动按照主键值得顺序显示记录，如果没有主键，则按照输入的记录顺序显示表中记录</p>
</li>
<li><p>外主键</p>
<ol>
<li>是主键的从属，表述了两个表之间的联系</li>
<li>作用：使用外键可以建立数据的关联，还可以避免冗余</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="oracle-mysql-SqlServer-的区别"><a href="#oracle-mysql-SqlServer-的区别" class="headerlink" title="oracle  mysql    SqlServer  的区别"></a>oracle  mysql    SqlServer  的区别</h4><ol>
<li>oracle 和 mysql 可以有命令登录   SqlServer 没有<br> oracle 属于大型数据库，而 mysql    SqlServer  属于中小型数据库<br />oracle 在增删改以后需要commit   而 mysql    SqlServer  不需要<br> oracle 支持并发大量访问  mysql    SqlServer   支持并发访问量没有oracle 大<br> oracle 安全性比 mysql    SqlServer  要高</li>
</ol>
</li>
<li><h4 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h4><ul>
<li>在sql中视图基于SQL语句的结果集的可视化类，视图包含行和列，就像一个真实的表，视图中的字段来源于数据库真实表的字段</li>
</ul>
</li>
<li><h2 id="什么时候查询数据库？"><a href="#什么时候查询数据库？" class="headerlink" title="什么时候查询数据库？"></a>什么时候查询数据库？</h2><ol>
<li>一般使用数据库时，我都需要数据库计算一些数据的百分比，查询一些数据库信息，还有我们小组人员要进行根性数据，方便以后的数据调用</li>
</ol>
</li>
<li><h2 id="表和视图的区别"><a href="#表和视图的区别" class="headerlink" title="表和视图的区别"></a>表和视图的区别</h2><ol>
<li>表是物理真实存在的，视图是虚拟的，表是真实的数据而视图不保存数据的</li>
</ol>
</li>
<li><h2 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h2><ol>
<li><p>定义</p>
<ol>
<li>MySQL 5.0 版本开始支持存储过程。</li>
<li>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</li>
<li>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</li>
<li>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</li>
</ol>
</li>
<li><p>优点</p>
<ol>
<li>重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</li>
<li>减少网络流量：存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</li>
<li>安全性：参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>更改比较繁琐：如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则仍需要更新程序集中的代码以添加参数、更新 GetValue() 调用，等等，这时候估计比较繁琐。</li>
<li>可移植性差：由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如果应用程序的可移植性在您的环境中非常重要，则需要将业务逻辑封装在不特定于 RDBMS 的中间层中。</li>
</ol>
</li>
<li><p>操作</p>
<ol>
<li></li>
<li><p>定义存储过程（模板)</p>
<ol>
<li><p>DELIMITER&#x2F;&#x2F;</p>
</li>
<li><p>CREATE PROCEDURE 存储过程的名称()</p>
</li>
<li><p>BEGIN</p>
<p> –存储过程代码</p>
</li>
<li><p>END&#x2F;&#x2F;</p>
</li>
<li><p>DELIMITER;</p>
</li>
</ol>
</li>
<li><p>存储过程例子</p>
<p> DROP PROCEDURE  IF EXISTS get_maxsal()</p>
<p> DELIMITER&#x2F;&#x2F;</p>
<p> CREATE PROCEDURE get_maxsal()</p>
<pre><code> BEGIN

      SELECT max(sal) from emp;

 END//
</code></pre>
<p> CALL get_maxsal(); –调整存储过程</p>
</li>
<li><p>在存储过程中声明并使用变量</p>
<p> DROP PROCEDURE  IF EXISTS get_sal；</p>
<p> DELIMITER&#x2F;&#x2F;</p>
<p> CREATE PROCEDURE get_sal()</p>
<pre><code> BEGIN

     DECLARE avgsal INT;

     SELECT avg(sal) into avgsal  from   emp;

     SELECT ename,sal FROM emp WHERE sal &gt; avgsal;

 END//
</code></pre>
<p> CALL get_sal();</p>
</li>
<li><p>带参数的存储过程</p>
<ol>
<li><p>文字定义</p>
<ol>
<li>在MySQL中，参数有三种模式：IN, OUT,INOUT.</li>
<li>IN -是默认模式，在存储过程中定义IN参数时，调用存储过程时必须将参数传递给存储过程。另外IN参数的值被保护，也就是说IN参数的值在过程中不能被改变</li>
<li>OUT - 可以在存储过程中改变OUT 参数的值，并将其更改后的新值传递回调用程序。由于OUT 参数并没有被赋值，所有不能读取，只能复制</li>
<li>INOUT - INOUT参数是IN 和OUT 参数的组合，这意味着调用程序可以传递参数，并且存储过程可以修改INOUT参数并将心的值传递回调用程序。</li>
<li>语法：IN&#x2F;OUT&#x2F;INOUT  param_name param_type(param_size)</li>
</ol>
</li>
</ol>
<p> DROP PROCEDURE  IF EXISTS get_sal；</p>
<p> DELIMITER&#x2F;&#x2F;</p>
<p> CREATE PROCEDURE get_sal(IN empname VARTHAR(5),OUT  empsal INT)</p>
<pre><code> BEGIN

     SELECT  sal INTO empsal  from emp WHERE ename = empname;

 END//
</code></pre>
<p> – 在存储过程中定义的参数，会在mysql中自动生成一下划线命名的参数</p>
<p> CALL get_sal(‘BLAKE’,@_empsal);</p>
<p> SELECT @_empsal;</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<ol>
<li><h3 id="网络技术"><a href="#网络技术" class="headerlink" title="网络技术"></a><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/01_%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></h3></li>
<li><h4 id="wireshark介绍"><a href="#wireshark介绍" class="headerlink" title="wireshark介绍"></a><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/02_wireshark%E4%BB%8B%E7%BB%8D/">wireshark介绍</a></h4></li>
<li><h2 id="网络协议的定义："><a href="#网络协议的定义：" class="headerlink" title="网络协议的定义："></a>网络协议的定义：</h2><ol>
<li>通常地说网络协议就是网络之间交流的桥梁，只有相同的网络协议的计算机才能进行信息的沟通与交流，这就好比人与人之间的交流所使用的各种语言，只有使用相同的语言才能正常的顺利进行交流，从专业角度定义：网络协议是计算机在网络中实现通信时必须遵守的约定，也即通信协议，主要是对信息传输的速率，传输的代码 代码结构，传输控制步骤，出错控制等作出规定制定标准</li>
</ol>
</li>
<li><h2 id="TCP-x2F-ip-ipv4"><a href="#TCP-x2F-ip-ipv4" class="headerlink" title="TCP&#x2F;ip ipv4"></a>TCP&#x2F;ip ipv4</h2><ol>
<li><p>网络接口层：公网达到局域网后需要转化为对应的MAC地址，交换机解析判断数据要发给MAC地址对应的那台电脑，使用的是arp协议（地址解析协议）</p>
</li>
<li><p><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/03_%E7%BD%91%E7%BB%9C%E5%B1%82.md">网络层</a>：寻找最佳网络路径（比如我们浏览其他的服务器会留下记录）</p>
</li>
<li><p><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/04_%E4%BC%A0%E8%BE%93%E5%B1%82.md">传输层</a>：设备和设备之间进行传送比特流数据</p>
</li>
<li><p><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/05_%E5%BA%94%E7%94%A8%E5%B1%82.md">应用层</a>：应用层是所有用户做面向的应用程序的统称</p>
</li>
<li><p>FTP文件传输协议，有两个端口  20 用于传输数据   21 用于传输控制信息通常用FTP协议把网页或者程序传到web服务器上，由于FTP传输效率非常高，在网络上传输大的文件时一般也采用该协议</p>
<p> oracle数据库 默认端口号：1521</p>
<p> sqlserver数据库  默认端口号：1433</p>
<p> mysql数据库 默认端口号：3306</p>
</li>
</ol>
</li>
<li><h2 id="应用层有哪些协议："><a href="#应用层有哪些协议：" class="headerlink" title="应用层有哪些协议："></a>应用层有哪些协议：</h2><ol>
<li><p>http（80）   https（443） ftp(21)  ssh(22) telnet(23) tcp  udp  arp 等</p>
<p> ftp文件传输协议     </p>
<p> ssh    linux系统安全连接协议</p>
<p> http协议：超文本传输协议      </p>
<p> https协议：加密超文本传输协议</p>
</li>
</ol>
</li>
<li><h2 id="SSH（安全外壳协议）"><a href="#SSH（安全外壳协议）" class="headerlink" title="SSH（安全外壳协议）"></a>SSH（安全外壳协议）</h2><ol>
<li>ssh为建立在应用层基础上的安全协议，ssh是目前较可靠，专为远程登录回话和其他网络服务提供安全性协议，利用ssh协议可以有效防止远程管理过程中的信息泄露的问题，ssh最初始unix系统上的一个程序，后来又迅速扩展到其他操作平台，ssh在正确使用时可弥补网络中的罗东，ssh客户端使用于多种平台，数据  端口号 22</li>
</ol>
</li>
<li><h2 id="Telnet（远程登录协议）"><a href="#Telnet（远程登录协议）" class="headerlink" title="Telnet（远程登录协议）"></a>Telnet（远程登录协议）</h2><ol>
<li>telnet 协议是tcp&#x2F;ip协议族中的一员，是internet远程登录服务的标准协议和主要方式，它为用户提供了在本地计算机上完成远程主句工作的能录，在终端使用者的电脑上使用Telnet程序，用它连接到服务器，终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行就像直接在服务器的控制台上输入一样，可以在本地就能控制服务器，要开始一个telnet会晤，必须输入用户名和密码来登录服务器数据端口号23</li>
</ol>
</li>
<li><h2 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP(地址解析协议)"></a>ARP(地址解析协议)</h2><ol>
<li>通过一致的ip寻找主机的mac地址（物理地址）硬件地址用来定义网络设备的位置，一个主机只有一个mac地址</li>
<li>RARP是反向的地址解析协议，通过mac地址确定ip地址</li>
</ol>
</li>
<li><h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ol>
<li>tcp是面向有链接的协议，提供可靠的报文传输和对上层应用的连接服务</li>
<li>udp是面向无链接的不可靠的传输协议，主要用于需要tcp的排序和流量 控制等功能的应用程序</li>
<li>tcp是一种可靠的传输协议，有请求有响应，规定接受端必须发回确认并且假如分组丢失，必须重新发送</li>
<li>udp则不具备这些，知识把数据包从客户端传输给服务端，至于服务端是否真实收到则不做判断</li>
</ol>
</li>
<li><h2 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI  七层协议"></a>OSI  七层协议</h2><ol>
<li><p>1.物理层   2.数据链路层  3.网络层  4. 传输层   5.会话层    6. 表示层   7.应用层</p>
<ol>
<li><p>物理层：两个硬件之间怎么进行通信，一个硬件发送比特流，另一个硬件成功进行接受</p>
<p> 物理层定义：定义物理层设备的标准比如光纤，网络，各种传输介质，出阿叔速度；</p>
<p> 主要关注：1和0之间的数模转换和模数转换（数模：用合适的数学模型，教数公式表达方便；魔术：设置一定的规则进行应用）</p>
</li>
<li><p>数据链路层：在数据的传输过程中识别传输比特流数据的正确性，</p>
<ol>
<li>主要关注：规范数据传输的格式，校验数据的正确性</li>
</ol>
</li>
<li><p>传输层：设备和设备之间进行传比特流数据</p>
<ol>
<li>tcp：面向有链接的协议请求，有请求有相应</li>
<li>udp：面向无链接的协议请求，有请求无响应</li>
</ol>
</li>
<li><p>网络层：寻找最佳网络路径（比如我们浏览其他的服务器会留下记录）</p>
</li>
<li><p>会话层：根据以上协议自动进行发送对应的数据</p>
</li>
<li><p>表示层：不同系统之间交互的通道（作用相当于我们的翻译）</p>
<ol>
<li>windows 运行软件  .exe</li>
<li>linux   运行软件   .sh</li>
</ol>
</li>
<li><p>应用层：贴近我们的日常生活，能够直观看到的</p>
<ol>
<li><img src="/assets/image-20211122140653-z9ls60r.png" alt="image.png"></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="osi-7层协议解释说明"><a href="#osi-7层协议解释说明" class="headerlink" title="osi 7层协议解释说明"></a>osi 7层协议解释说明</h2><ol>
<li>物理层（physical layer） 主要是处理机械的电器的过程的接口，以及物理层下的物理传输介质等</li>
<li>数据链路层（data link layer） 的任务是加强吴立成的功能 使其对网络层显示为一条无错的线路</li>
<li>网络层（network layer） 确定分组从源端到目的端的路由选择，路由可以选用网络中固定的静态路由表，也可以在每一次会化时决定，还可以根据当前的网络负载状态，灵活的为每一个分组分别决定</li>
<li>传输层（transport layer） 从会话层接受数据，并传给网络层，同时确保到达目的端的各段信息正确无误，而且使会话层不受硬件变化的影响</li>
<li>会话层（session layer） 允许不同的机器上的用户之间建立绘画关系，即可以进行类似传输层的数据传输，也可以被用于与远程登录到不同系统或者在两个机器间传递文件</li>
<li>表示层（presentation layer） 用于完成一些特定的功能，这些功能由于经常被请求，因人们希望有通用的解决方法，而不是由每个用户各自实现</li>
<li>应用层（application layer） 中包含了大量人们普遍需要的协议，如qq、浏览器等部分软件均在应用层</li>
</ol>
</li>
<li><h3 id="是否了解三次握手，四次挥手？"><a href="#是否了解三次握手，四次挥手？" class="headerlink" title="是否了解三次握手，四次挥手？"></a>是否了解三次握手，四次挥手？</h3><ol>
<li><h5 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h5><ol>
<li><p>第一次握手：建立连接时，客户端发送SYN包到服务器，并进入SYN-SEND（发送）状态，等待服务器确认。</p>
</li>
<li><p>第二次握手：服务器收到SYN包，必须确认客户的SYN，同时自己也发送一个syn包。即syn+ack（确认字符）包，此时服务器进入syn-recv（接受）状态</p>
</li>
<li><p>第三次握手：客户端收到服务器syn+ack包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入established（确认）状态，完成三次握手</p>
</li>
</ol>
</li>
<li><h5 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h5><ol>
<li><p>第一次挥手：客户端给服务器发送FIN包，用来关闭客户端到服务器的数据传送</p>
</li>
<li><p>第二次挥手：服务器收到FIN包，发送一个确认信号ACK</p>
</li>
<li><p>第三次挥手：服务器发送FIN包，请求关闭服务器到客户端的数据传送</p>
</li>
<li><p>第四次挥手：客户端收到服务器发送的FIN包之后，发回ACK包确认</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="长连接和短连接的区别"><a href="#长连接和短连接的区别" class="headerlink" title="长连接和短连接的区别"></a>长连接和短连接的区别</h2><ol>
<li><p>短连接：指socket连接后发送，接受完数据后马上断开（比如发短信）</p>
<pre><code> &lt;短连接：连接-数据传输-关闭连接（安全性比较高）&gt;
</code></pre>
<p> 长连接：指socket连接后不管是否传输都保持连接，单安全性比较低（比如打电话，视频通信）</p>
<pre><code> &lt;长连接：连接-数据传输-保持连接-数据传输-关闭连接（安全性比较低）&gt;
</code></pre>
</li>
</ol>
</li>
<li><h3 id="对协议这块是否熟悉了解，大概给我简单介绍下http协议？"><a href="#对协议这块是否熟悉了解，大概给我简单介绍下http协议？" class="headerlink" title="对协议这块是否熟悉了解，大概给我简单介绍下http协议？"></a>对协议这块是否熟悉了解，大概给我简单介绍下<strong>http</strong>协议？</h3><ol>
<li><p>对于协议这块，我们做接口测试一定要熟悉协议，而且我们所有接口都是 http 接口，所以对于 http 协议还算比较熟悉。</p>
<p> 其实http协议是一个超文本传输协议—- &gt;可以传输文字&#x2F;文本，图片，音频，视频等</p>
<p> HTTP<br> 是一个基于 TCP&#x2F;IP 通信协议来传递数据，目前有 1.0，1.1 两个版本，现在主要用的 1.1 版本协议。HTTP 协议工作于客户端-服务端架构为上一种协议。他的原理是这样的：浏览器作为 HTTP 客户端通过URL 向<br> HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p> 这个协议其实就是通过请求，响应的形式来进行数据传输的一种模式。</p>
<p> http 协议比较简单，传输速度比较快，例外，它是一种面向无状态，无连接的协议，同时支持<br> B&#x2F;S 及C&#x2F;S</p>
<p> 模式。它没有记忆能力，每次要获取数据都必须要重新发送请求。</p>
</li>
<li><p><img src="/assets/image-20211203174202-7p53c90.png" alt="image.png"></p>
</li>
</ol>
</li>
<li><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><ol>
<li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/01_HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">HTTP协议详解</a></li>
<li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/02_%E7%BC%93%E5%AD%98/">缓存</a></li>
<li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/03_%E4%BB%A3%E7%90%86/">代理</a></li>
<li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/04_%E7%8A%B6%E6%80%81%E7%A0%81/">状态码</a></li>
<li><a href="../904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/05_cookie/">cookie</a></li>
</ol>
</li>
<li><h3 id="http协议的报文"><a href="#http协议的报文" class="headerlink" title="http协议的报文"></a><strong>http</strong>协议的报文</h3><ol>
<li><p>哦，对于 http 的报文，由于它是通过请求，响应的方式在客户端与服务端进行数据传输的模式，所以它的报文分为请求报文和响应报文。</p>
<p> Http 的请求报文包含以下 4 个部分：请求行，请求头，空行，请求数据&#x2F;参数。</p>
<p> 我们其实一般最关注的主要是请求头及请求数据&#x2F;参数。尤其在做接口测试的时候我们需要关注这两个部分。例外，对于请求行里面，一般包含有：请求方式，请求地址&#x2F;URL，端口，协议版本等信息。</p>
<p> 而 http 的响应报文包含以下 4 个部分：响应行，响应头，空行，响应的数据</p>
<p> 对于响应，我们一般重点关注的是：响应头，响应的数据。例外，响应行中包含有：协议版本，状态（本次数据传输的状态），提示信息。还有就是，请求头中也有些比较关键的信息，比如用来做鉴权的<br> cookie 或着 token 的值，我们后面可能会需要用到。 而响应具体数据中包含：错误码，具体数据内容，一般具体的数据内容的格式有：json,xml,html。对于 Web端一般传输的是 html格式，而 app端一般传输的<br> json 格式居多。</p>
<blockquote>
<p>POST</p>
<p><a href="http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWwucJRFNxUfImKSQTQAgTEpzCOgh">http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWw</a> <a href="http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWwucJRFNxUfImKSQTQAgTEpzCOgh">ucJRFNxUfImKSQTQAgTEpzCOgh </a>HTTP&#x2F;1.1 请求行</p>
<p>Host: localhost 请求头</p>
<p>Connection: keep-alive Content-Length: 169</p>
<p>Accept: application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01 Origin: <a href="http://localhost/">http://localhost</a></p>
<p>X-Requested-With: XMLHttpRequest</p>
<p>User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;73.0.3683.103 Safari&#x2F;537.36</p>
<p>Content-Type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8 Referer: <a href="http://localhost/fw/">http://localhost/fw/</a></p>
<p>Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q&#x3D;0.9</p>
<p>Cookie: PHPSESSID&#x3D;1995aff9a42398edb17cd80bb76a5a5f</p>
<p>空行</p>
<p>email&#x3D;jason&amp;user_pwd&#x3D;WVRnSk1kS1hneW9RYkNxVmpTR1VVQmN1bHN3SlR4ekdEQkVIYlFIRmlZUnFW</p>
<p>cHBSYWElMjV1NjVCOSUyNXU3RUY0emdwMTIzNDU2JTI1dThGNkYlMjV1NEVGNg%3D%3D&amp;auto_login&#x3D;0</p>
<p>&amp;ajax&#x3D;1 请求参数&#x2F;数据</p>
</blockquote>
<blockquote>
<p>HTTP&#x2F;1.1 200 OK 响应行</p>
<p>Date: Thu, 25 Apr 2019 05:45:21 GMT 响应头</p>
<p>Server: Apache&#x2F;2.2.11 (Win32) DAV&#x2F;2 mod_ssl&#x2F;2.2.11 OpenSSL&#x2F;0.9.8i PHP&#x2F;5.2.9 X-Powered-By: PHP&#x2F;5.2.9</p>
<p>Expires: Thu, 19 Nov 1981 08:52:00 GMT</p>
<p>Cache-Control: no-store, no-cache, must-revalidate, post-check&#x3D;0, pre-check&#x3D;0 Pragma: no-cache</p>
<p>Content-Length: 262</p>
<p>Keep-Alive: timeout&#x3D;5, max&#x3D;100 Connection: Keep-Alive</p>
<p>Content-Type: text&#x2F;html; charset&#x3D;utf-8</p>
<p>空行</p>
<p>{“status”:2,”info”:”\u672c\u7ad9\u9700\u7ed1\u5b9a\u7b2c\u4e09\u65b9\u6258\u7ba1\ u8d26\u6237\uff0c\u662f\u5426\u9a6c\u4e0a\u53bb\u7ed1\u5b9a”,”data”:null,”jump”:”</p>
<p>/fw/index.php”,”jump1”:”/fw/index.php?ctl&#x3D;collocation&amp;act&#x3D;CreateNewAcct&amp;user_</p>
<p>type&#x3D;0&amp;user_id&#x3D;33”}响应的具体内容</p>
</blockquote>
</li>
</ol>
</li>
<li><h3 id="常用的-http协议的状态码？"><a href="#常用的-http协议的状态码？" class="headerlink" title="常用的 http协议的状态码？"></a>常用的 http协议的状态码？</h3><ol>
<li><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<ol>
<li>1xx：指示信息–表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ol>
</li>
<li><p>200 OK服务器成功处理了请求（这个是我们见到最多的） </p>
<p> 301&#x2F;302 MovedPermanently（重定向）请求的URL已移走。Response中应该包含一个Location URL,说明资源现在所处的位置 </p>
<p> 304 Not Modified（未修改）客户的缓存资源是最新的，要客户端使用缓存</p>
<p> 404 Not Found未找到资源 </p>
<p> 401Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </p>
<p> 400 Bad Request客户端请求与语法错误，不能被服务器所理解 </p>
<p> 403Forbidden服务器收到请求，但是拒绝提供服务 </p>
<p> 500InternalServerError服务器发生了不可预期的错误 </p>
<p> 501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务 </p>
<p> 503 Server Unavailable服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
</li>
</ol>
</li>
<li><p><strong>http</strong>协议的请求方式，<strong>Get</strong>请求与 <strong>Post</strong>请求的区别？</p>
<ol>
<li><p>我们常用的请求方式一般是:get 请求，post 请求</p>
<ol>
<li>GET提交，请求的数据会附在<br> URL之后（就是把数据放置在 HTTP协议头中），以?分割 URL和传输数据，多个参数用&amp;连接；如果传输的数据是中文&#x2F;其他字符，一般则直接把字符串用 BASE64加密。</li>
</ol>
<p> POST 提交：把提交的数据放置在是 HTTP 包的包体中</p>
<p> 因此，GET 提交的数据会在地址栏中显示出来，而<br> POST 提交，地址栏不会改变</p>
<ol start="2">
<li>传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</li>
</ol>
<p> 而在实际开发中存在的限制主要有：</p>
<p> GET:特定浏览器和服务器对 URL长度有限制，例如 IE对URL长度的限制是 2083字节(2K+35)。对于其他浏览器，如 Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系<br> 统的支持。</p>
<p> 因此对于 GET 提交时，传输数据就会受到 URL 长度的限制。</p>
<p> POST:由于不是通过URL 传值，理论上数据不受限。</p>
<ol start="3">
<li>POST的安全性要比 GET的安全性高。比如：通过 GET提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 GET<br> 提交数据还可能会造成Cross-siterequest<br> forgery攻击（数据篡改）</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="http协议与-https协议的区别"><a href="#http协议与-https协议的区别" class="headerlink" title="http协议与 https协议的区别"></a><strong>http</strong>协议与 <strong>https</strong>协议的区别</h3><ol>
<li><p>https 所用的端口号是 443 端口</p>
<p> http 所用的端口是 80 端口</p>
<p> HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用HTTP 协议传输隐私信息非常不安全， 为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p>
<p> https 通信的优点：</p>
<p> 1） 客户端产生的密钥只有客户端和服务器端能得到；</p>
<p> 2） 加密的数据只有客户端和服务器端才能得到明文；</p>
<p> 3） 客户端到服务端的通信是安全的。</p>
<p> 区别：</p>
<p> (1) https 协议需要ca 申请证书，并且大多数证书都是收费的。</p>
<p> (2) http 以明文的形式传输信息，https 则是具有安全性的ssl 加密传输协议。</p>
<p> (3) http 和https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80（有时是8080），后者是443。</p>
<p> (4) http 的连接简单，无状态；HTTPS 协议是在HTTP 协议的基础上，加上由SSL 层，构建的可进行加密传输、身份认证的网络协议，比http 协议安全。</p>
</li>
</ol>
</li>
<li><h4 id="tcp与udp的区别"><a href="#tcp与udp的区别" class="headerlink" title="tcp与udp的区别"></a>tcp与udp的区别</h4><ol>
<li><p>tcp是面向有链接的协议，提供可靠的报文传输和对上层应用的连接服务</p>
<p> udp是面向无链接的不可靠的传输协议，主要用于需要tcp的排序和流量 控制等功能的应用程序</p>
<p> tcp是一种可靠的传输协议，有请求有响应，规定接受端必须发回确认并且假如分组丢失，必须重新发送</p>
<p> udp则不具备这些，知识把数据包从客户端传输给服务端，至于服务端是否真实收到则不做判断</p>
</li>
</ol>
</li>
</ol>
<p>短连接：指socket连接后发送，接受完数据后马上断开（比如发短信）</p>
<pre><code>&lt;短连接：连接-数据传输-关闭连接（安全性比较高）&gt;
</code></pre>
<p>长连接：指socket连接后不管是否传输都保持连接，单安全性比较低（比如打电话，视频通信）</p>
<pre><code>&lt;长连接：连接-数据传输-保持连接-数据传输-关闭连接（安全性比较低）&gt;
</code></pre>
]]></content>
      <categories>
        <category>课中</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>windows快捷键</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01_windows%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h5 id="win快捷键："><a href="#win快捷键：" class="headerlink" title="win快捷键："></a>win快捷键：</h5><p>单独按Windows：显示或隐藏 “开始”功能表<br>Windows+BREAK：显示“系统属性” 对话框<br>Windows+D：显示桌面或恢复桌面<br>Windows+M：最小化所有窗口<br>Windows+Shift+M：还原最小化的窗口<br>Ctrl+Shift+N：新建文件夹<br>Windows+E：打开”我的电脑”<br>Windows+F：查找文件或文件夹<br>Windows+CTRL+ F：查找电脑<br>Windows+F1：显示 Windows “帮助”<br>Windows+R：开启“运行” 对话框<br>Windows+U：开启 “公用程序管理器”<br>Windows+L：锁定计算机（Windows XP新功能）<br>Windows按住不动+Tab：打开的应用程序切换，立体效果（win7系统支持）<br>windows +alt +F4：windows 关机窗口</p>
<h5 id="Ctr快捷键（文本编辑使用较多）"><a href="#Ctr快捷键（文本编辑使用较多）" class="headerlink" title="Ctr快捷键（文本编辑使用较多）"></a>Ctr快捷键（文本编辑使用较多）</h5><p>Ctrl+S 保存<br>Ctrl+W 关闭程序<br>Ctrl+N 新建<br>Ctrl+O 打开<br>Ctrl+Z 撤销<br>Ctrl+F 查找<br>Ctrl+P 打印文档<br>Ctrl+X 剪切<br>Ctrl+C 复制<br>Ctrl+V 粘贴<br>Ctrl+A全选<br>Ctrl+B 粗体<br>Ctrl+I 斜体<br>Ctrl+U 下划线<br>Ctrl+Shift输入法切换<br>Ctrl+ 空格 中英文切换<br>Ctrl+Home 光标快速移到文件头<br>Ctrl+End 光标快速移到文件尾<br>Ctrl+Esc 显示开始菜单<br>Ctrl+Shift+&lt; 快速缩小文字<br>Ctrl+Shift+&gt; 快速放大文字<br>Ctrl+F5 在IE中强行刷新<br>Ctrl+拖动文件 复制文件<br>Ctrl+Backspace 启动\关闭输入法<br>Ctrl+Alt+A 截屏(QQ的截屏）<br>shift + Alt + Print Screen(选中要截屏的地方，然后按这三个键，然后打开图画或者word，粘贴即可)<br>拖动文件时按住Ctrl+Shift 创建快捷方式<br>Ctrl+Tab+shift在打开的应用程序中以反方向切换</p>
<h5 id="ALT快捷键"><a href="#ALT快捷键" class="headerlink" title="ALT快捷键"></a>ALT快捷键</h5><p>Alt+F4 关闭当前程序<br>Alt+空格+C 关闭窗口<br>Alt+空格+N 最小化当前窗口<br>Alt+空格+R 恢复最大化窗口<br>Alt+空格+X 最大化当前窗口<br>Alt+空格+M 移动窗口<br>Alt+空格+S 改变窗口大小<br>Alt+u+v word全屏视图<br>Alt+F 打开文件菜单<br>Alt+V 打开视图菜单<br>Alt+E 打开编辑菜单<br>Alt+I 打开插入菜单<br>Alt+O 打开格式菜单<br>Alt+T 打开工具菜单<br>Alt+A 打开表格菜单<br>Alt+W 打开窗口菜单<br>Alt+H 打开帮助菜单<br>Alt+回车 查看文件属性<br>Alt+双击文件 查看文件属性<br>Alt+Tab在打开的应用不同窗口间进行切换</p>
<h5 id="shift快捷键"><a href="#shift快捷键" class="headerlink" title="shift快捷键"></a>shift快捷键</h5><p>Shift+空格 半\全角切换<br>Shift+F10 选中文件的右菜单<br>Shift+Del 永久删除</p>
<h5 id="FN快捷键"><a href="#FN快捷键" class="headerlink" title="FN快捷键"></a>FN快捷键</h5><p>F1 帮助<br>F2 重命名<br>F3 在windows中搜索文件<br>F5 刷新<br>F6 在窗口或桌面上循环切换屏幕元素。<br>F7 DoS下专用功能<br>F8 Windows 启动选项<br>F9 Excel 中计算公式<br>F11 切换全屏<br>F12 Word 里另存文档</p>
<h5 id="常规快捷键"><a href="#常规快捷键" class="headerlink" title="常规快捷键"></a>常规快捷键</h5><p>拖动某一项时按 CTRL 复制所选项。<br>拖动某一项时按 CTRL + SHIFT 创建所选项目的快捷键。<br>F2 重新命名所选项目。<br>CTRL + 向右键 将插入点移动到下一个单词的起始处。<br>CTRL + 向左键 将插入点移动到前一个单词的起始处。<br>CTRL + 向下键 将插入点移动到下一段落的起始处。<br>CTRL + 向上键 将插入点移动到前一段落的起始处。<br>CTRL + SHIFT + 任何箭头键突出显示一块文本。<br>SHIFT + 任何箭头键 在窗口或桌面上选择多项，或者选中文档中的文本。<br>Ctrl + A 选中全部内容。<br>F3 同一浏览器中打开的窗口切换。<br>Alt + Enter 查看所选项目的属性。<br>Alt + F4 打开关机，待机，重启<br>Alt +空格键为当前窗口打开快捷菜单。<br>Alt + Tab 在打开的项目之间切换。<br>Alt + Esc 以项目打开的顺序循环切换。<br>Shift + F10 显示所选项的快捷菜单。<br>ALT + 菜单名中带下划线的字母 显示相应的菜单（ALT在写字板中）。<br>右箭头键 打开右边的下一菜单或者打开子菜单。<br>Ctrl+Alt+Home或ctrl+home 回到页首</p>
<h5 id="FN键"><a href="#FN键" class="headerlink" title="FN键"></a>FN键</h5><p>F1 帮助<br>F2 重命名<br>F3 在windows中搜索文件<br>F5 刷新<br>F6 在窗口或桌面上循环切换屏幕元素。<br>F7 DoS下专用功能<br>F8 Windows 启动选项<br>F9 Excel 中计算公式<br>F11 切换全屏<br>F12 Word 里另存文档<br>Enter 执行活选项动或按钮所对应的命令。<br>方向键 活选项动是一组选项按钮时，请选中某个按钮。<br>BackSpace 如果在“另存为”或“打开”对话框中选中了某个文件夹，则打开上一级文件夹</p>
<h5 id="END-显示当前窗口的底端。"><a href="#END-显示当前窗口的底端。" class="headerlink" title="END 显示当前窗口的底端。"></a>END 显示当前窗口的底端。</h5><p>Home 显示当前窗口的顶端。<br>NUM LOCK+数字键盘星号* 显示所选文件夹的所有子文件夹。<br>NUM LOCK+数字键盘加号+ 显示所选文件夹的内容。<br>NUM LOCK+数字键盘减号- 折叠所选的文件夹。<br>左方向键 光标左移<br>右方向键 光标右移<br>TAB 制表键</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>windows快捷键</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02_Linux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="linux简介："><a href="#linux简介：" class="headerlink" title="linux简介："></a>linux简介：</h3><p>Linux 是一种自由和开放源码的类 UNIX 操作系统。<br>Linux 英文解释为 Linux is not Unix。<br>Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发。<br>本教程，我们将为大家介绍如何使用 Linux。</p>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。<br>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。<br>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h3 id="Linux-的发行版"><a href="#Linux-的发行版" class="headerlink" title="Linux 的发行版"></a>Linux 的发行版</h3><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p>
<p><img src="/assets/image-20211120104622-naz095z.png" alt="image.png"></p>
<h3 id="Linux-vs-Windows"><a href="#Linux-vs-Windows" class="headerlink" title="Linux vs Windows"></a>Linux vs Windows</h3><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>Windows</th>
<th>Linux</th>
</tr>
</thead>
<tbody><tr>
<td>界面</td>
<td>界面统一，外壳程序固定所有Windows程序菜单几乎一致，快捷键也几乎相同</td>
<td>图形界面风格依发布版不同而不同，可能互不兼容。GNU&#x2F;Linux的终端机是从UNIX传承下来，基本命令和操作方法也几乎一致。</td>
</tr>
<tr>
<td>驱动程序</td>
<td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的Windows下的驱动，也会比较头痛。</td>
<td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td>
</tr>
<tr>
<td>使用</td>
<td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td>
<td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td>
</tr>
<tr>
<td>学习</td>
<td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td>
<td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td>
</tr>
<tr>
<td>软件</td>
<td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td>
<td>大部分软件都可以自由获取，同样功能的软件选择较少。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>课中</category>
        <category>基础</category>
        <category>windows快捷键</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>windows与linux的区别</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/03_windows%E4%B8%8Elinux%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Windows和Linux是完全不同的两种操作系统。 Windows是微软公司出的商业操作系统，在全球90%以上的电脑用的都是Windows的操作系统。 Linux是一款开源免费的操作系统，不用掏钱就能用。全球好多服务器用的是这个操作系统。</p>
<p>做为个人电脑使用，这两种系统对比有什么优缺点呢？ 首先说说Windows。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><img src="/assets/image-20211122224703-cy1k2rz.png" alt="image.png"></p>
<p>Windows 做为全球使用量第一的操作系统，要说没有优点那是不可能的。 不但有优点，而且还有很多优点，有些优点还是其他操作系统无论如何也追不上的。</p>
<h3 id="1-不用安装"><a href="#1-不用安装" class="headerlink" title="1. 不用安装"></a>1. 不用安装</h3><p>这个不用安装并不是说不用安装操作系统，而是除了Mac之外，99%以上的个人电脑都是在出厂的时候就安装好了Windows系统， 电脑到手直接使用就行，不用再担心还要安装系统的问题。</p>
<h3 id="2-容易维修"><a href="#2-容易维修" class="headerlink" title="2. 容易维修"></a>2. 容易维修</h3><p>正是因为Windows是全球使用量第一的操作系统， 所以几乎所有的电脑店里面都是以维修Windows电脑为主。 如果系统出的问题，基本随便到一个电脑店都能解决。</p>
<h3 id="3-软件和游戏数量极大"><a href="#3-软件和游戏数量极大" class="headerlink" title="3. 软件和游戏数量极大"></a>3. 软件和游戏数量极大</h3><p>Windows全球使用量第一，所以全球开发者数量也很高。 这就造成了Windows上面的软件数量非常非常之大，这点是Linux无论如何也追不上的。 像我们国内常用的QQ，微信等在Linux上就没有， 更不要说像英雄联盟，绝地求生这些游戏了。 在Linux中虽然也能通过Wine安装Windows软件， 但大部分软件都是不兼容的， 而且安装了Wine以后整个系统都不稳定了。</p>
<h3 id="4-硬件兼容性好"><a href="#4-硬件兼容性好" class="headerlink" title="4. 硬件兼容性好"></a>4. 硬件兼容性好</h3><p>很多硬件的驱动在Windows能很方便的安装，但在Linux的根本就没有。 比如我用的笔记本，在使用Windows系统，WiFi，蓝牙，各种硬件都正常， 但使用Linux系统WiFi是不能用的， 还要自己编译安装驱动程序。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><img src="/assets/image-20211122224710-34agwn3.png" alt="image.png"></p>
<p>Linux做为开源免费的操作系统，也有些优点是Windows无论如何也赶不上的。</p>
<h3 id="1-不用花钱"><a href="#1-不用花钱" class="headerlink" title="1. 不用花钱"></a>1. 不用花钱</h3><p>正版的Windows系统是要花钱购买的，而且价钱还不低（买笔记本带Windows系统其实系统钱是包含在里面的）。 而Linux是开源免费的，任何人不用花钱都可以下载使用，而且有多个发行版可供选择。</p>
<h3 id="2-稳定性-x2F-流畅度高"><a href="#2-稳定性-x2F-流畅度高" class="headerlink" title="2. 稳定性&#x2F;流畅度高"></a>2. 稳定性&#x2F;流畅度高</h3><p>使用Windows系统时不时会出现卡顿，不稳定的问题，但Linux不会。选择一个好的发行版做为个人电脑系统使用的话一般不会出现卡顿的情况。 而且Windows系统长时间使用的话要重启一下，不然可能就没有开机时流畅了。</p>
<p>在Windows中由于空间不够用都会安装一款清理垃圾文件的软件，Windows系统本身会占用很大的空间，随便安装几个软件系统盘也许就满了。 但在Linux中一般不需要，因为Linux系统本身不会占用多大的磁盘空间，安装软件也都是规范的位置，系统临时目录重启时会自动清理，不会占用大量的磁盘空间。</p>
<p>在我的使用体验中，Linux的流畅度是比Windows高的。比如我使用的编程软件IDEA，同一台电脑同一块硬盘，在Windows上打开一个项目要3到5秒， 但在Linux（Ubuntu 18.04）中打开同一个项目只要不到1秒。</p>
<h3 id="4-安全性高"><a href="#4-安全性高" class="headerlink" title="4. 安全性高"></a>4. 安全性高</h3><p>在Windows系统中是一定要安装杀毒软件的。就算你不安装，Windows系统自带的也会启动。但在Linux中不用，因为Linux是一个有严格权限控制的系统，平常使用的时候一般不会使用root用户，就算有恶意脚本也不至于对系统造成大破坏。而且Linux的病毒数量也极少。</p>
<h3 id="5-可定制性高"><a href="#5-可定制性高" class="headerlink" title="5. 可定制性高"></a>5. 可定制性高</h3><p>由于Linux系统是开源的， 所以每个人都可以下载其源代码进行定制。就算是已经存在的发行版桌面环境也都是可以换的。如果你有能力，可以把Linux系统改的它亲爹都不认识。</p>
<h3 id="6-性能高"><a href="#6-性能高" class="headerlink" title="6. 性能高"></a>6. 性能高</h3><p>Linux的开发都可能比使用者还要多，这就意味着Linux从内核到软件都是经过多次的优化的。性能高自然也是不奇怪。这个性能不仅表现在软件性能，现在还表现在游戏性能上，我在同一台电脑上在Windows系统中玩我的世界不限制帧率能跑800多帧，但在Linux里面使用同一个显卡，加载同一个游戏，同一个场景，能跑1000多帧。</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>基础</category>
        <category>windows与linux的区别</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>测试计划</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p><img src="/assets/image-20211120225648-gfkhwjd.png" alt="image.png"></p>
<h1 id="软件测试人员如何编写测试计划"><a href="#软件测试人员如何编写测试计划" class="headerlink" title="软件测试人员如何编写测试计划"></a>软件测试人员如何编写测试计划</h1><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>每个公司的测试计划都不尽相同，但每个测试计划包含的主要内容又只有这几点，那我们一起研究一下测试计划的主要内容有哪些？</p>
<h2 id="测试计划概念"><a href="#测试计划概念" class="headerlink" title="测试计划概念"></a><strong>测试计划概念</strong></h2><p><strong>测试计划（Testing plan）的定义：</strong></p>
<blockquote>
<p>描述了要进行的测试活动的范围、方法、资源和进度的文档；<br>是对整个信息系统应用软件组装测试和确认测试。<br>它确定测试项、被测特性、测试任务、谁执行任务、各种可能的风险。<br>测试计划可以有效预防计划的风险，保障计划的顺利实施。</p>
</blockquote>
<p><strong>测试计划的目的</strong></p>
<blockquote>
<p>（1）为测试各项活动制定一个现实可行的、综合的计划，包括每项测试活动的对象、范围、方法、进度和预期结果。<br>（2）为项目实施建立一个组织模型，并定义测试项目中每个角色的责任和工作内容。<br>（3）开发有效的测试模型，能正确地验证正在开发的软件系统。<br>（4）确定测试所需要的时间和资源，以保证其可获得性、有效性。<br>（5）确立每个测试阶段测试完成以及测试成功的标准、要实现的目标。<br>（6）识别出测试活动中各种风险，并消除可能存在的风险，降低由不可能消除的风险所带来的损失。</p>
</blockquote>
<p>编写测试计划，就是为了达到这些目的。</p>
<p>通过测试计划可以宏观的指导测试的后续工作</p>
<p><strong>测试计划由谁编写</strong></p>
<p>测试计划属于管理型文档，是由测试经理、测试主管或测试组长进行编写。</p>
<p><strong>测试计划编写的6个要素</strong></p>
<blockquote>
<p>1）why——为什么要进行这些测试；<br>2) what—测试哪些方面，不同阶段的工作内容；<br>3) when—测试不同阶段的起止时间；<br>4) where—相应文档，缺陷的存放位置，测试环境等；<br>5) who—项目有关人员组成，安排哪些测试人员进行测试<br>6) how—如何去做，使用哪些测试工具以及测试方法进行测试。</p>
</blockquote>
<h2 id="测试计划主要内容"><a href="#测试计划主要内容" class="headerlink" title="测试计划主要内容"></a><strong>测试计划主要内容</strong></h2><p><strong>1.项目简介</strong></p>
<p>项目简介分为项目背景和编写目的。</p>
<p>主要描述项目实施的背景和为什么要编写测试计划的目的。</p>
<p><strong>2.参考文档</strong></p>
<p>描述编写测试计划时的依据。可以用列表的形式梳理出来。</p>
<p>参考文档 备注</p>
<p>详细设计</p>
<p>概要设计</p>
<p>UI原型图</p>
<p>接口文档</p>
<p><strong>3.测试范围</strong></p>
<p>描述本次测试活动的测试范围。</p>
<p>可以分为总体的测试范围和主要测试的功能点二个部分。</p>
<p>例如，本次测试范围为登录模块和注册模块，其中以注册模块为主要测试功能模块。</p>
<p><strong>4.时间进度安排</strong></p>
<p>首先描述测试活动的总体时间。</p>
<p>再描述测试活动的每个不同阶段需要多长时间，具体可以以表格的形式输出。</p>
<p>例如</p>
<p>测试阶段 计划开始时间 计划完成时间 备注</p>
<p>需要分析 2017-11-10 2017-11-13</p>
<p>需要评审 2017-11-14 2017-11-15</p>
<p>…… …… ……</p>
<p><strong>5.资源</strong></p>
<p>描述本次测试活动需要的人力资源和软硬件资源。</p>
<p><img src="/assets/image-20211120225709-3ou6vsb.png" alt="image.png"></p>
<p><strong>6.风险评估</strong></p>
<p>描述本次测试活动中有可能会产生的风险和解决方案。</p>
<p>在风险评估中确定风险级别最高的测试对象，优先测试，同时需要考虑的要点有：</p>
<p>重要性、严重性、原因、可能性</p>
<p><strong>7.测试交付件</strong></p>
<p>描述本次测试活动完成后测试部需要输出的文档。</p>
<p>例如：测试计划，测试方案，用例执行情况表，缺陷，总结测试报告等等</p>
<p>以上七点在测试计划中需要完全包含，测试计划中包含的主要内容是七点，但由于每个公司的项目和业务都不相同，故测试计划中的实质性内容也不一样，虽然说测试计划可以理解为填空题，但是每个空的答案都不是一样的。</p>
<p>测试策略在测试计划中可有可无，一般来说测试策略是写测试方案中。这里列出了包含进测试计划的测试策略。</p>
<p>图片为测试策略包含的主要内容</p>
<p><img src="/assets/image-20211120225717-b9ur7v7.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>基础</category>
        <category>测试计划</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试的分类</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="/assets/wpsEE47.tmp-20211120145802-z73wzpx.jpg"></p>
<ul>
<li><p>按开发阶段分类</p>
<ul>
<li><p>单元测试</p>
<ul>
<li>模块测试，最小单位的测试</li>
</ul>
</li>
<li><p>集成测试</p>
<ul>
<li>把单元的小模块组合起来进行的测试</li>
<li>测试不同模块接口的测试</li>
</ul>
</li>
<li><p>系统测试 ———————–把系统看成一个整体进行的测试</p>
<ul>
<li>功能测试</li>
<li>兼容性测试</li>
<li>性能测试</li>
<li>安全测试</li>
</ul>
</li>
<li><p>验收测试</p>
<ul>
<li>α测试   内测的一个版本测试</li>
<li>β测试   公测的一个版本测试</li>
</ul>
</li>
</ul>
</li>
<li><p>按是否查看代码</p>
<ul>
<li>白盒测试</li>
<li><a href="../03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">黑盒测试</a></li>
<li>灰盒测试</li>
</ul>
</li>
<li><p>按测试执行方式</p>
<ul>
<li>静态测试</li>
<li>动态测试</li>
</ul>
</li>
<li><p>按是否手工执行划分</p>
<ul>
<li>手动测试</li>
<li>自动化测试</li>
</ul>
</li>
<li><p>其他分类</p>
<ul>
<li>冒烟测试     快速验证主要功能的测试</li>
<li>回归测试</li>
<li>随机测试</li>
<li>探索性测试    随机测试的升级版，测试的一种思维方式，强调遇到问题之后，改变测试策略，能够发现更加深入的问题，是未来测试发展的一个领域</li>
</ul>
</li>
</ul>
<p><a href="../04_%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%88%92%E5%88%86/">测试种类划分</a></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>基础</category>
        <category>软件测试的分类</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>测试种类划分</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>软件测试方法种类繁多，记忆起来混乱， 如果把软件测试方法进行分类, 就会清晰很多。 我参考一些书籍和网上的资料， 把常用的软件测试方法列出来， 让大家对软件测试行业有个总体的看法。</p>
<h1 id="从测试设计方法分类"><a href="#从测试设计方法分类" class="headerlink" title="从测试设计方法分类"></a><strong>从测试设计方法分类</strong></h1><table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Black box黑盒测试</td>
<td>把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试.</td>
</tr>
<tr>
<td>White box白盒测试</td>
<td>设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。</td>
</tr>
<tr>
<td>Gray box.灰盒测试</td>
<td>介于黑盒和白盒之间</td>
</tr>
</tbody></table>
<p>总结：   实际工作中，对系统的了解越多越好。目前大多数的测试人员都是做黑盒测试，很少有做白盒测试的。 因为白盒测试对软件测试人员的要求非常高，需要有很多编程经验。做.NET程序的白盒测试你要能看得懂.NET代码。做JAVA程序的测试，需要你能看懂JAVA的代码。 如果你都能看懂了，你还会做测试么</p>
<h1 id="从测试是手动还是自动上分类"><a href="#从测试是手动还是自动上分类" class="headerlink" title="从测试是手动还是自动上分类"></a><strong>从测试是手动还是自动上分类</strong></h1><table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Manual Test手动测试</td>
<td>测试人员用鼠标去手动测试（测试GUI）</td>
</tr>
<tr>
<td>Automation自动化测试</td>
<td>用程序测试程序（测试API）</td>
</tr>
</tbody></table>
<p>对于项目来说， 手动测试和自动化测试同等重要，都是保障软件质量的方法。 目前大部分的项目组都是手动测试和自动化测试相结合。因为很多测试无法做成自动化，很多复杂的业务逻辑也很难自动化， 所以自动化测试无法取代手动测试。</p>
<p>对于软件测试人员个人发展来说， 做自动化测试是个挑战，也是测试人员发展的一个方向，  需要测试人员学习大量的开发知识（开发的知识真是学无止境啊）。 从长远角度来看，自动化测试肯定是越来越吃香的。</p>
<p>而手动测试比较适合刚工作不久的人，手动测试最大的缺点就是技术含量低，单调乏味，容易废人。</p>
<p>总的来说，手工测试胜在测试业务逻辑，而自动化测试胜在测试底层架构。</p>
<p>如果被测试的程序可测试性比较好， 很有必要做成自动化测试。 能做自动化的尽量做成自动化， 下面这些情形是可以做自动化的</p>
<ol>
<li>测试存储过程。  例如用C#去测试存储过程</li>
<li>测试Web servies. 例如： 用SoupUI工具，或者C#,Java 去测试Web servies。</li>
<li>界面和业务逻辑分离的系统，比如，MVC，MVP架构， 或者WPF 程序。 可以用测试脚本去测试这些程序的API。</li>
</ol>
<h1 id="从测试的目的分类"><a href="#从测试的目的分类" class="headerlink" title="从测试的目的分类"></a><strong>从测试的目的分类</strong></h1><p>功能测试</p>
<p>测试的范围从小到大，从内到外， 从程序开发人员（单元测试）到测试人员，到一般用户Alpha&#x2F;Beta测试</p>
<table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Unit Test 单元测试</td>
<td>在最低的功能&#x2F;参数上验证程序的准确性,比如测试一个函数的正确性(开发人员做的)</td>
</tr>
<tr>
<td>Functional Test功能测试</td>
<td>验证模块的功能（测试人员做的）</td>
</tr>
<tr>
<td>Integration Test集成测试</td>
<td>验证几个互相有依赖关系的模块的功能（测试人员做的）</td>
</tr>
<tr>
<td>Scenario Test场景测试</td>
<td>验证几个模块是否能完成一个用户场景（测试人员做的）</td>
</tr>
<tr>
<td>System Test系统测试</td>
<td>对于整个系统功能的测试（测试人员做的）</td>
</tr>
<tr>
<td>Alpha测试</td>
<td>软件测试人员在真实用户环境中对软件进行全面的测试（测试人员做的）</td>
</tr>
<tr>
<td>Beta测试</td>
<td>真实的用户在真实的用户环境中进行的测试, 也叫公测   （最终用户做的）</td>
</tr>
</tbody></table>
<p> </p>
<p>非功能测试</p>
<p>一个软件除了基本功能之外，还有很多功能之外的特性，这些叫“Quality of Service requirement”服务质量需求。没有软件的功能，这些特性都无从表现出来，因此，我们要在软件开发的适当阶段-基本功能完成后做这些测试。</p>
<table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Stress test压力测试</td>
<td>验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃</td>
</tr>
<tr>
<td>Load test负载测试</td>
<td>测试软件在负载情况下能否正常工作</td>
</tr>
<tr>
<td>Performance test性能测试</td>
<td>测试软件的效能，是否提供满意的服务质量</td>
</tr>
<tr>
<td>Accessibility test</td>
<td>软件辅助功能测试-测试软件是否向残疾用户提供足够的辅助功能</td>
</tr>
<tr>
<td>Localization&#x2F;Globalization</td>
<td>本地化&#x2F;全球化测试</td>
</tr>
<tr>
<td>Compatibility Test</td>
<td>兼容性测试</td>
</tr>
<tr>
<td>Configuration Test</td>
<td>配置测试-测试软件在各种配置下能否正常工作</td>
</tr>
<tr>
<td>Usability Test</td>
<td>可用性测试–测试软件是否好用</td>
</tr>
<tr>
<td>Security Test</td>
<td>软件安全性测试</td>
</tr>
</tbody></table>
<p>性能测试</p>
<p>性能测试要求测试人员熟练性能测试工具，比如QTP, LoadRunner, Jmeter。  Visual Studio也提供了很多性能测试的工具. 要求测试人员对低层协议非常理解和编写脚本</p>
<p>性能测试非常有技术含量， 很有发展前途， 是软件测试人员的一个职业发展方向。</p>
<p>安全性测试</p>
<p>安全性测试的内容很广， 非常有难度啊。 我只接触过XSS（跨站脚本攻击）和SQL注入攻击。</p>
<p>安全性测试非常有技术含量， 我认为也是软件测试人员的一个职业发展方向</p>
<p>按测试的时机和作用分类</p>
<p>在开发软件的过程中，不少测试起着“烽火台”的作用，它们告诉我们软件开发的流程是否畅通。</p>
<table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Smoke Test</td>
<td>“冒烟”–如果测试不通过，则不能进行下一步工作</td>
</tr>
<tr>
<td>Build Verification Test（BVT）</td>
<td>验证构建是否通过基本测试。</td>
</tr>
<tr>
<td>Acceptance Test</td>
<td>验收测试，为了全面考核某功能&#x2F;特性而做的测试</td>
</tr>
</tbody></table>
<p>BVT测试是一种Smoke Test, 指Build生成好之后，自动运行的自动化测试脚本来检查这个Build的基本功能。 如果BVT测试失败了，需要开发人员马上修改，重新生成Build</p>
<p>按测试测策略分类。</p>
<table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Regression Test回归测试</td>
<td>对一个新的版本，重新运行以往的测试用例，看看新版本和已知的版本相比是否有退化(regression)</td>
</tr>
<tr>
<td>Ad hoc Test探索性测试</td>
<td>随机进行的，探索性的测试。</td>
</tr>
<tr>
<td>Sanity Test</td>
<td>粗略的测试，只需要执行部分的测试用例</td>
</tr>
</tbody></table>
<p>Regression Test 回归测试：　　</p>
<p>对软件测试人员来说就是重复测试，所以回归测试最好是自动化的，　否则测试人员就要一遍又一遍地重复测试，　</p>
<ol>
<li>开发人员做些小改动，就需要测试人员做回归测试。确保现有的功能没有被破坏</li>
<li>Bug Fix 也需要回归测试，确保新的代码修复了Fix, 也确保现有的功能没有被破坏</li>
<li>项目后期，需要做一个完整回归测试， 确保所有的功能都是好的</li>
</ol>
<p>Ad hoc Test 探索性测试：</p>
<p>平常我最喜欢做随机测试了， 抛开test case.  自己按照自己的思路，随便点点。 如果测试GUI，Ad hoc能发现大量的bug.</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>基础</category>
        <category>测试种类划分</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>测试用例设计</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<ul>
<li><p><a href="../03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">黑盒测试</a></p>
</li>
<li><p>测试用例是什么样的<br><img src="/assets/image-20211203142629-2n42d14.png" alt="测试用例是什么样的"></p>
</li>
<li><p>目的</p>
<ul>
<li>绕不过的面试题</li>
<li>测试人员必备技能</li>
</ul>
</li>
<li><p>测试用例</p>
<ul>
<li>测试用例是为了发现软件存在的问题编写的一组包含测试输入、执行条件以及预期结果的文档，用来核实软件产品是否满需求</li>
<li><img src="/assets/image-20211120151028-c13v85v.png" alt="image.png"></li>
</ul>
</li>
<li><p>测试用例的目的</p>
<ul>
<li>理清思路，避免漏测和重测</li>
<li>提高测试效率</li>
<li>跟进测试进度</li>
<li>告诉领导做过什么</li>
<li>跟进重复性工作</li>
<li>更好的记录问题，发现问题，复现问题</li>
</ul>
</li>
<li><p>测试用例的组成</p>
<ul>
<li>用例编号<br>模块<br>测试标题<br>前置条件<br>操作步骤<br>预期结果<br>实际结果</li>
</ul>
</li>
<li><p>测试用例编写工具</p>
<ul>
<li>ximnd：思维导图工具<br>插入子主题：tab<br>插入兄弟主题（后面）：enter<br>插入兄弟主题（前面）：shift+enter</li>
<li>Excel</li>
</ul>
</li>
<li><p>测试用例编写方法</p>
<ul>
<li>划分功能模块<br>正向功能验证：正确的操作功能是否实现<br>单个功能项验证：正向+异常<br>功能之间交互验证：模块之间的数据传递<br>隐形需求：熟悉业务</li>
</ul>
</li>
<li><p>输入项设计要点</p>
<ul>
<li>数据长度验证<br>数据类型验证<br>是否必填项验证<br>限制约束验证</li>
</ul>
</li>
<li><p><a href="../06_%E7%99%BB%E5%BD%95/">实战：登录</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>课中</category>
        <category>测试用例设计</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>黑盒测试</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li>定义：</li>
<li>目的</li>
<li>优点</li>
<li>测试用例</li>
</ul>
<h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><ul>
<li><p>定义</p>
<ul>
<li>黑盒测试是从一种从软件外部对软件实施的测试，也成功能测试</li>
<li>不考虑内部结构，只考虑输入与输出的测试</li>
<li><img src="/assets/image-20211120150914-c5nxlpa.png" alt="image.png"></li>
</ul>
</li>
<li><p>目的</p>
<ul>
<li>黑盒测试是从用户观点出发的测试，其目的是尽可能发现软件的外部行为错误。在已知软件产品功能的基础上：<br>检测软件功能能否按照需求文档的规定正常工作，是否有功能遗漏；<br>检测是否有人机交互错误，是否有数据结构和外部数据库访问错误，是否能恰当地接收数据并保持外部信息等的完整性<br>检测行为、性能等特性是否满足要求等；<br>检测程序初始化和终止方面的错误等；</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>黑盒测试与软件具体实现无关，所以如果软件实现发生了变化，测试用例仍然可以使用；</li>
<li>设计黑盒测试用例可以和软件实现同时进行，因此可以压缩项目总的开发时间</li>
</ul>
</li>
<li><p>测试用例</p>
<ul>
<li><p>测试用例概念</p>
<ul>
<li>测试用例（testcase）是指对一项特定的软件进行测试任务的描述、体现测试方案、方法、技术和策略</li>
<li>简单地认为，测试用例是为了发现软件存在的问题编写的一组包含测试输入、执行条件以及预期结果的文档，用来核实软件产品是否满需求</li>
<li><img src="/assets/image-20211120151028-c13v85v.png" alt="image.png"></li>
</ul>
</li>
<li><p>测试用例的作用</p>
<ul>
<li><p>指导测试的实施</p>
</li>
<li><p>规划测试数据的准备</p>
</li>
<li><p>编写测试脚本的“设计规格说明书”</p>
</li>
<li><p>评估测试结果的度量基准</p>
</li>
<li><p>分析缺陷的标准</p>
<ul>
<li>bug</li>
</ul>
</li>
</ul>
</li>
<li><p>使用测试用例的好处</p>
<ul>
<li>避免盲目测试并提高测试效率</li>
<li>令软件测试的实施重点突出、目的明确</li>
<li>软件版本更新后只需修正少部分的测试用例便可展开测试工作</li>
<li>测试用例的通用化和复用化则会使软件测试易于开展</li>
</ul>
</li>
<li><p>测试用例的内容</p>
<ul>
<li>版本号<br>项目名称<br>模块名称<br>用例编号<br>用例名称<br>用例级别<br>前置条件<br>测试步骤<br>期望结果<br>测试结果<br>测试时间<br>测试人员</li>
</ul>
</li>
<li><p>((20211203110629-z3n01go “测试用例简介”))</p>
</li>
<li><p>输入内容的分类：字母+数字+特殊字符+汉字   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;   字符</p>
</li>
<li><p>常见黑盒测试用例设计方法</p>
<ul>
<li><p>等价类</p>
<ul>
<li><p>定义：等价类是指输入域的某个互不相交的子集集合，所有等价类的并集便是整个输入域</p>
</li>
<li><p>分类</p>
<ul>
<li>有效等价类      符合需求说明，合理地输入数据集合</li>
<li>无效等价类      不符合需求说明，无意义的输入数据的集合</li>
<li><img src="/assets/image-20211120151741-y3xtcn5.png" alt="image.png"></li>
</ul>
</li>
<li><p>等价类划分方法</p>
<ul>
<li><p>输入条件规定了取值范围或值的个数：确定一个有效等价类和两个无效等价类</p>
</li>
<li><p>输入条件规定了输入值的集合：确定一个有效等价类和一个无效等价类</p>
<ul>
<li><p>只允许输入汉字</p>
<ul>
<li>有效等价类：汉字</li>
<li>无效等价类：字母、数字、特殊字符</li>
</ul>
</li>
</ul>
</li>
<li><p>输入条件是一个布尔值：可以确定一个有效等价类和一个无效等价类   True&#x2F;FALSE（真&#x2F;假）</p>
</li>
<li><p>输入条件规定必须遵循某种规则：确定一个有效等价类和若干个无效等价类</p>
</li>
<li><p>在规定了输入数据的一组值（假定N个），并且程序要对每个输入值分别处理：可以确立N个有效等价类和一个无效等价类——-先不理解</p>
</li>
</ul>
</li>
<li><p>等价类划分用例设计步骤</p>
<ul>
<li>为每一个等价类规定一个唯一的编号</li>
<li>设计一个心得测试用例，尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步，直到测试用例覆盖了所有的有效等价类</li>
<li>设计一个新的测试用例，使其覆盖并只覆盖一个没有被覆盖的无效等价类。重复这一步，直至测试用例覆盖了所有的无效等价类</li>
</ul>
</li>
<li><p>练习</p>
<ul>
<li>问题：两位整数加法计数器<br>第一个数和第二个数都只能输入-99到99之间的整数<br>对于输入小于-99得数据或者大于99的数据，系统应该给出明确提示<br>对于输入小数、字符等非法数据，系统应该给出明确提示</li>
<li><img src="/assets/image-20211120151946-pg5vfr8.png" alt="image.png"></li>
<li><img src="/assets/image-20211120151957-ot0ftmq.png" alt="image.png"></li>
<li><img src="/assets/image-20211120152002-7y5g4a5.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>边界值</p>
<ul>
<li><p>定义：大量的软件测试时间证明，故障往往出现在定义域或值域的边界上，而不是在其内部</p>
</li>
<li><p>边界：是一些特殊情况，程序在处理大量中间数值时都是正确，但是在边界处可能出现错误，边界条件就是软件计划的操作界限所在的边缘条件</p>
</li>
<li><p>边界值选取方法</p>
<ul>
<li>选取正好等于、刚刚大于或者刚刚小于等价类边界值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据</li>
<li><img src="/assets/image-20211120152045-xkqwjfz.png" alt="image.png"></li>
</ul>
</li>
<li><p>边界值分析测试</p>
<ul>
<li>最小值（min）</li>
<li>稍大于最小值（min+）</li>
<li>域内任意值（nom）</li>
<li>稍小于最大值（max-）</li>
<li>最大值（max）</li>
</ul>
</li>
<li><p>健壮性边界值测试</p>
<ul>
<li>健壮性测试是边界值分析的一种扩展</li>
<li>变量除了取min、min+、nom、max-、max五个边界值外，还要考虑采用一个略超过最大值（max+）以及一个略小于最小值（min-）的取值，看看超过极限值时系统会出现什么情况</li>
</ul>
</li>
<li><p>边界值分析原则</p>
<ul>
<li>如果输入条件对取值范围进行了限定，则应以边界内部以及刚刚超出范围边界外的值作为测试用例</li>
<li>对于输入条件，同样可以应用上面提到的两条原则来进行测试用例设计</li>
<li>如果程序规格说明书中指明输入或者输出域是一个有序的集合，如顺序文件、表格等，则应注意选取有序集合中的第一个和最后一个元素作为测试用例</li>
</ul>
</li>
</ul>
</li>
<li><p>错误推断法</p>
<ul>
<li>定义： 指利用直觉和经验猜测出出错的可能类型，有针对性的列举出程序中所有可能的错误和容易发生错误的情况</li>
<li>列举出可能犯的错误或错误容易发生的清单，然后根据清单编写测试用例</li>
</ul>
</li>
<li><p>场景分析法</p>
</li>
<li><p>因果图</p>
</li>
<li><p>判定表</p>
</li>
<li><p>正交法</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课中</category>
        <category>基础</category>
        <category>黑盒测试</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>登录</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><p>需求</p>
<ul>
<li><img src="/assets/image-20211120214210-0675h05.png" alt="image.png"></li>
<li><img src="/assets/image-20211120214217-er5hgua.png" alt="image.png"></li>
</ul>
</li>
<li><p>xmind编写</p>
<ul>
<li><p>关闭按钮</p>
</li>
<li><p>账号密码登录</p>
<ul>
<li><p>正向功能验证</p>
<ul>
<li>正确的手机号+正确的密码+点击登录      登陆成功</li>
<li>正确的邮箱+正确的密码+点击登录        登陆成功</li>
</ul>
</li>
<li><p>头像</p>
<ul>
<li><p>展示</p>
<ul>
<li>账号空白时    展示默认头像</li>
<li>输入修改头像的已注册账号时     展示自定义头像</li>
<li>输入未注册账号时  展示默认头像</li>
<li>输入未修改头像已注册账号时  展示默认头像</li>
</ul>
</li>
</ul>
</li>
<li><p>账号</p>
<ul>
<li><p>手机号</p>
<ul>
<li>账号输入10位数字，输入符合要求的密码，点击登录 提示：手机号错误</li>
<li>账号输入12位数字，输入符合要求的密码，点击登录    提示：手机号错误</li>
<li>账号输入11位包含非数字，输入符合要求的密码，点击登录   提示：用户名或者密码错误</li>
<li>输入未注册的手机号+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li>
<li>输入空值+输入符合要求的密码+点击登录 提示：账号不能为空</li>
</ul>
</li>
<li><p>邮箱</p>
<ul>
<li>输入错误的邮箱格式+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li>
<li>输入没有注册的邮箱+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li>
</ul>
</li>
</ul>
</li>
<li><p>密码</p>
<ul>
<li>输入正确的账号+输入5位密码+点击登录   登录按钮置灰不可点击</li>
<li>输入正确的账号+输入7位密码+点击登录   提示：用户名或者密码错误</li>
</ul>
</li>
<li><p>忘记密码？</p>
</li>
<li><p>登录</p>
<ul>
<li>弱网    展示正在加载图标</li>
<li>断网      断网提示</li>
<li>频点登录    提示：频繁登录</li>
</ul>
</li>
<li><p>验证码快捷登录</p>
</li>
<li><p>海外手机号登录</p>
</li>
</ul>
</li>
<li><p>验证码快捷登录</p>
</li>
<li><p>第三方登录</p>
</li>
<li><p>海外手机号登录</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课中</category>
        <category>登录</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试执行</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/07_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>课中</category>
        <category>软件测试执行</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试报告</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/08_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>课中</category>
        <category>软件测试报告</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>测试概念总结</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li><h3 id="你上家公司的测试流程是怎么样的？"><a href="#你上家公司的测试流程是怎么样的？" class="headerlink" title="你上家公司的测试流程是怎么样的？"></a>你上家公司的测试流程是怎么样的？</h3><ol>
<li><p>需求下来之后，我们会首先熟悉下，然后公司会做一个’需求交接’,这个过程中一般会开一个简单的’需求澄清会’,在会议上把自己对需求不清楚，不理解，或者有异议的地方都提出来，由产品给我们解答。澄清会结束然后就写测试计划，测试计划前期一般都是有我们主管写的，后期基本上是由我们各个测试人员轮流细的，测试计划主要就是安排进度以及任务的分配之后各自领取自己负责的模块，做需求分析，挖掘，同时写测试点，测试点写完后,就编写测试用例。’测试点，我们用的 xmind的写的，用例当时用的Excel 表格管理的’，等测试用例编写完，一般会有评审，对于评审，有时候就是简单组内评审下，如果大的功能可能会组织会议评审，如果是会议评审，相关的开发，跟产品基本都会到场，其实主要就是看下用例的覆盖率这块，例外就是看检查点有没有检查到位。评审了之后，然后会等项目版本出来，开发那边一般会先做单元测试(UT)，之后就开始提测，我们首先会搭建测试环境，做项目部署，之后做冒烟测试，然后去执行用例做系统测试，测试过程中发现 bug就指派给对应的开发，待开发修复完成之后，我们测试需要做复测，复测没有问题就关闭Bug,如果还是有问题，重新开启 Bug，直到改好了复测完没问题才可以关闭这个bug。<del>一般系统功能测试我们需要测试2-3轮</del>，保证所有Bug基本都修复完成，之后写测试报告，然后看是否达到上线标准，达到了上线标准的话，由 SE组织时间进行产品上线，上线之后我么会做一个做总结。</p>
</li>
<li><h3 id="产品如何上线？（标准，过程）"><a href="#产品如何上线？（标准，过程）" class="headerlink" title="产品如何上线？（标准，过程）"></a>产品如何上线？（标准，过程）</h3><ol>
<li><h4 id="上线标准"><a href="#上线标准" class="headerlink" title="上线标准"></a>上线标准</h4><ol>
<li>用例执行率 100%</li>
<li>1,2 级Bug 修复率100%</li>
<li>3,4 级Bug 修复率95%</li>
</ol>
</li>
<li><h4 id="上线时间"><a href="#上线时间" class="headerlink" title="上线时间"></a>上线时间</h4><ol>
<li><p>周二，周四晚上 一般都在 10 点之后 （用户少，影响不大） 产品，运维，开发，测试都要到场</p>
<p> SE 组织安排上时间，上线注意事项，人员等</p>
</li>
</ol>
</li>
<li><h4 id="上线的过程"><a href="#上线的过程" class="headerlink" title="上线的过程"></a>上线的过程</h4><ol>
<li>第一步：运维从 svn<br> 下载交付版本（测试好的版本）,部署到（线上&#x2F;生产环境）服务器上</li>
<li>第二步：部署完了，测试这个时候才扑上去执行测试，各自执行各自的用例（新需求，各自负责各自的模块都需要点一遍），这个时候发现问题，立马要修复，重新上线，（会不会执行用例？）还是会执行用例， 但是，主要执行主要用例，级别高的用例的。把每个功能模块的流程走一遍，保证没有问题</li>
<li>第三步：有问题？严重的，致命的，会影响客户使用的问题，一般要求当场修复，如果修复不了，第二天修复，直到修复为止，然后复测，再上线。一般的，普通，提示的问题，对于客户影响不大的，一般产品会决定，可以先上线，推迟到下一个版本在修复。能当场修复，修复完成重新上线</li>
<li>第四步：一般我们上线一周，会做一个简单的总结</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><ol>
<li>首先对需求进行评审，评审通过后，测试人员根据需求编写测试用例，再对用例进行评审，评审通过后，对测试版本进行测试，测试过程中发现bug提交给对应的开发人员进行修改，待开发修改完成后，我们进行返测，返测通过直接关闭，返测不通过打回让开发重新修改，直至项目中所有的bug关闭，编写写实报告，进行版本发布，编写测试总结</li>
</ol>
</li>
<li><h3 id="用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？"><a href="#用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？" class="headerlink" title="用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？"></a>用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？</h3><ol>
<li><p>用例包含哪些部分，你认为哪些比较重要？</p>
<ol>
<li>用例编号，模块，用例标题，重要级别，前置条件，输入数据，操作步骤，预期结果</li>
<li>级别一定定得合理</li>
<li>标题一定要简明扼要的阐述清楚</li>
<li>预期结果一定要检查到位（不仅要考虑前端显示问题，还有相关模块的影响，以及后台数据库的考虑）</li>
<li>操作步骤要尽量详细（以便用例执行者能正常执行）</li>
<li>测试数据要正确合理，前置条件要准确。</li>
</ol>
</li>
<li><p>用例设计方法有哪些</p>
<ol>
<li>用例方法主要有：等价类  边界值  判定表  流程分析法 正交表 因果图 状态迁移 错误推断法，异常分析法。其实我一般用得比较多一点就是等价类  边界值  判定表  流程分析法这几个，有时候会用下错误推断法等来补充用例。</li>
</ol>
</li>
<li><p><img src="/assets/image-20211203153323-8cht73v.png" alt="image.png"></p>
</li>
</ol>
</li>
<li><h3 id="等价类与边界值怎么理解？"><a href="#等价类与边界值怎么理解？" class="headerlink" title="等价类与边界值怎么理解？"></a>等价类与边界值怎么理解？</h3><ol>
<li><p>等价类分为，有效等价类，无效等价类，有效等价类其实就从正向去考虑，正常的场景，无效等价类，就是站异常的场景角度去考虑用例。一般主要用在对文本编辑框的用例设计，比如：注册用户名，用户名规定在 3-15个字符之间，那么我们在设计用例的时候就要考虑有效等价类：3-15中随机取一个值，无效等价来就是：小于3,大于15。</p>
<p> 边界值其实是对等价类的一种补充，它其实不能当成主要的用例方法，但是一定要考虑，因为很多问题都发生在边上。边界值一般有上点，离点，内点，比如刚才说的用户名，边界值就要考虑 3,15,2,16这几个点。</p>
</li>
<li><p><strong>注释：如果自己的项目中没有登录或者注册的用户名输入框，可以选择其他输入框，如商品名称、订单编号等</strong></p>
</li>
</ol>
</li>
<li><h3 id="怎么保证用例的质量，保证覆盖度达到100"><a href="#怎么保证用例的质量，保证覆盖度达到100" class="headerlink" title="怎么保证用例的质量，保证覆盖度达到100%"></a><strong>怎么保证用例的质量，保证覆盖度达到</strong>100%</h3><ol>
<li><p>仔细分析需求，仔细阅读需求文档，有可能 se需求文档里面的一个图片，需求文档里面的一个提示都是需求点，前期多和 SE沟通，把需求吃透特别隐含的需求，和这个需求关联模块啊，一般出问题都是些隐含需求和相关模块没有分析出来,另外最好能站在用户的角度多考虑一些其他场景。保证用例的覆盖度。</p>
</li>
<li><p>分析完成，我会核对我罗列的需求点是否覆盖需求文档的需求点，这个一条一条过，这样基本问题不大了，不会有需求遗漏，再组内评审下，更能保证质量</p>
</li>
<li><p>必须要熟悉业务，比如说，查询订单，订单接口输入参数数据都来源于订单表，如果不熟悉来源哪些表，订单有哪些状态，这些，你就不好分析执行，多考虑业务流程上的测试点，以及相关模块的测试点</p>
</li>
<li><p>用例这块，检查结果要覆盖每一个检查点，像数据库检查，相关模块检查都要覆盖到位，用例必须需要经过评审</p>
</li>
<li><p>后期不停的完善，添加，补充用例，以保证用例的覆盖度。</p>
</li>
</ol>
</li>
<li><h3 id="你们用例是怎么评审的，评审过程中主要关注什么问题？"><a href="#你们用例是怎么评审的，评审过程中主要关注什么问题？" class="headerlink" title="你们用例是怎么评审的，评审过程中主要关注什么问题？"></a>你们用例是怎么评审的，评审过程中主要关注什么问题？</h3><ol>
<li>主要还是看项目大小和复杂程度，我们公司一般都是会议评审，一般提前预定会议室，把产品、开发同事都叫上，一起会议室评审用例，假如有时候只有简单业务，就简单的组内评审就可以了。</li>
<li>主要是关注用例覆盖是不是完整，有已没有漏测的用例，另外就是预期结果是否合理，检查到不到位。</li>
</ol>
</li>
<li><h2 id="用例评审的目的"><a href="#用例评审的目的" class="headerlink" title="用例评审的目的"></a>用例评审的目的</h2><ol>
<li>评审有歧义，有冲突，有问题，目的是查漏补缺</li>
</ol>
</li>
<li><h3 id="你的测试用例是怎样管理的？"><a href="#你的测试用例是怎样管理的？" class="headerlink" title="你的测试用例是怎样管理的？"></a>你的测试用例是怎样管理的？</h3><ol>
<li>我们公司的用例都是用的禅道 来管理的，一般会把用例情况，包括通过率、执行率、阻塞率、未执行数量、已执行数量都做好记录，方便后续查看，也方便修改。</li>
<li>另外也要注意用例的及时更新，不需要的用例可以备注隐藏，以免后续要再次使用的时候可以不必重复编写用例。</li>
</ol>
</li>
<li><h3 id="如何保证软件质量"><a href="#如何保证软件质量" class="headerlink" title="如何保证软件质量"></a>如何保证软件质量</h3><ol>
<li>需求要吃透，多问，多去了解</li>
<li>严格按照测试流程去执行： 引入合适的测试用例设计方法、进行用例评审机制。</li>
<li>要有良好的测试执行：要求用例执行率达到 100%，多次的测试轮次、引入测试工具，让测试可以做得更深入（通过查看日志，查数据库）</li>
<li>有良好的缺陷写作和过 Bug 机制、引入合适的缺陷管理工具和缺陷管理流程，有良好的测试流程， 引入更合适的测试流程和测试方法，采用更多的非功能测试，不能把非功能忽略测试。</li>
<li>多进行评审，完善大家的测试思维点。</li>
<li>进行交叉测试，可以多个人，不同测试考虑点。</li>
</ol>
</li>
<li><h3 id="提（bug）单工具"><a href="#提（bug）单工具" class="headerlink" title="提（bug）单工具"></a>提（bug）单工具</h3><ol>
<li>禅道，jira，qc，bugfree，bugzilla</li>
<li>((20211203111708-liwjzmp “禅道介绍”))      ((20211203112034-mzpktpu ‘禅道介绍-提交bug’))</li>
<li>注释： <a href="http://192.168.1.2/object/zentaopms/www/index.php">禅道链接</a></li>
</ol>
</li>
<li><h3 id="bug流程"><a href="#bug流程" class="headerlink" title="bug流程"></a>bug流程</h3><ol>
<li>版本一：发现bug以后，先截图，详细记录重现步骤，通过bug工具提交给对应的开发人员，等待开发解决以后我们进行返测，通过就关闭，不通过打回去重现修改，直到项目中所得bug关闭</li>
<li>版本二：原来 bug 是用 禅道来管理的，原来我们公司 bug，提交 bug 直接给对应的开发人员，对应开发人员修复完成，交给测试复测，复测通过关闭 bug，不通过打回给对应开发重新修改</li>
</ol>
</li>
<li><h3 id="提交bug包含哪些内容"><a href="#提交bug包含哪些内容" class="headerlink" title="提交bug包含哪些内容"></a>提交<strong>bug</strong>包含哪些内容</h3><ol>
<li>所属产品，所属模块，所属项目，影响版本，指派人员,截止日期，严重程度，优先级，bug 类型，bug 环境，Bug 标题，重现步骤，附件</li>
</ol>
</li>
<li><h3 id="bug的状态"><a href="#bug的状态" class="headerlink" title="bug的状态"></a>bug的状态</h3><ol>
<li>提交-开发人员：已激活未确认-开发进行确认，状态变成已激活，已确认，开发修复完成-标注状态是已修复，测试人员复测通过，已关闭，打回给对应开发，已经激活</li>
</ol>
</li>
<li><h3 id="bug的级别"><a href="#bug的级别" class="headerlink" title="bug的级别"></a>bug的级别</h3><ol>
<li><p>致命、严重、一般、建议      1   2    3   4</p>
</li>
<li><p>定义</p>
<ol>
<li>致命：对业务有至关重要的影响，业务系统完全散失业务功能，工作无法再继续进行，或业务系统丢失了业务数据且无法恢复，影响公司运营的重要业务数据出错</li>
<li>严重：对业务有严重的影响，业务系统已经丧失可部分的重要的业务功能，或业务系统丢失了业务数据且可以恢复，一般业务数据出错。</li>
<li>一般：对业务有较小的影响，业务系统丧失了较少的业务，功能。例如：界面错误，打印或显示格式错误。</li>
<li>建议：对业务没有影响，不影响业务过程正常进行，例如：辅助说明描述不清楚，提示不明确的错误提示</li>
</ol>
</li>
<li><h4 id="致命Bug跟严重-Bug的区别？"><a href="#致命Bug跟严重-Bug的区别？" class="headerlink" title="致命Bug跟严重 Bug的区别？"></a>致命<strong>Bug</strong>跟严重 <strong>Bug</strong>的区别？</h4><ol>
<li>致命 Bug:导致系统崩溃，数据丢失，卡死，闪退，数据库死锁，一般这种类型的，我们都会标注为致命 Bug</li>
<li>严重 Bug:功能没有实现，主流程走不通，功能有严重问题不能正常使用，这种，我们一般会标注为严重 Bug</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="bug的优先级"><a href="#bug的优先级" class="headerlink" title="bug的优先级"></a>bug的优先级</h3><ol>
<li>优先，高、中、低         &#x2F;      禅道中对应为 1、2、3、4</li>
<li>优先级别高的不一定优先处理，但是bug级别高的一定优先处理的</li>
</ol>
</li>
<li><h3 id="提-Bug需要注意哪些问题？"><a href="#提-Bug需要注意哪些问题？" class="headerlink" title="提 Bug需要注意哪些问题？"></a>提 <strong>Bug</strong>需要注意哪些问题？</h3><ol>
<li><p>不要急着提交，先做一下复现，进行证实，如果需要的话，也可以使用不用的版本测试对比一下</p>
</li>
<li><p>简单明了的概括 bug 标题，清晰的描述 bug 重现步骤，分析bug 和预期正确结果，附加 bug 的截图或者日志。描述 bug 的时候。</p>
</li>
<li><p>在不能确认该情况是否为bug 的时候，可以请教其他人。</p>
</li>
<li><p>提交完bug 以后，后面还要跟进bug。</p>
</li>
<li><p>bug单内容注意的地方:</p>
<ol>
<li>Bug标题要简明扼要的表述清楚</li>
<li>Bug的级别（严重级别，优先级别）</li>
<li>内容:操作步骤（一定要描述清楚，以便开发可以复现）,预期结果，实际结果</li>
<li>最好，把截图，日志相关的信息一并的提交（方便开发定位）</li>
<li>测试环境（如：浏览器google,华为手机上）</li>
<li>属于哪个产品，模块的</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="测试过程中bug比较多的原因"><a href="#测试过程中bug比较多的原因" class="headerlink" title="测试过程中bug比较多的原因"></a>测试过程中bug比较多的原因</h3><ol>
<li>开发的经验不足</li>
<li>需求的不明确</li>
<li>程序本身的错误</li>
<li>人与人之间交流不够</li>
<li>需求的不断变化</li>
<li>工期紧、任务重、时间压力大</li>
<li>参与人员的过度自信</li>
</ol>
</li>
<li><h3 id="如果系统快上线了，临时发现了一个bug怎么处理？"><a href="#如果系统快上线了，临时发现了一个bug怎么处理？" class="headerlink" title="如果系统快上线了，临时发现了一个bug怎么处理？"></a>如果系统快上线了，临时发现了一个bug怎么处理？</h3><ol>
<li>首先看bug级别，如果不严重，影响不到项目功能的，先于组长沟通，等上线了再优化</li>
<li>如果是一个严重的bug 赶紧找自己的领导，让领导去找项目经理看项目经理的决定</li>
</ol>
</li>
<li><h3 id="在工作中遇到棘手的问题是怎么解决的？"><a href="#在工作中遇到棘手的问题是怎么解决的？" class="headerlink" title="在工作中遇到棘手的问题是怎么解决的？"></a>在工作中遇到棘手的问题是怎么解决的？</h3><ol>
<li>需求不完整：找产品进行确认需求，让他完善需求</li>
<li>bug不能被开发承认：先从需求中找证据，证明是一个bug，如果开发还是不承认，这时候再找产品确认（拉上产品与开发对接），还是不承认，反馈给测试组长</li>
</ol>
</li>
<li><h3 id="你提交的-Bug开发不认可的话，如何解决？提皮球，扯皮！"><a href="#你提交的-Bug开发不认可的话，如何解决？提皮球，扯皮！" class="headerlink" title="你提交的 Bug开发不认可的话，如何解决？提皮球，扯皮！"></a>你提交的 <strong>Bug</strong>开发不认可的话，如何解决？提皮球，扯皮！</h3><ol>
<li>首先我要了解开发不认可的原因，如果是需求理解不一致的问题，首先我会再看需求文档，是不是我的理解有误，如果是我对需求理解错的话我就去关闭 bug，如果还是觉得没有问题，那就找产品确认需求，然后再与开发沟通</li>
<li>如果是其他问题，一般会再去让身边的同看看听下他们的意见，然后自己先再三去复测，并且保存好截图和日志，确定这是一个 bug之后我就去跟开发说明白，并且给他看bug 重现的截图以及日志。如果开发还是不认可的话我就跟产品或项目经理说明白情况</li>
</ol>
</li>
<li><h3 id="和开发是怎么沟通的"><a href="#和开发是怎么沟通的" class="headerlink" title="和开发是怎么沟通的"></a>和开发是怎么沟通的</h3><ol>
<li>一般我在提 bug 的时候跟开发沟通最多，比如有一些不清晰的内容会去问开发，还有提完 bug 后会跟踪 bug 的进度，提醒开发尽快修复 bug，还有测接口的时候去找开发拿接口文档，其实我们的工作跟开发都是息息相关的所以都经常都会有沟通的</li>
</ol>
</li>
<li><h3 id="系统上线了发现了一个严重的bug怎么办？"><a href="#系统上线了发现了一个严重的bug怎么办？" class="headerlink" title="系统上线了发现了一个严重的bug怎么办？"></a>系统上线了发现了一个严重的bug怎么办？</h3><ol>
<li>回滚上个版本，再对这个版本进行测试，测试通过再发布</li>
</ol>
</li>
<li><h3 id="线上环境发现bug你们是怎么处理的"><a href="#线上环境发现bug你们是怎么处理的" class="headerlink" title="线上环境发现bug你们是怎么处理的"></a>线上环境发现<strong>bug</strong>你们是怎么处理的</h3><ol>
<li>第一步需要到测试环境里面重现一下，看下是环境配置不一致的问题，还是代码漏提交了，需要要到客户的操作场景和数据分析这个 bug的严重级别，影响范围，bug 比较严重，立马修复，修改后，测试回归验证通过，打补丁，bug影响不大，放到下一个版本修改</li>
</ol>
</li>
<li><h3 id="软件终止的标准"><a href="#软件终止的标准" class="headerlink" title="软件终止的标准"></a>软件终止的标准</h3><ol>
<li>公司倒闭</li>
<li>达到了规定的时间</li>
<li>开发过程中偏离了需求的定位</li>
<li>预算超出了规定的值</li>
<li>执行完了所有的测试用例</li>
</ol>
</li>
<li><h3 id="测试中有哪些风险（如何把控风险）"><a href="#测试中有哪些风险（如何把控风险）" class="headerlink" title="测试中有哪些风险（如何把控风险）"></a>测试中有哪些风险（如何把控风险）</h3><ol>
<li><p>测试人员需求理解上面有偏差</p>
</li>
<li><p>测试人员水平不够，测试人员覆盖点不全</p>
</li>
<li><p>测试人员时间不够，导致测试完不成</p>
</li>
<li><p>测试环境上面不足，导致测试点不能完全测试完成</p>
</li>
</ol>
</li>
<li><h3 id="测试计划主要包含哪些内容"><a href="#测试计划主要包含哪些内容" class="headerlink" title="测试计划主要包含哪些内容"></a>测试计划主要包含哪些内容</h3><ol>
<li><p>内容</p>
<ol>
<li>目的和范围</li>
<li>规程</li>
<li>测试方案和方法</li>
<li>测试的准入和准出</li>
<li>测试计划(流程、时间安排、对应人员)</li>
<li>测试的环境配置和人员安排</li>
<li>交付件</li>
</ol>
</li>
<li><p>例外一种回答：</p>
<ol>
<li>我们公司之前按照考核要求写过测试计划，不过后面老大觉得太耽误工作进度，后面一般都不再写测试计划，而是写版本计划。这个在版本计划， 每个人的任务列出来，负责人列出来，自己根据自己的情况分配时间，然后汇总，大家一起开个小会评审就可以了</li>
</ol>
</li>
<li><p>测试的范围，测试目标，人员分配，环境配置，里程碑，测试周期，测试策略，风险分析</p>
</li>
</ol>
</li>
<li><h3 id="测试计划制定"><a href="#测试计划制定" class="headerlink" title="测试计划制定"></a><a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/">测试计划制定</a></h3></li>
<li><h3 id="有没有写过测试报告，测试报告主要包含哪些内容"><a href="#有没有写过测试报告，测试报告主要包含哪些内容" class="headerlink" title="有没有写过测试报告，测试报告主要包含哪些内容?"></a>有没有写过测试报告，测试报告主要包含哪些内容?</h3><ol>
<li>没有写过测试报告的，一般就是把整个测试过程的数据统计出来，做成报告，包括用例执行的情况，测试了哪些模块，用了多少用例，自动化用例的通过率，自动化跑了多少模块， 执行的用例是否全部通过，发现了多少 bug，bug 的严重程度，是否遗漏 bug，测试结论是什么这些。注意用例的执行要全部做完， 报告数据简洁明了，结论要描述全面。</li>
</ol>
</li>
<li><h3 id="开发怎么转测"><a href="#开发怎么转测" class="headerlink" title="开发怎么转测"></a>开发怎么转测</h3><ol>
<li>我们这边的话，是按模块的优先级来的，优先级高的先提测，首先开发做单元测试，测试通过后会把测试报告给我们，同时将源码上传到 SVN，我们确认单元报告没问题，再从 SVN 检出来，进行一轮冒烟测试，冒烟测试通过，就开始全量测试。</li>
</ol>
</li>
<li><h3 id="如果时间比较紧的话，你怎么安排你的工作"><a href="#如果时间比较紧的话，你怎么安排你的工作" class="headerlink" title="如果时间比较紧的话，你怎么安排你的工作"></a>如果时间比较紧的话，你怎么安排你的工作</h3><ol>
<li>首先要评估下风险，比如说，可能我根本做不完，风险太大，那么这个我首先要把风险提出来，给对应的领导，那么我会要求有人协助我完成，需要多少人力来完成</li>
<li>如果只是说，正常时间完不成，那么我可以提下加班，看加班这个时间段能否完成，如果可以，我会和老大商量，提出加班计划</li>
<li>如果是其他的，比如说我只需要把优先级高的工作完成，其他工作可以安排到下一个版本去做，那么我就做个计划，把计划给老大说</li>
</ol>
</li>
<li><h3 id="测试如何在各个阶段保证软件质量"><a href="#测试如何在各个阶段保证软件质量" class="headerlink" title="测试如何在各个阶段保证软件质量"></a>测试如何在各个阶段保证软件质量</h3><ol>
<li><p>需求分析阶段：</p>
<ol>
<li><p>需求要吃透，多问，多去了解</p>
</li>
<li><p>我们要做测试需求分析，并应用相对应的方法论，还要进行需求串讲</p>
</li>
<li><p>测试需求分析的方法：分解功能点，然后对每一个功能点进行需求规则的分析。分析的方法有：</p>
<ol>
<li>输入划分</li>
<li>质量模型分析（功能、性能、安全、易用性、稳定性等各个维度）</li>
<li>功能交互分析</li>
<li>用户关联图分析</li>
</ol>
</li>
</ol>
</li>
<li><p>测试计划</p>
<p> 计划影响的是执行，计划需要根据实际情况来做，计划一旦制定就需要尽量的按照这个计划执行。</p>
</li>
<li><p>用例设计</p>
<ol>
<li>所有功能点和需求规则都要被覆盖，</li>
<li>应多考虑业务层面的测试用例，安全、性能等各种非功能层面也应该考虑。</li>
<li>多考虑测试场景与结果检查</li>
<li>应对测试用例进行评审</li>
</ol>
</li>
<li><p>测试准备：</p>
<ol>
<li>测试环境应该要尽可能的接近真实环境</li>
<li>测试环境应该能够包含各种测试场景</li>
<li>测试数据应该尽可能真实，也包含了各种能够覆盖场景的测试数据</li>
</ol>
</li>
<li><p>测试执行：</p>
<ol>
<li>用例要 100%的执行，不能够放过任何一个测试用例或测试场景</li>
<li>测试的轮次安排，应安排</li>
<li>轮测试。每一轮测试重点应该不一样。</li>
<li>引用缺陷管理工具，标准化缺陷管理流程，规范开发与测试对缺陷的管理</li>
<li>及时跟踪Bug</li>
</ol>
</li>
<li><p>测试管理相关：</p>
<ol>
<li>编写测试日报，定期向团队汇报测试进展以及问题及风险</li>
<li>为了让文档的管理变得更规范，应引入SVN进行配置管理</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="你怎样快速上手公司的项目"><a href="#你怎样快速上手公司的项目" class="headerlink" title="你怎样快速上手公司的项目"></a>你怎样快速上手公司的项目</h3><ol>
<li>熟悉数据流的走向</li>
<li>业务的逻辑</li>
<li>数据的验证</li>
</ol>
</li>
<li><h3 id="质量体系：cmmi模型，衡量公司级别"><a href="#质量体系：cmmi模型，衡量公司级别" class="headerlink" title="质量体系：cmmi模型，衡量公司级别"></a>质量体系：cmmi模型，衡量公司级别</h3><ol>
<li>初始级</li>
<li>可管理级</li>
<li>已定义级</li>
<li>量化管理级</li>
<li>优化管理级</li>
</ol>
<p> 一般公司都在3级，5级一般都是买的</p>
</li>
<li><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ol>
<li>公司中一次性开发的功能点比较多的时候，会分批次进行开发，这样的开发模式成为迭代</li>
<li>迭代的周期：1-2周&lt;小迭代&gt;   2-3月&lt;大迭代&gt;</li>
<li><h2 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h2><ol>
<li><h5 id="螺旋模型："><a href="#螺旋模型：" class="headerlink" title="螺旋模型："></a>螺旋模型：</h5><ol>
<li><img src="/assets/image-20211122114847-u3g4kke.png" alt="image.png"></li>
<li>1、需求开始，2、确认方案，3、支出风险并解决，4、评估方案，5、本阶段开发测试，6、计划下一阶段，7、进入下一阶段</li>
</ol>
</li>
<li><h5 id="V模型："><a href="#V模型：" class="headerlink" title="V模型："></a>V模型：</h5><ol>
<li><img src="/assets/image-20211203161103-lhdu2tl.png" alt="image.png"></li>
</ol>
</li>
<li><h5 id="瀑布模型以及其他：-迭代模型"><a href="#瀑布模型以及其他：-迭代模型" class="headerlink" title="瀑布模型以及其他： 迭代模型"></a>瀑布模型以及其他： <a href="../901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B/">迭代模型</a></h5></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="敏捷测试"><a href="#敏捷测试" class="headerlink" title="敏捷测试"></a>敏捷测试</h3><ol>
<li><p>快速迭代，产品通过短期的迭代互通不断迭代产品</p>
</li>
<li><p>快速尝试，避免长时间的需求调研和分析</p>
</li>
<li><p>快速改进，产品上线后根据用户反馈的问题，进行快速的改进</p>
</li>
<li><p>充分交流：每天早上有一个简短的战略会，沟通一下工作的进展和安排</p>
</li>
<li><p>简化流程：丢掉一些形式的东西，使用简单应用的工具开始工作</p>
</li>
</ol>
</li>
<li><h3 id="软件架构：b-x2F-s-c-x2F-s"><a href="#软件架构：b-x2F-s-c-x2F-s" class="headerlink" title="软件架构：b&#x2F;s    c&#x2F;s"></a>软件架构：b&#x2F;s    c&#x2F;s</h3><ol>
<li><h5 id="b-x2F-s架构"><a href="#b-x2F-s架构" class="headerlink" title="b&#x2F;s架构"></a>b&#x2F;s架构</h5><ol>
<li>b表示浏览器；s表示服务器、展示以www形式</li>
<li>在浏览器中打开，不占用客户的资源</li>
<li>升级为自动升级</li>
<li>可以跨平台</li>
</ol>
</li>
<li><h5 id="c-x2F-s架构"><a href="#c-x2F-s架构" class="headerlink" title="c&#x2F;s架构"></a>c&#x2F;s架构</h5><ol>
<li>c表示客户端；s表示服务器   以图标形式展示</li>
<li>在电脑桌面中打开，占用客户的资源</li>
<li>升级为手动升级</li>
<li>不可以跨平台，只能在windows系统使用</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="测试分为三轮："><a href="#测试分为三轮：" class="headerlink" title="测试分为三轮："></a>测试分为三轮：</h3><ol>
<li>第一轮：初级测试(冒烟测试)：针对开发出来的前端页面的主功能测试</li>
<li>第二轮：系统测试：细测，性能，安全，兼容性</li>
<li>第三轮：回归测试：对稳定性的测试；最后一个阶段bug相对比较少</li>
</ol>
</li>
<li><h3 id="是否了解SVN"><a href="#是否了解SVN" class="headerlink" title="是否了解SVN"></a>是否了解SVN</h3><ol>
<li><p>SVN管理项目中产生的所有文档：</p>
<ol>
<li>开发的代码，测试计划，测试用例，产品需求，bug单，测试报告，测试总结，（一个人一个账号，根据权限显示对应的内容）</li>
</ol>
</li>
<li><p>SVN的作用：数据的迁入迁出</p>
</li>
</ol>
</li>
<li><h3 id="抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler"><a href="#抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler" class="headerlink" title="抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler"></a>抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler</h3><ol>
<li>对于某些难以定位的一些问题，一般我利用 fiddler 的抓包工具，去抓取前后台的数据交互的过程， 通过分析请求的数据来判断是前端还是后台的问题</li>
<li>首先看发的请求是否有问题，请求的接口 url 是否有错误，参数是否有错误，如果 url 或传参有问题那就是前端 Bug</li>
<li>如果请求没有问题，看下后台返回的数据是否有问题，状态码 5 开头的基本都是后台问题，状态码为200，响应数据与预期不一致，那也是后台Bug。</li>
<li>返回的数据没有问题，请求参数，url 也没有问题，那可能是前端代码是否转换有问题，那就是前端 Bug。</li>
</ol>
</li>
<li><h3 id="你们上家公司的测试策略是怎么样的？"><a href="#你们上家公司的测试策略是怎么样的？" class="headerlink" title="你们上家公司的测试策略是怎么样的？"></a>你们上家公司的测试策略是怎么样的？</h3><ol>
<li>上一家公司的测试策略基本是这样的，系统已经做好的模块功能，要全测，先测优先级高的用例，上午发现的 bug，下午就要修改完成，回归通过，下午发现的bug，第二天上午就得回归通过,时间挺紧的， 而且第一轮测试还要把所有用例执行完，（如果有自动化，第一轮还要用自动化覆盖所有老用例，在测试环境上执行，而且自动化通过率至少要 90%以上）</li>
<li>第二轮测试呢，要把上轮测试未通过的，补充的用例重新测试，确认所有的缺陷都已经改正才行，然后就要把上一轮bug最多的功能再测一遍，自动化也要重新跑一遍，在测试环境上执行，通过率必须 100%， 就这么多了</li>
</ol>
</li>
<li><p>对于测试环境实际进行的测试内容为：</p>
<p> a.DEV环境：  Development environment   主体是开发厂商自己进行，包括了单元测试+接口集成测试+业务模块功能点的系统测试。</p>
<p> b.SIT环境：  SystemIntegrationTesting     可以是整体集成商牵头进行，包括接口集成测试+系统测试，但是全为黑盒测试。</p>
<p> c.UAT环境：  UserAcceptanceTesting      以甲方用户牵头进行，也是只进行系统测试，以端到端流程和业务场景驱动进行测试。</p>
<p> d.PRD&#x2F;PROD环境：线上环境，生产环境</p>
</li>
<li><h2 id="在工作中接触的文档"><a href="#在工作中接触的文档" class="headerlink" title="在工作中接触的文档"></a>在工作中接触的文档</h2><ol>
<li>需求文档   详设文档  测试用例   测试大纲  bug单   测试报告  测试总结  测试计划</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>测试概念总结</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代模型</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a><strong>软件的生命周期</strong></h2><p>软件生命周期是软件的产生直到报废或停止使用的生命周期</p>
<p>软件生命周期内有问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等阶段。</p>
<p>软件开发模型</p>
<p><img src="/assets/wpsA7E5.tmp-20211120152251-qp0stk4.jpg"></p>
<p>瀑布模型是最早的开发模型</p>
<p>优点：有利于大型软件开发过程当中人员的组织与管理，提高软件开发的质量与效率</p>
<p>缺点：模型是线性的，增加开发的风险，例如需求分析时，已经出现错误，一直没有测试阶段，直到测试阶段才能发现问题。问题修改起来成本增加。另外 用户需求变化太快，前期调研在完善也抵不住用户的需求变更，跟不上市场变化的速度</p>
<p>衍生出敏捷开发</p>
<p><img src="/assets/wpsA7E6.tmp-20211120152251-x8q273s.jpg"></p>
<p>看板</p>
<p><img src="/assets/wpsA7E7.tmp-20211120152251-wbf6fok.jpg"></p>
<p>测试模型</p>
<p><img src="/assets/wpsA7E8.tmp-20211120152251-uf1al0p.jpg"></p>
<p>需求分析：首先要做的事，开发 测试 要做什么，分析</p>
<p>概要设计：架构的实现，开发做的事，搭建产品的架构</p>
<p>详细设计：在概要设计的基础上在每个模块内部实现的逻辑和方法在这个阶段设计好，</p>
<p>编码：</p>
<p>单元测试：最小测试单元进行测试</p>
<p>集成测试；</p>
<p>系统测试</p>
<p>验收测试</p>
<p>（中小型企业使用）</p>
<p><img src="/assets/wpsA7E9.tmp-20211120152251-xxg84iu.jpg"></p>
<p>W模型，在需求设计阶段增加了测试活动，开发测试同步进行（大型企业使用，对人员要求比较高）</p>
<p><img src="/assets/wpsA7EA.tmp-20211120152251-6i27xmg.jpg"></p>
<p>产品迭代，适合小型迭代，测试流程完全独立出来，测试就绪点，测试准入准则</p>
<p>一般小型企业使用，项目人员要了解整体情况</p>
<p>系统测试流程</p>
<p><img src="/assets/wpsA7EB.tmp-20211120152251-49ld7zq.jpg"></p>
<p>Bug管理流程</p>
<p><img src="/assets/wpsA7EC.tmp-20211120152251-2ssrp2b.jpg"></p>
<p>软件测试流程的价值</p>
<p>提高测试效率</p>
<p>提高产品质量</p>
<p>加强项目成员之间的沟通</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>基础</category>
        <category>迭代模型</category>
      </categories>
      <tags>
        <tag>课中</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本命令</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/01_Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ol>
<li><p>常用的linux命令：</p>
<ol>
<li><p>ls 显示当前路径下的文件和文件夹（横向显示）</p>
</li>
<li><p>ll 显示当前路径下的文件和文件夹（纵向显示）</p>
</li>
<li><p>ls + 空格+ -a  显示当前路径下的所有隐藏文件</p>
<ol>
<li>-a  称为参数   a 为所有的意思</li>
</ol>
</li>
<li><p>mkdir + 文件夹名    新建文件夹</p>
</li>
<li><p>touch + 文件名   新建文件</p>
</li>
<li><p>clear  清除当前屏幕内容</p>
</li>
<li><p>rm  -rf     （-rf ：  r 递归    f  强制       - rf   强制性递归删除）</p>
</li>
<li><p>cp + 文件名 +路径    复制文件</p>
</li>
<li><p>mv+ 文件（文件夹）名  路径    移动文件&#x2F;文件夹</p>
</li>
<li><p>mv + 文件（文件夹）名  + 文件（文件夹）新名   修改文件名</p>
</li>
<li><p>pwd   查看当前文件夹路径</p>
</li>
<li><p>tar  -cvf    新建文件名（.tar） 要打压缩的文件</p>
</li>
<li><p>tar -xvf    解压的文件</p>
</li>
<li><p>tar  -zcvf    新建文件名（.tar.gz） 要打压缩的文件</p>
</li>
<li><p>tar -zxvf    解压的文件</p>
</li>
<li><p>zip     新建文件名（.zip） 要打压缩的文件</p>
</li>
<li><p>unzip 要解压的文件</p>
</li>
<li><p>vi  + 文件名    进入文件（且为命令状态）</p>
<ol>
<li><p>vi  进入文件命令模式</p>
</li>
<li><p>a    i    进入编辑模式</p>
</li>
<li><p>命令模式：</p>
<ol>
<li>x  小写x删除光标所在字符</li>
<li>X  大写X 删除光标所在字符位置前一个字符</li>
<li>s  小写s  删除光标所在位置并进入编辑状态</li>
<li>S  大写S 删除光标所在行并进入编辑状态</li>
<li>o  小写o 在当前光标所在行的下一行插入空的行，进入编辑状态</li>
<li>O  大写O  在当前光标所在行的上一行插入空的行，进入编辑状态</li>
<li>r  小写r 是替换当前光标所在字符</li>
<li>R 大写R 可以一直替换操作</li>
<li>backspace   键  可以进行返回替换操作， u 是退回上一步操作</li>
<li>dd  删除一行（不要删除直接按u就返回了）</li>
<li>set+nu 设置行号</li>
<li>shift：&#x2F;  esc    进入命令状态</li>
<li>wq！  强制保存退出   w 保存   q 退出   ！ 强制</li>
</ol>
</li>
</ol>
</li>
<li><p>cat  查看小的文件</p>
</li>
<li><p>find   -name   +文件&#x2F;文件夹名    查找文件&#x2F;文件夹</p>
</li>
<li><p>| grep  要过滤的字符</p>
</li>
<li><p>more 查看大的文件</p>
</li>
<li><p>less  查看文件</p>
</li>
<li><p>chmod  修改权限</p>
<ol>
<li><p>u 表示该用户拥有者</p>
</li>
<li><p>g  所属组</p>
</li>
<li><p>o 其他</p>
</li>
<li><p>a 表示以上三个都有</p>
</li>
<li><p>“-” 没有权限</p>
</li>
<li><p>r 表示可读</p>
</li>
<li><p>x表示可执行</p>
</li>
<li><p>w 表示可写</p>
<ol>
<li>chmod a +rwx  文件名   直接添加所有</li>
<li>chmod o - w    文件名   减权限</li>
<li>chmod a - rwx 文件名  直接减所有</li>
</ol>
</li>
<li><p>r 可读  4     w 可写  2     x可执行  1      -  没有权限  0</p>
<ol>
<li>chmod  42-    加权限</li>
</ol>
</li>
</ol>
</li>
<li><p>tail  查看动态日志</p>
<ol>
<li>tail  - 20 文件名   显示从末尾到20行</li>
</ol>
</li>
<li><p>head  查看静态日志</p>
<ol>
<li>head  -n 文件名</li>
</ol>
</li>
<li><p>ps 查看进程</p>
<ol>
<li>ps  查看所有用户的进程</li>
<li>ps -ef 查看所有用户的进程</li>
<li>ps   - aux 查看详细进程</li>
<li>ps - ef | grep       过虑</li>
</ol>
</li>
<li><p>kill -9  id  （进程的id）   不能用，真的删除了</p>
</li>
<li><p>netstat   - an   查看端口号</p>
</li>
<li><p>df  查看分区</p>
<ol>
<li>df  - h  以G的形式查看</li>
</ol>
</li>
<li><p>top 查看动态资源占有率</p>
</li>
<li><p>vmstat  查看静态资源占有率</p>
</li>
<li><p>su  切换用户</p>
</li>
<li><p>du  查看文件夹大小</p>
</li>
<li><p>du   - h    以G的形式显示</p>
</li>
<li><p>find   -name  查找文件</p>
</li>
<li><p>free  查看运行内存和交互内存</p>
</li>
<li><p>rz  从windows 上传文件到linux</p>
</li>
<li><p>sz  从linux下载文件到windows</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>linux基本命令</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础知识</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/01_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>查询语句的执行过程</p>
<p><img src="/assets/image-20211214111304-o4w9uqm.png" alt="image.png"></p>
<p>专业术语</p>
<p><img src="/assets/image-20211214111328-gt0i4os.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>数据库基础知识</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令实操</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/02_linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<ol>
<li><p>find 基本语法参数如下：</p>
<ol>
<li><pre><code> find [PATH] [option] [action]

 # 与时间有关的参数：
 -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；
 -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；
 -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；
 -newer file : 列出比file还要新的文件名
 # 例如：
 find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件

 # 与用户或用户组名有关的参数：
 -user name : 列出文件所有者为name的文件
 -group name : 列出文件所属用户组为name的文件
 -uid n : 列出文件所有者为用户ID为n的文件
 -gid n : 列出文件所属用户组为用户组ID为n的文件
 # 例如：
 find /home/hadoop -user hadoop # 在目录/home/hadoop中找出所有者为hadoop的文件

 # 与文件权限及名称有关的参数：
 -name filename ：找出文件名为filename的文件
 -size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件
 -tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、
              目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；
 -perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；
 -perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示
 -perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示
 # 例如：
 find / -name passwd # 查找文件名为passwd的文件
 find . -perm 0755 # 查找当前目录中文件权限的0755的文件
 find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte
</code></pre>
<p>  使用截图：</p>
<p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504211338122-1598976431.png"></p>
<p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504211629560-1737782460.png"></p>
<p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504212137576-1297477565.png"></p>
<ol start="2">
<li>ls 命令，展示文件夹内内容，参数如下：</li>
</ol>
<pre><code>-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ 
-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ 
-d ：仅列出目录本身，而不是列出目录内的档案数据 
-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) 
-F ：根据档案、目录等信息，给予附加数据结构，例如： 
*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； 
-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； 
-i ：列出 inode 位置，而非列出档案属性； 
-l ：长数据串行出，包含档案的属性等等数据； 
-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) 
-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； 
-R ：连同子目录内容一起列出来； 
-S ：以档案容量大小排序！ 
-t ：依时间排序 
--color=never ：不要依据档案特性给予颜色显示； 
--color=always ：显示颜色 
--color=auto ：让系统自行依据设定来判断是否给予颜色 
--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 
--time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) 
而非内容变更时间 (modification time)  

例如：
ls [-aAdfFhilRS] 目录名称 
ls [--color=&#123;none,auto,always&#125;] 目录名称 
ls [--full-time] 目录名称  
</code></pre>
<p>  使用截图：</p>
<p> <img src="/assets/image-20211122224052-hv2w7p5.png" alt="image.png"></p>
<p> <img src="/assets/image-20211122224059-f0xzfu9.png" alt="image.png"></p>
<ol start="3">
<li>cd 命令：</li>
</ol>
<pre><code>cd /root/Docements # 切换到目录/root/Docements
cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  
cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录
</code></pre>
<p> <img src="/assets/image-20211122224108-677n1g7.png" alt="image.png"></p>
<ol start="4">
<li>tree命令，显示树形的层级目录结构，非原生命令，需要安装tree</li>
</ol>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224115-492g23a.png" alt="image.png"></p>
<ol start="5">
<li>cp 命令，作用复制，参数如下：</li>
</ol>
<pre><code>-a ：将文件的特性一起复制
-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份
-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行
-r ：递归持续复制，用于目录的复制行为
-u ：目标文件与源文件有差异时才会复制
</code></pre>
<p>  编辑示例：</p>
<p> <img src="/assets/image-20211122224122-kvzer3g.png" alt="image.png"></p>
<p> <img src="/assets/image-20211122224130-xstggsr.png" alt="image.png"></p>
<ol start="6">
<li>rm命令作用为删除，参数：</li>
</ol>
<pre><code>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息
-i ：互动模式，在删除前会询问用户是否操作
-r ：递归删除，最常用于目录删除，它是一个非常危险的参数
</code></pre>
<p>  使用示例：</p>
<p> <img src="/assets/image-20211122224137-i3kptwv.png" alt="image.png"></p>
<ol start="7">
<li>mv命令作用为移动文件：</li>
</ol>
<pre><code>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖
-i ：若目标文件已经存在，就会询问是否覆盖
-u ：若目标文件已经存在，且比目标文件新，才会更新
</code></pre>
<p> <img src="/assets/image-20211122224143-iuk9wzn.png" alt="image.png"></p>
<ol start="8">
<li>pwd命令，作用为查看”当前工作目录“的完整路径</li>
</ol>
<pre><code>pwd -P # 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径
</code></pre>
<p> 使用截图：</p>
<p> <img src="/assets/image-20211122224150-p71ji8z.png" alt="image.png"></p>
<ol start="9">
<li>tar命令，用于压缩解压：</li>
</ol>
<pre><code>-c ：新建打包文件
-t ：查看打包文件的内容含有哪些文件名
-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中
-j ：通过bzip2的支持进行压缩/解压缩
-z ：通过gzip的支持进行压缩/解压缩
-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来
-f filename ：filename为要处理的文件
-C dir ：指定压缩/解压缩的目录dir
</code></pre>
<p> 缩略版…</p>
<pre><code>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称
查询：tar -jtv -f filename.tar.bz2
解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录
</code></pre>
<ol start="10">
<li>mkdir命令创建目录：</li>
</ol>
<pre><code>mkdir [选项]... 目录... 
 -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask
 -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; 
 -v, --verbose  每次创建新目录都显示信息
</code></pre>
<p> <img src="/assets/image-20211122224158-z6hvsot.png" alt="image.png"></p>
<ol start="11">
<li>rmdir 命令删除目录：</li>
</ol>
<pre><code>rmdir [选项]... 目录...
-p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 
-v --verbose  显示指令执行过程 
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224205-ho83tya.png" alt="image.png"></p>
<ol start="12">
<li>gzip 命令压缩文件或文件夹为 .gz文件：</li>
</ol>
<pre><code> gzip[参数][文件或者目录]
-a or --ascii 　使用ASCII文字模式。 
-c or --stdout or --to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 
-d or --decompress or ----uncompress 　解开压缩文件。 
-f or --force 　强行压缩文件。不理会文件名称 or 硬连接是否存在以及该文件是否为符号连接。 
-h or --help 　在线帮助。 
-l or --list 　列出压缩文件的相关信息。 
-L or --license 　显示版本与版权信息。 
-n or --no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 
-N or --name 　压缩文件时，保存原来的文件名称及时间戳记。 
-q or --quiet 　不显示警告信息。 
-r or --recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 
-S&lt;压缩字尾字符串&gt; or ----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 
-t or --test 　测试压缩文件是否正确无误。 
-v or --verbose 　显示指令执行过程。 
-V or --version 　显示版本信息。 
-num 用指定的数字num调整压缩的速度，-1 or --fast表示最快压缩方法（低压缩比），-9 or --best表示最慢压缩方法（高压缩比）。系统缺省值为6。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224214-u5sy61x.png" alt="image.png"></p>
<p> <strong>二. 进程相关命令：</strong></p>
<ol start="13">
<li>ps 命令显示运行的进程，还会显示进程的一些信息如pid, cpu和内存使用情况等：</li>
</ol>
<pre><code>-A ：所有的进程均显示出来
-a ：不与terminal有关的所有进程
-u ：有效用户的相关进程
-x ：一般与a参数一起使用，可列出较完整的信息
-l ：较长，较详细地将PID的信息列出
</code></pre>
<p>  使用示例：</p>
<p> <img src="/assets/image-20211122224220-7x3b7a0.png" alt="image.png"></p>
<ol start="14">
<li>kill 命令用于终止进程，参数：</li>
</ol>
<pre><code>kill -signal PID

1：SIGHUP，启动被终止的进程
2：SIGINT，相当于输入ctrl+c，中断一个程序的进行
9：SIGKILL，强制中断一个进程的进行
15：SIGTERM，以正常的结束进程方式来终止进程
17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224228-nl950hz.png" alt="image.png"></p>
<ol start="15">
<li>killall 命令和参数：</li>
</ol>
<pre><code>killall [-iIe] [command name]

-i ：交互式的意思，若需要删除时，会询问用户
-e ：表示后面接的command name要一致，但command name不能超过15个字符
-I ：命令名称忽略大小写
# 例如：
killall -SIGHUP syslogd # 重新启动syslogd
</code></pre>
<p>  使用示例：</p>
<p> <img src="/assets/image-20211122224234-v7au6zb.png" alt="image.png"></p>
<ol start="16">
<li>crontab命令是启动linux定时任务的服务</li>
</ol>
<pre><code>service cron start # 启动cronjob
service cron stop # 停止cronjob
service cron restart #  重启cronjob
crontab -e # 编辑cronjob任务
</code></pre>
<p> 使用示例：打开crontab -e后通过vi方式编辑任务列表</p>
<p> <img src="/assets/image-20211122224241-dq8lpqb.png" alt="image.png"></p>
<ol start="17">
<li>free 命令用于显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer：</li>
</ol>
<pre><code>free [参数]
-b 　以Byte为单位显示内存使用情况。 
-k 　以KB为单位显示内存使用情况。 
-m 　以MB为单位显示内存使用情况。
-g   以GB为单位显示内存使用情况。 
-o 　不显示缓冲区调节列。 
-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 
-t 　显示内存总和列。 
-V 　显示版本信息。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224250-pjnkr61.png" alt="image.png"></p>
<ol start="18">
<li>top 命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器：</li>
</ol>
<pre><code>top [参数]
-b 批处理
-c 显示完整的治命令
-I 忽略失效过程
-s 保密模式
-S 累积模式
-i&lt;时间&gt; 设置间隔时间
-u&lt;用户名&gt; 指定用户名
-p&lt;进程号&gt; 指定进程
-n&lt;次数&gt; 循环显示的次数
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224256-wshssr0.png" alt="image.png"></p>
<p> <strong>三. 权限相关命令：</strong></p>
<ol start="19">
<li>chmod命令：</li>
</ol>
<pre><code>chmod [-R] xyz 文件或目录
-R：进行递归的持续更改，即连同子目录下的所有文件都会更改
</code></pre>
<pre><code>#同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改，编号是各种权限的数字代码，示例：
chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x
chmod g+w file # 向file的文件权限中加入用户组可写权限
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224304-fl7x0xb.png" alt="image.png"></p>
<ol start="20">
<li>chown命令改变文件所有者：</li>
</ol>
<pre><code>chown [para]... [owner][:[group]] file...
</code></pre>
<p>   -c 显示更改的部分的信息</p>
<p> 　-f 忽略错误信息</p>
<p> 　-h 修复符号链接</p>
<p> 　-R 处理指定目录以及其子目录下的所有文件</p>
<p> 　-v 显示详细的处理信息</p>
<p> 　-deference 作用于符号链接的指向，而不是链接文件本身</p>
<p>  使用示例：</p>
<p> <img src="/assets/image-20211122224310-6w1fr7l.png" alt="image.png"></p>
<ol start="21">
<li>chgrp命令，改变文件所属组：</li>
</ol>
<pre><code>-c 当发生改变时输出调试信息
-f 不显示错误信息
-R 处理指定目录以及其子目录下的所有文件
-v 运行时显示详细的处理信息
--dereference 作用于符号链接的指向，而不是符号链接本身
--no-dereference 作用于符号链接本身
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224318-udazx56.png" alt="image.png"></p>
<ol start="22">
<li>useradd 命令建立用户账号：</li>
</ol>
<pre><code>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号] 

    -c #&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。　
　　-d #&lt;登入目录&gt; 　指定用户登入时的启始目录。
　　-D #　变更预设值．
　　-e # &lt;有效期限&gt; 　指定帐号的有效期限。
　　-f # &lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。
　　-g # &lt;群组&gt; 　指定用户所属的群组。
　　-G # &lt;群组&gt; 　指定用户所属的附加群组。
　　-m # 自动建立用户的登入目录。
　　-M # 不要自动建立用户的登入目录。
　　-n # 取消建立以用户名称为名的群组．
　　-r # 建立系统帐号。
　　-s # 指定用户登入后所使用的shell。
　　-u # 指定用户ID。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224326-axrl6j6.png" alt="image.png"></p>
<ol start="23">
<li>usermod 修改用户信息：</li>
</ol>
<pre><code>usermod -h
usermod [options] LOGIN
</code></pre>
<p>  -c #后面接账号的说明，即&#x2F;etc&#x2F;passwd第五栏的说明栏，可以加入一些账号的说明<br>  -d #后面接账号的家目录，即修改&#x2F;etc&#x2F;passwd的第六栏<br>  -e #后面接日期，格式是YYYY-MM-DD也就是在&#x2F;etc&#x2F;shadow内的第八栏<br>  -f #后面接天数，修改shadow的第七栏<br>  -g #后面接主群组，修改&#x2F;etc&#x2F;passwd的第四个字段，即是GID的字段<br>  -G #后面接附加群组，修改这个使用者能够支持的群组，修改的是&#x2F;etc&#x2F;group<br>  -a #与 -G 合用，可增加附加群组的支持而非设定<br>  -l #后面接账号名称。修改账号名称，&#x2F;etc&#x2F;passwd的第一栏<br>  -s #后面接Shell的文件，例如&#x2F;bin&#x2F;bash或&#x2F;bin&#x2F;csh等等<br>  -u #后面接 UID 数字，修改用户的UID &#x2F;etc&#x2F;passwd第三栏<br>  -L #暂时将用户的密码冻结，让他无法登入。其实就是在&#x2F;etc&#x2F;shadow的密码栏前面加上了“!”<br>  -U #将&#x2F;etc&#x2F;shadow 密码栏的“!”去掉</p>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224335-lrs0c06.png" alt="image.png"></p>
<ol start="24">
<li>userdel 删除用户：</li>
</ol>
<pre><code>userdel [options] LOGIN
-f # 强制删除，包括用户的一切相关内容，这个参数是危险的参数，不建议大家使用。详细说明看MAN
-r # 删除用户的家目录和用户的邮件池
</code></pre>
<p> <img src="/assets/image-20211122224341-3cqfuie.png" alt="image.png"></p>
<ol start="25">
<li>groupadd　命令用于将新组加入系统：</li>
</ol>
<pre><code>groupadd [－g gid] [－o]] [－r] [－f] groupname

－g gid：指定组ID号。
－o：允许组ID号，不必惟一。
－r：加入组ID号，低于499系统账号。
－f：加入已经有的组时，发展程序退出。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224347-bl46p38.png" alt="image.png"></p>
<ol start="26">
<li>groupdel　命令删除组：</li>
</ol>
<pre><code>＃　用于删除不再需要的组，如果指定的组中包含用户，则必须先删除组里面的用户&gt;以后，才能删除组
groupdel [options] GROUP
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224353-2gftldo.png" alt="image.png"></p>
<ol start="27">
<li>sudo 用来以其他身份来执行命令，预设的身份为root:</li>
</ol>
<pre><code>sudo(选项)(参数)

-b：在后台执行指令；
-h：显示帮助；
-H：将HOME环境变量设为新身份的HOME环境变量；
-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。
-l：列出目前用户可执行与无法执行的指令；
-p：改变询问密码的提示符号；
-s：执行指定的shell；
-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；
-v：延长密码有效期限5分钟；
-V ：显示版本信息。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224353-2gftldo.png" alt="image.png"></p>
<ol start="28">
<li>passwd 设置用户的密码：</li>
</ol>
<pre><code>passwd [OPTION...] &lt;accountName&gt;
-k, --keep-tokens       keep non-expired authentication tokens
-d, --delete            delete the password for the named account (root only)
-l, --lock              lock the named account (root only)
-u, --unlock            unlock the named account (root only)
-f, --force             force operation
-x, --maximum=DAYS      maximum password lifetime (root only)
-n, --minimum=DAYS      minimum password lifetime (root only)
-w, --warning=DAYS      number of days warning users receives before password expiration (root only)
-i, --inactive=DAYS     number of days after password expiration when an account becomes disabled (root only)
-S, --status            report password status on the named account (root)
</code></pre>
<p> <img src="/assets/image-20211122224406-25bth2a.png" alt="image.png"></p>
<ol start="29">
<li>groups 显示用户所属组：</li>
</ol>
<pre><code>groups # 默认显示当前用户的组

groups hadoop2 # 显示hadoop2用户的组
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224412-5vhacar.png" alt="image.png"></p>
<p> <strong>四. 文本查看编辑等命令</strong></p>
<ol start="30">
<li>vi&#x2F;vim 是使用vi编辑器的命令：</li>
</ol>
<pre><code>vi /var/log/aa.log # 打开 /var/log/aa.log文件并编辑
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224419-x1zt9xw.png" alt="image.png"></p>
<p> vi的操作命令比较复杂，就不在这里详细展开了。</p>
<ol start="31">
<li>cat　用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。</li>
</ol>
<pre><code> cat [选项] [文件]...
-A, --show-all           等价于 -vET
-b, --number-nonblank    对非空输出行编号
-e                       等价于 -vE
-E, --show-ends          在每行结束处显示 $
-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号
-s, --squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行 
-t                       与 -vT 等价
-T, --show-tabs          将跳格字符显示为 ^I
-u                       (被忽略)
-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224426-8n5q9cp.png" alt="image.png"></p>
<ol start="32">
<li>more 命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能：</li>
</ol>
<pre><code>more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 
命令参数：
+n 从笫n行开始显示
-n 定义屏幕大小为n行
+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 
-c 从顶部清屏，然后显示
-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能
-l 忽略Ctrl+l（换页）字符
-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
-s 把连续的多个空行显示为一行
-u 把文件内容中的下画线去掉
常用操作命令：
Enter 向下n行，需要定义。默认为1行
Ctrl+F 向下滚动一屏
空格键 向下滚动一屏
Ctrl+B 返回上一屏
= 输出当前行的行号
：f 输出文件名和当前行的行号
V 调用vi编辑器
!命令 调用Shell，并执行命令 
q 退出more
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224434-a522j9k.png" alt="image.png"></p>
<ol start="33">
<li>less　命令用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</li>
</ol>
<pre><code> less [参数]  文件 
-b &lt;缓冲区大小&gt; 设置缓冲区的大小
-e 当文件显示结束后，自动离开
-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-g 只标志最后搜索的关键词
-i 忽略搜索时的大小写
-m 显示类似more命令的百分比
-N 显示每行的行号
-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来
-Q 不使用警告音
-s 显示连续空行为一行
-S 行过长时间将超出部分舍弃
-x &lt;数字&gt; 将“tab”键显示为规定的数字空格
/字符串：向下搜索“字符串”的功能
?字符串：向上搜索“字符串”的功能
n：重复前一个搜索（与 / 或 ? 有关）
N：反向重复前一个搜索（与 / 或 ? 有关）
b 向后翻一页
d 向后翻半页
h 显示帮助界面
Q 退出less 命令
u 向前滚动半页
y 向前滚动一行
空格键 滚动一行
回车键 滚动一页
[pagedown]： 向下翻动一页
[pageup]： 向上翻动一页
</code></pre>
<p> 使用示例：</p>
<p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507155949515-2041094265.png"></p>
<p> <img src="/assets/image-20211122224448-1w68car.png" alt="image.png"></p>
<ol start="34">
<li>tail 命令</li>
</ol>
<pre><code>#从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示
在屏幕上,并且不但刷新,使你看到最新的文件内容. 
tail[必要参数][选择参数][文件]   

-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c&lt;数目&gt; 显示的字节数
-n&lt;行数&gt; 显示行数
--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. 
-q, --quiet, --silent 从不输出给出文件名的首部 
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224455-m4rxv5g.png" alt="image.png"></p>
<ol start="35">
<li>head 命令用于显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行：</li>
</ol>
<pre><code>head [参数]... [文件]...  
-q 隐藏文件名
-v 显示文件名
-c&lt;字节&gt; 显示字节数
-n&lt;行数&gt; 显示的行数
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224502-vj0dcek.png" alt="image.png"></p>
<ol start="36">
<li>diff 命令用于比较两个文件或目录的不同：</li>
</ol>
<pre><code> diff[参数][文件1或目录1][文件2或目录2]

# diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定
比较的是目录的的时候，diff 命令会比较两个目录下名字相同的
# 文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。

-a or --text 　#diff预设只会逐行比较文本文件。
-b or --ignore-space-change 　#不检查空格字符的不同。
-B or --ignore-blank-lines 　#不检查空白行。
-c 　#显示全部内文，并标出不同之处。
-C or --context 　#与执行&quot;-c-&quot;指令相同。
-d or --minimal 　#使用不同的演算法，以较小的单位来做比较。
-D or ifdef 　#此参数的输出格式可用于前置处理器巨集。
-e or --ed 　#此参数的输出格式可用于ed的script文件。
-f or -forward-ed 　#输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。
-H or --speed-large-files 　#比较大文件时，可加快速度。
-l or --ignore-matching-lines 　#若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符 or 字符串，则不显示这两个文件的差异。
-i or --ignore-case 　#不检查大小写的不同。
-l or --paginate 　#将结果交由pr程序来分页。
-n or --rcs 　#将比较结果以RCS的格式来显示。
-N or --new-file 　#在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。
-p 　#若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。
-P or --unidirectional-new-file 　#与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。
-q or --brief 　#仅显示有无差异，不显示详细的信息。
-r or --recursive 　#比较子目录中的文件。
-s or --report-identical-files 　#若没有发现任何差异，仍然显示信息。
-S or --starting-file 　#在比较目录时，从指定的文件开始比较。
-t or --expand-tabs 　#在输出时，将tab字符展开。
-T or --initial-tab 　#在每行前面加上tab字符以便对齐。
-u,-U or --unified= 　#以合并的方式来显示文件内容的不同。
-v or --version 　#显示版本信息。
-w or --ignore-all-space 　#忽略全部的空格字符。
-W or --width 　#在使用-y参数时，指定栏宽。
-x or --exclude 　#不比较选项中所指定的文件 or 目录。
-X or --exclude-from 　#您可以将文件 or 目录类型存成文本文件，然后在=中指定此文本文件。
-y or --side-by-side 　#以并列的方式显示文件的异同之处。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224509-vbbhrfp.png" alt="image.png"></p>
<p> <img src="/assets/image-20211122224514-2y6th4o.png" alt="image.png"></p>
<p> <strong>网络相关命令：</strong></p>
<ol start="37">
<li>ping 用于确定主机与外部连接状态：</li>
</ol>
<pre><code>ping [参数] [主机名或IP地址]
-d 使用Socket的SO_DEBUG功能。
-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。
-n 只输出数值。
-q 不显示任何传送封包的信息，只显示最后的结果。
-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。
-R 记录路由过程。
-v 详细显示指令的执行过程。
&lt;p&gt;-c 数目：在发送指定数目的包后停止。
-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。
-I 网络界面：使用指定的网络界面送出数据包。
-l 前置载入：设置在送出要求信息之前，先行发出的数据包。
-p 范本样式：设置填满数据包的范本样式。
-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。
-t 存活数值：设置存活数值TTL的大小。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224521-kf8ed1z.png" alt="image.png"></p>
<ol start="38">
<li>ssh 命令用于远程登录上Linux主机：</li>
</ol>
<pre><code>ssh [-l login_name] [-p port] [user@]hostname
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224527-ohj9izq.png" alt="image.png"></p>
<ol start="39">
<li>scp 命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的：</li>
</ol>
<pre><code>scp [参数] [原路径] [目标路径]

-1 强制scp命令使用协议ssh1 
-2 强制scp命令使用协议ssh2 
-4 强制scp命令只使用IPv4寻址 
-6 强制scp命令只使用IPv6寻址 
-B 使用批处理模式（传输过程中不询问传输口令或短语） 
-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） 
-p 保留原文件的修改时间，访问时间和访问权限。 
-q 不显示传输进度条。 
-r 递归复制整个目录。 
-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 
-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 
-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 
-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 
-l limit 限定用户所能使用的带宽，以Kbit/s为单位。 
-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， 
-P port 注意是大写的P, port是指定数据传输用到的端口号 
-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224534-eahegc7.png" alt="image.png"></p>
<ol start="40">
<li>telnet 命令用来远程登录操作：</li>
</ol>
<pre><code> telnet[参数][主机]

-8 允许使用8位字符资料，包括输入与输出。
-a 尝试自动登入远端系统。
-b&lt;主机别名&gt; 使用别名指定远端主机名称。
-c 不读取用户专属目录里的.telnetrc文件。
-d 启动排错模式。
-e&lt;脱离字符&gt; 设置脱离字符。
-E 滤除脱离字符。
-f 此参数的效果和指定&quot;-F&quot;参数相同。
-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。
-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。
-K 不自动登入远端主机。
-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。
-L 允许输出8位字符资料。
-n&lt;记录文件&gt; 指定文件记录相关信息。
-r 使用类似rlogin指令的用户界面。
-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。
-x 假设主机有支持数据加密的功能，就使用它。
-X&lt;认证形态&gt; 关闭指定的认证形态。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224540-7uvwxi6.png" alt="image.png"></p>
<ol start="41">
<li>wget 是从远程下载的工具：</li>
</ol>
<pre><code>wget [参数] [URL地址]

启动参数：
-V, –version 显示wget的版本后退出
-h, –help 打印语法帮助
-b, –background 启动后转入后台执行
-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc

记录和输入文件参数：
-o, –output-file=FILE 把记录写到FILE文件中
-a, –append-output=FILE 把记录追加到FILE文件中
-d, –debug 打印调试输出
-q, –quiet 安静模式(没有输出)
-v, –verbose 冗长模式(这是缺省设置)
-nv, –non-verbose 关掉冗长模式，但不是安静模式
-i, –input-file=FILE 下载在FILE文件中出现的URLs
-F, –force-html 把输入文件当作HTML格式文件对待
-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀
–sslcertfile=FILE 可选客户端证书
–sslcertkey=KEYFILE 可选客户端证书的KEYFILE
–egd-file=FILE 指定EGD socket的文件名

下载参数：
–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)
-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).
-O –output-document=FILE 把文档写到FILE文件中
-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀
-c, –continue 接着下载没下载完的文件
–progress=TYPE 设定进程条标记
-N, –timestamping 不要重新下载文件除非比本地文件新
-S, –server-response 打印服务器的回应
–spider 不下载任何东西
-T, –timeout=SECONDS 设定响应超时的秒数
-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒
–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒
–random-wait 在下载之间等待0…2*WAIT秒
-Y, –proxy=on/off 打开或关闭代理
-Q, –quota=NUMBER 设置下载的容量限制
–limit-rate=RATE 限定下载输率

目录参数：
-nd –no-directories 不创建目录
-x, –force-directories 强制创建目录
-nH, –no-host-directories 不创建主机目录
-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…
–cut-dirs=NUMBER 忽略 NUMBER层远程目录

HTTP 选项参数：
–http-user=USER 设定HTTP用户名为 USER.
–http-passwd=PASS 设定http密码为 PASS
-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)
-E, –html-extension 将所有text/html文档以.html扩展名保存
–ignore-length 忽略 `Content-Length’头域
–header=STRING 在headers中插入字符串 STRING
–proxy-user=USER 设定代理的用户名为 USER
–proxy-passwd=PASS 设定代理的密码为 PASS
–referer=URL 在HTTP请求中包含 `Referer: URL’头
-s, –save-headers 保存HTTP头到文件
-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION
–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)
–cookies=off 不使用 cookies
–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie
–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中

FTP 选项参数：
-nr, –dont-remove-listing 不移走 `.listing’文件
-g, –glob=on/off 打开或关闭文件名的 globbing机制
–passive-ftp 使用被动传输模式 (缺省值).
–active-ftp 使用主动传输模式
–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)

递归下载参数：
-r, –recursive 递归下载－－慎用!
-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)
–delete-after 在现在完毕后局部删除文件
-k, –convert-links 转换非相对链接为相对链接
-K, –backup-converted 在转换文件X之前，将之备份为 X.orig
-m, –mirror 等价于 -r -N -l inf -nr
-p, –page-requisites 下载显示HTML文件的所有图片

递归下载中的包含和不包含(accept/reject)：
-A, –accept=LIST 分号分隔的被接受扩展名的列表
-R, –reject=LIST 分号分隔的不被接受的扩展名的列表
-D, –domains=LIST 分号分隔的被接受域的列表
–exclude-domains=LIST 分号分隔的不被接受的域的列表
–follow-ftp 跟踪HTML文档中的FTP链接
–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表
-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表
-H, –span-hosts 当递归时转到外部主机
-L, –relative 仅仅跟踪相对链接
-I, –include-directories=LIST 允许目录的列表
-X, –exclude-directories=LIST 不被包含目录的列表
-np, –no-parent 不要追溯到父目录
wget -S –spider url 不下载只显示过程
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224550-6wlept6.png" alt="image.png"></p>
<ol start="42">
<li>ifconfig　命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置：</li>
</ol>
<pre><code> ifconfig [网络设备] [参数]

up 启动指定网络设备/网卡。
down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。
arp 设置指定网卡是否支持ARP协议。
-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包
-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包
-a 显示全部接口信息
-s 显示摘要信息（类似于 netstat -i）
add 给指定网卡配置IPv6地址
del 删除指定网卡的IPv6地址
&lt;硬件地址&gt; 配置网卡最大的传输单元
mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)
netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。
tunel 建立隧道
dstaddr 设定一个远端地址，建立点对点通信
-broadcast&lt;地址&gt; 为指定网卡设置广播协议
-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议
multicast 为网卡设置组播标志
address 为网卡设置IPv4地址
txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224557-cjhqx1y.png" alt="image.png"></p>
<ol start="43">
<li>route</li>
</ol>
<pre><code> route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 
-c  # 显示更多信息
-n  # 不解析名字
-v  # 显示详细的处理信息
-F  # 显示发送信息
-C # 显示路由缓存
-f  # 清除所有网关入口的路由表。 
-p # 与 add 命令一起使用时使路由具有永久性。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224604-4lniowf.png" alt="image.png"></p>
<p> <strong>五. 搜索文件：</strong></p>
<ol start="44">
<li>whereis 命令：</li>
</ol>
<pre><code># whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 

 whereis [-bmsu] [BMS 目录名 -f ] 文件名
</code></pre>
<p> 　-b 定位可执行文件。<br> 　-m 定位帮助文件。<br> 　-s 定位源代码文件。<br> 　-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。<br> 　-B 指定搜索可执行文件的路径。<br> 　-M 指定搜索帮助文件的路径。<br> 　-S 指定搜索源代码文件的路径。</p>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224612-awkb0rj.png" alt="image.png"></p>
<ol start="45">
<li>locate　命令</li>
</ol>
<pre><code>＃　locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)

Locate [选择参数] [样式]
-e   将排除在寻找的范围之外。
-1  如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。
-f   将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。
-q  安静模式，不会显示任何错误讯息。
-n 至多显示 n个输出。
-r 使用正规运算式 做寻找的条件。
-o 指定资料库存的名称。
-d 指定资料库的路径
-h 显示辅助讯息
-V 显示程式的版本讯息
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224620-3i0tc39.png" alt="image.png"></p>
<ol start="46">
<li>which 会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果：</li>
</ol>
<pre><code>which 可执行文件名称 
-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-p 　与-n参数相同，但此处的包括了文件的路径。
-w 　指定输出时栏位的宽度。
-V 　显示版本信息
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224626-1ptxl30.png" alt="image.png"></p>
<p> <strong>六. 其他：</strong></p>
<ol start="47">
<li>grep命令</li>
</ol>
<p> 该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，比如可以加在ps, tail, cat后面</p>
<p> 它的简单语法为</p>
<pre><code>grep [-acinv] [--color=auto] &#39;查找字符串&#39; filename
</code></pre>
<p>  使用示例：</p>
<p> <img src="/assets/image-20211122224632-20ikszh.png" alt="image.png"></p>
<ol start="48">
<li>clear 命令用于清除终端屏幕上现有的文字内容，将之上滚：</li>
</ol>
<p>  额，这条不需要啥示例，非常简单…用了以后就没有了…</p>
<ol start="49">
<li>date 命令用于显示或设定时间：</li>
</ol>
<pre><code>date [参数]... [+格式]

必要参数:
%H 小时(以00-23来表示)。 
%I 小时(以01-12来表示)。 
%K 小时(以0-23来表示)。 
%l 小时(以0-12来表示)。 
%M 分钟(以00-59来表示)。 
%P AM或PM。 
%r 时间(含时分秒，小时以12小时AM/PM来表示)。 
%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 
%S 秒(以本地的惯用法来表示)。 
%T 时间(含时分秒，小时以24小时制来表示)。 
%X 时间(以本地的惯用法来表示)。 
%Z 市区。 
%a 星期的缩写。 
%A 星期的完整名称。 

%b 月份英文名的缩写。 
%B 月份的完整英文名称。 
%c 日期与时间。只输入date指令也会显示同样的结果。 
%d 日期(以01-31来表示)。 
%D 日期(含年月日)。 
%j 该年中的第几天。 
%m 月份(以01-12来表示)。 
%U 该年中的周数。 
%w 该周的天数，0代表周日，1代表周一，异词类推。 
%x 日期(以本地的惯用法来表示)。 
%y 年份(以00-99来表示)。 
%Y 年份(以四位数来表示)。 
%n 在显示时，插入新的一行。 
%t 在显示时，插入tab。 
MM 月份(必要) 
DD 日期(必要) 
hh 小时(必要) 
mm 分钟(必要)
ss 秒(选择性) 

选择参数:
-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。 
-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。 
-u 　显示GMT。 
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224640-37cec89.png" alt="image.png"></p>
<ol start="50">
<li>ln 命令是为某一个文件在另外一个位置建立一个同步的链接</li>
</ol>
<pre><code>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。

软链接：
1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
2.软链接可以 跨文件系统 ，硬链接不可以
3.软链接可以对一个不存在的文件名进行链接
4.软链接可以对目录进行链接

硬链接:
1.硬链接，以文件副本的形式存在。但不占用实际空间。
2.不允许给目录创建硬链接
3.硬链接只有在同一个文件系统中才能创建

ln [参数][源文件或目录][目标文件或目录]

必要参数:
-b 删除，覆盖以前建立的链接
-d 允许超级用户制作目录的硬链接
-f 强制执行
-i 交互模式，文件存在则提示用户是否覆盖
-n 把符号链接视为一般目录
-s 软链接(符号链接)
-v 显示详细的处理过程

选择参数:
-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”
-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/image-20211122224646-p8ocp5y.png" alt="image.png"></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>linux命令实操</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库命令行操作</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/02_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="查看服务器mysql服务有没有开启"><a href="#查看服务器mysql服务有没有开启" class="headerlink" title="查看服务器mysql服务有没有开启:"></a>查看服务器mysql服务有没有开启:</h3><p>ps -ef | grep mysql</p>
<p><img src="/assets/image-20211120233959-4dpkuvo.png" alt="image.png"></p>
<hr>
<h3 id="登录到MySQL"><a href="#登录到MySQL" class="headerlink" title="登录到MySQL:"></a><strong>登录到MySQL:</strong></h3><p>mysql -h 主机名 -u 用户名 -p</p>
<p>-h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略;<br>-u : 所要登录的用户名;<br>-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。</p>
<p><img src="/assets/image-20211120234007-btx7xmn.png" alt="image.png"></p>
<hr>
<h2 id="一-查看数据库、表、数据字段、数据"><a href="#一-查看数据库、表、数据字段、数据" class="headerlink" title="一 查看数据库、表、数据字段、数据"></a>一 查看数据库、表、数据字段、数据</h2><h3 id="查看当前所有的数据库："><a href="#查看当前所有的数据库：" class="headerlink" title="查看当前所有的数据库："></a>查看当前所有的数据库：</h3><pre><code>  show  databases；
</code></pre>
<p><img src="/assets/image-20211120234015-huoyybn.png" alt="image.png"></p>
<hr>
<h3 id="选择（进入）-数据库："><a href="#选择（进入）-数据库：" class="headerlink" title="选择（进入） 数据库："></a>选择（进入） 数据库：</h3><pre><code> use   数据库名；
</code></pre>
<p><img src="/assets/image-20211120234022-bbmujsd.png" alt="image.png"></p>
<hr>
<h3 id="查看当前数据库所有的表："><a href="#查看当前数据库所有的表：" class="headerlink" title="查看当前数据库所有的表："></a>查看当前数据库所有的表：</h3><pre><code>show tables；
</code></pre>
<p><img src="/assets/image-20211120234028-ue71c2x.png" alt="image.png"></p>
<hr>
<h3 id="查看-某个表的字段结构-："><a href="#查看-某个表的字段结构-：" class="headerlink" title="查看 某个表的字段结构 ："></a>查看 某个表的字段结构 ：</h3><pre><code> desc  表名；
</code></pre>
<p><img src="/assets/image-20211120234037-6qr8p92.png" alt="image.png"></p>
<hr>
<h3 id="查询表数据："><a href="#查询表数据：" class="headerlink" title="查询表数据："></a>查询表数据：</h3><pre><code> select * from  表名；
</code></pre>
<p><img src="/assets/image-20211120234046-g3smurz.png" alt="image.png"></p>
<pre><code>    SELECT user_qq AS &#39;玩家QQ&#39;,user_name AS &#39;玩家昵称&#39;  FROM users    //显示中文别名
    SELECT DISTINCT user_qq  FROM scores    //消除重复行
    SELECT * FROM users LIMIT 2,3           //从下标为2的记录开始，显示3条数据（3-5条数据）
</code></pre>
<hr>
<h2 id="二-新建数据库、数据表（表）、数据（添加数据）"><a href="#二-新建数据库、数据表（表）、数据（添加数据）" class="headerlink" title="二 新建数据库、数据表（表）、数据（添加数据）"></a>二 新建数据库、数据表（表）、数据（添加数据）</h2><h3 id="新建数据库："><a href="#新建数据库：" class="headerlink" title="新建数据库："></a>新建数据库：</h3><pre><code>create  database  数据库名；
</code></pre>
<p><img src="/assets/image-20211120234057-lksi10b.png" alt="image.png"></p>
<hr>
<h3 id="新建表："><a href="#新建表：" class="headerlink" title="新建表："></a>新建表：</h3><pre><code>CREATE TABLE 表名 &lt;
    字段名字   数据类型  修饰,
    ...
 &gt;; 
</code></pre>
<p>注意至少要有一个字段 修饰与数据类型在这里不再详细说明 关键字大写 字段间用，隔开 最后一行不用</p>
<p><img src="/assets/image-20211120234057-lksi10b.png" alt="image.png"></p>
<hr>
<h3 id="添加数据："><a href="#添加数据：" class="headerlink" title="添加数据："></a>添加数据：</h3><pre><code>insert into 表名 valuse（值，值）；
</code></pre>
<p><img src="/assets/image-20211120234114-73elez8.png" alt="image.png"></p>
<hr>
<h2 id="三-修改数据表，修改数据"><a href="#三-修改数据表，修改数据" class="headerlink" title="三 修改数据表，修改数据"></a>三 修改数据表，修改数据</h2><h3 id="修改数据表："><a href="#修改数据表：" class="headerlink" title="修改数据表："></a>修改数据表：</h3><pre><code>alter table 表名 add 字段名 类型 修饰【加的列在表的最后面】
</code></pre>
<p><img src="/assets/image-20211120234120-uqqruem.png" alt="image.png"></p>
<pre><code>alter table 表名 add 字段名  类型 修饰 after 某列【把新列加在某列后面】
</code></pre>
<p><img src="/assets/image-20211120234125-0wyw6yo.png" alt="image.png"></p>
<hr>
<h3 id="修改数据："><a href="#修改数据：" class="headerlink" title="修改数据："></a>修改数据：</h3><pre><code> update user set name=新值 where
</code></pre>
<p><img src="/assets/image-20211120234131-u9lqob9.png" alt="image.png"></p>
<hr>
<h2 id="四-删除数据库，数据表，数据"><a href="#四-删除数据库，数据表，数据" class="headerlink" title="四 删除数据库，数据表，数据"></a>四 删除数据库，数据表，数据</h2><h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><pre><code>drop database 数据库名；
</code></pre>
<p><img src="/assets/image-20211120234137-i3k1y62.png" alt="image.png"></p>
<hr>
<h3 id="删除数据表："><a href="#删除数据表：" class="headerlink" title="删除数据表："></a>删除数据表：</h3><pre><code> drop  table  表名;
</code></pre>
<p><img src="/assets/image-20211120234143-v4gn8sk.png" alt="image.png"></p>
<hr>
<h3 id="删除列："><a href="#删除列：" class="headerlink" title="删除列："></a><strong>删除列：</strong></h3><pre><code>alter table 表名 drop 列名称;
</code></pre>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="/assets/image-20211120234151-ilexh3g.png" alt="image.png"></h3><hr>
<h3 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h3><pre><code> delete  from  表名 where；
</code></pre>
<p><img src="/assets/image-20211120234158-ibmm67v.png" alt="image.png"></p>
<hr>
<h3 id="MySQL有三大类数据类型"><a href="#MySQL有三大类数据类型" class="headerlink" title="MySQL有三大类数据类型"></a>MySQL有三大类数据类型</h3><p>分别为 <strong>数字</strong> 、 <strong>日期\时间</strong> 、 <strong>字符串</strong> 。这三大类中又更细致的划分了许多子类型:</p>
<p><strong>整数:</strong> tinyint、smallint、mediumint、int、bigint<br>浮点数: float、double、real、decimal</p>
<p>日期和时间: date、time、datetime、timestamp、year</p>
<p>字符串: char、varchar<br><strong>文本:</strong> tinytext、text、mediumtext、longtext<br> <strong>二进制</strong> (可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob</p>
<hr>
<p><strong>End</strong></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>数据库命令行操作</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库其他连接工具</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/04_%E5%85%B6%E4%BB%96%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<pre><code>   工欲善其事，必先利其器。开发者在开发一个项目时，必定要选择一款合适的数据库，而数据库管理工具则可以帮助开发者轻松搞定很多难题。
   任何Web软件和应用程序都需要强大的数据库来做后盾，目前，网上有无数个数据库管理工具，而开发者选择一款适合自己的尤为重要。为大家介绍10款免费的数据库管理工具，开发者可以使用它们进行SQL操作、多链接、多数据库引擎操作等等。
</code></pre>
<ol>
<li>Open KeyVal<br> Open KeyVal是一款开源免费的键值数据库管理工具，基于Web，并且基于PHP开发，其目标是用最简单的方法来管理Web应用程序数据。用户只需发送一个POST请求就可以存储任何类型的数据，它是以JSON的格式来响应请求的。</li>
<li>DBV<br> DBV顾名思义，是数据库版本管理工具，基于PHP开发。用户在安装后，它可以自动跟踪记录，并且用户还可以把这些记录以SQL文件的形式导出。MySQL数据库默认情况下自动支持DBV，并且允许多用户连接。</li>
<li>DBeaver<br> DBeaver是一个通用的数据库管理工具和SQL客户端，支持MySQL、PostgreSQL、Oracle、DB2、MSSQL、Sybase、Mimer、HSQLDB、Derby以及其他兼容JDBC的数据库。基于Java开发。DBeaver提供一个图形界面用来查看数据库结构、执行SQL查询和脚本，浏览和导出数据，处理BLOB&#x2F;CLOB 数据，修改数据库结构等等。</li>
<li>DBNinja<br> DBNinja是一款基于Web的MySQL数据库管理工具，使用PHP开发，类似桌面应用的接口，可连接多个远程和本地的数据库。它支持所有的新功能包括：触发、事件、视图、存储程序和外键。</li>
<li>MyWebSQL<br> MyWebSql是一个基于Web的MySQL数据库管理客户端，支持多种语言。它除了操作表格数据外，MyWebSql 还可以对包括视图，存储过程，触发器和函数在内的对象进行控制。支持数据和查询结果的导入导出。MyWebSql还内置一个带语法着色功能的SQL编辑器。</li>
<li>Genghis<br> Genghis自称是单文件的MongoDB管理应用程序，它可以高效地管理多个数据库、甚至可以帮助用户收集、管理数据库和文档的服务器。</li>
<li>MyDB Studio<br> MyDB Studio是一个免费的MySQL数据库管理程序，它几乎拥有你所期望的所有功能特性。它可以同时连接没有数量限制的任意多的数据库。如果这些数据库位于防火墙后面或他们是本地数据库，该工具也提供SSH通道访问的支持来解决这些问题。</li>
<li>HeidiSQL<br> HeidiSQL是一款基于Windows的数据库管理软件，意味着它可以管理Microsoft SQL数据库和MySQL。它的功能非常强大，它可以浏览和编辑数据，创建和编辑表格、视图、存储过程、触发器和安排日程。另外，还可以导出结构和数据SQL文件。<br> 它是德国程序员Ansgar Becker和几个Delphi程序员开发的一个开源工具。要通过HeidiSQL来管理数据库，用户应该用有效地凭证登陆到MySQL服务器，创建一个会话。HeidiSQL最大的特色就是操作方便，界面设计合理，功能都是最实用的，尤其适合DBA，它更加强调了对MySQL运行时的参数设置和性能监控等。</li>
<li>SQLite Manager<br> SQLite Manager是开源的SQLite管理工具，用来管理本地电脑上的SQLite数据库，可以独立运行（以XULRunner方式），也可以作为Firefox、Thunderbird、Seamonkey、Songbird、Komodo、Gecko等的插件运行。</li>
<li>Sequel.js<br> Sequel.js是一个轻量级JavaScript库，使用它可以轻松进行SQL查询，它既可以在浏览器上运行，也可以在所有标准的SQL查询上运行。</li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>数据库其他连接工具</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库语句优化</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/03_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在MySQL数据库怎么加快查询速度，优化查询效率，主要原则就是应尽量避免全表扫描，应该考虑在where及order by 涉及的列上建立索引。</p>
<p>　　建立索引不是建的越多越好，原则是：</p>
<p>　　第一：一个表的索引不是越多越好，也没有一个具体的数字，根据以往的经验，一个表的索引最多不能超过6个，因为索引越多，对update和insert操作也会有性能的影响，涉及到索引的新建和重建操作。</p>
<p>　　第二：建立索引的方法论为：</p>
<p>　　多数查询经常使用的列；<br>　　很少进行修改操作的列；<br>　　索引需要建立在数据差异化大的列上<br>　　利用以上的基础我们讨论一下如何优化sql.</p>
<p>1、MySQY语句模型结构优化指导</p>
<p>　　　　a. ORDER BY + LIMIT组合的索引优化</p>
<p>　　　　　　如果一个SQL语句形如：SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort] LIMIT [offset],[LIMIT];</p>
<p>　　　　　　这个SQL语句优化比较简单，在[sort]这个栏位上建立索引即可。</p>
<p>　　　　b. WHERE + ORDER BY + LIMIT组合的索引优化</p>
<p>　　　　　　如果一个SQL语句形如：SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] &#x3D; [VALUE] ORDER BY [sort] LIMIT [offset],[LIMIT];</p>
<p>　　　　　　这个语句，如果你仍然采用第一个例子中建立索引的方法，虽然可以用到索引，但是效率不高。更高效的方法是建立一个联合索引(columnX,sort)</p>
<p>　　　　c. WHERE+ORDER BY多个栏位+LIMIT</p>
<p>　　　　　　 如果一个SQL语句形如：SELECT * FROM [table] WHERE uid&#x3D;1 ORDER x,y LIMIT 0,10;</p>
<p>　　　　　　 对于这个语句，大家可能是加一个这样的索引:(x,y,uid)。但实际上更好的效果是(uid,x,y)。这是由MySQL处理排序的机制造成的。</p>
<p>　　2、复合索引(形如(x,y,uid)索引的索引)</p>
<p>　　　　先看这样一条语句这样的：select* from users where area &#x3D;’beijing’ and age&#x3D;22;</p>
<p>　　 　 如果我们是在area和age上分别创建索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果area，age两列上创建复合索引的话将带来更高的效率。</p>
<pre><code>　　  在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
</code></pre>
<p>　　　 例如我们建立了一个这样的索引（area,age,salary），那么其实相当于创建了（area,age,salary）,(area,age),(area)三个索引，这样称为最佳左前缀特性。</p>
<p>　　3、like语句优化</p>
<p>　　　　SELECT id FROM A WHERE name like ‘%abc%’<br> 　　　　　　由于abc前面用了“%”，因此该查询必然走全表查询，除非必要，否则不要在关键词前加%，优化成如下</p>
<p>　　　　SELECT id FROM A WHERE name like ‘abc%’<br> 　　4、where子句使用 ！&#x3D; 或 &lt;&gt; 操作符优化</p>
<p>　　　　　在where子句中使用 ！&#x3D; 或 &lt;&gt;操作符，索引将被放弃使用，会进行全表查询。</p>
<p> 　　　　如SQL:SELECT id FROM A WHERE ID !&#x3D; 5 优化成：SELECT id FROM A WHERE ID&gt;5 OR ID&lt;5</p>
<p>　　5、where子句中使用 IS NULL 或 IS NOT NULL 的优化</p>
<p>　　　　在where子句中使用 IS NULL 或 IS NOT NULL 判断，索引将被放弃使用，会进行全表查询。</p>
<p>　　 　　如SQL:SELECT id FROM A WHERE num IS NULL 优化成num上设置默认值0，确保表中num没有null值，然后SQL为：SELECT id FROM A WHERE num&#x3D;0</p>
<p>　　6、where子句使用or的优化</p>
<p>　　　　很多时候使用union all 或 nuin(必要的时候)的方式替换“or”会得到更好的效果。where子句中使用了or,索引将被放弃使用。</p>
<p>　　 　　如SQL:SELECT id FROM A WHERE num &#x3D;10 or num &#x3D; 20 优化成：SELECT id FROM A WHERE num &#x3D; 10 union all SELECT id FROM A WHERE num&#x3D;20</p>
<p>　　7、where子句使用IN 或 NOT IN的优化</p>
<p>　　　　in和not in 也要慎用，否则也会导致全表扫描。</p>
<p>　　 　　方案一：between替换in</p>
<p>　　 　　　　如SQL:SELECT id FROM A WHERE num in(1,2,3) 优化成：SELECT id FROM A WHERE num between 1 and 3</p>
<p>　　 　　方案二：exist替换in</p>
<p>　　 　　　　如SQL:SELECT id FROM A WHERE num in(select num from b ) 优化成：SELECT num FROM A WHERE num exists(select 1 from B where B.num &#x3D; A.num)</p>
<p>　　 　　方案三：left join替换in</p>
<p>　　　　　　如SQL:SELECT id FROM A WHERE num in(select num from B) 优化成：SELECT id FROM A LEFT JOIN B ON A.num &#x3D; B.num</p>
<p>　　8、where子句中对字段进行表达式操作的优化</p>
<p>　　　　不要在where子句中的“&#x3D;”左边进行函数、算数运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>　　 　　如SQL:SELECT id FROM A WHERE num&#x2F;2 &#x3D; 100 优化成：SELECT id FROM A WHERE num &#x3D; 100*2</p>
<p>　　 　　如SQL:SELECT id FROM A WHERE datediff(day,createdate,’2016-11-30’)&#x3D;0 优化成：SELECT id FROM A WHERE createdate&gt;&#x3D;’2016-11-30’ and createdate&lt;’2016-12-1’</p>
<p>　　 　　如SQL:SELECT id FROM A WHERE year(addate) &lt;2016 优化成：SELECT id FROM A where addate&lt;’2016-01-01’</p>
<p>　　9、任何地方都不要用 select * from table ，用具体的字段列表替换”*”，不要返回用不到的字段　　</p>
<p>　　10、使用“临时表”暂存中间结果</p>
<p>　　　　采用临时表暂存中间结果好处：</p>
<p>　　　　　　（1）避免程序中多次扫描主表，减少程序执行“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p>
<p>　　　　　　（2）尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>　　　　　　（3）避免频繁创建和删除临时表，以减少系统资源的浪费。</p>
<p>　　　　　　（4）尽量避免向客户端返回大数据量，若数据量过大，应考虑相应需求是否合理。</p>
<p>　　11、limit分页优化</p>
<p>　　　　　　总数据有500万左右，以下例子</p>
<p>   　　　　　　select * from wl_tagindex where byname&#x3D;’f’ order by id limit 300000,10 执行时间是 3.21s</p>
<p>　　　　　　优化后：</p>
<p>　　　　　　　　select * from (</p>
<p>   　　　　　　　　　　select id from wl_tagindex</p>
<p>　　　　　　　　　　where byname&#x3D;’f’ order by id limit 300000,10</p>
<p>　　　　　　　　) a</p>
<p>　　　　　　　　left join wl_tagindex b on a.id&#x3D;b.id</p>
<p>   　　　　　　执行时间为 0.11s 速度明显提升</p>
<p>   　　　　　　这里需要说明的是 我这里用到的字段是 byname ,id 需要把这两个字段做复合索引，否则的话效果提升不明显</p>
<p>　　12、批量插入优化</p>
<p>　　　　　　INSERT into person(name,age) values(‘A’,14)<br>　　　　　　INSERT into person(name,age) values(‘B’,14)<br>　　　　　　INSERT into person(name,age) values(‘C’,14)<br>　　　　可优化为：</p>
<p>　　　　　　INSERT into person(name,age) values(‘A’,14),(‘B’,14),(‘C’,14),<br>　　13、利用limit 1 、top 1 取得一行，<br>　　　　但是需要注意的是，Top关键字只能在SQL Server数据库中可以使用，而在MySQL数据库中就要使用具有同样功能的LIMIT函数</p>
<p>　　　　有时要查询一张表时，你知道只需要看一条记录，你可能去查询一条特殊的记录。可以使用limit 1 或者 top 1 来终止数据库索引继续扫描整个表或索引。</p>
<p>　　　　如SQL：SELECT id FROM A LIKE ‘abc%’ 优化为：SELECT id FROM A LIKE ‘abc%’ limit 1</p>
<p>　　14、尽量不要使用 BY RAND()命令</p>
<p>　　　　BY RAND()是随机显示结果，这个函数可能会为表中每一个独立的行执行BY RAND()命令，这个会消耗处理器的处理能力。</p>
<p>　　　　如SQL：SELECT * FROM A order by rand() limit 10 优化为：SELECT * FROM A WHERE id &gt;&#x3D; ((SELECT MAX(id) FROM A)-(SELECT MIN(id) FROM A)) * RAND() + (SELECT MIN(id) FROM A) LIMIT 10</p>
<p>　　15、排序的索引问题　</p>
<p>　　 　Mysql查询只是用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求情况下不要使用排序操作；</p>
<p>　　　尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p>
<p>　　16、尽量用 union all 替换 union</p>
<p>　　　union和union all的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的cpu运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用union all而不是union</p>
<p>　　17、避免类型转换</p>
<p>　　　这里所说的“类型转换”是指where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换。人为的上通过转换函数进行转换，直接导致mysql无法使用索引。如果非要转型，应该在传入参数上进行转换。</p>
<pre><code>   　例如utime 是datetime类型，传入的参数是“2016-07-23”，在比较大小时通常是 date（utime）&gt;&quot;2016-07-23&quot;,可以优化为utime&gt;&quot;2016-07-23 00：00：00&quot;
</code></pre>
<p>　　18、尽可能使用更小的字段　　　　　　 　　</p>
<p>　　　　MySQL从磁盘读取数据后是存储到内存中的，然后使用cpu周期和磁盘I&#x2F;O读取它，这意味着越小的数据类型占用的空间越小，从磁盘读或打包到内存的效率都更好，但也不要太过执着减小数据类型，要是以后应用程序发生什么变化就没有空间了。</p>
<p>　　　　修改表将需要重构，间接地可能引起代码的改变，这是很头疼的问题，因此需要找到一个平衡点。</p>
<p>　　19、Inner join 和 left join、right join、子查询</p>
<p>　　第一：inner join内连接也叫等值连接是，left&#x2F;rightjoin是外连接。</p>
<p>　　　　 SELECT A.id,A.name,B.id,B.name FROM A LEFT JOIN B ON A.id &#x3D;B.id;</p>
<p>　　　　 SELECT A.id,A.name,B.id,B.name FROM A RIGHT JOIN ON B A.id&#x3D; B.id;</p>
<p>　　　　 SELECT A.id,A.name,B.id,B.name FROM A INNER JOIN ON A.id &#x3D;B.id;</p>
<p>　　 　　经过来之多方面的证实inner join性能比较快，因为inner join是等值连接，或许返回的行数比较少。但是我们要记得有些语句隐形的用到了等值连接，如：</p>
<p>　　　　SELECT A.id,A.name,B.id,B.name FROM A,B WHERE A.id &#x3D; B.id;</p>
<p>　　　　推荐：能用inner join连接尽量使用inner join连接</p>
<p>　　 第二：子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。</p>
<p>　　　　Select* from A where exists (select * from B where id&gt;&#x3D;3000 and A.uuid&#x3D;B.uuid);</p>
<p>　　　　A表的数据为十万级表，B表为百万级表，在本机执行差不多用2秒左右，我们可以通过explain可以查看到子查询是一个相关子查询(DEPENDENCE SUBQUERY);Mysql是先对外表A执行全表查询，然后根据uuid逐次执行子查询，如果外层表是一个很大的表，我们可以想象查询性能会表现比这个更加糟糕。</p>
<pre><code>  　　一种简单的优化就是用innerjoin的方法来代替子查询，查询语句改为：
</code></pre>
<p>  　　　Select* from A inner join B ON A.uuid&#x3D;B.uuid using(uuid) where b.uuid&gt;&#x3D;3000;  这个语句执行测试不到一秒；</p>
<p>　　第三：使用JOIN时候，应该用小的结果驱动打的结果（left join 左边表结果尽量小，如果有条件应该放到左边先处理，right join同理反向），同时尽量把牵涉到多表联合的查询拆分多个query (多个表查询效率低，容易锁表和阻塞)。如：</p>
<p>　　Select * from A left join B A.id&#x3D;B.ref_id where  A.id&gt;10;可以优化为：select * from (select * from A wehre id &gt;10) T1 left join B on T1.id&#x3D;B.ref_id;</p>
<p>　　20、exist 代替 in</p>
<p>SELECT * from A WHERE idin (SELECT id from B)<br>SELECT * from A WHERE id EXISTS(SELECT 1 from A.id&#x3D; B.id)<br>　　in 是在内存中遍历比较</p>
<p>　　exist 需要查询数据库，所以当B的数据量比较大时，exists效率优于in.</p>
<p>　　in()只执行一次，把B表中的所有id字段缓存起来，之后检查A表的id是否与B表中的id相等，如果id相等则将A表的记录加入到结果集中，直到遍历完A表的所有记录。</p>
<p>　　In 操作的流程原理如同一下代码</p>
<p>　　　　List resultSet&#x3D;{};<br>　　　　Array A&#x3D;(select * from A);<br>　　　　Array B&#x3D;(select id from B);<br>　　　　for(int i&#x3D;0;i&lt;A.length;i++) {<br>　　　　　　for(int j&#x3D;0;j&lt;B.length;j++) {<br>　　　　　　　　if(A[i].id&#x3D;&#x3D;B[j].id) {<br>　　　　　　　　　　resultSet.add(A[i]);<br>　　　　　　　　　　break;<br>　　　　　　　　}<br>　　　　　　}<br>　　　　}<br>　　　return resultSet;</p>
<p>　　可以看出，当B表数据较大时不适合使用in()，因为它会B表数据全部遍历一次</p>
<p>　　如：A表有10000条记录，B表有1000000条记录，那么最多有可能遍历10000*1000000次，效率很差。</p>
<p>　　再如：A表有10000条记录，B表有100条记录，那么最多有可能遍历10000*100次，遍历次数大大减少，效率大大提升。</p>
<p>　　结论：in()适合B表比A表数据小的情况</p>
<p>　　exist()会执行A.length()次，执行过程代码如下</p>
<p>　　　　List resultSet&#x3D;{};<br>　　　　Array A&#x3D;(select * from A);<br>　　　　for(int i&#x3D;0;i&lt;A.length;i++) {<br>　　　　　　if(exists(A[i].id) { &#x2F;&#x2F;执行select 1 from B where B.id&#x3D;A.id是否有记录返回<br>　　　　　　　　resultSet.add(A[i]);<br>　　　　　　}<br>　　　　}<br>　　　　return resultSet;</p>
<p>　　当B表比A表数据大时适合使用exists()，因为它没有那么多遍历操作，只需要再执行一次查询就行。</p>
<p>　　如：A表有10000条记录，B表有1000000条记录，那么exists()会执行10000次去判断A表中的id是否与B表中的id相等。</p>
<p>　　如：A表有10000条记录，B表有100000000条记录，那么exists()还是执行10000次，因为它只执行A.length次，可见B表数据越多，越适合exists()发挥效果。</p>
<p>　　再如：A表有10000条记录，B表有100条记录，那么exists()还是执行10000次，还不如使用in()遍历10000*100次，因为in()是在内存里遍历比较，而exists()需要查询数据库，</p>
<p>　　我们都知道查询数据库所消耗的性能更高，而内存比较很快。</p>
<p>　　结论：exists()适合B表比A表数据大的情况</p>
<p>　　 当A表数据与B表数据一样大时，in与exists效率差不多，可任选一个使用。</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>数据库语句优化</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/05_%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<ol>
<li><p>索引底层原理</p>
<ol>
<li><p>语句：</p>
<ol>
<li><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/07_explain%E8%AF%A6%E8%A7%A3/">explain详解</a></li>
<li>explain +sql语句   查看读取数据的信息</li>
</ol>
</li>
<li><p>什么是索引</p>
<ol>
<li><a href="https://www.tutorialspoint.com/mysql/mysql-indexes.htm">MySQL - INDEXES (tutorialspoint.com)</a></li>
<li>A database index is a data structure that improves the speed of operations in a table</li>
</ol>
</li>
<li><p>怎么创建索引</p>
<ol>
<li>数据库管理工具-添加</li>
<li>命令行添加：create index index_name  on tablename;</li>
</ol>
</li>
<li><p>为什么需要索引</p>
<ol>
<li>能够改善数据库的性能瓶颈问题，体现在服务端的磁盘IO的消耗</li>
<li>减少存储引擎需要扫描的数据量</li>
<li>减少使用临时表的概率</li>
<li>将随机的IO转换成为顺序的IO</li>
</ol>
</li>
<li><p>索引的类型有哪些</p>
<ol>
<li><p>从存储结构上划分： BTree索引、Hash索引、全文索引、空间索引</p>
<ol>
<li>使用最多的为BTree索引</li>
</ol>
</li>
<li><p>从应用层次来划分： 普通索引（单列索引、多列索引）、唯一索引（具有唯一性，允许为空值）、复合索引（组合索引，多个列建立一个索引）</p>
</li>
<li><p>从表记录的排列顺序是否与索引的排列顺序是否一致：聚集索引、非聚集索引</p>
</li>
</ol>
</li>
<li><p>索引是怎么工作的</p>
<ol>
<li><p>内存、 <a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/09_%E7%A3%81%E7%9B%98/">磁盘</a></p>
<ol>
<li><p>磁盘：硬盘、软盘– 保存数据信息的一个载体</p>
</li>
<li><p>读取磁盘IO 的时间：寻道时间（3-15ms，主流：5ms）+旋转延迟（1&#x2F;（7200&#x2F;60）&#x2F;2 &#x3D;4.17ms）+传输时间（0.n ms，忽略不计） &#x3D; 9ms</p>
</li>
<li><p>2.4GHZ:5亿条指令&#x2F;秒</p>
</li>
<li><p>解决磁盘IO消耗：</p>
<ol>
<li><p>系统自带的处理方式（按页读取-4kb，8kb，局部性原理）</p>
</li>
<li><p>降低了磁盘IO消耗的数量级：mysql存储引擎：innodb，  索引：B+Tree     eg： 传统查询无索引：逐条遍历</p>
<ol>
<li><img src="/assets/image-20211222164141-65arjxu.png" alt="image.png"></li>
</ol>
</li>
<li><p>B+tree  校验网址：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
</li>
<li><p>查看表的索引情况</p>
<ol>
<li>show  index from  表名</li>
<li>其他： reset  query  cache</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><a href="../903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/08_%E7%B4%A2%E5%BC%95%E6%96%87%E7%8C%AE/">索引文献</a></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>主键</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/06_%E4%B8%BB%E9%94%AE/</url>
    <content><![CDATA[<ul>
<li><p>数据的完整性</p>
<ul>
<li>数据的完整性指存储在数据库中的数据应该保持准确性和可靠性。</li>
<li>如出现学号相同的数据就是不准确的</li>
</ul>
</li>
<li><p>实体完整性</p>
<ul>
<li>实体完整性是对关系中的记录唯一性</li>
<li>定义表中的多有行能唯一的标识</li>
<li>表中主属性（字段）不能为Null且不能有相同值</li>
<li>一般用主键、唯一索引、unique关键字来实现</li>
<li>目的：在表中至少有一个唯一的标识，主属性字段中，不能为空，不能重复</li>
</ul>
</li>
<li><p>实体完整性–主键约束</p>
<ul>
<li><p>主键约束</p>
<ul>
<li>主关键字（primary key）是表中一个或者多个字段，它的值用于唯一地标识表中某一条记录</li>
<li>唯一，不重复，不能为空， primary key</li>
<li><ol>
<li><p>创建表的铜焊丝创建主键约束</p>
</li>
<li><p><img src="/assets/image-20220301110120-f1jylt6.png" alt="image.png"></p>
<p> a. CREATE  TABLE t_user（user_id INT（10） PRIMARY KEY）;</p>
<p> b. CREATE TABLE  t-user(user_id(user_id INT(10),user_name varchar(30),consttaint pk_id_name primary key(user_id,user_name));</p>
<p> c. CREATE TABLE t_user(user_id INT(10),PRIMARY KEY(USER_ID));</p>
</li>
<li><p>针对已存在的表，添加主键约束</p>
<ol>
<li>ALTER TABLE t_user MODIFY user_id INT(10) PRIMARY KEY;</li>
<li>ALTER TABLE t_user ADD  PRIMARY KEY(user_id);</li>
<li>ALTER TABLE t_user ADD  CONSTRAINT PK_ID PRIMARY KEY(user_id);</li>
</ol>
</li>
<li><p>删除主键约束</p>
<ol>
<li>ALTER TABLE t_user DROP PRIMARY KEY;</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>唯一约束</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课中</category>
        <category>主键</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>explain详解</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/07_explain%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p>
<pre><code>-- 实际SQL，查找用户名为Jefabc的员工
select * from emp where name = &#39;Jefabc&#39;;
-- 查看SQL是否使用索引，前面加上explain即可
explain select * from emp where name = &#39;Jefabc&#39;;
</code></pre>
<p><img src="https://images2018.cnblogs.com/blog/512541/201808/512541-20180803142201303-545775900.png"></p>
<p>expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</p>
<p><strong>概要描述：</strong><br>id:选择标识符<br>select_type:表示查询的类型。<br>table:输出结果集的表<br>partitions:匹配的分区<br>type:表示表的连接类型<br>possible_keys:表示查询时，可能使用的索引<br>key:表示实际使用的索引<br>key_len:索引字段的长度<br>ref:列与索引的比较<br>rows:扫描出的行数(估算的行数)<br>filtered:按表条件过滤的行百分比<br>Extra:执行情况的描述和说明</p>
<p><strong>下面对这些字段出现的可能进行解释：</strong></p>
<p>一、 <strong>id</strong></p>
<p>SELECT识别符。这是SELECT的查询序列号</p>
<p><strong>我的理解是SQL执行的顺序的标识，SQL从大到小的执行</strong></p>
<ol>
<li>id相同时，执行顺序由上至下</li>
<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>
</ol>
<pre><code>-- 查看在研发部并且名字以Jef开头的员工，经典查询
explain select e.no, e.name from emp e left join dept d on e.dept_no = d.no where e.name like &#39;Jef%&#39; and d.name = &#39;研发部&#39;;
</code></pre>
<p><img src="https://images2018.cnblogs.com/blog/512541/201808/512541-20180803143413064-173136748.png"></p>
<p><strong>二、select_type</strong></p>
<p>**      <strong>示查询中每个select子句的类型</strong>**</p>
<p>(1) SIMPLE(简单SELECT，不使用UNION或子查询等)</p>
<p>(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p>
<p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p>
<p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p>
<p>(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p>
<p>(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p>
<p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p>
<p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p>
<p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p>
<p><strong>三、table</strong></p>
<p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p>
<p><strong>四、type</strong></p>
<p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p>
<p>常用的类型有： ** ALL、index、range、 ref、eq_ref、const、system、** <strong>NULL（从左到右，性能从差到好）</strong></p>
<p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p>
<p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p>
<p>range:只检索给定范围的行，使用一个索引来选择行</p>
<p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p>
<p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p>
<p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
<p><strong>五、possible_keys</strong></p>
<p><strong>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</strong></p>
<p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p>
<p><strong>六、Key</strong></p>
<p><strong>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</strong></p>
<p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>
<p><strong>七、key_len</strong></p>
<p><strong>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</strong></p>
<p>不损失精确性的情况下，长度越短越好** **</p>
<p><strong>八、ref</strong></p>
<p><strong>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</strong></p>
<p><strong>九、rows</strong></p>
<p> <strong>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</strong></p>
<p><strong>十、Extra</strong></p>
<p><strong>该列包含MySQL解决查询的详细信息,有以下几种情况：</strong></p>
<p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p>
<p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p>
<p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p>
<pre><code>-- 测试Extra的filesort
explain select * from emp order by name;
</code></pre>
<p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>
<p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p>
<p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p>
<p>No tables used：Query语句中使用from dual 或不含任何from子句</p>
<pre><code>-- explain select now() from dual;
</code></pre>
<p><strong>总结</strong>:<br><em>• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况<br>• EXPLAIN不考虑各种Cache<br>• EXPLAIN不能显示MySQL在执行查询时所作的优化工作<br>• 部分统计信息是估算的，并非精确值<br>• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</em></p>
<p>通过收集统计信息不可能存在结果</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>explain详解</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>索引文献</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/08_%E7%B4%A2%E5%BC%95%E6%96%87%E7%8C%AE/</url>
    <content><![CDATA[<p><strong>一、引言</strong></p>
<p>对数据库索引的关注从未淡出我的们的讨论，那么数据库索引是什么样的？聚集索引与非聚集索引有什么不同？希望本文对各位同仁有一定的帮助。有不少存疑的地方，诚心希望各位不吝赐教指正，共同进步。[最近首页之争沸沸扬扬，也不知道这个放在这合适么，苦劳？功劳？……]</p>
<p> <strong>二、</strong> <strong>B-Tree</strong></p>
<p>我们常见的数据库系统，其索引使用的数据结构多是B-Tree或者B+Tree。例如，MsSql使用的是B+Tree，Oracle及Sysbase使用的是B-Tree。所以在最开始，简单地介绍一下B-Tree。</p>
<p>B-Tree不同于Binary Tree（二叉树，最多有两个子树），一棵M阶的B-Tree满足以下条件：<br>1）每个结点至多有M个孩子；<br>2）除根结点和叶结点外，其它每个结点至少有M&#x2F;2个孩子；<br>3）根结点至少有两个孩子（除非该树仅包含一个结点）；<br>4）所有叶结点在同一层，叶结点不包含任何关键字信息；<br>5）有K个关键字的非叶结点恰好包含K+1个孩子；</p>
<p>另外，对于一个结点，其内部的关键字是从小到大排序的。以下是B-Tree（M&#x3D;4）的样例：</p>
<p> <img src="/assets/wpsC22B.tmp-20211222153838-2v6kwd8.jpg"></p>
<p>对于每个结点，主要包含一个关键字数组Key[]，一个指针数组（指向儿子）Son[]。在B-Tree内，查找的流程是：使用顺序查找（数组长度较短时）或折半查找方法查找Key[]数组，若找到关键字K，则返回该结点的地址及K在Key[]中的位置；否则，可确定K在某个Key[i]和Key[i+1]之间，则从Son[i]所指的子结点继续查找，直到在某结点中查找成功；或直至找到叶结点且叶结点中的查找仍不成功时，查找过程失败。</p>
<p>接着，我们使用以下图片演示如何生成B-Tree（M&#x3D;4，依次插入1~6）：<br>从图可见，当我们插入关键字4时，由于原结点已经满了，故进行分裂，基本按一半的原则进行分裂，然后取出中间的关键字2，升级（这里是成为根结点）。其它的依类推，就是这样一个大概的过程。</p>
<p> <img src="/assets/wpsC22C.tmp-20211222153838-ib1g6d3.jpg"></p>
<p><strong>三、数据库索引</strong></p>
<p> <strong>1</strong> <strong>．什么是索引</strong></p>
<p>在数据库中，索引的含义与日常意义上的“索引”一词并无多大区别（想想小时候查字典），它是用于提高数据库表数据访问速度的数据库对象。<br>A）索引可以避免全表扫描。多数查询可以仅扫描少量索引页及数据页，而不是遍历所有数据页。<br>B）对于非聚集索引，有些查询甚至可以不访问数据页。<br>C）聚集索引可以避免数据插入操作集中于表的最后一个数据页。<br>D）一些情况下，索引还可用于避免排序操作。</p>
<p>当然，众所周知，虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要同时更新索引。</p>
<p> <strong>2.</strong> <strong>索引的存储</strong></p>
<p>一条索引记录中包含的基本信息包括：键值（即你定义索引时指定的所有字段的值）+逻辑指针（指向数据页或者另一索引页）。</p>
<p> <img src="/assets/wpsC22D.tmp-20211222153838-d0fj2jo.jpg"></p>
<p>当你为一张空表创建索引时，数据库系统将为你分配一个索引页，该索引页在你插入数据前一直是空的。此页此时既是根结点，也是叶结点。每当你往表中插入一行数据，数据库系统即向此根结点中插入一行索引记录。当根结点满时，数据库系统大抵按以下步骤进行分裂：<br>A）创建两个儿子结点<br>B）将原根结点中的数据近似地拆成两半，分别写入新的两个儿子结点<br>C）根结点中加上指向两个儿子结点的指针</p>
<p>通常状况下，由于索引记录仅包含索引字段值（以及4-9字节的指针），索引实体比真实的数据行要小许多，索引页相较数据页来说要密集许多。一个索引页可以存储数量更多的索引记录，这意味着在索引中查找时在I&#x2F;O上占很大的优势，理解这一点有助于从本质上了解使用索引的优势。</p>
<p> <strong>3</strong> <strong>．索引的类型</strong></p>
<p>A）聚集索引，表数据按照索引的顺序来存储的。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。<br>B）非聚集索引，表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致。</p>
<p>在一张表上只能创建一个聚集索引，因为真实数据的物理顺序只可能是一种。如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加的表的末尾位置。</p>
<p> <strong>4</strong> <strong>．聚集索引</strong></p>
<p>在聚集索引中，叶结点也即数据结点，所有数据行的存储顺序与索引的存储顺序一致。</p>
<p> <img src="/assets/wpsC22E.tmp-20211222153838-ulh98xw.jpg"></p>
<p>1）聚集索引与查询操作</p>
<p>如上图，我们在名字字段上建立聚集索引，当需要在根据此字段查找特定的记录时，数据库系统会根据特定的系统表查找的此索引的根，然后根据指针查找下一个，直到找到。例如我们要查询“Green”，由于它介于[Bennet,Karsen]，据此我们找到了索引页1007，在该页中“Green”介于[Greane, Hunter]间，据此我们找到叶结点1133（也即数据结点），并最终在此页中找以了目标数据行。</p>
<p>此次查询的IO包括3个索引页的查询（其中最后一次实际上是在数据页中查询）。这里的查找可能是从磁盘读取(Physical Read)或是从缓存中读取(Logical Read)，如果此表访问频率较高，那么索引树中较高层的索引很可能在缓存中被找到。所以真正的IO可能小于上面的情况。</p>
<p>2）聚集索引与插入操作</p>
<p>最简单的情况下，插入操作根据索引找到对应的数据页，然后通过挪动已有的记录为新数据腾出空间，最后插入数据。</p>
<p>如果数据页已满，则需要拆分数据页（页拆分是一种耗费资源的操作，一般数据库系统中会有相应的机制要尽量减少页拆分的次数，通常是通过为每页预留空间来实现）：<br>A）在该使用的数据段（extent）上分配新的数据页，如果数据段已满，则需要分配新段。<br>B）调整索引指针，这需要将相应的索引页读入内存并加锁。<br>C）大约有一半的数据行被归入新的数据页中。<br>D）如果表还有非聚集索引，则需要更新这些索引指向新的数据页。</p>
<p>特殊情况：<br>A）如果新插入的一条记录包含很大的数据，可能会分配两个新数据页，其中之一用来存储新记录，另一存储从原页中拆分出来的数据。<br>B）通常数据库系统中会将重复的数据记录存储于相同的页中。<br>C）类似于自增列为聚集索引的，数据库系统可能并不拆分数据页，页只是简单的新添数据页。</p>
<p>3）聚集索引与删除操作</p>
<p>删除行将导致其下方的数据行向上移动以填充删除记录造成的空白。</p>
<p>如果删除的行是该数据页中的最后一行，那么该数据页将被回收，相应的索引页中的记录将被删除。如果回收的数据页位于跟该表的其它数据页相同的段上，那么它可能在随后的时间内被利用。如果该数据页是该段的唯一一个数据页，则该段也被回收。</p>
<p>对于数据的删除操作，可能导致索引页中仅有一条记录，这时，该记录可能会被移至邻近的索引页中，原索引页将被回收，即所谓的“索引合并”。</p>
<p> <strong>5</strong> <strong>．非聚集索引</strong></p>
<p>非聚集索引与聚集索引相比：<br>A）叶子结点并非数据结点<br>B）叶子结点为每一真正的数据行存储一个“键-指针”对<br>C）叶子结点中还存储了一个指针偏移量，根据页指针及指针偏移量可以定位到具体的数据行。<br>D）类似的，在除叶结点外的其它索引结点，存储的也是类似的内容，只不过它是指向下一级的索引页的。</p>
<p>聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。</p>
<p>对于根与中间级的索引记录，它的结构包括：<br>A）索引字段值<br>B）RowId（即对应数据页的页指针+指针偏移量）。在高层的索引页中包含RowId是为了当索引允许重复值时，当更改数据时精确定位数据行。<br>C）下一级索引页的指针</p>
<p>对于叶子层的索引对象，它的结构包括：<br>A）索引字段值<br>B）RowId</p>
<p> <img src="/assets/wpsC23F.tmp-20211222153838-ccyibjj.jpg"></p>
<p>1）非聚集索引与查询操作</p>
<p>针对上图，如果我们同样查找“Green”，那么一次查询操作将包含以下IO：3个索引页的读取+1个数据页的读取。同样，由于缓存的关系，真实的IO实际可能要小于上面列出的。</p>
<p>2）非聚集索引与插入操作</p>
<p>如果一张表包含一个非聚集索引但没有聚集索引，则新的数据将被插入到最末一个数据页中，然后非聚集索引将被更新。如果也包含聚集索引，该聚集索引将被用于查找新行将要处于什么位置，随后，聚集索引、以及非聚集索引将被更新。</p>
<p>3）非聚集索引与删除操作</p>
<p>如果在删除命令的Where子句中包含的列上，建有非聚集索引，那么该非聚集索引将被用于查找数据行的位置，数据删除之后，位于索引叶子上的对应记录也将被删除。如果该表上有其它非聚集索引，则它们叶子结点上的相应数据也要删除。</p>
<p>如果删除的数据是该数所页中的唯一一条，则该页也被回收，同时需要更新各个索引树上的指针。</p>
<p>由于没有自动的合并功能，如果应用程序中有频繁的随机删除操作，最后可能导致表包含多个数据页，但每个页中只有少量数据。</p>
<p> <strong>6</strong> <strong>．索引覆盖</strong></p>
<p>索引覆盖是这样一种索引策略：当某一查询中包含的所需字段皆包含于一个索引中，此时索引将大大提高查询性能。</p>
<p>包含多个字段的索引，称为复合索引。索引最多可以包含31个字段，索引记录最大长度为600B。如果你在若干个字段上创建了一个复合的非聚集索引，且你的查询中所需Select字段及Where,Order By,Group By,Having子句中所涉及的字段都包含在索引中，则只搜索索引页即可满足查询，而不需要访问数据页。由于非聚集索引的叶结点包含所有数据行中的索引列值，使用这些结点即可返回真正的数据，这种情况称之为“索引覆盖”。</p>
<p>在索引覆盖的情况下，包含两种索引扫描：<br>A）匹配索引扫描<br>B）非匹配索引扫描</p>
<p>1）匹配索引扫描</p>
<p>此类索引扫描可以让我们省去访问数据页的步骤，当查询仅返回一行数据时，性能提高是有限的，但在范围查询的情况下，性能提高将随结果集数量的增长而增长。</p>
<p>针对此类扫描，索引必须包含查询中涉及的的所有字段，另外，还需要满足：Where子句中包含索引中的“引导列”（Leading Column），例如一个复合索引包含A,B,C,D四列，则A为“引导列”。如果Where子句中所包含列是BCD或者BD等情况，则只能使用非匹配索引扫描。</p>
<p>2）非配置索引扫描</p>
<p>正如上述，如果Where子句中不包含索引的导引列，那么将使用非配置索引扫描。这最终导致扫描索引树上的所有叶子结点，当然，它的性能通常仍强于扫描所有的数据页。</p>
<p> <strong>[</strong>  <strong>参考</strong> <strong>]</strong><br>[1]<a href="http://manuals.sybase.com/onlinebooks/group-asarc/asg1200e/aseperf/@Generic__BookTextView/3358">http:&#x2F;&#x2F;manuals.sybase.com&#x2F;onlinebooks&#x2F;group-asarc&#x2F;asg1200e&#x2F;aseperf&#x2F;@Generic__BookTextView&#x2F;3358</a><br>[2] <a href="http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.adref.doc/adref235.htm">http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.adref.doc/adref235.htm</a></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>索引文献</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/09_%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<ol>
<li><p>硬盘基础知识</p>
<ol>
<li><p><img src="/assets/image-20211214105741-2bd570s.png" alt="image.png"><img src="/assets/image-20211214110050-dyzj8it.png" alt="image.png"><img src="/assets/image-20211214110131-aoec4ll.png" alt="image.png"><img src="/assets/image-20211214110109-jox8ouv.png" alt="image.png"></p>
</li>
<li><p>磁盘读响应时间</p>
<ol>
<li><img src="/assets/image-20211214110347-bnejtrz.png" alt="image.png"></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>磁盘</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>网络技术</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/01_%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>网络技术（TCP&#x2F;UDP）</p>
<p>原理图</p>
<p><img src="/assets/image-20211120110955-m8jreyh.png" alt="image.png"></p>
<pre><code>课程目标
    osi 七层模型以及数据传输过程
    网络层协议重点协议--ARP，IP，路由协议
    传输层重点协议--TCP,UDP
    应用层重点协议--HTTP
    应用层重点协议--HTTPS
    抓包工具wireshark的使用  ：((20211120111353-joikthh &quot;安装&quot;))

        前期是为了实现两台机器互联，规范--同意标准实现通信
    ![image.png](assets/image-20211120112125-q8unjrt.png)
</code></pre>
<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><h2 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h2><p>通过定义各种应用协议规范数据格式：http协议，https协议，ftp协议，dns协议，smtp协议等等<br /></p>
<h2 id="表示层："><a href="#表示层：" class="headerlink" title="表示层："></a>表示层：</h2><p>翻译工作，提供一种公共语言，通信<br /></p>
<h2 id="会话层："><a href="#会话层：" class="headerlink" title="会话层："></a>会话层：</h2><p>1.可以从校验点继续恢复数据进行重传。2.自动收发包，自动寻址的功能	网络中大文件数据传输，相当于续传</p>
<h2 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h2><p>1.对发送数据进行封装，—TCP,UDP协议，一个一个按顺序依次发送2.两个应用程序（QQ–QQ0），定义端口的概念，寻找到对应程序，进行数据处理</p>
<h2 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h2><p>1.怎么知道对方的MAC地址—-ARP (ADDRESS RESOLUTION PROTOCOL),通过IP地址知晓MAC;–包<br>2.判断是否在同一个子网，—-IP协议</p>
<p>3.怎么选择最优路径 —- 一组协议 路由协议 静态路由 动态路由 （RIP,OSPF,BGP）。</p>
<h2 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h2><p>1.比特流进行处理：分组。8位一组–一个字节，依次按顺序发送数据—帧2.MAC地址。–网卡-身份证（唯一性）。寄件人地址+收件人地址</p>
<h2 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h2><p>互联物理链路，物理介质。网线（双绞线），光纤，无线电波–可实现基本连接<br>存在形式：计算机语言（010010101110001）二进制，–电信号–在网络中叫比特流</p>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>1.实现两台机器互联，及其与机器之间通信–物理层<br>2.0101010比特流其实是没有什么意义的数据，变成有意义的数据–数据链路层<br>3.主机A-B，C,D,E-主机F    – 路径有很多条，怎么选择最优路径，要怎么知道反对方的MAC地址–网络层<br>4.发送数据特别多，数据包很大，需要长时间，中间网络中断，重传？？ —传输层<br>5.断点续传功能—会话层实现<br>6.操作系统，windows10，macos，linux，语法是不一样的，不同的系统之间进行通信–表示层<br>7.字节流的格式，不好识别，不好操作，浏览器操作–应用层操作</p>
<p>TCP&#x2F;IP四层模型    VS    ISO七层模型<br>        <img src="/assets/image-20211120112647-ybjw1zn.png" alt="image.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code>数据传输过程
</code></pre>
<p><img src="/assets/image-20211120112150-l4p7m20.png" alt="image.png"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>课中</category>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark介绍</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/02_wireshark%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>wireshark的官方下载网站： <a href="http://www.wireshark.org/">http://www.wireshark.org/</a></p>
<p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。</p>
<p>wireshark是开源软件，可以放心使用。 可以运行在Windows和Mac OS上。</p>
<p>使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。</p>
<h1 id="Wireshark不能做的"><a href="#Wireshark不能做的" class="headerlink" title="Wireshark不能做的"></a><strong>Wireshark不能做的</strong></h1><p>为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p>
<h1 id="Wireshark-VS-Fiddler"><a href="#Wireshark-VS-Fiddler" class="headerlink" title="Wireshark VS Fiddler"></a><strong>Wireshark VS Fiddler</strong></h1><p>Fiddler是在windows上运行的程序，专门用来捕获HTTP，HTTPS的。</p>
<p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容</p>
<p>总结，如果是处理HTTP,HTTPS 还是用Fiddler,  其他协议比如TCP,UDP 就用wireshark</p>
<h1 id="同类的其他工具"><a href="#同类的其他工具" class="headerlink" title="同类的其他工具"></a><strong>同类的其他工具</strong></h1><p>微软的network monitor</p>
<p>sniffer</p>
<h1 id="什么人会用到wireshark"><a href="#什么人会用到wireshark" class="headerlink" title="什么人会用到wireshark"></a><strong>什么人会用到wireshark</strong></h1><ol>
<li>网络管理员会使用wireshark来检查网络问题</li>
<li>软件测试工程师使用wireshark抓包，来分析自己测试的软件</li>
<li>从事socket编程的工程师会用wireshark来调试</li>
<li>听说，华为，中兴的大部分工程师都会用到wireshark。</li>
</ol>
<p>总之跟网络相关的东西，都可能会用到wireshark.</p>
<h1 id="wireshark-开始抓包"><a href="#wireshark-开始抓包" class="headerlink" title="wireshark 开始抓包"></a><strong>wireshark 开始抓包</strong></h1><p>开始界面</p>
<p><img src="/assets/wps223.tmp-20211222150251-4msi772.jpg"></p>
<p>wireshark是捕获机器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要选择一个网卡。</p>
<p>点击Caputre-&gt;Interfaces.. 出现下面对话框，选择正确的网卡。然后点击”Start”按钮, 开始抓包</p>
<p><img src="/assets/wps224.tmp-20211222150251-8mp50nu.jpg"></p>
<h1 id="Wireshark-窗口介绍"><a href="#Wireshark-窗口介绍" class="headerlink" title="Wireshark 窗口介绍"></a><strong>Wireshark 窗口介绍</strong></h1><p><img src="/assets/wps225.tmp-20211222150251-8ptmq5c.jpg"></p>
<p>WireShark 主要分为这几个界面</p>
<ol>
<li>Display Filter(显示过滤器)，  用于过滤</li>
<li>Packet List Pane(封包列表)， 显示捕获到的封包， 有源地址和目标地址，端口号。 颜色不同，代表</li>
<li>Packet Details Pane(封包详细信息), 显示封包中的字段</li>
<li>Dissector Pane(16进制数据)</li>
<li>Miscellanous(地址栏，杂项)</li>
</ol>
<h1 id="Wireshark-显示过滤"><a href="#Wireshark-显示过滤" class="headerlink" title="Wireshark 显示过滤"></a><strong>Wireshark 显示过滤</strong></h1><p><img src="/assets/wps226.tmp-20211222150251-ih9fas3.jpg"></p>
<p>使用过滤是非常重要的， 初学者使用wireshark时，将会得到大量的冗余信息，在几千甚至几万条记录中，以至于很难找到自己需要的部分。搞得晕头转向。</p>
<p>过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。</p>
<p>过滤器有两种，</p>
<p>一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录</p>
<p>一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。 在Capture -&gt; Capture Filters 中设置</p>
<h1 id="保存过滤"><a href="#保存过滤" class="headerlink" title="保存过滤"></a><strong>保存过滤</strong></h1><p>在Filter栏上，填好Filter的表达式后，点击Save按钮， 取个名字。比如”Filter 102”,</p>
<p><img src="/assets/wps227.tmp-20211222150251-vuhqcm5.jpg"></p>
<p>Filter栏上就多了个”Filter 102” 的按钮。</p>
<p><img src="/assets/wps228.tmp-20211222150251-vqp495b.jpg"></p>
<h1 id="过滤表达式的规则"><a href="#过滤表达式的规则" class="headerlink" title="过滤表达式的规则"></a><strong>过滤表达式的规则</strong></h1><p>表达式规则</p>
<ol>
<li>协议过滤</li>
</ol>
<p>比如TCP，只显示TCP协议。</p>
<ol start="2">
<li>IP 过滤</li>
</ol>
<p>比如 ip.src &#x3D;&#x3D;192.168.1.102 显示源地址为192.168.1.102，</p>
<p>ip.dst&#x3D;&#x3D;192.168.1.102, 目标地址为192.168.1.102</p>
<ol start="3">
<li>端口过滤</li>
</ol>
<p>tcp.port &#x3D;&#x3D;80,  端口为80的</p>
<p>tcp.srcport &#x3D;&#x3D; 80,  只显示TCP协议的愿端口为80的。</p>
<ol start="4">
<li>Http模式过滤</li>
</ol>
<p>http.request.method&#x3D;&#x3D;”GET”,   只显示HTTP GET方法的。</p>
<ol start="5">
<li>逻辑运算符为 AND&#x2F; OR</li>
</ol>
<p>常用的过滤表达式</p>
<table>
<thead>
<tr>
<th>过滤表达式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>http</td>
<td>只查看HTTP协议的记录</td>
</tr>
<tr>
<td>ip.src &#x3D;&#x3D;192.168.1.102 or ip.dst&#x3D;&#x3D;192.168.1.102</td>
<td>源地址或者目标地址是192.168.1.102</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="封包列表-Packet-List-Pane"><a href="#封包列表-Packet-List-Pane" class="headerlink" title="封包列表(Packet List Pane)"></a><strong>封包列表(Packet List Pane)</strong></h1><p>封包列表的面板中显示，编号，时间戳，源地址，目标地址，协议，长度，以及封包信息。 你可以看到不同的协议用了不同的颜色显示。</p>
<p>你也可以修改这些显示颜色的规则，  View -&gt;Coloring Rules.</p>
<p><img src="/assets/wps229.tmp-20211222150251-4lpd7s0.jpg"></p>
<h1 id="封包详细信息-Packet-Details-Pane"><a href="#封包详细信息-Packet-Details-Pane" class="headerlink" title="封包详细信息 (Packet Details Pane)"></a><strong>封包详细信息 (Packet Details Pane)</strong></h1><p>这个面板是我们最重要的，用来查看协议中的每一个字段。</p>
<p>各行信息分别为</p>
<p>Frame:   物理层的数据帧概况</p>
<p>Ethernet II: 数据链路层以太网帧头部信息</p>
<p>Internet Protocol Version 4: 互联网层IP包头部信息</p>
<p>Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP</p>
<p>Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议</p>
<h1 id="wireshark与对应的OSI七层模型"><a href="#wireshark与对应的OSI七层模型" class="headerlink" title="wireshark与对应的OSI七层模型"></a><strong>wireshark与对应的OSI七层模型</strong></h1><p><img src="/assets/wps22A.tmp-20211222150252-f5a714s.jpg"></p>
<h1 id="TCP包的具体内容"><a href="#TCP包的具体内容" class="headerlink" title="TCP包的具体内容"></a><strong>TCP包的具体内容</strong></h1><p> 从下图可以看到wireshark捕获到的TCP包中的每个字段。</p>
<p><img src="/assets/wps22B.tmp-20211222150252-ful58qc.jpg"></p>
<h1 id="实例分析TCP三次握手过程"><a href="#实例分析TCP三次握手过程" class="headerlink" title="实例分析TCP三次握手过程"></a><strong>实例分析TCP三次握手过程</strong></h1><p>看到这， 基本上对wireshak有了初步了解， 现在我们看一个TCP三次握手的实例</p>
<p> 三次握手过程为</p>
<p><img src="/assets/wps22C.tmp-20211222150252-2d6j1q0.jpg"></p>
<p>这图我都看过很多遍了， 这次我们用wireshark实际分析下三次握手的过程。</p>
<p>打开wireshark, 打开浏览器输入 <a href="http://www.cnblogs.com/tankxiao">http://www.cnblogs.com/tankxiao</a></p>
<p>在wireshark中输入http过滤， 然后选中GET &#x2F;tankxiao HTTP&#x2F;1.1的那条记录，右键然后点击”Follow TCP Stream”,</p>
<p>这样做的目的是为了得到与浏览器打开网站相关的数据包，将得到如下图</p>
<p><img src="/assets/wps22D.tmp-20211222150252-oq4qbxm.jpg"></p>
<p>图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。</p>
<p>第一次握手数据包</p>
<p>客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图</p>
<p><img src="/assets/wps22E.tmp-20211222150252-ozixvlj.jpg"></p>
<p>第二次握手的数据包</p>
<p>服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1&#x3D;1, 如下图</p>
<p><img src="/assets/wps22F.tmp-20211222150252-6x3zq2e.jpg"></p>
<p>第三次握手的数据包</p>
<p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图:</p>
<p><img src="/assets/wps230.tmp-20211222150252-1xrltr9.jpg"></p>
<p> 就这样通过了TCP三次握手，建立了连接</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>wireshark介绍</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/04_%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<ul>
<li><p>TCP协议</p>
<ul>
<li><p>定义</p>
<ul>
<li>TCP（Transmission Control Protocol），传输控制协议，顾名思义，就是要对数据的传输进行一定的控制</li>
</ul>
</li>
<li><p>TCP协议头部组成部分</p>
<ul>
<li><p><img src="/assets/image-20211120135744-9acv70f.png" alt="image.png"></p>
</li>
<li><p>序号</p>
<ul>
<li>sequence number</li>
<li>编号：TCP数据包过大，需分段（10段）—（到达目的主机）按照顺序重组，</li>
</ul>
</li>
<li><p>确认号</p>
<ul>
<li><p>acknowledge number</p>
</li>
<li><p>服务器能否回应？—存在于确认消息里</p>
</li>
<li><p>跟序号有什么关系</p>
<ul>
<li>依据序号生成   序号+1    表示服务器期望收到你的下一个包的序号</li>
</ul>
</li>
</ul>
</li>
<li><p>状态控制码（code control flag）1 or 0（1表示打开，0表示关闭（表示数据包的类型））</p>
</li>
</ul>
</li>
<li><p>备注</p>
<ul>
<li>实现原理过程：HTTP,HTTPS协议—-基于TCP协议；client —百度服务器：TCP协议–交互和连接 —HTTP,HTTPS协议交互</li>
</ul>
</li>
<li><p>TCP协议连接</p>
<ul>
<li><p>TCP连接请求：TCP三次握手过程（新建连接），TCP四次挥手（断开连接）</p>
</li>
<li><p>TCP三次握手</p>
<ul>
<li><p><img src="/assets/image-20211120135957-moi5rq0.png" alt="image.png"></p>
</li>
<li><p>例</p>
<ul>
<li><img src="/assets/image-20211120140009-m2lc65n.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>TCP四次挥手</p>
<ul>
<li><p><img src="/assets/image-20211120140016-u5m759r.png" alt="image.png"></p>
</li>
<li><p>例</p>
<ul>
<li><img src="/assets/image-20211120140027-yydd5yd.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>抓包</p>
<ul>
<li>wireshark</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP协议</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>UDP（User Datageam Protocol）用户数据报协议</p>
</li>
<li><p><img src="/assets/image-20211120140103-wikw2g0.png" alt="image.png"></p>
</li>
<li><p>没有 序号，确认号（重传）标志 等</p>
</li>
<li><p>UDP协议不会建立连接–无连接传输协议-不可靠的协议，容易丢包</p>
</li>
<li><p>UDP场景</p>
<ul>
<li><p>1。不需要可靠机制，只要求速度快—UDP协议</p>
</li>
<li><p>2.流媒体，多媒体游戏，IP电话     </p>
<ul>
<li>UDP协议封装</li>
</ul>
</li>
<li><p>3.资源消耗特别小</p>
</li>
</ul>
</li>
<li><p>UDP应用协议</p>
<ul>
<li>DNS(域名解析协议),SNMP(简单网络管理协议)，DHCP(动态获取IP),RIP  –UDP协议</li>
</ul>
</li>
<li><p>TCP应用协议</p>
<ul>
<li>HTTP,HTTPS,FTP</li>
</ul>
</li>
<li><p>实操</p>
<ul>
<li><p>结合cmd+wireshark</p>
<ul>
<li>cmd：ping <a href="http://www.baidu,com/">www.baidu,com</a></li>
<li>wireshark: 抓取dns（UDP）包</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/assets/image-20211122192010-wrkiio4.png" alt="image.png"></p>
<ol>
<li>tcp是面向连接的，所有tcp三次握手和四次挥手的过程 —-|||—-udp无连接协议</li>
<li>tcp因为有可靠的连接机制&#x3D;&#x3D;&#x3D;可靠协议—-|||—-udp没有连接和确认机制&#x3D;&#x3D;会丢包会出错 不可靠的协议</li>
<li>tcp协议：数据量很大，防止丢包正确重传对数据的正确性很关心—-|||—-udp量小</li>
<li>速度：tcp协议速度很慢—-|||—-udp速度很快，传输效率很高</li>
</ol>
]]></content>
      <categories>
        <category>课中</category>
        <category>传输层</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/03_%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<ul>
<li><p>ARP协议</p>
<ul>
<li><p>ARP–定义</p>
<ul>
<li>ARP–地址解析协议（Address Resolution Protocol），实现通过对方IP地址（域名）寻找对方的MAC地址– ARP的功能</li>
</ul>
</li>
<li><p>例</p>
<ul>
<li><img src="/assets/image-20211120113425-tvawmj4.png" alt="image.png"></li>
<li><img src="/assets/image-20211120113433-gnbk314.png" alt="image.png"></li>
</ul>
</li>
<li><p>ARP协议的工作流程</p>
<ul>
<li>1.主机A首先查看自己的ARP表，如果找到了的主机B的MAC地址，则直接对IP数据包进行帧封装，发送给主机B</li>
<li>2.如果主机A在ARP表中找不到主机B的MAC地址，则将缓存改数据报文，然后以广播的方式发送一个ARP请求报文，ARP请求报文中带上源IP地址和MAC地址（主机A），目标IP地址和目标MAC地址为主机B的IP和全0的MAC地址。广播，该网段上的所有主机都可以接受到该请求，但只有被请求的主机（即主机B）会对该请求进行处理</li>
<li>3.主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中，之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MA地址。</li>
<li>4.主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li><p>电脑打开cmd</p>
<ul>
<li>arp-a        查看表中连接信息</li>
<li>arp -d *    删除ARP缓存列表的命令</li>
</ul>
</li>
<li><p>抓包</p>
<ul>
<li><p>wireshark    选中对应的网卡，点击开始抓包</p>
<ul>
<li><img src="/assets/image-20211120113803-tfdrmv8.png" alt="image.png"></li>
<li>fram 物理层<br>Ethernet II 数据链路层<br>address resolution protocol</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>IP协议</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>IP（Internet Protocol），分配给用户上网使用国际协议的设备的数字标签，分为两大类：IPV4 和IPV6</p>
</li>
<li><p>分别</p>
<ul>
<li><p>IPV4</p>
<ul>
<li>32位，<br>二进制:11000000.10101000.00000001.00000001，<br>十进制：192.168.1.1</li>
</ul>
</li>
<li><p>IPV6</p>
<ul>
<li>目的为了弥补IPV4地址池不够的缺陷–IPV4 数量有限<br>128位–有更多的IP地址<br>16进制:2001:ffdd:asdf:asde</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>IP地址的组成</p>
<ul>
<li>IP地址由32bit组成，分为4段并用，使用“.”分隔：192.168.1.1</li>
<li><img src="/assets/image-20211120114039-rhuojhj.png" alt="image.png"></li>
</ul>
</li>
<li><p>子网掩码</p>
<ul>
<li><p>前置</p>
<ul>
<li>IP 没有办法进行判断，不能确定子网掩码</li>
<li>子网掩码表示子网</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>用来标识子网，必须跟IP地址一起存在</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li>子网掩码跟IP地址一样，也是由连续的1和0组成，连续的1表示网络地址，连续的0表示主机地址，只有网络地址相同的主机在同一子网，才能直接通信</li>
</ul>
</li>
<li><p>表示方法</p>
<ul>
<li>255.255.255.0，或者&#x2F;24.</li>
<li>二进制   11111111.11111111.11111111.00000000</li>
</ul>
</li>
</ul>
</li>
<li><p>案例</p>
<ul>
<li><img src="/assets/image-20211120114205-k6z43al.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>路由协议</p>
<ul>
<li><p>前置   不在一个子网，怎么通信？–路由协议完成</p>
</li>
<li><p>定义</p>
<ul>
<li><p>路由协议（Routing protocol），指定数据包转送方式的网上协议</p>
</li>
<li><p>分类</p>
<ul>
<li><p>静态路由协议</p>
<ul>
<li>指定目的地址—指定下一跳<br>默认路由（0.0.0.0.0.0.0.0-匹配所有）（主机–默认网关–做详细的路由选择）</li>
</ul>
</li>
<li><p>动态路由协议（RIP（V1 V2）,OSPF,BGP）</p>
<ul>
<li>动态路由协议，配置之后，动态学习路由条目–路由表</li>
</ul>
</li>
</ul>
</li>
<li><p>cmd命令</p>
<ul>
<li>route print   打开路由表</li>
<li>网络目标   目的地址</li>
<li>网络掩码</li>
<li>网关     下一跳</li>
<li>接口</li>
<li>跃点数      路由的优先级   跳跃数越小优先级越高</li>
<li><img src="/assets/image-20211122191712-ani9owc.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课中</category>
        <category>网络层</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/05_%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<ul>
<li><p>HTTP</p>
<ul>
<li><p>HTTP定义</p>
<ul>
<li>HTTP协议  （Hyper Text Transfer Protocol） 超文本传输协议</li>
<li>HTTP协议是基于TCP协议，默认是80端口—可靠的协议</li>
<li>功能：用来规定客户端和服务端的数据传输格式</li>
<li>特点：基于请求和响应模式的、无状态、无连接的应用层协议</li>
<li><img src="/assets/image-20211120140426-37e7idv.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP请求（基于请求和响应模式）</p>
<ul>
<li><p>请求行</p>
<ul>
<li><img src="/assets/image-20211120140500-njj9r9v.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP请求的方法</p>
<ul>
<li><img src="/assets/image-20211120140507-qxa6kew.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP请求头内容</p>
<ul>
<li><img src="/assets/image-20211120140514-odif7ya.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP响应行</p>
<ul>
<li><img src="/assets/image-20211120140522-1oq96m8.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP响应头</p>
<ul>
<li><img src="/assets/image-20211120140528-ufuwkma.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议–无连接应用协议</p>
<ul>
<li><p>定义</p>
<ul>
<li>无状态应用协议解释：<br>1.对事物处理没有记忆功能，服务器不知道客户端是什么状态，给服务器发送http请求之后，服务器回应之后，不会有任何记录；<br>2.每次请求都是独立的<br>特点：服务器处理后续请求-前面的请求信息–重传</li>
<li>优点：释放了服务器的压力</li>
<li>缺点：数据重传–重复的内容，增大数据传输量，资源浪费</li>
<li>动态交互：淘宝：购物车功能–商品信息      登录：login–后续操作（充值）<br>—cookies<br>—session</li>
<li>限制每次连接只处理一个请求</li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接</li>
</ul>
</li>
<li><p>初衷</p>
<ul>
<li>用户量（十万、上百万）页面请求，单个用户间歇性大（突发性，瞬时性），数据没有关联性，—资源浪费&#x3D;&#x3D;&#x3D;设计：释放连接</li>
<li>问题：网页越来越复杂，–图片–效率低&#x3D;&#x3D;&#x3D;头部信息keep-alive 放在connection中</li>
</ul>
</li>
<li><p>keep-alive设置</p>
<ul>
<li><p>1。开启：connection：keep-alive ，会发起keep-alive的连接请求–长链接。http1.1-默认打开的</p>
<ul>
<li>不需要重新建立连接<br /></li>
</ul>
</li>
<li><p>2。关闭：在http请求头中设置connection：close，即可关闭</p>
</li>
<li><p>3。设置连接时间：</p>
<ul>
<li>在http header中设置keep-alive：timeout&#x3D;5，max&#x3D;1000<br>timeout是超时时间，单位秒，超过这个时间后就会断开–释放<br>max是最多的连接次数，若超过这个次数就强制断开连接<br /></li>
</ul>
</li>
</ul>
</li>
<li><p>cookies</p>
<ul>
<li>将前面请求信息保存成一个临时文件–cookies值，—存放在浏览器里，如淘宝购物车：写进入cookies；<br>登录：充值 先登录在充值，从login获取登录的账号信息保留到cookies值中</li>
<li>关闭浏览器会被删除</li>
<li>清除缓存会被删除</li>
</ul>
</li>
<li><p>session</p>
<ul>
<li>永久的ciikies值</li>
<li>session ID（会话编号）–保存在服务器上–传给客户端。客户端浏览器保存在内存里</li>
<li>问题：资源占用。设置session超时时间–可清除sessionID</li>
</ul>
</li>
<li><p>http协议问题</p>
<ul>
<li>发送数据都是明文，第三方窃听，窃取数据包，伪装客户端    对数据包进行篡改数据-服务器不知道<br>存在安全隐患<br>解决方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTPS</p>
<ul>
<li><p>概念：HTTPS（Hypertext Transfer Protocol Secure）超文本传输安全协议，是以安全为目的HTTP通道，简单讲是HTTP的安全版本。<br>它加密数据并确保其机密性–加密，数据密文；<br>可保护用户在与网站交互时免于窃取个人信息和计费信息数据–身份认证；<br>防止信息被篡改–完整性–安全保障</p>
</li>
<li><p><img src="/assets/image-20211120140837-24axt48.png" alt="image.png"></p>
<ul>
<li><p>http+加密+身份认证+完整性保护&#x3D;HTTPS</p>
<ul>
<li>过程原理（交互）</li>
<li><img src="/assets/image-20211120141019-dohg0nx.png" alt="image.png"></li>
<li><img src="/assets/image-20211120141023-o1pbp6b.png" alt="image.png"></li>
<li><img src="/assets/image-20211122192944-z4bp9fx.png" alt="image.png"></li>
</ul>
</li>
<li><p>wireshark实例</p>
<ul>
<li><p>追踪流-TLS流</p>
<ul>
<li>看到完整ssl交互的过程</li>
</ul>
</li>
<li><p>客户端加密套件（支持的列表）</p>
<ul>
<li><img src="/assets/image-20211120141054-sbng2g0.png" alt="image.png"></li>
</ul>
</li>
<li><p>服务端加密套件（支持的）</p>
<ul>
<li><img src="/assets/image-20211120141101-l8s4ytc.png" alt="image.png"></li>
</ul>
</li>
<li><p>服务端发送证书</p>
<ul>
<li><img src="/assets/image-20211120141111-mdx3djr.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><p>tls是ssl协议的版本</p>
<ul>
<li>sslv3，tls1.0，tls1.2</li>
</ul>
</li>
<li><p>加密：–秘钥+身份认证+证书（权威机构颁发（申请）&#x3D;&#x3D;双向认证）+完整性保护（哈希算法–计算一个hash值，验证消息的完整性）<br /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议VS  HTTPS 协议</p>
<ul>
<li><img src="/assets/image-20211120141142-x6tlrun.png" alt="image.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课中</category>
        <category>应用层</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议详解</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/01_HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a><strong>什么是HTTP协议</strong></h1><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</p>
<p>目前我们使用的是HTTP&#x2F;1.1 版本</p>
<h1 id="Web服务器，浏览器-代理服务器"><a href="#Web服务器，浏览器-代理服务器" class="headerlink" title="Web服务器，浏览器,代理服务器"></a><strong>Web服务器，浏览器,代理服务器</strong></h1><p>当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？</p>
<p>实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示</p>
<p><img src="/assets/wps81FC.tmp-20211222150430-3fflmhm.png"></p>
<p>我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。</p>
<p>过程如下图所示</p>
<p><img src="/assets/wps820D.tmp-20211222150430-jrbyasx.jpg"></p>
<p>代理服务器就是网络信息的中转站，有什么功能呢？</p>
<ol>
<li>提高访问速度， 大多数的代理服务器都有缓存功能。</li>
<li>突破限制， 也就是FQ了</li>
<li>隐藏身份。</li>
</ol>
<h1 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a><strong>URL详解</strong></h1><p> URL(Uniform Resource Locator) 地址用于描述一个网络上的资源,  基本格式如下</p>
<p>schema:&#x2F;&#x2F;host[:port#]&#x2F;path&#x2F;…&#x2F;[?query-string][#anchor]</p>
<p>scheme               指定低层使用的协议(例如：http, https, ftp)</p>
<p>host                   HTTP服务器的IP地址或者域名</p>
<p>port#                 HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/">http://www.cnblogs.com:8080/</a></p>
<p>path                   访问资源的路径</p>
<p>query-string       发送给http服务器的数据</p>
<p>anchor-             锚</p>
<p>URL 的一个例子</p>
<p><img src="/assets/wps820E.tmp-20211222150430-vxxzzyy.png"></p>
<p><a href="http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff">http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</a></p>
<p>Schema:                 http<br>host:                   <a href="http://www.mywebsite.com/">www.mywebsite.com</a><br>path:                   &#x2F;sj&#x2F;test&#x2F;test.aspx<br>Query String:           name&#x3D;sviergn&amp;x&#x3D;true<br>Anchor:                 stuff</p>
<p><img src="/assets/wps820F.tmp-20211222150430-que97w7.png"></p>
<h1 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a><strong>HTTP协议是无状态的</strong></h1><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p>
<h1 id="打开一个网页需要浏览器发送很多次Request"><a href="#打开一个网页需要浏览器发送很多次Request" class="headerlink" title="打开一个网页需要浏览器发送很多次Request"></a><strong>打开一个网页需要浏览器发送很多次Request</strong></h1><ol>
<li>当你在浏览器输入URL <a href="http://www.cnblogs.com/">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com/">http://www.cnblogs.com</a> 的html.  服务器把Response发送回给浏览器.</li>
<li>浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。</li>
<li>浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</li>
<li>等所有的文件都下载成功后。 网页就被显示出来了。</li>
</ol>
<h1 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a><strong>HTTP消息的结构</strong></h1><p>先看Request 消息的结构,   Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图</p>
<p><img src="/assets/wps8210.tmp-20211222150430-r1erjah.jpg"></p>
<p>第一行中的Method表示请求方法,比如”POST”,”GET”,  Path-to-resoure表示请求的资源， Http&#x2F;version-number 表示HTTP协议的版本号</p>
<p>当使用的是”GET” 方法的时候， body是为空的</p>
<p>比如我们打开博客园首页的request 如下</p>
<p>GET <a href="http://www.cnblogs.com/">http://www.cnblogs.com/</a> HTTP&#x2F;1.1<br>Host: <a href="http://www.cnblogs.com/">www.cnblogs.com</a></p>
<p>抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response.</p>
<p>下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息，   如下图</p>
<p><img src="/assets/wps8211.tmp-20211222150430-ey18q0p.jpg"></p>
<p>我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行,  结构如下图</p>
<p><img src="/assets/wps8212.tmp-20211222150430-vl2gmcd.jpg"></p>
<p>HTTP&#x2F;version-number表示HTTP协议的版本号，  status-code 和message 请看下节[<a href="#statecode">状态代码</a>]的详细解释.</p>
<p>我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息，   如下图</p>
<p><img src="/assets/wps8213.tmp-20211222150430-4yjwq5a.jpg"></p>
<h1 id="Get和Post方法的区别"><a href="#Get和Post方法的区别" class="headerlink" title="Get和Post方法的区别"></a><strong>Get和Post方法的区别</strong></h1><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息.</p>
<p>我们看看GET和POST的区别</p>
<ol>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456.  POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li>
</ol>
<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><strong>状态码</strong></h1><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
<p>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p>
<p>HTTP&#x2F;1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p>
<p>1XX  提示信息 - 表示请求已被成功接收，继续处理</p>
<p>2XX  成功 - 表示请求已被成功接收，理解，接受</p>
<p>3XX  重定向 - 要完成请求必须进行更进一步的处理</p>
<p>4XX  客户端错误 -  请求有语法错误或请求无法实现</p>
<p>5XX  服务器端错误 -   服务器未能实现合法的请求</p>
<p>看看一些常见的状态码</p>
<p>200 OK</p>
<p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p>
<p>如下图， 打开博客园首页</p>
<p><img src="/assets/wps8214.tmp-20211222150430-lm5mp15.jpg"></p>
<p>302 Found</p>
<p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request</p>
<p>例如在IE中输入， <a href="http://www.google.com/">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p>
<p><img src="/assets/wps8215.tmp-20211222150430-s198i48.jpg"></p>
<p>304 Not Modified</p>
<p>代表上次的文档已经被缓存了， 还可以继续使用，</p>
<p>例如打开博客园首页, 发现很多Response 的status code 都是304</p>
<p><img src="/assets/wps8216.tmp-20211222150430-xzo1alf.jpg"></p>
<p>提示：　如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面</p>
<p>400 Bad Request  客户端请求与语法错误，不能被服务器所理解</p>
<p>403 Forbidden 服务器收到请求，但是拒绝提供服务</p>
<p>404 Not Found</p>
<p>请求资源不存在（输错了URL）</p>
<p>比如在IE中输入一个错误的URL， <a href="http://www.cnblogs.com/tesdf.aspx">http://www.cnblogs.com/tesdf.aspx</a></p>
<p><img src="/assets/wps8217.tmp-20211222150430-14s4kkp.jpg"></p>
<p>500 Internal Server Error 服务器发生了不可预期的错误</p>
<p>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<h1 id="HTTP-Request-header"><a href="#HTTP-Request-header" class="headerlink" title="HTTP Request header"></a><strong>HTTP Request header</strong></h1><p>使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers  如下图所示.</p>
<p><img src="/assets/wps8218.tmp-20211222150430-dika77y.jpg"></p>
<p>header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p>
<h2 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a><strong>Cache 头域</strong></h2><p>If-Modified-Since</p>
<p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p>
<p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</p>
<p>实例如下图</p>
<p><img src="/assets/wps8229.tmp-20211222150430-tgwstoq.jpg"></p>
<p>If-None-Match</p>
<p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能</p>
<p>例如: If-None-Match: “03f2b33c0bfcc1:0”</p>
<p>实例如下图</p>
<p><img src="/assets/wps822A.tmp-20211222150430-hxee3yt.jpg"></p>
<p>Pragma</p>
<p>作用： 防止页面被缓存， 在HTTP&#x2F;1.1版本中，它和Cache-Control:no-cache作用一模一样</p>
<p>Pargma只有一个用法， 例如： Pragma: no-cache</p>
<p>注意: 在HTTP&#x2F;1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p>
<p>Cache-Control</p>
<p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p>
<p>Cache-Control:Public   可以被任何缓存所缓存（）</p>
<p>Cache-Control:Private     内容只缓存到私有缓存中</p>
<p>Cache-Control:no-cache  所有内容都不会被缓存</p>
<p>还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料</p>
<h2 id="Client-头域"><a href="#Client-头域" class="headerlink" title="Client 头域"></a><strong>Client 头域</strong></h2><p>Accept</p>
<p>作用： 浏览器端可以接受的媒体类型,</p>
<p>例如：  Accept: text&#x2F;html  代表浏览器可以接受服务器回发的类型为 text&#x2F;html  也就是我们常说的html文档,</p>
<p>如果服务器无法返回text&#x2F;html类型的数据,服务器应该返回一个406错误(non acceptable)</p>
<p>通配符 * 代表任意类型</p>
<p>例如  Accept: <em>&#x2F;</em>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p>
<p>Accept-Encoding：</p>
<p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;</p>
<p>例如： Accept-Encoding: gzip, deflate</p>
<p>Accept-Language</p>
<p>作用： 浏览器申明自己接收的语言。</p>
<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p>
<p>例如： Accept-Language: en-us</p>
<p>User-Agent</p>
<p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>
<p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p>
<p>例如： User-Agent: Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p>
<p>Accept-Charset</p>
<p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</p>
<p>例如：</p>
<h2 id="Cookie-x2F-Login-头域"><a href="#Cookie-x2F-Login-头域" class="headerlink" title="Cookie&#x2F;Login 头域"></a><strong>Cookie&#x2F;Login 头域</strong></h2><p>Cookie:</p>
<p>作用： 最重要的header, 将cookie的值发送给HTTP 服务器</p>
<h2 id="Entity头域"><a href="#Entity头域" class="headerlink" title="Entity头域"></a><strong>Entity头域</strong></h2><p>Content-Length</p>
<p>作用：发送给HTTP服务器数据的长度。</p>
<p>例如： Content-Length: 38</p>
<p>Content-Type</p>
<p>作用：</p>
<p>例如：Content-Type: application&#x2F;x-www-form-urlencoded</p>
<h2 id="Miscellaneous-头域"><a href="#Miscellaneous-头域" class="headerlink" title="Miscellaneous 头域"></a><strong>Miscellaneous 头域</strong></h2><p>Referer:</p>
<p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>
<p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p>
<h2 id="Transport-头域"><a href="#Transport-头域" class="headerlink" title="Transport 头域"></a><strong>Transport 头域</strong></h2><p>Connection</p>
<p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<p>Host（发送请求时，该报头域是必需的）</p>
<p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>
<p>例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html">http://www.guet.edu.cn/index.html</a></p>
<p>浏览器发送的请求消息中，就会包含Host请求报头域，如下：</p>
<p>Host：<a href="http://www.guet.edu.cn/">http://www.guet.edu.cn</a></p>
<p>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p>
<h1 id="HTTP-Response-header"><a href="#HTTP-Response-header" class="headerlink" title="HTTP Response header"></a><strong>HTTP Response header</strong></h1><p>同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers  如下图所示</p>
<p><img src="/assets/wps822B.tmp-20211222150430-rnrd88w.jpg"></p>
<p> 我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p>
<h2 id="Cache头域"><a href="#Cache头域" class="headerlink" title="Cache头域"></a><strong>Cache头域</strong></h2><p>Date</p>
<p>作用:  生成消息的具体时间和日期</p>
<p>例如：　Date: Sat, 11 Feb 2012 11:35:14 GMT</p>
<p>Expires</p>
<p>作用: 浏览器会在指定过期时间内使用本地缓存</p>
<p>例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</p>
<p>Vary</p>
<p>作用：</p>
<p>例如: Vary: Accept-Encoding</p>
<h2 id="Cookie-x2F-Login-头域-1"><a href="#Cookie-x2F-Login-头域-1" class="headerlink" title="Cookie&#x2F;Login 头域"></a><strong>Cookie&#x2F;Login 头域</strong></h2><p>P3P</p>
<p>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p>
<p>例如: P3P: CP&#x3D;CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p>
<p>Set-Cookie</p>
<p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p>
<p>例如: Set-Cookie: sc&#x3D;4c31523a; path&#x3D;&#x2F;; domain&#x3D;.acookie.taobao.com</p>
<p><img src="/assets/wps822C.tmp-20211222150430-bknlpw2.jpg"></p>
<h2 id="Entity头域-1"><a href="#Entity头域-1" class="headerlink" title="Entity头域"></a><strong>Entity头域</strong></h2><p>ETag</p>
<p>作用:  和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p>
<p>例如: ETag: “03f2b33c0bfcc1:0”</p>
<p>Last-Modified:</p>
<p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p>
<p>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p>
<p>Content-Type</p>
<p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p>
<p>例如:</p>
<p>Content-Type: text&#x2F;html; charset&#x3D;utf-8</p>
<p>Content-Type:text&#x2F;html;charset&#x3D;GB2312</p>
<p>Content-Type: image&#x2F;jpeg</p>
<p>Content-Length</p>
<p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>
<p>例如: Content-Length: 19847</p>
<p>Content-Encoding</p>
<p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p>
<p>例如：Content-Encoding：gzip</p>
<p>Content-Language</p>
<p>作用： WEB服务器告诉浏览器自己响应的对象的语言者</p>
<p>例如： Content-Language:da</p>
<h2 id="Miscellaneous-头域-1"><a href="#Miscellaneous-头域-1" class="headerlink" title="Miscellaneous 头域"></a><strong>Miscellaneous 头域</strong></h2><p>Server:</p>
<p>作用：指明HTTP服务器的软件信息</p>
<p>例如:Server: Microsoft-IIS&#x2F;7.5</p>
<p>X-AspNet-Version:</p>
<p>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本</p>
<p>例如: X-AspNet-Version: 4.0.30319</p>
<p>X-Powered-By:</p>
<p>作用：表示网站是用什么技术开发的</p>
<p>例如： X-Powered-By: ASP.NET</p>
<h2 id="Transport头域"><a href="#Transport头域" class="headerlink" title="Transport头域"></a><strong>Transport头域</strong></h2><p>Connection</p>
<p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<h2 id="Location头域"><a href="#Location头域" class="headerlink" title="Location头域"></a><strong>Location头域</strong></h2><p>Location</p>
<p>作用： 用于重定向一个新的位置, 包含新的URL地址</p>
<p> 实例请看304状态实例</p>
<h1 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a><strong>HTTP协议是无状态的和Connection: keep-alive的区别</strong></h1><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p>
<p>从HTTP&#x2F;1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>HTTP协议详解</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/02_%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="缓存的概念"><a href="#缓存的概念" class="headerlink" title="缓存的概念"></a><strong>缓存的概念</strong></h1><p>缓存这个东西真的是无处不在， 有浏览器端的缓存， 有服务器端的缓存，有代理服务器的缓存， 有ASP.NET页面缓存，对象缓存。 数据库也有缓存， 等等。</p>
<p>http中具有缓存功能的是浏览器缓存，以及缓存代理服务器。</p>
<p>http缓存的是指:当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。</p>
<h1 id="缓存的好处"><a href="#缓存的好处" class="headerlink" title="缓存的好处"></a><strong>缓存的好处</strong></h1><p>缓存的好处是显而易见的， 好处有，</p>
<ol>
<li>减少了冗余的数据传输，节省了网费。</li>
<li>减少了服务器的负担， 大大提高了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<h1 id="Fiddler可以方便地查看缓存的header"><a href="#Fiddler可以方便地查看缓存的header" class="headerlink" title="Fiddler可以方便地查看缓存的header"></a><strong>Fiddler可以方便地查看缓存的header</strong></h1><p>Fiddler中把header都分门别类的放在一起，这样方便查看。</p>
<p><img src="/assets/wpsE155.tmp-20211222151127-949mku1.png"></p>
<h1 id="如何判断缓存新鲜度"><a href="#如何判断缓存新鲜度" class="headerlink" title="如何判断缓存新鲜度"></a><strong>如何判断缓存新鲜度</strong></h1><p>Web服务器通过2种方式来判断浏览器缓存是否是最新的。</p>
<p>第一种， 浏览器把缓存文件的最后修改时间通过 header ”If-Modified-Since“来告诉Web服务器。</p>
<p>第二种， 浏览器把缓存文件的ETag, 通过header “If-None-Match”, 来告诉Web服务器。</p>
<h1 id="通过最后修改时间-来判断缓存新鲜度"><a href="#通过最后修改时间-来判断缓存新鲜度" class="headerlink" title="通过最后修改时间, 来判断缓存新鲜度"></a><strong>通过最后修改时间, 来判断缓存新鲜度</strong></h1><ol>
<li>浏览器客户端想请求一个文档，  首先检查本地缓存，发现存在这个文档的缓存，  获取缓存中文档的最后修改时间，通过： If-Modified-Since， 发送Request给Web服务器。</li>
<li>Web服务器收到Request，将服务器的文档修改时间（Last-Modified）: 跟request header 中的，If-Modified-Since相比较， 如果时间是一样的， 说明缓存还是最新的， Web服务器将发送304 Not Modified给浏览器客户端， 告诉客户端直接使用缓存里的版本。如下图。</li>
</ol>
<p><img src="/assets/wpsE156.tmp-20211222151127-4a40jej.jpg"></p>
<ol start="3">
<li>假如该文档已经被更新了。Web服务器将发送该文档的最新版本给浏览器客户端， 如下图。</li>
</ol>
<p><img src="/assets/wpsE157.tmp-20211222151127-uyh67po.jpg"></p>
<p>实例： 打开Fiddler, 然后打开博客园首页。然后F5刷新几次浏览器。 你会看到博客园首页也用了缓存。</p>
<p><img src="/assets/wpsE158.tmp-20211222151127-etqucwh.jpg"></p>
<h1 id="与缓存有关的header"><a href="#与缓存有关的header" class="headerlink" title="与缓存有关的header"></a><strong>与缓存有关的header</strong></h1><p>我们来看看每个header的具体含义。</p>
<p>Request</p>
<table>
<thead>
<tr>
<th>Cache-Control: max-age&#x3D;0</th>
<th>以秒为单位</th>
</tr>
</thead>
<tbody><tr>
<td>If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT</td>
<td>缓存文件的最后修改时间。</td>
</tr>
<tr>
<td>If-None-Match: “0693f67a67cc1:0”</td>
<td>缓存文件的Etag值</td>
</tr>
<tr>
<td>Cache-Control: no-cache</td>
<td>不使用缓存</td>
</tr>
<tr>
<td>Pragma: no-cache</td>
<td>不使用缓存</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Response</p>
<table>
<thead>
<tr>
<th>Cache-Control: public</th>
<th>响应被缓存，并且在多用户间共享，（<a href="#publicAndPrivate">公有缓存和私有缓存的区别，请看另一节</a>）</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control: private</td>
<td>响应只能作为私有缓存，不能在用户之间共享</td>
</tr>
<tr>
<td>Cache-Control:no-cache</td>
<td>提醒浏览器要从服务器提取文档进行验证</td>
</tr>
<tr>
<td>Cache-Control:no-store</td>
<td>绝对禁止缓存（用于机密，敏感文件）</td>
</tr>
<tr>
<td>Cache-Control: max-age&#x3D;60</td>
<td>60秒之后缓存过期（相对时间）</td>
</tr>
<tr>
<td>Date: Mon, 19 Nov 2012 08:39:00 GMT</td>
<td>当前response发送的时间</td>
</tr>
<tr>
<td>Expires: Mon, 19 Nov 2012 08:40:01 GMT</td>
<td>缓存过期的时间（绝对时间）</td>
</tr>
<tr>
<td>Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT</td>
<td>服务器端文件的最后修改时间</td>
</tr>
<tr>
<td>ETag: “20b1add7ec1cd1:0”</td>
<td>服务器端文件的Etag值</td>
</tr>
</tbody></table>
<p>如果同时存在cache-control和Expires怎么办呢？<br>浏览器总是优先使用cache-control，如果没有cache-control才考虑Expires</p>
<h1 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><strong>ETag</strong></h1><p>ETag是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。</p>
<p>ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。</p>
<p>为什么使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。</p>
<ol>
<li>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</li>
<li>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</li>
<li>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</li>
</ol>
<p>实例， 打开Fiddler, 打开博客园首页。  你可以看到很多图片，或者CSS文件都是用了缓存。 这些都是通过比较ETag的值，来判断文件是否更新了。</p>
<p><img src="/assets/wpsE159.tmp-20211222151127-o57jc2l.jpg"></p>
<h1 id="浏览器不使用缓存"><a href="#浏览器不使用缓存" class="headerlink" title="浏览器不使用缓存"></a><strong>浏览器不使用缓存</strong></h1><p>CTRL+F5强制刷新浏览器，或者设置IE。  可以让浏览器不使用缓存。</p>
<ol>
<li>浏览器发送Http request, 给Web 服务器， header中带有Cache-Control: no-cache.   明确告诉Web服务器，客户端不使用缓存。</li>
<li>Web服务器将把最新的文档发送给浏览器客户端.</li>
</ol>
<p>实例:</p>
<p>打开Fiddler, 打开博客园首页， 然后按CTRL+F5强制刷新浏览器，你将看到</p>
<p><img src="/assets/wpsE15A.tmp-20211222151127-xzmycng.jpg"></p>
<p>Pragma: no-cache的作用和Cache-Control: no-cache一模一样。 都是不使用缓存。</p>
<p>Pragma: no-cache 是HTTP 1.0中定义的， 所以为了兼容HTTP 1.0. 所以会同时使用Pragma: no-cache和Cache-Control: no-cache</p>
<h1 id="直接使用缓存，不去服务器验证"><a href="#直接使用缓存，不去服务器验证" class="headerlink" title="直接使用缓存，不去服务器验证"></a><strong>直接使用缓存，不去服务器验证</strong></h1><p>按F5刷新浏览器和在地址栏里输入网址然后回车。 这两个行为是不一样的。</p>
<p>按F5刷新浏览器， 浏览器会去Web服务器验证缓存。</p>
<p>如果是在地址栏输入网址然后回车，浏览器会”直接使用有效的缓存”, 而不会发http request 去服务器验证缓存，这种情况叫做缓存命中，如下图</p>
<p><img src="/assets/wpsE15B.tmp-20211222151127-vlk8i3m.jpg"></p>
<p>实例： 比较第一次访问博客园主页和第二次博客园主页</p>
<ol>
<li>启动Fiddler, 用firefox打开博客园主页， 发现有50多个session。</li>
<li>按CTRL+X将Fiddler中的所有session删除。 关闭firefox,重新打开一个firefox，打开博客园主页。   发现只有30多个session.</li>
</ol>
<p>分析；  少了的session是因为firefox直接用了缓存，而没有发http request。</p>
<p><img src="/assets/wpsE15C.tmp-20211222151127-owy880x.jpg"></p>
<h1 id="如何设置IE不使用缓存"><a href="#如何设置IE不使用缓存" class="headerlink" title="如何设置IE不使用缓存"></a><strong>如何设置IE不使用缓存</strong></h1><p>打开IE。点击工具栏上的， 工具-&gt;Internet选项-&gt;常规-&gt;浏览历史记录 设置. 选择“从不”。然后保存。</p>
<p>然后点击“删除”  把Internet临时文件都删掉 （IE缓存的文件就是Internet临时文件）。</p>
<p><img src="/assets/wpsE15D.tmp-20211222151127-tnxmonf.jpg"></p>
<h1 id="公有缓存和私有缓存的区别"><a href="#公有缓存和私有缓存的区别" class="headerlink" title="公有缓存和私有缓存的区别"></a><strong>公有缓存和私有缓存的区别</strong></h1><p>Cache-Control: public 指可以公有缓存， 可以是数千名用户共享的。</p>
<p>Cache-Control: private 指只支持私有缓存， 私有缓存是单个用户专用的。</p>
<p><img src="/assets/wpsE16E.tmp-20211222151127-uql8c7i.jpg"></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>状态码</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/04_%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h1 id="什么是HTTP状态码"><a href="#什么是HTTP状态码" class="headerlink" title="什么是HTTP状态码"></a><strong>什么是HTTP状态码</strong></h1><p>HTTP状态码的作用是：Web服务器用来告诉客户端，发生了什么事。</p>
<p>状态码位于HTTP Response 的第一行中，会返回一个”三位数字的状态码“和一个“状态消息”。 ”三位数字的状态码“便于程序进行处理， “状态消息”更便于人理解。</p>
<p>如下图，  当客户端请求一个不存在的URL的时候， Web服务器会返回 “HTTP&#x2F;1.1 404 Not Found” 告诉浏览器客户端。 服务器无法找到所请求的URL。</p>
<p><img src="/assets/wps58D2.tmp-20211222151316-t1cgk41.jpg"></p>
<h1 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a><strong>状态码分类</strong></h1><p>HTTP状态码被分为五大类， 目前我们使用的HTTP协议版本是1.1， 支持以下的状态码。随着协议的发展，HTTP规范中会定义更多的状态码。</p>
<p>小技巧：  假如你看到一个状态码518， 你并不知道具体518是什么意思。 这时候你只要知道518是属于（5XX，服务器错误就可以了）</p>
<table>
<thead>
<tr>
<th></th>
<th>已定义范围</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>100-101</td>
<td>信息提示</td>
</tr>
<tr>
<td>2XX</td>
<td>200-206</td>
<td>成功</td>
</tr>
<tr>
<td>3XX</td>
<td>300-305</td>
<td>重定向</td>
</tr>
<tr>
<td>4XX</td>
<td>400-415</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5XX</td>
<td>500-505</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<h1 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a><strong>常见的状态码</strong></h1><p>一般人只需要了解以下常见的状态码就够了， 如果你想了解更多， 请继续往下看。</p>
<table>
<thead>
<tr>
<th>200 OK 服务器成功处理了请求（这个是我们见到最多的）</th>
</tr>
</thead>
<tbody><tr>
<td>301&#x2F;302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td>
</tr>
<tr>
<td>304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存</td>
</tr>
<tr>
<td>404 Not Found 未找到资源</td>
</tr>
<tr>
<td>501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</td>
</tr>
</tbody></table>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="1XX-信息性状态码"><a href="#1XX-信息性状态码" class="headerlink" title="1XX 信息性状态码"></a><strong>1XX 信息性状态码</strong></h1><p>这些状态码是HTTP 1.1引入的。 对于这些状态码的价值还存在争论 （我个人从来没见过这些状态码， 也没有理解这些状态码。）</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue(继续)</td>
<td>收到了请求的起始部分，客户端应该继续请求</td>
<td></td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols（切换协议）</td>
<td>服务器正根据客户端的指示将协议切换成Update Header列出的协议</td>
<td></td>
</tr>
</tbody></table>
<h1 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a><strong>2XX 成功状态码</strong></h1><p>客户端发起请求时， 这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>服务器成功处理了请求（这个是我们见到最多的）</td>
<td><a href="#code200">HTTP协议详解-200</a></td>
</tr>
<tr>
<td>201</td>
<td>Created（已创建）</td>
<td>对于那些要服务器创建对象的请求来说，资源已创建完毕。</td>
<td></td>
</tr>
<tr>
<td>202</td>
<td>Accepted（已接受）</td>
<td>请求已接受，但服务器尚未处理</td>
<td></td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information（非权威信息）</td>
<td>服务器已将事务成功处理，只是实体Header包含的信息不是来自原始服务器，而是来自资源的副本。</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>No Content(没有内容)</td>
<td>Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）</td>
<td><a href="#code204">状态码204</a></td>
</tr>
<tr>
<td>205</td>
<td>Reset Content(重置内容)</td>
<td>另一个主要用于浏览器的代码。意思是浏览器应该重置当前页面上所有的HTML表单。</td>
<td></td>
</tr>
<tr>
<td>206</td>
<td>Partial Content（部分内容）</td>
<td>部分请求成功</td>
<td><a href="#code206">状态码206</a></td>
</tr>
</tbody></table>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a><strong>3XX 重定向状态码</strong></h1><p>重定向状态码用来告诉浏览器客户端，它们访问的资源已被移动， Web服务器发送一个重定向状态码和一个可选的Location Header, 告诉客户端新的资源地址在哪。</p>
<p>浏览器客户端会自动用Location中提供的地址，重新发送新的Request。 这个过程对用户来说是透明的。</p>
<p>301和302 非常相似，  一个是永久转移，一个是临时转移。</p>
<p>（SEO中，搜索引擎如果碰到301， 比如网页A用301重定向到网页B，搜索引擎可以肯定网页A永久性改变地址，就会把网页B当做唯一有效目标）</p>
<p>302，303，307 是一样。  这是因为302是HTTP 1.0定义的， HTTP1.1中使用303,307. 同时又保留了302.  （但在现实中，我们还是用302，我是没见过303和307）</p>
<p>所以这一节， 我们只需要掌握302， 304 就可以了。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices（多项选择）</td>
<td>客户端请求了实际指向多个资源的URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望的选项了</td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently（永久移除)</td>
<td>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td>
<td><a href="#code301">状态码301</a></td>
</tr>
<tr>
<td>302</td>
<td>Found（已找到）</td>
<td>与状态码301类似。但这里的移除是临时的。 客户端会使用Location中给出的URL，重新发送新的HTTP request</td>
<td><a href="#Found302">HTTP协议详解-302</a></td>
</tr>
<tr>
<td>303</td>
<td>See Other（参见其他）</td>
<td>类似302</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>Not Modified（未修改）</td>
<td>客户的缓存资源是最新的，要客户端使用缓存</td>
<td><a href="#lastModify">HTTP协议之缓存-304</a></td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy（使用代理）</td>
<td>必须通过代理访问资源，代理的地址在Response 的Location中</td>
<td></td>
</tr>
<tr>
<td>306</td>
<td>未使用</td>
<td>这个状态码当前没使用</td>
<td></td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect（临时重定向</td>
<td>类似302</td>
<td></td>
</tr>
</tbody></table>
<h1 id="4XX客户端错误状态码"><a href="#4XX客户端错误状态码" class="headerlink" title="4XX客户端错误状态码"></a><strong>4XX客户端错误状态码</strong></h1><p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的Request, 或者最常见的是， 请求一个不存在的URL。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request（坏请求）</td>
<td>告诉客户端，它发送了一个错误的请求。</td>
<td><a href="#code400">状态码400</a></td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized（未授权）</td>
<td>需要客户端对自己认证</td>
<td><a href="#guocheng">HTTP协议之基本认证-401</a></td>
</tr>
<tr>
<td>402</td>
<td>Payment Required（要求付款）</td>
<td>这个状态还没被使用，保留给将来用</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>Forbidden（禁止）</td>
<td>请求被服务器拒绝了</td>
<td><a href="#code403">状态码403</a></td>
</tr>
<tr>
<td>404</td>
<td>Not Found（未找到）</td>
<td>未找到资源</td>
<td><a href="#code404">HTTP协议详解-404</a></td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed（不允许使用的方法）</td>
<td>不支持该Request的方法。</td>
<td><a href="#code405">状态码405</a></td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable（无法接受）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required(要求进行代理认证)</td>
<td>与状态码401类似， 用于需要进行认证的代理服务器</td>
<td><a href="#proxyAuth">HTTP协议之代理-407</a></td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout（请求超时）</td>
<td>如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接</td>
<td></td>
</tr>
<tr>
<td>409</td>
<td>Conflict（冲突）</td>
<td>发出的请求在资源上造成了一些冲突</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td>Gone（消失了）</td>
<td>服务器曾经有这个资源，现在没有了，与状态码404类似</td>
<td></td>
</tr>
<tr>
<td>411</td>
<td>Length Required（要求长度指示）</td>
<td>服务器要求在Request中包含Content-Length。</td>
<td><a href="#code411">状态码411</a></td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed（先决条件失败）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large（请求实体太大）</td>
<td>客户端发送的实体主体部分比服务器能够或者希望处理的要大</td>
<td><a href="#code413">状态码413</a></td>
</tr>
<tr>
<td>414</td>
<td>Request URI Too Long（请求URI太长）</td>
<td>客户端发送的请求所携带的URL超过了服务器能够或者希望处理的长度</td>
<td><a href="#code414">状态码414</a></td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type（不支持的媒体类型）</td>
<td>服务器无法理解或不支持客户端所发送的实体的内容类型</td>
<td></td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable（所请求的范围未得到满足）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed（无法满足期望）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><h1 id="5XX服务器错误状态码"><a href="#5XX服务器错误状态码" class="headerlink" title="5XX服务器错误状态码"></a><strong>5XX服务器错误状态码</strong></h1><p>有时候客户端发送了一条有效Request, Web服务器自身却出错了。 可能是Web服务器运行出错了， 或者网站都挂了。  5XX就是用来描述服务器错误的。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error(内部服务器错误)</td>
<td>服务器遇到一个错误，使其无法为请求提供服务</td>
<td><a href="#code500">状态码500</a></td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented（未实现）</td>
<td>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码。</td>
<td><a href="#code501">状态码501</a></td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway（网关故障）</td>
<td>代理使用的服务器遇到了上游的无效响应</td>
<td><a href="#code502">状态码502</a></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable（未提供此服务）</td>
<td>服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</td>
<td></td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout（网关超时）</td>
<td>与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时</td>
<td></td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported（不支持的HTTP版本）</td>
<td>服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本</td>
<td><a href="#code505">状态码505</a></td>
</tr>
</tbody></table>
<h1 id="204-No-Content-没有内容"><a href="#204-No-Content-没有内容" class="headerlink" title="204 No Content(没有内容)"></a><strong>204 No Content(没有内容)</strong></h1><p>返回的Response中只有一些Header和一个状态行， 没有实体的主题内容（没有response body）</p>
<p>204状态码的作用在于： 1. 在不获取资源的情况下了解资源的情况（比如判断其类型）</p>
<ol start="2">
<li>通过查看Response中的状态码， 看看某个对象是否存在</li>
<li>通过查看Header, 测试资源是否被修改了。</li>
</ol>
<p>实例：先打开Fiddler, 然后启动浏览器访问ditu.google.cn,  你会捕获到很多204</p>
<p><img src="/assets/wps58E3.tmp-20211222151316-3psm9de.png"></p>
<h1 id="206-Partial-Content-部分内容"><a href="#206-Partial-Content-部分内容" class="headerlink" title="206 Partial Content(部分内容)"></a><strong>206 Partial Content(部分内容)</strong></h1><p>206状态码代表服务器已经成功处理了部分GET请求（只有发送GET 方法的request, web服务器才可能返回206），</p>
<p>应用场景：</p>
<ol>
<li>FlashGet, 迅雷或者HTTP下载工具都是使用206状态码来实现断点续传</li>
<li>将以个大文档分解为多个下载段同时下载 比如，在线看视频</li>
</ol>
<p>实例：　一些流媒体技术比如在线视频，可以边看边下载。　就是使用206来实现的。</p>
<p>打开Fiddler， 然后用浏览器打开“搜狐视频中的绿箭侠” <a href="http://tv.sohu.com/20121011/n354681393.shtml">http://tv.sohu.com/20121011/n354681393.shtml</a>    然后你在Fiddler中就能看到一堆的206</p>
<ol>
<li>浏览器发送一个Get 方法的request.  header中包含 Range: bytes&#x3D;5303296-5336063. (意思就是请求得到5303296-5336063这个范围的数据)。</li>
<li>Web服务器返回一个206 的Response. header中包含Content-Range: bytes 5303296-5336063&#x2F;12129376(表明这次返回的内容范围)</li>
</ol>
<p><img src="/assets/wps58E4.tmp-20211222151316-tq4eq8y.jpg"></p>
<h1 id="301-Moved-Permanently（永久移除"><a href="#301-Moved-Permanently（永久移除" class="headerlink" title="301 Moved Permanently（永久移除)"></a><strong>301 Moved Permanently（永久移除)</strong></h1><p>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</p>
<p>例如：  1.  浏览器客户端访问 <a href="http://map.google.cn/">http://map.google.cn</a></p>
<ol start="2">
<li>Web服务器返回Response 301，Location&#x3D;<a href="http://titu.google.cn/">http://titu.google.cn</a>  （告诉客户端我们的资源位于这里， ）</li>
<li>浏览器客户端会自动再发送一个Request 去访问<a href="http://titu.google.cn/">http://titu.google.cn</a></li>
</ol>
<p><img src="/assets/wps58E5.tmp-20211222151316-23pq1a5.png"></p>
<h1 id="400-Bad-Request（坏请求"><a href="#400-Bad-Request（坏请求" class="headerlink" title="400 Bad Request（坏请求)"></a><strong>400 Bad Request（坏请求)</strong></h1><p>发送的Request中的数据有错误(比如：表单有错误，Cookie有错误)，  这个我们也经常见到。</p>
<p>实例： 还没想到， 想到了再贴个实例上来。</p>
<h1 id="403-Forbidden-禁止"><a href="#403-Forbidden-禁止" class="headerlink" title="403 Forbidden(禁止)"></a><strong>403 Forbidden(禁止)</strong></h1><p>Web客户端发送的请求被Web服务器拒绝了， 如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态码通常是服务器不想说明拒绝原因。</p>
<p>访问下面的URL， 会被服务器拒绝. 并且返回403状态码</p>
<p><a href="http://t2.baidu.com/it/u=1791561788,200960144&fm=0&gp=0.jpg">http://t2.baidu.com/it/u=1791561788,200960144&fm=0&gp=0.jpg</a></p>
<h1 id="404-Page-not-Found-请求的资源不存在"><a href="#404-Page-not-Found-请求的资源不存在" class="headerlink" title="404 Page not Found (请求的资源不存在)"></a><strong>404 Page not Found (请求的资源不存在)</strong></h1><p>这个大家都懂的， 值得一提的是：　腾讯把404页面做成了“寻找被拐儿童”</p>
<p><img src="/assets/wps58E6.tmp-20211222151316-qyq8gno.png"></p>
<h1 id="405-Method-Not-Allowed-不允许使用的方法"><a href="#405-Method-Not-Allowed-不允许使用的方法" class="headerlink" title="405 Method Not Allowed(不允许使用的方法)"></a><strong>405 Method Not Allowed(不允许使用的方法)</strong></h1><p>405是指Web服务器不支持Request中的方法。</p>
<p>我个人认为状态码405Method Not Allowed和501 Not Implemented 是一样的意思。都是不支持Request的方法。 （目前我还不知道这两个的区别）</p>
<p>实例:  发送一个是trace方法的Request 给<a href="http://www.google.com/">www.google.com</a></p>
<p><img src="/assets/wps58E7.tmp-20211222151316-g6wvu4u.png"></p>
<p><img src="/assets/wps58E8.tmp-20211222151316-5dizdq9.png"></p>
<h1 id="411-Length-Required（要求长度指示）"><a href="#411-Length-Required（要求长度指示）" class="headerlink" title="411 Length Required（要求长度指示）"></a><strong>411 Length Required（要求长度指示）</strong></h1><p>服务器要求在Request中包含Content-Length。</p>
<p>当浏览器使用Post方法，发送数据给Web服务器时， 必须要有Content-Length。这样Web服务器才知道你要发送多少数据，否则Web服务器会返回411状态码</p>
<p>实例： 发送一个Post方法的Request 给<a href="http://www.google.com/">www.google.com</a>.   Request中没有Content-Length</p>
<p><img src="/assets/wps58F9.tmp-20211222151316-iql1y7y.png"></p>
<p><img src="/assets/wps58FA.tmp-20211222151316-gdysfe6.png"></p>
<h1 id="413-Request-Entity-Too-Large（请求实体太大）"><a href="#413-Request-Entity-Too-Large（请求实体太大）" class="headerlink" title="413 Request Entity Too Large（请求实体太大）"></a><strong>413 Request Entity Too Large（请求实体太大）</strong></h1><p>作用：客户端发送的实体主体部分比服务器能够或者希望处理的要大。  一般情况下我们看不到这个状态码。 因为浏览器不会发送太大的数据给网站，但是机器人可能会。</p>
<p>实例: 用post方法发送一个大文件(100MB以上)给<a href="http://www.google.com/">www.google.com</a></p>
<p><img src="/assets/wps58FB.tmp-20211222151316-qtpckvt.png"></p>
<p><img src="/assets/wps58FC.tmp-20211222151316-fin7xes.png"></p>
<h1 id="414-Request-URI-Too-Long-请求URI太长"><a href="#414-Request-URI-Too-Long-请求URI太长" class="headerlink" title="414 Request URI Too Long(请求URI太长)"></a><strong>414 Request URI Too Long(请求URI太长)</strong></h1><p>就是说Request URI太长， 一般浏览器本身对URI的长度就会有限制，所以不会发送URI很长的Request. 我们平常是根本看不到414错误的。 但是机器人可以发送很长URI。</p>
<p>例如：我们用Fiddler Composer发送一个很长的URI给Google, 比如 “<a href="http://www.google.com/?q">www.google.com?q</a>&#x3D;asdfasdasf..”  q&#x3D;后面的参数很长。 就可以看到414了</p>
<p><img src="/assets/wps58FD.tmp-20211222151316-ai45r9x.png"></p>
<p><img src="/assets/wps58FE.tmp-20211222151316-k42ksdg.png"></p>
<h1 id="500-Internal-Server-Error-内部服务器错误"><a href="#500-Internal-Server-Error-内部服务器错误" class="headerlink" title="500 Internal Server Error(内部服务器错误)"></a><strong>500 Internal Server Error(内部服务器错误)</strong></h1><p>这个太常见了， 我们开发网站的时候，当我们的程序出错了时，就会返回500错误。</p>
<p>实例：ASP.NET 程序出错</p>
<p><img src="/assets/wps58FF.tmp-20211222151316-hapybyl.png"></p>
<p> <img src="/assets/wps5900.tmp-20211222151316-u3y9rl9.png"></p>
<h1 id="501-Not-Implemented-未实现"><a href="#501-Not-Implemented-未实现" class="headerlink" title="501 Not Implemented(未实现)"></a><strong>501 Not Implemented(未实现)</strong></h1><p>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码）。  一般的Web服务器只支持GET和POST方法。</p>
<p>实例： 使用Fiddler Composer 给<a href="http://www.qq.com/">www.qq.com</a>,  发送一个OPTIONS 方法的Request.   服务器就能返回501了。</p>
<p><img src="/assets/wps5901.tmp-20211222151316-l7a5n1g.jpg"></p>
<p><img src="/assets/wps5902.tmp-20211222151316-jpgi2af.jpg"></p>
<h1 id="502-Bad-Gateway（网关故障）"><a href="#502-Bad-Gateway（网关故障）" class="headerlink" title="502 Bad Gateway（网关故障）"></a><strong>502 Bad Gateway（网关故障）</strong></h1><p>代理使用的服务器遇到了上游的无效响应。</p>
<p>Fiddler本身就是代理服务器。  当我们访问<a href="http://www.facebook.com,这网站被我们天朝屏蔽了./">www.facebook.com，这网站被我们天朝屏蔽了。</a> 所以我们可以得到502</p>
<p><img src="/assets/wps5903.tmp-20211222151316-xc9razj.png"></p>
<h1 id="505-HTTP-Version-Not-Supported-不支持的HTTP版本"><a href="#505-HTTP-Version-Not-Supported-不支持的HTTP版本" class="headerlink" title="505 HTTP Version Not Supported(不支持的HTTP版本)"></a><strong>505 HTTP Version Not Supported(不支持的HTTP版本)</strong></h1><p>表示Web服务器不支持此HTTP协议的版本。</p>
<p>众所周知我们现在使用的HTTP协议版本是HTTP&#x2F;1.1， 如果我们发送一个HTTP&#x2F;2.0 的request 给博客园， 博客园肯定不能支持HTTP&#x2F;2.0，所以会返回505</p>
<p>想要发送这样的request, 可以使用Fiddler工具中的Composer来发送自定义的request, 如下图。</p>
<p><img src="/assets/wps5904.tmp-20211222151316-986ruis.png"></p>
<p><img src="/assets/wps5905.tmp-20211222151316-egcdh5j.jpg"></p>
]]></content>
      <categories>
        <category>课中</category>
        <category>状态码</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>代理</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/03_%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="什么是代理服务器"><a href="#什么是代理服务器" class="headerlink" title="什么是代理服务器"></a><strong>什么是代理服务器</strong></h1><p>Web代理（proxy）服务器是网络的中间实体。 代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。</p>
<p>HTTP的代理服务器即是Web服务器又是Web客户端。</p>
<p><img src="/assets/wpsDF5D.tmp-20211222151232-ddixl0r.jpg"></p>
<h1 id="Fiddler就是个典型的代理"><a href="#Fiddler就是个典型的代理" class="headerlink" title="Fiddler就是个典型的代理"></a><strong>Fiddler就是个典型的代理</strong></h1><p>Fiddler 是以代理web服务器的形式工作的,它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler退出的时候它会自动注销代理，这样就不会影响别的程序。</p>
<p><img src="/assets/wpsDF5E.tmp-20211222151232-3k0fozh.jpg"></p>
<p><img src="/assets/wpsDF5F.tmp-20211222151232-8omms3m.jpg"></p>
<h1 id="代理的作用一，-FQ"><a href="#代理的作用一，-FQ" class="headerlink" title="代理的作用一， FQ"></a><strong>代理的作用一， FQ</strong></h1><p>很多人都喜欢用Facebook， 看youTube。但是我们在天朝，天朝有The Great of Wall(长城防火墙)，屏蔽了这些好网站。  怎么办?   通过代理来跳墙，就可以访问了。</p>
<p>自己去寻找代理服务器很麻烦， 一般都是用FQ软件来自动发现代理服务器的。</p>
<p><img src="/assets/wpsDF60.tmp-20211222151232-96nhbdt.jpg"></p>
<h1 id="代理的作用二，-匿名访问"><a href="#代理的作用二，-匿名访问" class="headerlink" title="代理的作用二， 匿名访问"></a><strong>代理的作用二， 匿名访问</strong></h1><p>经常听新闻，说”某某某“在网络上发布帖子，被跨省追缉了。   假如他使用匿名的代理服务器，就不容易暴露自己的身份了。</p>
<p>http代理服务器的匿名性是指： HTTP代理服务器通过删除HTTP报文中的身份特性（比如客户端的IP地址， 或cookie,或URI的会话ID）， 从而对远端服务器隐藏原始用户的IP地址以及其他细节。 同时HTTP代理服务器上也不会记录原始用户访问记录的log(否则也会被查到)。</p>
<h1 id="代理的作用三，-通过代理上网"><a href="#代理的作用三，-通过代理上网" class="headerlink" title="代理的作用三， 通过代理上网"></a><strong>代理的作用三， 通过代理上网</strong></h1><p>比如局域网不能上网， 只能通过局域网内的一台代理服务器上网。</p>
<h1 id="代理的作用四，-通过代理缓存，加快上网速度"><a href="#代理的作用四，-通过代理缓存，加快上网速度" class="headerlink" title="代理的作用四， 通过代理缓存，加快上网速度"></a><strong>代理的作用四， 通过代理缓存，加快上网速度</strong></h1><p>大部分代理服务器都具有缓存的功能，就好像一个大的cache， 它有很大的存储空间，它不断将新取得数据存储到它本地的存储器上， 如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传给用户的浏览器，这样就能显著提高浏览速度。</p>
<h1 id="代理的作用五：儿童过滤器"><a href="#代理的作用五：儿童过滤器" class="headerlink" title="代理的作用五：儿童过滤器"></a><strong>代理的作用五：儿童过滤器</strong></h1><p>很多教育机构， 会利用过滤器代理来阻止学生访问成人内容。</p>
<p><img src="/assets/wpsDF61.tmp-20211222151232-ipw4fkt.jpg"></p>
<h1 id="IE代理设置：手动设置代理"><a href="#IE代理设置：手动设置代理" class="headerlink" title="IE代理设置：手动设置代理"></a><strong>IE代理设置：手动设置代理</strong></h1><p>IE浏览器可以手动设置代理， 很简单，指定一个IP地址和端口就可以了。 如下图。</p>
<p>工具 -＞ Internet选项 -&gt; 连接 -&gt; 局域网设置 （快捷键）</p>
<p><img src="/assets/wpsDF62.tmp-20211222151232-t1rz1e9.jpg"></p>
<p>假如代理服务器的IP地址改变了，或者端口号改变了。 难道要几百个客户端的浏览器去修改浏览器设置？ Impossable  这太难维护了。  下面还有一种更高级点的方法。</p>
<h1 id="IE代理设置：使用自动配置脚本（PAC）"><a href="#IE代理设置：使用自动配置脚本（PAC）" class="headerlink" title="IE代理设置：使用自动配置脚本（PAC）"></a><strong>IE代理设置：使用自动配置脚本（PAC）</strong></h1><p> 手动配置代理很简单，但是不灵活。 只能指定一个代理服务器，而且不支持故障转移。</p>
<p>在大公司里一般都使用PAC文件来配置。只需要指定PAC文件的URL就可以了， 如图：</p>
<p><img src="/assets/wpsDF63.tmp-20211222151232-0ylxvbu.jpg"></p>
<p>PAC（Proxy Auto Config）文件是一个小型的JavaScript程序的文本文件，后缀为.dat。</p>
<p>当浏览器访问网络的时候，会根据PAC文件中的JavaScript函数来选择恰当的代理服务器。</p>
<p>sample_pac.dat文件的内容</p>
<p><img src="/assets/wpsDF64.tmp-20211222151232-tfzfr8d.png"></p>
<p>function FindProxyForURL(url, host) {</p>
<pre><code>if (url.substring(0, 5) == &quot;http:&quot;) &#123;

    // 应该使用指定的代理

    return &quot;PROXY proxy:80&quot;;

&#125;

else if (url.substring(0, 4) == &quot;ftp:&quot;) &#123;

    return &quot;PROXY fproxy:80&quot;;

&#125;

else if (url.substring(0, 7) == &quot;gopher:&quot;) &#123;

    return &quot;PROXY gproxy&quot;;

&#125;

else if (url.substring(0, 6) == &quot;https:&quot;) &#123;

    return &quot;PROXY secproxy:8080&quot;;

&#125;

else &#123;

    // 直连，不经过任何代理

    return &quot;DIRECT&quot;;

&#125;
</code></pre>
<p>}</p>
<p><img src="/assets/wpsDF65.tmp-20211222151232-x67d5mc.png"></p>
<h1 id="IE代理设置：自动探测设置（WPAD）"><a href="#IE代理设置：自动探测设置（WPAD）" class="headerlink" title="IE代理设置：自动探测设置（WPAD）"></a><strong>IE代理设置：自动探测设置（WPAD）</strong></h1><p> 浏览器只要选中“自动检测设置”， 就可以使用WPAD协议， WPAD会自动找到PAC文件的URL。  WPAD会使用一系列的资源发现技术（DHCP,DNS等）去寻找PAC文件。</p>
<p><img src="/assets/wpsDF66.tmp-20211222151232-u1fechv.jpg"></p>
<h1 id="代理认证，和407状态码"><a href="#代理认证，和407状态码" class="headerlink" title="代理认证，和407状态码"></a><strong>代理认证，和407状态码</strong></h1><p>代理服务器也可以需要权限认证， HTTP定义了一种名为代理认证（Proxy authentication）的机制。 这种机制可以阻止对内容的请求。</p>
<p>当浏览器访问需要认证的代理时， 代理服务器会返回407 Authorization Required,告诉浏览器输入用户名和密码。</p>
<p>代理认证跟HTTP基本认证是一样的机制， 如需了解代理认证的机制，请看<a href="http://www.cnblogs.com/TankXiao/archive/2012/09/26/2695955.html">[HTTP协议基本认证]</a></p>
<p><img src="/assets/wpsDF67.tmp-20211222151232-n3wbdm6.jpg"></p>
<h1 id="使用代理服务器的安全问题"><a href="#使用代理服务器的安全问题" class="headerlink" title="使用代理服务器的安全问题"></a><strong>使用代理服务器的安全问题</strong></h1><p>代理服务器和抓包工具（比如Fiddler）都能看到http request中的数据。 如果我们发送的request中有敏感数据，比如用户名，密码，信用卡号码。这些信息都会被代理服务器看到。所以非常危险。 所以我们一般都是用HTTPS来加密Http request.  这样代理服务器就看不到里面的数据了。</p>
<h1 id="如何搭建代理服务器"><a href="#如何搭建代理服务器" class="headerlink" title="如何搭建代理服务器"></a><strong>如何搭建代理服务器</strong></h1><p>可以使用CCproxy, 和Squid 来搭建代理服务器。</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>代理</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie</title>
    <url>/%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0/02_%E8%AF%BE%E4%B8%AD/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/05_cookie/</url>
    <content><![CDATA[<h1 id="Cookie是什么，有什么用，为什么要用到Cookie"><a href="#Cookie是什么，有什么用，为什么要用到Cookie" class="headerlink" title="Cookie是什么，有什么用，为什么要用到Cookie"></a><strong>Cookie是什么，有什么用，为什么要用到Cookie</strong></h1><p>请看Fish Li 写的【<a href="http://www.cnblogs.com/fish-li/archive/2011/07/03/2096903.html">细说<strong>Cookie】</strong></a></p>
<h1 id="Cookie的分类"><a href="#Cookie的分类" class="headerlink" title="Cookie的分类"></a><strong>Cookie的分类</strong></h1><p>可以大致把Cookie分为2类： 回话cookie和持久cookie</p>
<p>会话cookie: 是一种临时的cookie，它记录了用户访问站点时的设置和偏好，关闭浏览器，会话cookie就被删除了</p>
<p>持久cookie: 存储在硬盘上，（不管浏览器退出，或者电脑重启，持久cookie都存在）， 持久cookie有过期时间</p>
<h1 id="Cookie存在哪里"><a href="#Cookie存在哪里" class="headerlink" title="Cookie存在哪里"></a><strong>Cookie存在哪里</strong></h1><p>Cookie是存在硬盘上，  IE存cookie的地方和Firefox存cookie的地方不一样。  不同的操作系统也可能存cookie的地方不一样。</p>
<p>不同的浏览器会在各自的独立空间存放Cookie, 互不干涉</p>
<p>以我的windows7， IE8为例，  cookie存在这： C:\Users\xiaoj\AppData\Local\Microsoft\Windows\Temporary Internet Files</p>
<p>注意： 缓存文件和cookie文件，是存在一起的, 都在这个目录下。</p>
<p>你也可以这样找, 打开IE，点击Tools-&gt;Internet Options-&gt;General Tab下的-&gt;Browsing history下的Setting按钮，弹出的对话框中点击View files.</p>
<p><img src="/assets/wps7EA5.tmp-20211222151419-fbxtpyw.png"><img src="/assets/wps7EA6.tmp-20211222151419-olwgxkx.jpg"></p>
<p>不同的网站会有不同的cookie文件</p>
<p><img src="/assets/wps7EA7.tmp-20211222151419-qi8mr5o.png"><img src="/assets/wps7EA8.tmp-20211222151419-zru7a1f.jpg"></p>
<h1 id="使用和禁用Cookie"><a href="#使用和禁用Cookie" class="headerlink" title="使用和禁用Cookie"></a><strong>使用和禁用Cookie</strong></h1><p>IE:   工具-&gt;Internet 选项 -&gt; 隐私</p>
<p><img src="/assets/wps7EA9.tmp-20211222151419-ptu9ut9.png"><img src="/assets/wps7EAA.tmp-20211222151419-aop8gqr.jpg"></p>
<h1 id="Fiddler查看HTTP中的Cookie"><a href="#Fiddler查看HTTP中的Cookie" class="headerlink" title="Fiddler查看HTTP中的Cookie"></a><strong>Fiddler查看HTTP中的Cookie</strong></h1><p>浏览器把cookie通过HTTP Request 中的“Cookie: header”发送给Web服务器</p>
<p>Web服务器通过HTTP Response中的”Set-Cookie: header”把cookie发送给浏览器</p>
<p>使用Fiddler可以清楚地看到cookie在HTTP中传递。 Fiddler工具中可以清晰的看到Http Request 中的Cookie， 和Http Response中的cookie</p>
<p>实例： 启动Fiddler,  启动浏览器访问一些购物网站，就可以看到。</p>
<p><img src="/assets/wps7EAB.tmp-20211222151419-2d6q7ul.png"> <img src="/assets/wps7EAC.tmp-20211222151419-zvo47bs.jpg"></p>
<h1 id="网站自动登陆的原理"><a href="#网站自动登陆的原理" class="headerlink" title="网站自动登陆的原理"></a><strong>网站自动登陆的原理</strong></h1><p>我们以”博客园自动登陆“的例子，来说明cookie是如何传递的。</p>
<p>大家知道博客园是可以自动登陆的。 如下图，这个是什么原理呢?</p>
<p><img src="/assets/wps7EAD.tmp-20211222151419-onffgyw.png"><img src="/assets/wps7EAE.tmp-20211222151419-7eoj92p.jpg"></p>
<p>假如我已经在登陆页面输入了用户名，密码，选择了保存密码，登陆。</p>
<p>（这时候，其实在你的机器上保存好了登陆的cookie, 不信你可以按照上节介绍方法去你的电脑上找下博客园的cookie）</p>
<p>当我下次访问博客园流程如下。</p>
<ol>
<li>用户打开IE浏览器，在地址栏上输入<a href="http://www.cnblogs.com/">www.cnblogs.com</a>.</li>
<li>IE首先会在硬盘中查找关于cnblogs.com的cookie. 然后把cookie放到HTTP Request中，再把Request发给Web服务器。</li>
<li>Web服务器返回博客园首页（你会看到你已经登陆了）。</li>
</ol>
<p><img src="/assets/wps7EAF.tmp-20211222151419-vob6ewr.png"><img src="/assets/wps7EB0.tmp-20211222151419-w1gki0n.jpg"></p>
<h1 id="截获Cookie，冒充别人身份"><a href="#截获Cookie，冒充别人身份" class="headerlink" title="截获Cookie，冒充别人身份"></a><strong>截获Cookie，冒充别人身份</strong></h1><p>通过上面这个例子，可以看到cookie是很重要的，识别是否是登陆用户，就是通过cookie。  假如截获了别人的cookie是否可以冒充他人的身份登陆呢？  当然可以， 这就是一种黑客技术叫Cookie欺骗。</p>
<p>利用Cookie 欺骗， 不需要知道用户名密码。就可以直接登录，使用别人的账户做坏事。</p>
<p>我知道有两种方法可以截获他人的cookie，</p>
<ol>
<li>通过XSS脚步攻击， 获取他人的cookie. 具体原理可以看 [<a href="http://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html">Web安全性测试之XSS</a>]</li>
<li>想办法获取别人电脑上保存的cookie文件（这个比较难）</li>
</ol>
<p>拿到cookie后，就可以冒充别人的身份了。 这个过程我就不演示了。</p>
<h1 id="Cookie和文件缓存的区别"><a href="#Cookie和文件缓存的区别" class="headerlink" title="Cookie和文件缓存的区别"></a><strong>Cookie和文件缓存的区别</strong></h1><p>很多人会把cookie和文件缓存弄混淆， 这两个完全是不一样的东西。唯一的相同之处可能是它们俩都存在硬盘上，而且是存在同一个文件夹下。</p>
<p>关于HTTP缓存请看这 【<a href="http://www.cnblogs.com/TankXiao/archive/2012/11/28/2793365.html">HTTP协议之缓存</a>】</p>
<p>我们在IE中可以选择分别删除Cookie和缓存文件</p>
<p><img src="/assets/wps7EC1.tmp-20211222151419-9749lqa.png"> <img src="/assets/wps7EC2.tmp-20211222151419-x09ud12.jpg"></p>
<h1 id="Cookie-泄露隐私"><a href="#Cookie-泄露隐私" class="headerlink" title="Cookie 泄露隐私"></a><strong>Cookie 泄露隐私</strong></h1><p>2013年央视的315晚会上， 曝光了很多不法公司利用Cookie跟踪并采集用户的个人信息，并转卖给网络广告商，形成了一条窃取用户信息的灰色产业链。从而实现广告准确投放。严重干扰了用户的正常网络应用，侵害了个人的隐私和利益。</p>
<p>我经常就在门户网站上发现广告位上显示的是我在电商网站上流量过的商品。  这就是我的cookie被泄露了。</p>
<p>目前在欧洲， 已经对Cookie立法， 如果网站需要保存用户的cookie, 必须弹出一个对话框，要用户确认后才能保存Cookie.</p>
<h1 id="P3P协议"><a href="#P3P协议" class="headerlink" title="P3P协议"></a><strong>P3P协议</strong></h1><p>从上面看来， Cookie 是一个比较容易泄露用户隐私和危险的东西。  有没有办法保护个人用户隐私呢？    那就是P3P协议</p>
<p>P3P是一种被称为个人隐私安全平台项目（the Platform for Privacy Preferences）的标准，能够保护在线隐私权，使Internet冲浪者可以选择在浏览网页时，是否被第三方收集并利用自己的个人信息。如果一个 站点不遵守P3P标准的话，那么有关它的Cookies将被自动拒绝，并且P3P还能够自动识破多种Cookies的嵌入方式。p3p是由全球资讯联盟网 所开发的。</p>
]]></content>
      <categories>
        <category>课中</category>
        <category>cookie</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
</search>
