<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pytest文档01_环境准备与入门</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A301_%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%E4%B8%8E%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/yoyoketang/p/9356693.html">中文教程</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先说下为什么要学pytest，在此之前相信大家已经掌握了python里面的unittest单元测试框架，那再学一个框架肯定是需要学习时间成本的。<br>刚开始我的内心是拒绝的，我想我用unittest也能完成自动化测试，干嘛要去学pytest呢？最近看到越来越多的招聘要求会pytest框架了，也有小伙伴出去面试说会unittest框架被鄙视的。<br>所以学此框架应该至少有以下2个理由，第一条已经足够：</p>
<ul>
<li>学会了可以装逼</li>
<li>可以避免被面试官鄙视</li>
</ul>
<p><strong>python鄙视链：pytest 鄙视 &gt; unittest 鄙视 &gt; robotframework 鄙视 &gt; 记流水账 鄙视 &gt; “hello world”小白</strong></p>
<h1 id="pytest简介"><a href="#pytest简介" class="headerlink" title="pytest简介"></a>pytest简介</h1><p>pytest是python的一种单元测试框架，与python自带的unittest测试框架类似，但是比unittest框架使用起来更简洁，效率更高。根据pytest的官方网站介绍，它具有如下特点：</p>
<ul>
<li>非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考</li>
<li>能够支持简单的单元测试和复杂的功能测试</li>
<li>支持参数化</li>
<li>执行测试过程中可以将某些测试跳过（skip），或者对某些预期失败的case标记成失败</li>
<li>支持重复执行(rerun)失败的case</li>
<li>支持运行由nose, unittest编写的测试case</li>
<li>可生成html报告</li>
<li>方便的和持续集成工具jenkins集成</li>
<li>可支持执行部分用例</li>
<li>具有很多第三方插件，并且可以自定义扩展</li>
</ul>
<h1 id="安装pytest"><a href="#安装pytest" class="headerlink" title="安装pytest"></a>安装pytest</h1><p>1.安装方法</p>
<blockquote>
<p>pip install -U pytest</p>
</blockquote>
<p><img src="/assets/2/image-20220515235354-zc59f22.png" alt="image.png"></p>
<p>2.pip show pytest查看安装版本</p>
<blockquote>
<p>pip show pytest</p>
</blockquote>
<p><img src="/assets/2/image-20220515235401-lpgcjha.png" alt="image.png"></p>
<p>3.也可以pytest –version查看安装的版本</p>
<blockquote>
<p>pytest –version</p>
</blockquote>
<pre><code class="vbnet">This is pytest version 3.6.3, imported from d:\soft\python3.6\lib\site-packages\
pytest.py
</code></pre>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>1.新建一个test_sample.py文件，写以下代码</p>
<pre><code class="python"># content of test_sample.py
def func(x):
    return x +1

def test_answer():
    assert func(3)==5
</code></pre>
<p>2.打开test_sample.py所在的文件夹，cmd窗口输入：pytest（或者输入py.test也可以）</p>
<p><img src="/assets/2/image-20220515235412-n045ujz.png" alt="image.png"></p>
<pre><code class="markdown">D:\YOYO&gt;pytest
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO, inifile:
collected 1 item

test_sample.py F                                                         [100%]

================================== FAILURES ===================================
_________________________________ test_answer _________________________________

    def test_answer():
&gt;       assert func(3)==5
E       assert 4 == 5
E        +  where 4 = func(3)

test_sample.py:6: AssertionError
========================== 1 failed in 0.19 seconds ===========================
</code></pre>
<p>3.pytest运行规则：<strong>查找当前目录及其子目录下以test_*.py或*_test.py文件，找到文件后，在文件中找到以test开头函数并执行。</strong></p>
<h1 id="写个测试类"><a href="#写个测试类" class="headerlink" title="写个测试类"></a>写个测试类</h1><p>1.前面是写的一个test开头的测试函数，当用例用多个的时候，写函数就不太合适了。这时可以把多个测试用例，写到一个测试类里。</p>
<pre><code class="python"># test_class.py

class TestClass:
    def test_one(self):
        x = &quot;this&quot;
        assert &#39;h&#39; in x

    def test_two(self):
        x = &quot;hello&quot;
        assert hasattr(x, &#39;check&#39;)
</code></pre>
<p>2.pytest会找到符合规则（test_ <em>.py和</em> _test.py）所有测试，因此它发现两个test_前缀功能。 如果只想运行其中一个，可以指定传递文件名test_class.py来运行模块：<br><strong>备注： -q, –quiet decrease verbosity( 显示简单结果)</strong></p>
<blockquote>
<p>py.test -q test_class.py</p>
</blockquote>
<pre><code class="markdown">D:\YOYO&gt;py.test -q test_class.py
.F                                                                       [100%]
================================== FAILURES ===================================
_____________________________ TestClass.test_two ______________________________

self = &lt;test_class.TestClass object at 0x00000000039F1828&gt;

    def test_two(self):
        x = &quot;hello&quot;
&gt;       assert hasattr(x, &#39;check&#39;)
E       AssertionError: assert False
E        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)

test_class.py:11: AssertionError
1 failed, 1 passed in 0.04 seconds
</code></pre>
<p>第一次测试通过，第二次测试失败。 您可以在断言中轻松查看失败的原因。</p>
<h1 id="pytest用例规则"><a href="#pytest用例规则" class="headerlink" title="pytest用例规则"></a>pytest用例规则</h1><ul>
<li>文件名以test_*.py文件和*_test.py</li>
<li>以test_开头的函数</li>
<li>以Test开头的类，test_开头的方法，并且不能带有__init__ 方法</li>
<li>所有的包pakege必须要有__init__.py文件</li>
<li>断言使用assert</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档02_用例运行规则</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A302_%E7%94%A8%E4%BE%8B%E8%BF%90%E8%A1%8C%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="用例设计原则"><a href="#用例设计原则" class="headerlink" title="用例设计原则"></a>用例设计原则</h1><ul>
<li>文件名以test_*.py文件和*_test.py</li>
<li>以test_开头的函数</li>
<li>以Test开头的类，test_开头的方法，并且不能带有__init__ 方法</li>
<li>所有的包pakege必须要有__init__.py文件</li>
<li>断言使用assert</li>
</ul>
<h1 id="help帮助"><a href="#help帮助" class="headerlink" title="help帮助"></a>help帮助</h1><p>1.查看pytest命令行参数，可以用pytest -h 或pytest –help查看</p>
<pre><code class="vhdl">
C:\Users\admin&gt;pytest -h
usage: pytest [options] [file_or_dir] [file_or_dir] [...]

positional arguments:
  file_or_dir

general:
  -k EXPRESSION         only run tests which match the given substring
                        expression. An expression is a python evaluatable
                        expression where all names are substring-matched
                        against test names and their parent classes. Example:
                        -k &#39;test_method or test_other&#39; matches all test
                        functions and classes whose name contains
                        &#39;test_method&#39; or &#39;test_other&#39;, while -k &#39;not
                        test_method&#39; matches those that don&#39;t contain
                        &#39;test_method&#39; in their names. Additionally keywords
                        are matched to classes and functions containing extra
                        names in their &#39;extra_keyword_matches&#39; set, as well as
                        functions which have names assigned directly to them.
  -m MARKEXPR           only run tests matching given mark expression.
                        example: -m &#39;mark1 and not mark2&#39;.
  --markers             show markers (builtin, plugin and per-project ones).
  -x, --exitfirst       exit instantly on first error or failed test

reporting:
  -v, --verbose         increase verbosity.
  -q, --quiet           decrease verbosity.
  --verbosity=VERBOSE   set verbosity
 
只贴了一部分
</code></pre>
<h1 id="按以下目录写用例"><a href="#按以下目录写用例" class="headerlink" title="按以下目录写用例"></a>按以下目录写用例</h1><pre><code class="python">D:YOYO\
    __init__.py
  
    test_class.py
        #  content of  test_class.py  
        class TestClass:
            def test_one(self):
                x = &quot;this&quot;
                assert &#39;h&#39; in x
      
            def test_two(self):
                x = &quot;hello&quot;
                assert hasattr(x, &#39;check&#39;)
              
            def test_three(self):
                a = &quot;hello&quot;
                b = &quot;hello world&quot;
                assert a in b
          
    test_sample.py
        #  content of  test_sample.py
        def func(x):
            return x +1
  
        def test_answer():
            assert func(3)==5

</code></pre>
<h1 id="python-m"><a href="#python-m" class="headerlink" title="python -m"></a>python -m</h1><p>cmd执行pytest用例有三种方法,以下三种方法都可以，一般推荐第一个</p>
<ul>
<li><blockquote>
<p>pytest</p>
</blockquote>
</li>
<li><blockquote>
<p>py.test</p>
</blockquote>
</li>
<li><blockquote>
<p>python -m pytest</p>
</blockquote>
</li>
</ul>
<p>如果不带参数，在某个文件夹下执行时，它会查找该文件夹下所有的符合条件的用例（查看用例设计原则）</p>
<h1 id="执行用例规则"><a href="#执行用例规则" class="headerlink" title="执行用例规则"></a>执行用例规则</h1><p>1.执行某个目录下所有的用例</p>
<blockquote>
<p>pytest 文件名&#x2F;</p>
</blockquote>
<p>2.执行某一个py文件下用例</p>
<blockquote>
<p>pytest 脚本名称.py</p>
</blockquote>
<p>3.-k 按关键字匹配</p>
<blockquote>
<p>pytest -k “MyClass and not method”</p>
</blockquote>
<p>这将运行包含与给定字符串表达式匹配的名称的测试，其中包括Python<br>使用文件名，类名和函数名作为变量的运算符。 上面的例子将运行<br>TestMyClass.test_something但不运行TestMyClass.test_method_simple</p>
<p>4.按节点运行</p>
<p>每个收集的测试都分配了一个唯一的nodeid，它由模块文件名和后跟说明符组成<br>来自参数化的类名，函数名和参数，由:: characters分隔。</p>
<p>运行.py模块里面的某个函数</p>
<blockquote>
<p>pytest test_mod.py::test_func</p>
</blockquote>
<p>运行.py模块里面,测试类里面的某个方法</p>
<blockquote>
<p>pytest test_mod.py::TestClass::test_method</p>
</blockquote>
<p>5.标记表达式</p>
<blockquote>
<p>pytest -m slow</p>
</blockquote>
<p>将运行用@ pytest.mark.slow装饰器修饰的所有测试。</p>
<p>6.从包里面运行</p>
<blockquote>
<p>pytest –pyargs pkg.testing</p>
</blockquote>
<p>这将导入pkg.testing并使用其文件系统位置来查找和运行测试。</p>
<h1 id="x-遇到错误时停止测试"><a href="#x-遇到错误时停止测试" class="headerlink" title="-x 遇到错误时停止测试"></a>-x 遇到错误时停止测试</h1><blockquote>
<p>pytest -x test_class.py</p>
</blockquote>
<p>从运行结果可以看出，本来有3个用例，第二个用例失败后就没继续往下执行了</p>
<pre><code class="markdown">D:\YOYO&gt;pytest -x test_class.py
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO, inifile:
collected 3 items

test_class.py .F

================================== FAILURES ===================================
_____________________________ TestClass.test_two ______________________________

self = &lt;YOYO.test_class.TestClass object at 0x0000000003A29780&gt;

    def test_two(self):
        x = &quot;hello&quot;
&gt;       assert hasattr(x, &#39;check&#39;)
E       AssertionError: assert False
E        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)

test_class.py:11: AssertionError
===================== 1 failed, 1 passed in 0.05 seconds ======================
</code></pre>
<h1 id="–maxfail-x3D-num"><a href="#–maxfail-x3D-num" class="headerlink" title="–maxfail&#x3D;num"></a>–maxfail&#x3D;num</h1><blockquote>
<p>pytest –maxfail&#x3D;1</p>
</blockquote>
<p>当用例错误个数达到指定数量时，停止测试</p>
<pre><code class="markdown">D:\YOYO&gt;pytest --maxfail=1
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO, inifile:
collected 4 items

test_class.py .F

================================== FAILURES ===================================
_____________________________ TestClass.test_two ______________________________

self = &lt;YOYO.test_class.TestClass object at 0x0000000003A3D080&gt;

    def test_two(self):
        x = &quot;hello&quot;
&gt;       assert hasattr(x, &#39;check&#39;)
E       AssertionError: assert False
E        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)

test_class.py:11: AssertionError
===================== 1 failed, 1 passed in 0.06 seconds ======================
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档03_pycharm运行pytest</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A303_pycharm%E8%BF%90%E8%A1%8Cpytest/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇<a href="https://www.cnblogs.com/yoyoketang/p/9362415.html">pytest文档2-用例运行规则</a>已经介绍了如何在cmd执行pytest用例，平常我们写代码在pycharm比较多<br>写完用例之后，需要调试看看，是不是能正常运行，如果每次跑去cmd执行，太麻烦，所以很有必要学习如何在pycharm里面运行pytest用例</p>
<h1 id="pycharm运行三种方式"><a href="#pycharm运行三种方式" class="headerlink" title="pycharm运行三种方式"></a>pycharm运行三种方式</h1><p>1.以xx.py脚本方式直接执行，当写的代码里面没用到unittest和pytest框架时，并且脚本名称不是以test_开头命名的，此时pycharm会以xx.py脚本方式运行</p>
<p><img src="/assets/2/image-20220516000404-mnk1zvu.png" alt="image.png"></p>
<p>2.当脚本命名为test_xx.py时，用到unittest框架，此时运行代码，pycharm会自动识别到以unittest方式运行</p>
<p><img src="/assets/2/image-20220516000411-7dvsdge.png" alt="image.png"></p>
<p>3.以pytest方式运行，需要改该工程设置默认的运行器：file-&gt;Setting-&gt;Tools-&gt;Python Integrated Tools-&gt;项目名称-&gt;Default test runner-&gt;选择py.test</p>
<p><img src="/assets/2/image-20220516000429-4fvw1wa.png" alt="image.png"></p>
<p><strong>备注：pytest是可以兼容unittest框架代码的</strong></p>
<h1 id="pycharm写pytest代码"><a href="#pycharm写pytest代码" class="headerlink" title="pycharm写pytest代码"></a>pycharm写pytest代码</h1><p>1.在pycharm里面写pytest用例，先导入pytest</p>
<pre><code class="python"># D:/YOYO/test_class.py

** 作者：上海-悠悠 QQ交流群：588402570**

import pytest

class TestClass:
        def test_one(self):
            x = &quot;this&quot;
            assert &#39;h&#39; in x

        def test_two(self):
            x = &quot;hello&quot;
            assert hasattr(x, &#39;check&#39;)

        def test_three(self):
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
            assert a in b

if __name__ == &quot;__main__&quot;:
    pytest.main(&#39;-q test_class.py&#39;)
</code></pre>
<p>运行结果</p>
<pre><code class="python">.F.                                                                      [100%]
================================== FAILURES ===================================
_____________________________ TestClass.test_two ______________________________

self = &lt;YOYO.test_class.TestClass object at 0x00000000039F9080&gt;

    def test_two(self):
        x = &quot;hello&quot;
&gt;       assert hasattr(x, &#39;check&#39;)
E       AssertionError: assert False
E        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)

test_class.py:11: AssertionError
============================== warnings summary ===============================
&lt;undetermined location&gt;
  passing a string to pytest.main() is deprecated, pass a list of arguments instead.

-- Docs: http://doc.pytest.org/en/latest/warnings.html
1 failed, 2 passed, 1 warnings in 0.06 seconds
</code></pre>
<p>2.运行结果“.F. ” 点是代表测试通过，F是Fail的意思，1 warnings是用于pytest.main(‘-q test_class.py’)里面参数需要传list，多个参数放list就不会有警告了</p>
<blockquote>
<p>pytest.main([‘-q’, ‘test_class.py’])</p>
</blockquote>
<h1 id="pycharm设置pytest"><a href="#pycharm设置pytest" class="headerlink" title="pycharm设置pytest"></a>pycharm设置pytest</h1><p>1.新建一个工程后，左上角file-&gt;Setting-&gt;Tools-&gt;Python Integrated Tools-&gt;项目名称-&gt;Default test runner-&gt;选择py.test</p>
<p><img src="/assets/2/image-20220516000438-pf9g134.png" alt="image.png"></p>
<p>2.改完之后，再重新建个脚本（注意是先改项目运行方式，再写代码才能出来），接下来右键运行就能出来pytest运行了</p>
<p><img src="/assets/2/image-20220516000445-ccombr5.png" alt="image.png"></p>
<p>3.pytest是可以兼容unittest脚本的，之前写的unittest用例也能用pytest框架去运行</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档04_测试用例setup和teardown</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A304_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8Bsetup%E5%92%8Cteardown/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学过unittest的都知道里面用前置和后置setup和teardown非常好用，在每次用例开始前和结束后都去执行一次。<br>当然还有更高级一点的setupClass和teardownClass，需配合@classmethod装饰器一起使用，在做selenium自动化的时候，它的效率尤为突出，可以只启动一次浏览器执行多个用例。<br>pytest框架也有类似于setup和teardown的语法，并且还不止这四个</p>
<h1 id="用例运行级别"><a href="#用例运行级别" class="headerlink" title="用例运行级别"></a>用例运行级别</h1><ul>
<li>模块级（setup_module&#x2F;teardown_module）开始于模块始末，全局的</li>
<li>函数级（setup_function&#x2F;teardown_function）只对函数用例生效（不在类中）</li>
<li>类级（setup_class&#x2F;teardown_class）只在类中前后运行一次(在类中)</li>
<li>方法级（setup_method&#x2F;teardown_method）开始于方法始末（在类中）</li>
<li>类里面的（setup&#x2F;teardown）运行在调用方法的前后</li>
</ul>
<h1 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h1><h3 id="setup-function-x2F-teardown-function"><a href="#setup-function-x2F-teardown-function" class="headerlink" title="setup_function&#x2F;teardown_function"></a>setup_function&#x2F;teardown_function</h3><p>1.pytest框架支持函数和类两种用例方式，先看函数里面的前置与后置用法：</p>
<blockquote>
<p><strong>setup_function&#x2F;teardown_function</strong> 每个用例开始和结束调用一次</p>
</blockquote>
<pre><code class="python"># test_fixt.py

# coding:utf-8
import pytest
# 函数式

** 作者：上海-悠悠 QQ交流群：588402570**

def setup_function():
    print(&quot;setup_function：每个用例开始前都会执行&quot;)

def teardown_function():
    print(&quot;teardown_function：每个用例结束后都会执行&quot;)

def test_one():
    print(&quot;正在执行----test_one&quot;)
    x = &quot;this&quot;
    assert &#39;h&#39; in x

def test_two():
    print(&quot;正在执行----test_two&quot;)
    x = &quot;hello&quot;
    assert hasattr(x, &#39;check&#39;)

def test_three():
    print(&quot;正在执行----test_three&quot;)
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a in b

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixt.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="markdown">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO, inifile:
collected 3 items

test_fixt.py setup_function：每个用例开始前都会执行
正在执行----test_one
.teardown_function：每个用例结束后都会执行
setup_function：每个用例开始前都会执行
正在执行----test_two
Fteardown_function：每个用例结束后都会执行
setup_function：每个用例开始前都会执行
正在执行----test_three
.teardown_function：每个用例结束后都会执行


================================== FAILURES ===================================
__________________________________ test_two ___________________________________

    def test_two():
        print(&quot;正在执行----test_two&quot;)
        x = &quot;hello&quot;
&gt;       assert hasattr(x, &#39;check&#39;)
E       AssertionError: assert False
E        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)

test_fixt.py:19: AssertionError
===================== 1 failed, 2 passed in 0.03 seconds ======================
</code></pre>
<p>2.从结果可以看出用例执行顺序：setup_function》用例1》teardown_function， setup_function》用例2》teardown_function， setup_function》用例3》teardown_function</p>
<p><strong>备注：-s参数是为了显示用例的打印信息。 -q参数只显示结果，不显示过程</strong></p>
<h3 id="setup-module-x2F-teardown-module"><a href="#setup-module-x2F-teardown-module" class="headerlink" title="setup_module&#x2F;teardown_module"></a>setup_module&#x2F;teardown_module</h3><p>1.setup_module是所有用例开始前只执行一次，teardown_module是所有用例结束后只执行一次</p>
<pre><code class="python"># test_fixt.py

# coding:utf-8
import pytest
# 函数式

** 作者：上海-悠悠 QQ交流群：588402570**

def setup_module():
    print(&quot;setup_module：整个.py模块只执行一次&quot;)
    print(&quot;比如：所有用例开始前只打开一次浏览器&quot;)

def teardown_module():
    print(&quot;teardown_module：整个.py模块只执行一次&quot;)
    print(&quot;比如：所有用例结束只最后关闭浏览器&quot;)

def setup_function():
    print(&quot;setup_function：每个用例开始前都会执行&quot;)

def teardown_function():
    print(&quot;teardown_function：每个用例结束前都会执行&quot;)

def test_one():
    print(&quot;正在执行----test_one&quot;)
    x = &quot;this&quot;
    assert &#39;h&#39; in x

def test_two():
    print(&quot;正在执行----test_two&quot;)
    x = &quot;hello&quot;
    assert hasattr(x, &#39;check&#39;)

def test_three():
    print(&quot;正在执行----test_three&quot;)
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a in b

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixt.py&quot;])
</code></pre>
<p>2.从运行结果可以看到setup_module和teardown_module只执行了一次</p>
<pre><code class="css">test_fixt.py setup_module：整个.py模块只执行一次
比如：所有用例开始前只打开一次浏览器
setup_function：每个用例开始前都会执行
正在执行----test_one
.teardown_function：每个用例结束前都会执行
setup_function：每个用例开始前都会执行
正在执行----test_two
Fteardown_function：每个用例结束前都会执行
setup_function：每个用例开始前都会执行
正在执行----test_three
.teardown_function：每个用例结束前都会执行
teardown_module：整个.py模块只执行一次
比如：所有用例结束只最好关闭浏览器
</code></pre>
<p><strong>备注：setup_function&#x2F;teardown_function和setup_module&#x2F;teardown_module这四种方法是可以任意组合的，用一个和多个都可以</strong></p>
<h1 id="类和方法"><a href="#类和方法" class="headerlink" title="类和方法"></a>类和方法</h1><p>1.setup&#x2F;teardown和unittest里面的setup&#x2F;teardown是一样的功能，setup_class和teardown_class等价于unittest里面的setupClass和teardownClass</p>
<pre><code class="python">#test_fixtclass.py

# coding:utf-8
import pytest
# 类和方法

** 作者：上海-悠悠 QQ交流群：588402570**

class TestCase():

    def setup(self):
        print(&quot;setup: 每个用例开始前执行&quot;)

    def teardown(self):
        print(&quot;teardown: 每个用例结束后执行&quot;)

    def setup_class(self):
        print(&quot;setup_class：所有用例执行之前&quot;)

    def teardown_class(self):
        print(&quot;teardown_class：所有用例执行之前&quot;)

    def setup_method(self):
        print(&quot;setup_method:  每个用例开始前执行&quot;)

    def teardown_method(self):
        print(&quot;teardown_method:  每个用例结束后执行&quot;)

    def test_one(self):
        print(&quot;正在执行----test_one&quot;)
        x = &quot;this&quot;
        assert &#39;h&#39; in x

    def test_two(self):
        print(&quot;正在执行----test_two&quot;)
        x = &quot;hello&quot;
        assert hasattr(x, &#39;check&#39;)

    def test_three(self):
        print(&quot;正在执行----test_three&quot;)
        a = &quot;hello&quot;
        b = &quot;hello world&quot;
        assert a in b

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixtclass.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="makefile">test_fixtclass.py setup_class：所有用例执行之前
setup_method:  每个用例开始前执行
setup: 每个用例开始前执行
正在执行----test_one
.teardown: 每个用例结束后执行
teardown_method:  每个用例结束后执行
setup_method:  每个用例开始前执行
setup: 每个用例开始前执行
正在执行----test_two
Fteardown: 每个用例结束后执行
teardown_method:  每个用例结束后执行
setup_method:  每个用例开始前执行
setup: 每个用例开始前执行
正在执行----test_three
.teardown: 每个用例结束后执行
teardown_method:  每个用例结束后执行
teardown_class：所有用例执行之前
</code></pre>
<p>2.从结果看出，运行的优先级：setup_class》setup_method》setup 》用例》teardown》teardown_method》teardown_class<br><strong>备注：这里setup_method和teardown_method的功能和setup&#x2F;teardown功能是一样的，一般二者用其中一个即可</strong></p>
<h1 id="函数和类混合"><a href="#函数和类混合" class="headerlink" title="函数和类混合"></a>函数和类混合</h1><p>1.如果一个.py的文件里面既有函数用例又有类和方法用例，运行顺序又是怎样的呢？</p>
<pre><code class="python"># coding:utf-8
import pytest
# 类和方法

** 作者：上海-悠悠 QQ交流群：588402570**

def setup_module():
    print(&quot;setup_module：整个.py模块只执行一次&quot;)
    print(&quot;比如：所有用例开始前只打开一次浏览器&quot;)

def teardown_module():
    print(&quot;teardown_module：整个.py模块只执行一次&quot;)
    print(&quot;比如：所有用例结束只最后关闭浏览器&quot;)

def setup_function():
    print(&quot;setup_function：每个用例开始前都会执行&quot;)

def teardown_function():
    print(&quot;teardown_function：每个用例结束前都会执行&quot;)

def test_one():
    print(&quot;正在执行----test_one&quot;)
    x = &quot;this&quot;
    assert &#39;h&#39; in x

def test_two():
    print(&quot;正在执行----test_two&quot;)
    x = &quot;hello&quot;
    assert hasattr(x, &#39;check&#39;)

class TestCase():

    def setup_class(self):
        print(&quot;setup_class：所有用例执行之前&quot;)

    def teardown_class(self):
        print(&quot;teardown_class：所有用例执行之前&quot;)

    def test_three(self):
        print(&quot;正在执行----test_three&quot;)
        x = &quot;this&quot;
        assert &#39;h&#39; in x

    def test_four(self):
        print(&quot;正在执行----test_four&quot;)
        x = &quot;hello&quot;
        assert hasattr(x, &#39;check&#39;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixtclass.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="css">test_fixtclass.py setup_module：整个.py模块只执行一次
比如：所有用例开始前只打开一次浏览器
setup_function：每个用例开始前都会执行
正在执行----test_one
.teardown_function：每个用例结束前都会执行
setup_function：每个用例开始前都会执行
正在执行----test_two
Fteardown_function：每个用例结束前都会执行
setup_class：所有用例执行之前
正在执行----test_three
.正在执行----test_four
Fteardown_class：所有用例执行之前
teardown_module：整个.py模块只执行一次
比如：所有用例结束只最后关闭浏览器
</code></pre>
<p>2.从运行结果看出，setup_module&#x2F;teardown_module的优先级是最大的，然后函数里面用到的setup_function&#x2F;teardown_function与类里面的setup_class&#x2F;teardown_class互不干涉</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档05_fixture之conftest.py</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A305_fixture%E4%B9%8Bconftest.py/</url>
    <content><![CDATA[<p>前言</p>
<p>前面一篇讲到用例加setup和teardown可以实现在测试用例之前或之后加入一些操作，但这种是整个脚本全局生效的，如果我想实现以下场景：<br>用例1需要先登录，用例2不需要登录，用例3需要先登录。很显然这就无法用setup和teardown来实现了。这就是本篇学习的目的，自定义测试用例的预置条件</p>
<h1 id="fixture优势"><a href="#fixture优势" class="headerlink" title="fixture优势"></a>fixture优势</h1><p>1.firture相对于setup和teardown来说应该有以下几点优势</p>
<ul>
<li>命名方式灵活，不局限于setup和teardown这几个命名</li>
<li>conftest.py 配置里可以实现数据共享，不需要import就能自动找到一些配置</li>
<li>scope&#x3D;”module” 可以实现多个.py跨文件共享前置, 每一个.py文件调用一次</li>
<li>scope&#x3D;”session” 以实现多个.py跨文件使用一个session来完成多个用例</li>
</ul>
<pre><code class="sql">fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None):
    &quot;&quot;&quot;使用装饰器标记fixture的功能
     ** 作者：上海-悠悠 QQ交流群：588402570**
     可以使用此装饰器（带或不带参数）来定义fixture功能。 fixture功能的名称可以在以后使用
     引用它会在运行测试之前调用它：test模块或类可以使用pytest.mark.usefixtures（fixturename标记。 
     测试功能可以直接使用fixture名称作为输入参数，在这种情况下，夹具实例从fixture返回功能将被注入。

    :arg scope: scope 有四个级别参数 &quot;function&quot; (默认), &quot;class&quot;, &quot;module&quot; or &quot;session&quot;.

    :arg params: 一个可选的参数列表，它将导致多个参数调用fixture功能和所有测试使用它

    :arg autouse:  如果为True，则为所有测试激活fixture func 可以看到它。 如果为False（默认值）则显式需要参考来激活fixture

    :arg ids: 每个字符串id的列表，每个字符串对应于params 这样他们就是测试ID的一部分。 如果没有提供ID它们将从params自动生成

    :arg name:   fixture的名称。 这默认为装饰函数的名称。 如果fixture在定义它的同一模块中使用，夹具的功能名称将被请求夹具的功能arg遮蔽; 解决这个问题的一种方法是将装饰函数命名
                       “fixture_ &lt;fixturename&gt;”然后使用”@ pytest.fixture（name =&#39;&lt;fixturename&gt;&#39;）“”。
</code></pre>
<p><strong>Fixtures可以选择使用<code>yield</code>语句为测试函数提供它们的值，而不是<code>return</code>。 在这种情况下，<code>yield</code>语句之后的代码块作为拆卸代码执行，而不管测试结果如何。fixture功能必须只产生一次</strong></p>
<h1 id="fixture参数传入（scope-x3D-”function”）"><a href="#fixture参数传入（scope-x3D-”function”）" class="headerlink" title="fixture参数传入（scope&#x3D;”function”）"></a>fixture参数传入（scope&#x3D;”function”）</h1><p>1.实现场景：用例1需要先登录，用例2不需要登录，用例3需要先登录</p>
<pre><code class="python"># 新建一个文件test_fixt.py
# coding:utf-8
** 作者：上海-悠悠 QQ交流群：588402570**
import pytest

# 不带参数时默认scope=&quot;function&quot;
@pytest.fixture()
def login():
    print(&quot;输入账号，密码先登录&quot;)

def test_s1(login):
    print(&quot;用例1：登录之后其它动作111&quot;)

def test_s2():  # 不传login
    print(&quot;用例2：不需要登录，操作222&quot;)

def test_s3(login):
    print(&quot;用例3：登录之后其它动作333&quot;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fix.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="diff">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO, inifile:
collected 3 items

test_fix.py 输入账号，密码先登录
用例1：登录之后其它动作111
.用例2：不需要登录，操作222
.输入账号，密码先登录
用例3：登录之后其它动作333
.

========================== 3 passed in 0.06 seconds ===========================
</code></pre>
<p>2.如果@pytest.fixture()里面没有参数，那么默认scope&#x3D;”function”，也就是此时的级别的function，针对函数有效</p>
<h1 id="conftest-py配置"><a href="#conftest-py配置" class="headerlink" title="conftest.py配置"></a>conftest.py配置</h1><p>1.上面一个案例是在同一个.py文件中，多个用例调用一个登陆功能，如果有多个.py的文件都需要调用这个登陆功能的话，那就不能把登陆写到用例里面去了。<br>此时应该要有一个配置文件，单独管理一些预置的操作场景，pytest里面默认读取conftest.py里面的配置</p>
<p>conftest.py配置需要注意以下点：</p>
<ul>
<li>conftest.py配置脚本名称是固定的，不能改名称</li>
<li>conftest.py与运行的用例要在同一个pakage下，并且有__init__.py文件</li>
<li>不需要import导入 conftest.py，pytest用例会自动查找</li>
</ul>
<p>2.参考脚本代码设计如下</p>
<pre><code class="python">** 作者：上海-悠悠 QQ交流群：588402570**
__init__.py

conftest.py
    # coding:utf-8
    import pytest

    @pytest.fixture()
    def login():
        print(&quot;输入账号，密码先登录&quot;)

test_fix1.py
    # coding:utf-8
    import pytest
  
    def test_s1(login):
        print(&quot;用例1：登录之后其它动作111&quot;)
  
    def test_s2():  # 不传login
        print(&quot;用例2：不需要登录，操作222&quot;)
  
    def test_s3(login):
        print(&quot;用例3：登录之后其它动作333&quot;)
  
    if __name__ == &quot;__main__&quot;:
        pytest.main([&quot;-s&quot;, &quot;test_fix1.py&quot;])

test_fix2.py
    # coding:utf-8
    import pytest
  
    def test_s4(login):
        print(&quot;用例4：登录之后其它动作111&quot;)
  
    def test_s5():  # 不传login
        print(&quot;用例5：不需要登录，操作222&quot;)
  
    if __name__ == &quot;__main__&quot;:
        pytest.main([&quot;-s&quot;, &quot;test_fix2.py&quot;])
</code></pre>
<p>3.单独运行test_fix1.py和test_fix2.py都能调用到login()方法，这样就能实现一些公共的操作可以单独拿出来了</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档06_fixture之yield实现teardown</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A306_fixture%E4%B9%8Byield%E5%AE%9E%E7%8E%B0teardown/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇讲到fixture通过scope参数控制setup级别，既然有setup作为用例之前前的操作，用例执行完之后那肯定也有teardown操作。<br>这里用到fixture的teardown操作并不是独立的函数，用yield关键字呼唤teardown操作</p>
<h1 id="scope-x3D-”module”"><a href="#scope-x3D-”module”" class="headerlink" title="scope&#x3D;”module”"></a>scope&#x3D;”module”</h1><p>1.fixture参数scope&#x3D;”module”，module作用是整个.py文件都会生效，用例调用时，参数写上函数名称就行</p>
<pre><code class="python"># 新建一个文件test_f1.py
# coding:utf-8
import pytest
&#39;&#39;&#39;
** 作者：上海-悠悠 QQ交流群：588402570**
&#39;&#39;&#39;

@pytest.fixture(scope=&quot;module&quot;)
def open():
    print(&quot;打开浏览器，并且打开百度首页&quot;)

def test_s1(open):
    print(&quot;用例1：搜索python-1&quot;)

def test_s2(open):
    print(&quot;用例2：搜索python-2&quot;)

def test_s3(open):
    print(&quot;用例3：搜索python-3&quot;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_f1.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="diff">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
collected 3 items

..\..\..\..\..\..\YOYO\test_f1.py 打开浏览器，并且打开百度首页
用例1：搜索python-1
.用例2：搜索python-2
.用例3：搜索python-3
.

========================== 3 passed in 0.01 seconds ===========================
</code></pre>
<p><strong>从结果看出，虽然test_s1,test_s2,test_s3三个地方都调用了open函数，但是它只会在第一个用例前执行一次</strong></p>
<p>2.如果test_s1不调用,test_s2（调用open）,test_s3不调用，运行顺序会是怎样的？</p>
<pre><code class="python"># 新建一个文件test_f1.py
# coding:utf-8
import pytest
&#39;&#39;&#39;
** 作者：上海-悠悠 QQ交流群：588402570**
&#39;&#39;&#39;

@pytest.fixture(scope=&quot;module&quot;)
def open():
    print(&quot;打开浏览器，并且打开百度首页&quot;)

def test_s1():
    print(&quot;用例1：搜索python-1&quot;)

def test_s2(open): 
    print(&quot;用例2：搜索python-2&quot;)

def test_s3():
    print(&quot;用例3：搜索python-3&quot;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_f1.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="diff">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
collected 3 items

..\..\..\..\..\..\YOYO\test_f1.py 用例1：搜索python-1
.打开浏览器，并且打开百度首页
用例2：搜索python-2
.用例3：搜索python-3
.

========================== 3 passed in 0.01 seconds ===========================
</code></pre>
<p><strong>从结果看出，module级别的fixture在当前.py模块里，只会在用例（test_s2）第一次调用前执行一次</strong></p>
<h1 id="yield执行teardown"><a href="#yield执行teardown" class="headerlink" title="yield执行teardown"></a>yield执行teardown</h1><p>1.前面讲的是在用例前加前置条件，相当于setup,既然有setup那就有teardown,fixture里面的teardown用yield来唤醒teardown的执行</p>
<pre><code class="python"># 新建一个文件test_f1.py
# coding:utf-8
import pytest
&#39;&#39;&#39;
** 作者：上海-悠悠 QQ交流群：588402570**
&#39;&#39;&#39;

@pytest.fixture(scope=&quot;module&quot;)
def open():
    print(&quot;打开浏览器，并且打开百度首页&quot;)

    yield
    print(&quot;执行teardown!&quot;)
    print(&quot;最后关闭浏览器&quot;)

def test_s1(open):
    print(&quot;用例1：搜索python-1&quot;)

def test_s2(open):
    print(&quot;用例2：搜索python-2&quot;)

def test_s3(open):
    print(&quot;用例3：搜索python-3&quot;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_f1.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="diff">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
collected 3 items

..\..\..\..\..\..\YOYO\test_f1.py 打开浏览器，并且打开百度首页
用例1：搜索python-1
.用例2：搜索python-2
.用例3：搜索python-3
.执行teardown!
最后关闭浏览器


========================== 3 passed in 0.01 seconds ===========================
</code></pre>
<h1 id="yield遇到异常"><a href="#yield遇到异常" class="headerlink" title="yield遇到异常"></a>yield遇到异常</h1><p>1.如果其中一个用例出现异常，不影响yield后面的teardown执行,运行结果互不影响，并且全部用例执行完之后，yield呼唤teardown操作</p>
<pre><code class="python"># 新建一个文件test_f1.py
# coding:utf-8
import pytest
&#39;&#39;&#39;
** 作者：上海-悠悠 QQ交流群：588402570**
&#39;&#39;&#39;

@pytest.fixture(scope=&quot;module&quot;)
def open():
    print(&quot;打开浏览器，并且打开百度首页&quot;)
    yield
    print(&quot;执行teardown!&quot;)
    print(&quot;最后关闭浏览器&quot;)

def test_s1(open):
    print(&quot;用例1：搜索python-1&quot;)

    # 如果第一个用例异常了，不影响其他的用例执行
    raise NameError  # 模拟异常

def test_s2(open):
    print(&quot;用例2：搜索python-2&quot;)

def test_s3(open):
    print(&quot;用例3：搜索python-3&quot;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_f1.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="python">\YOYO\test_f1.py 打开浏览器，并且打开百度首页
用例1：搜索python-1
F
open = None

    def test_s1(open):
        print(&quot;用例1：搜索python-1&quot;)
  
        # 如果第一个用例异常了，不影响其他的用例执行
&gt;       raise NameError  # 模拟异常
E       NameError

D:\YOYO\test_f1.py:16: NameError
用例2：搜索python-2
.用例3：搜索python-3
.执行teardown!
最后关闭浏览器
</code></pre>
<p>2.如果在setup就异常了，那么是不会去执行yield后面的teardown内容了</p>
<p>3.yield也可以配合with语句使用，以下是官方文档给的案例</p>
<pre><code class="python"># 官方文档案例
# content of test_yield2.py

import smtplib
import pytest
&#39;&#39;&#39;
** 作者：上海-悠悠 QQ交流群：588402570**
&#39;&#39;&#39;

@pytest.fixture(scope=&quot;module&quot;)
def smtp():
    with smtplib.SMTP(&quot;smtp.gmail.com&quot;) as smtp:
        yield smtp  # provide the fixture value
</code></pre>
<h1 id="addfinalizer终结函数"><a href="#addfinalizer终结函数" class="headerlink" title="addfinalizer终结函数"></a>addfinalizer终结函数</h1><p>1.除了yield可以实现teardown,在request-context对象中注册addfinalizer方法也可以实现终结函数。</p>
<pre><code class="python"># 官方案例

# content of conftest.py
import smtplib
import pytest

@pytest.fixture(scope=&quot;module&quot;)
def smtp_connection(request):
    smtp_connection = smtplib.SMTP(&quot;smtp.gmail.com&quot;, 587, timeout=5)
    def fin():
        print(&quot;teardown smtp_connection&quot;)
        smtp_connection.close()
    request.addfinalizer(fin)
    return smtp_connection  # provide the fixture value
</code></pre>
<p>2.yield和addfinalizer方法都是在测试完成后呼叫相应的代码。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档07_pytest-html生成html报告</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A307_pytest-html%E7%94%9F%E6%88%90html%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest-HTML是一个插件，pytest用于生成测试结果的HTML报告。兼容Python 2.7,3.6</p>
<h1 id="pytest-html"><a href="#pytest-html" class="headerlink" title="pytest-html"></a>pytest-html</h1><p>1.github上源码地址<a href="https://github.com/pytest-dev/pytest-html">【https://github.com/pytest-dev/pytest-html】</a></p>
<p>2.pip安装</p>
<blockquote>
<p>$ pip install pytest-html</p>
</blockquote>
<p><img src="/assets/2/image-20220516001356-6zs7ypp.png" alt="image.png"></p>
<p>3.执行方法</p>
<blockquote>
<p>$ pytest –html&#x3D;report.html</p>
</blockquote>
<h1 id="html报告"><a href="#html报告" class="headerlink" title="html报告"></a>html报告</h1><p>1.打开cmd，cd到需要执行pytest用例的目录，执行指令：pytest –html&#x3D;report.html</p>
<p><img src="/assets/2/image-20220516001403-jbuctku.png" alt="image.png"></p>
<p>2.执行完之后，在当前目录会生成一个report.html的报告文件，显示效果如下</p>
<p><img src="/assets/2/image-20220516001417-37ojnzw.png" alt="image.png"></p>
<h1 id="指定报告路径"><a href="#指定报告路径" class="headerlink" title="指定报告路径"></a>指定报告路径</h1><p>1.直接执行”pytest –html&#x3D;report.html”生成的报告会在当前脚本的同一路径，如果想指定报告的存放位置，放到当前脚本的同一目录下的report文件夹里</p>
<blockquote>
<p>pytest –html&#x3D;.&#x2F;report&#x2F;report.html</p>
</blockquote>
<p><img src="/assets/2/image-20220516001426-fulsp6s.png" alt="image.png"></p>
<p>2.如果想指定执行某个.py文件用例或者某个文件夹里面的所有用例，需加个参数。具体规则参考<a href="https://www.cnblogs.com/yoyoketang/p/9362415.html">【pytest文档2-用例运行规则】</a></p>
<p><img src="/assets/2/image-20220516001436-kdb1uuj.png" alt="image.png"></p>
<h1 id="报告独立显示"><a href="#报告独立显示" class="headerlink" title="报告独立显示"></a>报告独立显示</h1><p>1.上面方法生成的报告，css是独立的，分享报告的时候样式会丢失，为了更好的分享发邮件展示报告，可以把css样式合并到html里</p>
<blockquote>
<p>$ pytest –html&#x3D;report.html –self-contained-html</p>
</blockquote>
<h1 id="显示选项"><a href="#显示选项" class="headerlink" title="显示选项"></a>显示选项</h1><p>默认情况下，“ 结果”表中的所有行都将被展开，但具测试通过的行除外Passed。</p>
<p>可以使用查询参数自定义此行为：?collapsed&#x3D;Passed,XFailed,Skipped。</p>
<h1 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h1><p>1.更多功能查看官方文档<a href="https://github.com/pytest-dev/pytest-html">【https://github.com/pytest-dev/pytest-html】</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档08_html报告报错截图+失败重跑</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A308_html%E6%8A%A5%E5%91%8A%E6%8A%A5%E9%94%99%E6%88%AA%E5%9B%BE+%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%B7%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做web自动化的小伙伴应该都希望在html报告中展示失败后的截图，提升报告的档次，pytest-html也可以生成带截图的报告。</p>
<h1 id="conftest-py"><a href="#conftest-py" class="headerlink" title="conftest.py"></a>conftest.py</h1><p>1.失败截图可以写到conftest.py文件里，这样用例运行时，只要检测到用例实例，就调用截图的方法，并且把截图存到html报告上</p>
<pre><code class="python"># conftest.py文件
# coding:utf-8

from selenium import webdriver
import pytest


driver = None

@pytest.mark.hookwrapper
def pytest_runtest_makereport(item):
    &quot;&quot;&quot;
    当测试失败的时候，自动截图，展示到html报告中
    ** 作者：上海-悠悠 QQ交流群：588402570**
    :param item:
    &quot;&quot;&quot;
    pytest_html = item.config.pluginmanager.getplugin(&#39;html&#39;)
    outcome = yield
    report = outcome.get_result()
    extra = getattr(report, &#39;extra&#39;, [])

    if report.when == &#39;call&#39; or report.when == &quot;setup&quot;:
        xfail = hasattr(report, &#39;wasxfail&#39;)
        if (report.skipped and xfail) or (report.failed and not xfail):
            file_name = report.nodeid.replace(&quot;::&quot;, &quot;_&quot;)+&quot;.png&quot;
            screen_img = _capture_screenshot()
            if file_name:
                html = &#39;&lt;div&gt;&lt;img src=&quot;data:image/png;base64,%s&quot; alt=&quot;screenshot&quot; style=&quot;width:600px;height:300px;&quot; &#39; \
                       &#39;onclick=&quot;window.open(this.src)&quot; align=&quot;right&quot;/&gt;&lt;/div&gt;&#39; % screen_img
                extra.append(pytest_html.extras.html(html))
        report.extra = extra

def _capture_screenshot():
    &#39;&#39;&#39;
    ** 作者：上海-悠悠 QQ交流群：588402570**
    截图保存为base64，展示到html中
    :return:
    &#39;&#39;&#39;
    return driver.get_screenshot_as_base64()


@pytest.fixture(scope=&#39;session&#39;, autouse=True)
def browser(request):
    global driver
    if driver is None:
        driver = webdriver.Firefox()

    def end():
        driver.quit()
    request.addfinalizer(end)
    return driver
</code></pre>
<p>2.用例部分如下：</p>
<pre><code class="python"># test_01.py文件

from selenium import webdriver
import time

#** 作者：上海-悠悠 QQ交流群：588402570**

def test_yoyo_01(browser):

    browser.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)
    time.sleep(2)
    t = browser.title
    assert t == &quot;上海-悠悠&quot;

# test_02.py文件

from selenium import webdriver
import time

# ** 作者：上海-悠悠 QQ交流群：588402570**

def test_yoyo_01(browser):

    browser.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)
    time.sleep(2)
    t = browser.title
    assert &quot;上海-悠悠&quot; in t
</code></pre>
<h1 id="报告展示"><a href="#报告展示" class="headerlink" title="报告展示"></a>报告展示</h1><p>1.cmd打开，cd到用例的目录，执行指令</p>
<blockquote>
<p>$ pytest –html&#x3D;report.html –self-contained-html</p>
</blockquote>
<p><img src="/assets/2/image-20220516001612-m24nqsv.png" alt="image.png"></p>
<p>2.生成报告如下</p>
<p><img src="/assets/2/image-20220516001619-6ty9avx.png" alt="image.png"></p>
<h1 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h1><p>失败重跑需要依赖pytest-rerunfailures插件，使用pip安装就行</p>
<blockquote>
<p>$ pip install pytest-rerunfailures</p>
</blockquote>
<p><img src="/assets/2/image-20220516001626-5l8qcqf.png" alt="image.png"></p>
<p>用例失败再重跑1次,命令行加个参数–reruns就行了</p>
<blockquote>
<p>$ py.test –reruns 1 –html&#x3D;report.html –self-contained-html</p>
</blockquote>
<p><img src="/assets/2/image-20220516001644-nfycp7s.png" alt="image.png"></p>
<p>关于reruns参数的2个用法</p>
<pre><code class="sql">re-run failing tests to eliminate flaky failures:
  --reruns=RERUNS       number of times to re-run failed tests. defaults to 0.
  --reruns-delay=RERUNS_DELAY
                        add time (seconds) delay between reruns.
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档09_参数化parametrize</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A309_%E5%8F%82%E6%95%B0%E5%8C%96parametrize/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest.mark.parametrize装饰器可以实现测试用例参数化。</p>
<h1 id="parametrizing"><a href="#parametrizing" class="headerlink" title="parametrizing"></a>parametrizing</h1><p>1.这里是一个实现检查一定的输入和期望输出测试功能的典型例子</p>
<pre><code class="python"># content of test_expectation.py

# coding:utf-8

import pytest
@pytest.mark.parametrize(&quot;test_input,expected&quot;,
                         [ (&quot;3+5&quot;, 8),
                           (&quot;2+4&quot;, 6),
                           (&quot;6 * 9&quot;, 42),
                         ])
def test_eval(test_input, expected):
    assert eval(test_input) == expected

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_canshu1.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="python">
================================== FAILURES ===================================
_____________________________ test_eval[6 * 9-42] _____________________________

test_input = &#39;6 * 9&#39;, expected = 42

    @pytest.mark.parametrize(&quot;test_input,expected&quot;,
                             [ (&quot;3+5&quot;, 8),
                               (&quot;2+4&quot;, 6),
                               (&quot;6 * 9&quot;, 42),
                             ])
    def test_eval(test_input, expected):
&gt;       assert eval(test_input) == expected
E       AssertionError: assert 54 == 42
E        +  where 54 = eval(&#39;6 * 9&#39;)

test_canshu1.py:11: AssertionError
===================== 1 failed, 2 passed in 1.98 seconds ======================
</code></pre>
<p>在这个例子中设计的，只有一条输入&#x2F;输出值的简单测试功能。和往常一样</p>
<p>函数的参数，你可以在运行结果看到在输入和输出值</p>
<p>2.它也可以标记单个测试实例在参数化，例如使用内置的mark.xfail</p>
<pre><code class="python"># content of test_expectation.py
import pytest
@pytest.mark.parametrize(&quot;test_input,expected&quot;, [
                        (&quot;3+5&quot;, 8),
                        (&quot;2+4&quot;, 6),
                        pytest.param(&quot;6 * 9&quot;, 42, marks=pytest.mark.xfail),
                        ])
def test_eval(test_input, expected):
    print(&quot;-------开始用例------&quot;)
    assert eval(test_input) == expected



if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_canshu1.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="lua">test_canshu1.py -------开始用例------
.-------开始用例------
.-------开始用例------
x

===================== 2 passed, 1 xfailed in 1.84 seconds =====================
</code></pre>
<p>标记为失败的用例，预期结果是失败，实际运行也是失败，显示xfailed</p>
<h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>1.若要获得多个参数化参数的所有组合，可以堆叠参数化装饰器</p>
<pre><code class="python">import pytest
@pytest.mark.parametrize(&quot;x&quot;, [0, 1])
@pytest.mark.parametrize(&quot;y&quot;, [2, 3])
def test_foo(x, y):
    print(&quot;测试数据组合：x-&gt;%s, y-&gt;%s&quot; % (x, y))


if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_canshu1.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="rust">
test_canshu1.py 测试数据组合：x-&gt;0, y-&gt;2
.测试数据组合：x-&gt;1, y-&gt;2
.测试数据组合：x-&gt;0, y-&gt;3
.测试数据组合：x-&gt;1, y-&gt;3
.

========================== 4 passed in 1.75 seconds ===========================
</code></pre>
<p>这将运行测试，参数设置为x＝0／y＝2，x＝1／y＝2，x＝0／y＝3，x＝1／y＝3组合参数。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档10_命令行传参</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A310_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>命令行参数是根据命令行选项将不同的值传递给测试函数，比如平常在cmd执行”pytest –html&#x3D;report.html”,这里面的”–html&#x3D;report.html“就是从命令行传入的参数<br>对应的参数名称是html，参数值是report.html</p>
<h1 id="conftest配置参数"><a href="#conftest配置参数" class="headerlink" title="conftest配置参数"></a>conftest配置参数</h1><p>1.首先需要在conftest.py添加命令行选项,命令行传入参数”–cmdopt“, 用例如果需要用到从命令行传入的参数，就调用cmdopt函数：</p>
<pre><code class="python"># content of conftest.py
import pytest


def pytest_addoption(parser):
    parser.addoption(
        &quot;--cmdopt&quot;, action=&quot;store&quot;, default=&quot;type1&quot;, help=&quot;my option: type1 or type2&quot;
    )

@pytest.fixture
def cmdopt(request):
    return request.config.getoption(&quot;--cmdopt&quot;)
</code></pre>
<p>2.测试用例编写案例</p>
<pre><code class="python"># content of test_sample.py
import pytest
def test_answer(cmdopt):
    if cmdopt == &quot;type1&quot;:
        print(&quot;first&quot;)
    elif cmdopt == &quot;type2&quot;:
        print(&quot;second&quot;)
    assert 0  # to see what was printed

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_case1.py&quot;])
</code></pre>
<p>cmd打开，输入指令启动，也可以在pycharm里面右键执行上面代码</p>
<blockquote>
<p>$ pytest -s test_sample.py</p>
</blockquote>
<p>运行结果：</p>
<pre><code class="markdown">&gt;pytest -s
============================= test session starts =============================
test_sample.py first
F

================================== FAILURES ===================================
_________________________________ test_answer _________________________________

cmdopt = &#39;type1&#39;

    def test_answer(cmdopt):
        if cmdopt == &quot;type1&quot;:
            print(&quot;first&quot;)
        elif cmdopt == &quot;type2&quot;:
            print(&quot;second&quot;)
&gt;       assert 0  # to see what was printed
E       assert 0

test_case1.py:8: AssertionError
========================== 1 failed in 0.05 seconds ===========================
</code></pre>
<h1 id="带参数启动"><a href="#带参数启动" class="headerlink" title="带参数启动"></a>带参数启动</h1><p>1.如果不带参数执行，那么传默认的default&#x3D;”type1”，接下来在命令行带上参数去执行</p>
<blockquote>
<p>$ pytest -s test_sample.py –cmdopt&#x3D;type2</p>
</blockquote>
<pre><code class="markdown">test_sample.py second
F

================================== FAILURES ===================================
_________________________________ test_answer _________________________________

cmdopt = &#39;type2&#39;

    def test_answer(cmdopt):
        if cmdopt == &quot;type1&quot;:
            print(&quot;first&quot;)
        elif cmdopt == &quot;type2&quot;:
            print(&quot;second&quot;)
&gt;       assert 0  # to see what was printed
E       assert 0

test_case1.py:8: AssertionError
========================== 1 failed in 0.05 seconds ===========================
</code></pre>
<p>2.命令行传参数有两种写法，还有一种分成2个参数也可以的,参数和名称用空格隔开</p>
<blockquote>
<p>$ pytest -s test_case1.py –cmdopt type2</p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档11-assert断言</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A311-assert%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>断言是写自动化测试基本最重要的一步，一个用例没有断言，就失去了自动化测试的意义了。什么是断言呢？<br>简单来讲就是实际结果和期望结果去对比，符合预期那就测试pass，不符合预期那就测试 failed</p>
<h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>pytest允许您使用标准Python断言来验证Python测试中的期望和值。例如，你可以写下</p>
<pre><code class="csharp"># content of test_assert1.py
def f():
    return 3
def test_function():
    assert f() == 4
</code></pre>
<p>断言f()函数的返回值，接下来会看到断言失败，因为返回的值是3，判断等于4，所以失败了</p>
<pre><code class="markdown">$ pytest test_assert1.py
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y
rootdir: $REGENDOC_TMPDIR, inifile:
collected 1 item
test_assert1.py F [100%]
================================= FAILURES =================================
______________________________ test_function _______________________________
def test_function():
&gt; assert f() == 4
E assert 3 == 4
E + where 3 = f()
test_assert1.py:5: AssertionError
========================= 1 failed in 0.12 seconds =========================
</code></pre>
<p>从报错信息可以看到断言失败原因：E assert 3 &#x3D;&#x3D; 4</p>
<h1 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h1><p>接下来再看一个案例，如果想在异常的时候，输出一些提示信息，这样报错后，就方便查看是什么原因了</p>
<pre><code class="ruby">def f():
    return 3

def test_function():

    a = f()
    assert a % 2 == 0, &quot;判断a为偶数，当前a的值为：%s&quot;%a
</code></pre>
<p>运行结果</p>
<pre><code class="markdown">================================== FAILURES ===================================
________________________________ test_function ________________________________

    def test_function():
  
        a = f()
&gt;       assert a % 2 == 0, &quot;判断a为偶数，当前a的值为：%s&quot;%a
E       AssertionError: 判断a为偶数，当前a的值为：3
E       assert (3 % 2) == 0

test_03.py:9: AssertionError
========================== 1 failed in 0.18 seconds ===========================
</code></pre>
<p>这样当断言失败的时候，会给出自己写的失败原因了E AssertionError: 判断a为偶数，当前a的值为：3</p>
<h1 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h1><p>为了写关于引发异常的断言，可以使用pytest.raises作为上下文管理器，如下</p>
<pre><code class="python"># content of test_assert1.py

import pytest
def test_zero_division():
    with pytest.raises(ZeroDivisionError):
        1 / 0
</code></pre>
<p>运行结果</p>
<pre><code class="yaml">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO\canshuhua, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 1 item

test_assert1.py.

========================== 1 passed in 0.31 seconds ===========================
</code></pre>
<p>如果我们要断言它抛的异常是不是预期的，比如执行：1&#x2F;0,预期结果是抛异常：ZeroDivisionError: division by zero，那我们要断言这个异常，通常是断言异常的type和value值了。<br>这里1&#x2F;0的异常类型是ZeroDivisionError，异常的value值是division by zero，于是用例可以这样设计</p>
<pre><code class="python"># content of test_assert1.py

# ** 作者：上海-悠悠 QQ交流群：588402570**

import pytest
def test_zero_division():
    &#39;&#39;&#39;断言异常&#39;&#39;&#39;
    with pytest.raises(ZeroDivisionError) as excinfo:
        1 / 0

    # 断言异常类型type
    assert excinfo.type == ZeroDivisionError
    # 断言异常value值
    assert &quot;division by zero&quot; in str(excinfo.value)
</code></pre>
<p><strong>excinfo 是一个异常信息实例，它是围绕实际引发的异常的包装器。主要属性是.type、 .value 和 .traceback</strong></p>
<p>注意：断言type的时候，异常类型是不需要加引号的，断言value值的时候需转str</p>
<p>在上下文管理器窗体中，可以使用关键字参数消息指定自定义失败消息：</p>
<pre><code class="python">with pytest.raises(ZeroDivisionError, message=&quot;Expecting ZeroDivisionError&quot;):
    pass

结果：Failed: Expecting ZeroDivisionError
</code></pre>
<h1 id="常用断言"><a href="#常用断言" class="headerlink" title="常用断言"></a>常用断言</h1><p>pytest里面断言实际上就是python里面的assert断言方法，常用的有以下几种</p>
<ul>
<li>assert xx 判断xx为真</li>
<li>assert not xx 判断xx不为真</li>
<li>assert a in b 判断b包含a</li>
<li>assert a &#x3D;&#x3D; b 判断a等于b</li>
<li>assert a !&#x3D; b 判断a不等于b</li>
</ul>
<pre><code class="python">import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

def is_true(a):
    if a &gt; 0:
        return True
    else:
        return False

def test_01():
    &#39;&#39;&#39;断言xx为真&#39;&#39;&#39;
    a = 5
    b = -1
    assert is_true(a)
    assert not is_true(b)

def test_02():
    &#39;&#39;&#39;断言b 包含 a&#39;&#39;&#39;
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a in b

def test_03():
    &#39;&#39;&#39;断言相等&#39;&#39;&#39;
    a = &quot;yoyo&quot;
    b = &quot;yoyo&quot;
    assert a == b

def test_04():
    &#39;&#39;&#39;断言不等于&#39;&#39;&#39;
    a = 5
    b = 6
    assert a != b

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_01.py&quot;])
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档12-skip跳过用例</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A312-skip%E8%B7%B3%E8%BF%87%E7%94%A8%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest.mark.skip可以标记无法在某些平台上运行的测试功能，或者您希望失败的测试功能</p>
<p>skip意味着只有在满足某些条件时才希望测试通过，否则pytest应该跳过运行测试。 常见示例是在非Windows平台上跳过仅限Windows的测试，或跳过测试依赖于当前不可用的外部资源（例如数据库）。</p>
<p>xfail意味着您希望测试由于某种原因而失败。 一个常见的例子是对功能的测试尚未实施，或尚未修复的错误。 当测试通过时尽管预计会失败（标有pytest.mark.xfail），它是一个xpass，将在测试摘要中报告。</p>
<p>pytest计数并分别列出skip和xfail测试。 未显示有关跳过&#x2F; xfailed测试的详细信息默认情况下，以避免混乱输出。 您可以使用-r选项查看与“short”字母对应的详细信息显示在测试进度中</p>
<blockquote>
<p>pytest -rxXs # show extra info on xfailed, xpassed, and skipped tests</p>
</blockquote>
<p>有关-r选项的更多详细信息，请运行pytest -h</p>
<h1 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h1><p>跳过测试函数的最简单方法是使用跳过装饰器标记它，可以传递一个可选的原因</p>
<pre><code class="python">@pytest.mark.skip(reason=&quot;no way of currently testing this&quot;)
def test_the_unknown():
    ...
</code></pre>
<p>或者，也可以通过调用来在测试执行或设置期间强制跳过pytest.skip（reason）功能：</p>
<pre><code class="csharp">def test_function():
    if not valid_config():
        pytest.skip(&quot;unsupported configuration&quot;)
</code></pre>
<p>也可以使用pytest.skip（reason，allow_module_level &#x3D; True）跳过整个模块级别：</p>
<pre><code class="python">import pytest
if not pytest.config.getoption(&quot;--custom-flag&quot;):
    pytest.skip(&quot;--custom-flag is missing, skipping tests&quot;, allow_module_level=True)
</code></pre>
<p>当在导入时间内无法评估跳过条件时，命令性方法很有用。</p>
<h1 id="skipif"><a href="#skipif" class="headerlink" title="skipif"></a>skipif</h1><p>如果您希望有条件地跳过某些内容，则可以使用skipif代替。 这是标记测试的示例在Python3.6之前的解释器上运行时要跳过的函数</p>
<pre><code class="python">import sys
@pytest.mark.skipif(sys.version_info &lt; (3,6),
reason=&quot;requires python3.6 or higher&quot;)
def test_function():
    ...
</code></pre>
<p>如果条件在收集期间评估为True，则将跳过测试函数，具有指定的原因使用-rs时出现在摘要中。</p>
<p>您可以在模块之间共享skipif标记。参考以下案例</p>
<pre><code class="python"># content of test_mymodule.py
import mymodule
minversion = pytest.mark.skipif(mymodule.__versioninfo__ &lt; (1,1),
reason=&quot;at least mymodule-1.1 required&quot;)
@minversion
def test_function():
    ...
</code></pre>
<p>您可以导入标记并在另一个测试模块中重复使用它：</p>
<pre><code class="python"># test_myothermodule.py
from test_mymodule import minversion
@minversion
def test_anotherfunction():
    ...
</code></pre>
<p>对于较大的测试套件，通常最好有一个文件来定义标记，然后一致适用于整个测试套件。</p>
<p>或者，您可以使用条件字符串而不是布尔值，但它们之间不能轻易共享它们支持它们主要是出于向后兼容的原因</p>
<h1 id="skip类或模块"><a href="#skip类或模块" class="headerlink" title="skip类或模块"></a>skip类或模块</h1><p>您可以在类上使用skipif标记（与任何其他标记一样）：</p>
<pre><code class="python">@pytest.mark.skipif(sys.platform == &#39;win32&#39;,
reason=&quot;does not run on windows&quot;)
class TestPosixCalls(object):
    def test_function(self):
        &quot;will not be setup or run under &#39;win32&#39; platform&quot;
</code></pre>
<p>如果条件为True，则此标记将为该类的每个测试方法生成跳过结果</p>
<p><strong>警告：强烈建议不要在使用继承的类上使用skipif。 pytest中的一个已知错误标记可能会导致超类中的意外行为。</strong></p>
<p>如果要跳过模块的所有测试功能，可以在全局级别使用pytestmark名称</p>
<pre><code class="ini"># test_module.py
pytestmark = pytest.mark.skipif(...)
</code></pre>
<p>如果将多个skipif装饰器应用于测试函数，则如果任何跳过条件为真，则将跳过它</p>
<h1 id="skip文件或目录"><a href="#skip文件或目录" class="headerlink" title="skip文件或目录"></a>skip文件或目录</h1><p>有时您可能需要跳过整个文件或目录，例如，如果测试依赖于特定于Python的版本功能或包含您不希望pytest运行的代码。 在这种情况下，您必须排除文件和目录来自收藏。 有关更多信息，请参阅自定义测试集合。</p>
<h1 id="skip缺少导入依赖项"><a href="#skip缺少导入依赖项" class="headerlink" title="skip缺少导入依赖项"></a>skip缺少导入依赖项</h1><p>您可以在模块级别或测试或测试设置功能中使用以下帮助程序</p>
<pre><code class="ini">docutils = pytest.importorskip(&quot;docutils&quot;)
</code></pre>
<p>如果无法在此处导入docutils，则会导致测试跳过结果。 你也可以跳过库的版本号</p>
<pre><code class="ini">docutils = pytest.importorskip(&quot;docutils&quot;, minversion=&quot;0.3&quot;)
</code></pre>
<p>将从指定模块的__version__属性中读取版本。</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这是一个快速指南，介绍如何在不同情况下跳过模块中的测试</p>
<p>1.无条件地跳过模块中的所有测试：</p>
<blockquote>
<p>pytestmark &#x3D; pytest.mark.skip(“all tests still WIP”)</p>
</blockquote>
<p>2.根据某些条件跳过模块中的所有测试</p>
<blockquote>
<p>pytestmark &#x3D; pytest.mark.skipif(sys.platform &#x3D;&#x3D; “win32”, “tests for linux<br>˓→ only”</p>
</blockquote>
<p>3.如果缺少某些导入，则跳过模块中的所有测试</p>
<blockquote>
<p>pexpect &#x3D; pytest.importorskip(“pexpect”)</p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档13-allure2生成html报告(史上最详细)-已废弃，不用看了</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A313-allure2%E7%94%9F%E6%88%90html%E6%8A%A5%E5%91%8A(%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86)-%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%8C%E4%B8%8D%E7%94%A8%E7%9C%8B%E4%BA%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>allure是一个report框架,支持java的Junit&#x2F;testng等框架,当然也可以支持python的pytest框架，也可以集成到Jenkins上展示高大上的报告界面。</p>
<p>环境准备</p>
<ul>
<li>1.python3.6</li>
<li>2.windows环境</li>
<li>3.pycharm</li>
<li>4.pytest-allure-adaptor</li>
<li>5.allure2.7.0</li>
<li>6.java1.8</li>
</ul>
<p>** 作者：上海-悠悠 QQ交流群：588402570**</p>
<h1 id="pytest-allure-adaptor下载"><a href="#pytest-allure-adaptor下载" class="headerlink" title="pytest-allure-adaptor下载"></a>pytest-allure-adaptor下载</h1><p>pip安装pytest-allure-adaptor,<a href="https://github.com/allure-framework/allure-pytest">github地址https://github.com/allure-framework/allure-pytest</a></p>
<blockquote>
<p>pip3 install pytest-allure-adaptor</p>
</blockquote>
<h1 id="生成xml报告"><a href="#生成xml报告" class="headerlink" title="生成xml报告"></a>生成xml报告</h1><blockquote>
<p>pytest -s -q –alluredir report</p>
</blockquote>
<p>如果不指定路径，默认在当前目录下新建一个report目录，当然也可以指定路径</p>
<blockquote>
<p>pytest -s -q –alluredir 指定report路径</p>
</blockquote>
<p>执行完之后打开report文件夹,会自动生成xml格式的报告</p>
<h1 id="安装-Command-Tool"><a href="#安装-Command-Tool" class="headerlink" title="安装 Command Tool"></a>安装 Command Tool</h1><p>allure的版本目前有2个，从github上看，allure1不再被支持，请考虑使用allure2 <a href="https://github.com/allure-framework/allure2%E6%9B%BF%E4%BB%A3">https://github.com/allure-framework/allure2替代</a></p>
<p><img src="/assets/2/image-20220516002220-ya5d3ht.png" alt="image.png"></p>
<p><a href="https://github.com/allure-framework/allure2/releases">allure-commandline releases版本https://github.com/allure-framework/allure2/releases</a></p>
<p>下载最新的Download allure2.7.0版本</p>
<p><img src="/assets/2/image-20220516002228-mtxaqix.png" alt="image.png"></p>
<p>[下载Download allure2.7.0 地址：<a href="https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip">https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip</a>]<br>(<a href="https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip">https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip</a>)</p>
<p>下载好之后，解压到运行pytest的目录下</p>
<p><img src="/assets/2/image-20220516002235-6dv34xv.png" alt="image.png"></p>
<p>打开\allure-2.7.0\bin文件夹，会看到allure.bat文件，讲此路径设置为系统环境变量path下，这样cmd任意目录都能执行了</p>
<p><img src="/assets/2/image-20220516002242-2kqqalh.png" alt="image.png"></p>
<p>比如我的路径：D:\YOYO\case\allure-2.7.0\bin</p>
<p><img src="/assets/2/image-20220516002249-m7hw61j.png" alt="image.png"></p>
<h1 id="运行allure2"><a href="#运行allure2" class="headerlink" title="运行allure2"></a>运行allure2</h1><p>前面pytest -s -q –alluredir 这一步已经生产了xml格式的报告，放到了report目录下，接着执行以下命令格式</p>
<blockquote>
<p>allure generate directory-with-results&#x2F; -o directory-with-report</p>
</blockquote>
<p><strong>directory-with-results是alluredir生成的xml目录，directory-with-report是最终生成html的目录</strong></p>
<p>allure.bat已经加到环境变量了，所以可以用相对路径去生成html报告</p>
<blockquote>
<p>allure generate report&#x2F; -o report&#x2F;html</p>
</blockquote>
<p>执行完之后目录结构如下：</p>
<p><img src="/assets/2/image-20220516002256-b37vhve.png" alt="image.png"></p>
<h1 id="打开报告"><a href="#打开报告" class="headerlink" title="打开报告"></a>打开报告</h1><p>直接找到report&#x2F;html打开index.html会显示一个空的报告，这里用pycharm去打开</p>
<p><img src="/assets/2/image-20220516002303-rl6grln.png" alt="image.png"></p>
<p>打开后报告展示</p>
<p><img src="/assets/2/image-20220516002310-rqr8rah.png" alt="image.png"></p>
<h1 id="依赖java环境"><a href="#依赖java环境" class="headerlink" title="依赖java环境"></a>依赖java环境</h1><p>之前用的jdk1.7版本，执行allure时候报错：Unsupported major.minor VERSION 51.0<br>由于allure2是java开发的，需要依赖java环境，解决办法：jdk版本用1.8就可以了</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档14-函数传参和fixture传参数request</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A314-%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E5%92%8Cfixture%E4%BC%A0%E5%8F%82%E6%95%B0request/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了提高代码的复用性，我们在写用例的时候，会用到函数，然后不同的用例去调用这个函数。<br>比如登录操作，大部分的用例都会先登录，那就需要把登录单独抽出来写个函数，其它用例全部的调用这个登陆函数就行。<br>但是登录的账号不能写死，有时候我想用账号1去登录，执行用例1，用账号2去登录执行用例2，所以需要对函数传参。</p>
<h1 id="登录函数传参"><a href="#登录函数传参" class="headerlink" title="登录函数传参"></a>登录函数传参</h1><p>把登录单独出来，写一个函数，传2个参数user和psw，写用例的时候调用登录函数，输入几组user,psw参数化登录用例</p>
<p>测试用例传参需要用装饰器@pytest.mark.parametrize，里面写两个参数</p>
<ul>
<li>第一个参数是字符串，多个参数中间用逗号隔开</li>
<li>第二个参数是list,多组数据用元祖类型</li>
</ul>
<pre><code class="python"># test_01.py

# coding:utf-8
import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

# 测试登录数据
test_login_data = [(&quot;admin&quot;, &quot;111111&quot;),  (&quot;admin&quot;, &quot;&quot;)]

def login(user, psw):
    &#39;&#39;&#39;普通登录函数&#39;&#39;&#39;
    print(&quot;登录账户：%s&quot;%user)
    print(&quot;登录密码：%s&quot;%psw)
    if psw:
        return True
    else:
        return False

@pytest.mark.parametrize(&quot;user, psw&quot;, test_login_data)
def test_login(user, psw):
    &#39;&#39;&#39;登录用例&#39;&#39;&#39;
    result = login(user, psw)
    assert result == True, &quot;失败原因：密码为空&quot;


if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_01.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="python">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
plugins: metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

..\..\..\..\..\..\YOYO\marktest\test_01.py 登录账户：admin
登录密码：111111
.登录账户：admin
登录密码：
F
user = &#39;admin&#39;, psw = &#39;&#39;

    @pytest.mark.parametrize(&quot;user, psw&quot;, [(&quot;admin&quot;, &quot;111111&quot;), (&quot;admin&quot;, &quot;&quot;)])
    def test_01(user, psw):
        result = login(user, psw)
&gt;       assert result == True
E       assert False == True

D:\YOYO\marktest\test_01.py:18: AssertionError


================================== FAILURES ===================================
_______________________________ test_01[admin-] _______________________________

user = &#39;admin&#39;, psw = &#39;&#39;

    @pytest.mark.parametrize(&quot;user, psw&quot;, [(&quot;admin&quot;, &quot;111111&quot;), (&quot;admin&quot;, &quot;&quot;)])
    def test_01(user, psw):
        result = login(user, psw)
&gt;       assert result == True
E       assert False == True

D:\YOYO\marktest\test_01.py:18: AssertionError
===================== 1 failed, 1 passed in 0.05 seconds ======================
</code></pre>
<p>从结果可以看出，有2个用例，一个测试通过，一个测试失败了，互不影响</p>
<h1 id="request参数"><a href="#request参数" class="headerlink" title="request参数"></a>request参数</h1><p>如果想把登录操作放到前置操作里，也就是用到@pytest.fixture装饰器，传参就用默认的request参数<br>user &#x3D; request.param 这一步是接收传入的参数，本案例是传一个参数情况</p>
<pre><code class="python"># test_02.py
# coding:utf-8
import pytest

#** 作者：上海-悠悠 QQ交流群：588402570**

# 测试账号数据
test_user_data = [&quot;admin1&quot;, &quot;admin2&quot;]

@pytest.fixture(scope=&quot;module&quot;)
def login(request):
    user = request.param
    print(&quot;登录账户：%s&quot;%user)
    return user

@pytest.mark.parametrize(&quot;login&quot;, test_user_data, indirect=True)
def test_login(login):
    &#39;&#39;&#39;登录用例&#39;&#39;&#39;
    a = login
    print(&quot;测试用例中login的返回值:%s&quot; % a)
    assert a != &quot;&quot;


if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_02.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="makefile">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
plugins: metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

..\..\..\..\..\..\YOYO\marktest\test_02.py 登录账户：admin1
测试用例中login的返回值:admin1
.登录账户：admin2
测试用例中login的返回值:admin2
.

========================== 2 passed in 0.01 seconds ===========================
</code></pre>
<p><strong>添加indirect&#x3D;True参数是为了把login当成一个函数去执行，而不是一个参数</strong></p>
<h1 id="request传2个参数"><a href="#request传2个参数" class="headerlink" title="request传2个参数"></a>request传2个参数</h1><p>如果用到@pytest.fixture，里面用2个参数情况，可以把多个参数用一个字典去存储，这样最终还是只传一个参数<br>不同的参数再从字典里面取对应key值就行，如： user &#x3D; request.param[“user”]</p>
<pre><code class="python"># test_03.py
# coding:utf-8
import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

# 测试账号数据
test_user_data = [&#123;&quot;user&quot;: &quot;admin1&quot;, &quot;psw&quot;: &quot;111111&quot;&#125;,
                  &#123;&quot;user&quot;: &quot;admin1&quot;, &quot;psw&quot;: &quot;&quot;&#125;]

@pytest.fixture(scope=&quot;module&quot;)
def login(request):
    user = request.param[&quot;user&quot;]
    psw = request.param[&quot;psw&quot;]
    print(&quot;登录账户：%s&quot; % user)
    print(&quot;登录密码：%s&quot; % psw)
    if psw:
        return True
    else:
        return False

# indirect=True 声明login是个函数
@pytest.mark.parametrize(&quot;login&quot;, test_user_data, indirect=True)
def test_login(login):
    &#39;&#39;&#39;登录用例&#39;&#39;&#39;
    a = login
    print(&quot;测试用例中login的返回值:%s&quot; % a)
    assert a, &quot;失败原因：密码为空&quot;


if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_03.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="python">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
plugins: metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

..\..\..\..\..\..\YOYO\marktest\test_03.py 登录账户：admin1
登录密码：111111
测试用例中login的返回值:True
.登录账户：admin1
登录密码：
测试用例中login的返回值:False
F
login = False

    @pytest.mark.parametrize(&quot;login&quot;, test_user_data, indirect=True)
    def test_login(login):
        &#39;&#39;&#39;登录用例&#39;&#39;&#39;
        a = login
        print(&quot;测试用例中login的返回值:%s&quot; % a)
&gt;       assert a, &quot;失败原因：密码为空&quot;
E       AssertionError: 失败原因：密码为空
E       assert False

D:\YOYO\marktest\test_03.py:25: AssertionError


================================== FAILURES ===================================
_____________________________ test_login[login1] ______________________________

login = False

    @pytest.mark.parametrize(&quot;login&quot;, test_user_data, indirect=True)
    def test_login(login):
        &#39;&#39;&#39;登录用例&#39;&#39;&#39;
        a = login
        print(&quot;测试用例中login的返回值:%s&quot; % a)
&gt;       assert a, &quot;失败原因：密码为空&quot;
E       AssertionError: 失败原因：密码为空
E       assert False

D:\YOYO\marktest\test_03.py:25: AssertionError
===================== 1 failed, 1 passed in 0.05 seconds ======================
</code></pre>
<p><strong>如果要用到login里面的返回值，def test_login(login)时，传入login参数，函数返回值就是login了</strong></p>
<h1 id="多个fixtrue"><a href="#多个fixtrue" class="headerlink" title="多个fixtrue"></a>多个fixtrue</h1><p>用例上面是可以同时放多个fixture的，也就是多个前置操作，可以支持装饰器叠加，使用parametrize装饰器叠加时，用例组合是2个参数个数相乘</p>
<pre><code class="python"># test_04.py
# ** 作者：上海-悠悠 QQ交流群：588402570**
# coding:utf-8
import pytest

# 测试账号数据
test_user = [&quot;admin1&quot;, &quot;admin2&quot;]
test_psw = [&quot;11111&quot;, &quot;22222&quot;]


@pytest.fixture(scope=&quot;module&quot;)
def input_user(request):
    user = request.param
    print(&quot;登录账户：%s&quot; % user)
    return user


@pytest.fixture(scope=&quot;module&quot;)
def input_psw(request):
    psw = request.param
    print(&quot;登录密码：%s&quot; % psw)
    return psw



@pytest.mark.parametrize(&quot;input_user&quot;, test_user, indirect=True)
@pytest.mark.parametrize(&quot;input_psw&quot;, test_psw, indirect=True)
def test_login(input_user, input_psw):
    &#39;&#39;&#39;登录用例&#39;&#39;&#39;
    a = input_user
    b = input_psw
    print(&quot;测试数据a-&gt; %s， b-&gt; %s&quot; % (a,b))
    assert b

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_04.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="haskell">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\par, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 4 items

test_04.py 登录账户：admin1
登录密码：11111
测试数据a-&gt; admin1， b-&gt; 11111
.登录账户：admin2
测试数据a-&gt; admin2， b-&gt; 11111
.登录密码：22222
测试数据a-&gt; admin2， b-&gt; 22222
.登录账户：admin1
测试数据a-&gt; admin1， b-&gt; 22222
.

========================== 4 passed in 0.05 seconds ===========================
</code></pre>
<p>如果参数user有2个数据，参数psw有2个数据，那么组合起来的案例是两个相乘，也就是组合2*2 &#x3D; 4个用例</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档15-使用自定义标记mark</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A315-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AE%B0mark/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest可以支持自定义标记，自定义标记可以把一个web项目划分多个模块，然后指定模块名称执行。一个大项目自动化用例时，可以划分多个模块，<br>也可以使用标记功能，标明哪些是模块1用例，哪些是模块2的，运行代码时候指定mark名称运行就可以</p>
<h1 id="mark标记"><a href="#mark标记" class="headerlink" title="mark标记"></a>mark标记</h1><p>1.以下用例，标记test_send_http()为webtest</p>
<pre><code class="python"># content of test_server.py

import pytest

@pytest.mark.webtest
def test_send_http():
    pass # perform some webtest test for your app

def test_something_quick():
    pass

def test_another():
    pass

class TestClass:
    def test_method(self):
        pass

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_server.py&quot;, &quot;-m=webtest&quot;])
</code></pre>
<p>只运行用webtest标记的测试，cmd运行的时候，加个-m 参数，指定参数值webtest</p>
<blockquote>
<p>$ pytest -v -m webtest</p>
</blockquote>
<pre><code class="yaml">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\se, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 4 items / 3 deselected

test_server.py .

=================== 1 passed, 3 deselected in 0.10 seconds ====================
</code></pre>
<p>如果不想执行标记webtest的用例，那就用”not webtest”</p>
<blockquote>
<p>$ pytest -v -m “not webtest”</p>
</blockquote>
<pre><code class="python">import pytest

@pytest.mark.webtest
def test_send_http():
    pass # perform some webtest test for your app
def test_something_quick():
    pass
def test_another():
    pass
class TestClass:
    def test_method(self):
        pass

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_server.py&quot;, &quot;-m=&#39;not webtest&#39;&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="yaml">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\se, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 4 items

test_server.py ....

========================== 4 passed in 0.06 seconds ===========================
</code></pre>
<h1 id="指定的函数节点id"><a href="#指定的函数节点id" class="headerlink" title="::指定的函数节点id"></a>::指定的函数节点id</h1><p>如果想指定运行某个.py模块下，类里面的一个用例，如：TestClass里面test_method用例<br>每个test_开头(或_test结尾)的用例，函数(或方法)的名称就是用例的节点id，指定节点id运行用::</p>
<blockquote>
<p>$ pytest -v test_server.py::TestClass::test_method</p>
</blockquote>
<p>pycharm运行代码</p>
<pre><code class="java">if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-v&quot;, &quot;test_server.py::TestClass::test_method&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="php">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0 -- E:\python36\python.exe
cachedir: .pytest_cache
metadata: &#123;&#39;Python&#39;: &#39;3.6.0&#39;, &#39;Platform&#39;: &#39;Windows-10-10.0.17134-SP0&#39;, &#39;Packages&#39;: &#123;&#39;pytest&#39;: &#39;3.6.3&#39;, &#39;py&#39;: &#39;1.5.4&#39;, &#39;pluggy&#39;: &#39;0.6.0&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;metadata&#39;: &#39;1.7.0&#39;, &#39;html&#39;: &#39;1.19.0&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;D:\\java\\jdk17&#39;&#125;
rootdir: E:\YOYO\se, inifile:
plugins: metadata-1.7.0, html-1.19.0
collecting ... collected 1 item

test_server.py::TestClass::test_method PASSED                            [100%]

========================== 1 passed in 0.06 seconds ===========================
</code></pre>
<p>当然也能选择运行整个class</p>
<blockquote>
<p>$ pytest -v test_server.py::TestClass</p>
</blockquote>
<p>也能选择多个节点运行，多个节点中间空格隔开</p>
<blockquote>
<p>$ pytest -v test_server.py::TestClass test_server.py::test_send_http</p>
</blockquote>
<p>pycharm运行参考</p>
<pre><code class="java">if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-v&quot;, &quot;test_server.py::TestClass&quot;, &quot;test_server.py::test_send_http&quot;])
</code></pre>
<h1 id="k-匹配用例名称"><a href="#k-匹配用例名称" class="headerlink" title="-k 匹配用例名称"></a>-k 匹配用例名称</h1><p>可以使用-k命令行选项指定在匹配用例名称的表达式</p>
<blockquote>
<p>$ pytest -v -k http</p>
</blockquote>
<pre><code class="bash">$ pytest -v -k http # running with the above defined example module
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y -- $PYTHON_
˓→PREFIX/bin/python3.5
cachedir: .pytest_cache
rootdir: $REGENDOC_TMPDIR, inifile:
collecting ... collected 4 items / 3 deselected
test_server.py::test_send_http PASSED [100%]
================== 1 passed, 3 deselected in 0.12 seconds ==================
</code></pre>
<p>您也可以运行所有的测试，根据用例名称排除掉某些用例：</p>
<blockquote>
<p>$ pytest -k “not send_http” -v</p>
</blockquote>
<pre><code class="php">=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y -- $PYTHON_
˓→PREFIX/bin/python3.5
cachedir: .pytest_cache
rootdir: $REGENDOC_TMPDIR, inifile:
collecting ... collected 4 items / 1 deselected
test_server.py::test_something_quick PASSED [ 33%]
test_server.py::test_another PASSED [ 66%]
test_server.py::TestClass::test_method PASSED [100%]
================== 3 passed, 1 deselected in 0.12 seconds ==================
</code></pre>
<p>也可以同时选择匹配 “http” 和“quick”</p>
<blockquote>
<p>$ pytest -k “http or quick” -v</p>
</blockquote>
<pre><code class="bash">=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y -- $PYTHON_
˓→PREFIX/bin/python3.5
cachedir: .pytest_cache
rootdir: $REGENDOC_TMPDIR, inifile:
collecting ... collected 4 items / 2 deselected
test_server.py::test_send_http PASSED [ 50%]
test_server.py::test_something_quick PASSED [100%]
================== 2 passed, 2 deselected in 0.12 seconds ==================
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档16-用例a失败，跳过测试用例b和c并标记失败xfail</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A316-%E7%94%A8%E4%BE%8Ba%E5%A4%B1%E8%B4%A5%EF%BC%8C%E8%B7%B3%E8%BF%87%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8Bb%E5%92%8Cc%E5%B9%B6%E6%A0%87%E8%AE%B0%E5%A4%B1%E8%B4%A5xfail/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当用例a失败的时候，如果用例b和用例c都是依赖于第一个用例的结果，那可以直接跳过用例b和c的测试，直接给他标记失败xfail<br>用到的场景，登录是第一个用例，登录之后的操作b是第二个用例，登录之后操作c是第三个用例，很明显三个用例都会走到登录。<br>如果登录都失败了，那后面2个用例就没测试必要了，直接跳过，并且标记为失败用例，这样可以节省用例时间。</p>
<h1 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h1><p>1.pytest里面用xfail标记用例为失败的用例，可以直接跳过。实现基本思路</p>
<ul>
<li>把登录写为前置操作</li>
<li>对登录的账户和密码参数化，参数用canshu &#x3D; [{“user”:”amdin”, “psw”:”111”}]表示</li>
<li>多个用例放到一个Test_xx的class里</li>
<li>test_01，test_02， test_03全部调用fixture里面的login功能</li>
<li>test_01测试登录用例</li>
<li>test_02和test_03执行前用if判断登录的结果，登录失败就执行，pytest.xfail(“登录不成功, 标记为xfail”)</li>
</ul>
<pre><code class="python"># content of test_05.py

# coding:utf-8
import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

canshu = [&#123;&quot;user&quot;:&quot;amdin&quot;, &quot;psw&quot;:&quot;111&quot;&#125;]

@pytest.fixture(scope=&quot;module&quot;)
def login(request):
    user = request.param[&quot;user&quot;]
    psw = request.param[&quot;psw&quot;]
    print(&quot;正在操作登录，账号：%s, 密码：%s&quot; % (user, psw))
    if psw:
        return True
    else:
        return False


@pytest.mark.parametrize(&quot;login&quot;, canshu, indirect=True)
class Test_xx():

    def test_01(self, login):
        &#39;&#39;&#39;用例1登录&#39;&#39;&#39;
        result = login
        print(&quot;用例1：%s&quot; % result)
        assert result == True


    def test_02(self, login):
        result = login
        print(&quot;用例3,登录结果：%s&quot; % result)
        if not result:
            pytest.xfail(&quot;登录不成功, 标记为xfail&quot;)

        assert 1 == 1

    def test_03(self, login):
        result = login
        print(&quot;用例3,登录结果：%s&quot; %result)
        if not result:
            pytest.xfail(&quot;登录不成功, 标记为xfail&quot;)

        assert 1 == 1


if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_05.py&quot;])
</code></pre>
<p>上面传的登录参数是登录成功的案例，三个用例全部通过</p>
<pre><code class="vbnet">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
plugins: metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 3 items

..\..\..\..\..\..\YOYO\peizhi\test_05.py 正在操作登录，账号：amdin, 密码：111
用例1：True
.用例3,登录结果：True
.用例3,登录结果：True
.

========================== 3 passed in 0.02 seconds ===========================
</code></pre>
<h1 id="标记为xfail"><a href="#标记为xfail" class="headerlink" title="标记为xfail"></a>标记为xfail</h1><p>1.再看看登录失败情况的用例,修改登录的参数</p>
<pre><code class="python"># content of test_05.py
# coding:utf-8
import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

canshu = [&#123;&quot;user&quot;:&quot;amdin&quot;, &quot;psw&quot;:&quot;&quot;&#125;]

@pytest.fixture(scope=&quot;module&quot;)
def login(request):
    user = request.param[&quot;user&quot;]
    psw = request.param[&quot;psw&quot;]
    print(&quot;正在操作登录，账号：%s, 密码：%s&quot; % (user, psw))
    if psw:
        return True
    else:
        return False


@pytest.mark.parametrize(&quot;login&quot;, canshu, indirect=True)
class Test_xx():

    def test_01(self, login):
        &#39;&#39;&#39;用例1登录&#39;&#39;&#39;
        result = login
        print(&quot;用例1：%s&quot; % result)
        assert result == True


    def test_02(self, login):
        result = login
        print(&quot;用例3,登录结果：%s&quot; % result)
        if not result:
            pytest.xfail(&quot;登录不成功, 标记为xfail&quot;)

        assert 1 == 1

    def test_03(self, login):
        result = login
        print(&quot;用例3,登录结果：%s&quot; %result)
        if not result:
            pytest.xfail(&quot;登录不成功, 标记为xfail&quot;)

        assert 1 == 1


if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_05.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="python">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
plugins: metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 3 items

..\..\..\..\..\..\YOYO\peizhi\test_05.py 正在操作登录，账号：amdin, 密码：
用例1：False
F
self = &lt;YOYO.peizhi.test_05.Test_xx object at 0x00000000045ACF98&gt;, login = False

    def test_01(self, login):
        &#39;&#39;&#39;用例1登录&#39;&#39;&#39;
        result = login
        print(&quot;用例1：%s&quot; % result)
&gt;       assert result == True
E       assert False == True

D:\YOYO\peizhi\test_05.py:24: AssertionError
用例3,登录结果：False
x
Test ignored.用例3,登录结果：False
x
Test ignored.

================================== FAILURES ===================================
___________________________ Test_xx.test_01[login0] ___________________________

self = &lt;YOYO.peizhi.test_05.Test_xx object at 0x00000000045ACF98&gt;, login = False

    def test_01(self, login):
        &#39;&#39;&#39;用例1登录&#39;&#39;&#39;
        result = login
        print(&quot;用例1：%s&quot; % result)
&gt;       assert result == True
E       assert False == True

D:\YOYO\peizhi\test_05.py:24: AssertionError
===================== 1 failed, 2 xfailed in 0.06 seconds =====================
</code></pre>
<p>从结果可以看出用例1失败了，用例2和3没执行，直接标记为xfail了</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档17-fixture之autouse=True</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A317-fixture%E4%B9%8Bautouse=True/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常写自动化用例会写一些前置的fixture操作，用例需要用到就直接传该函数的参数名称就行了。当用例很多的时候，每次都传这个参数，会比较麻烦。<br>fixture里面有个参数autouse，默认是Fasle没开启的，可以设置为True开启自动使用fixture功能，这样用例就不用每次都去传参了</p>
<p>调用fixture三种方法</p>
<ul>
<li>1.函数或类里面方法直接传fixture的函数参数名称</li>
<li>2.使用装饰器@pytest.mark.usefixtures()修饰</li>
<li>3.autouse&#x3D;True自动使用</li>
</ul>
<h1 id="用例传fixture参数"><a href="#用例传fixture参数" class="headerlink" title="用例传fixture参数"></a>用例传fixture参数</h1><p>方法一：先定义start功能，用例全部传start参数，调用该功能</p>
<pre><code class="python"># content of test_06.py
import time
import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

@pytest.fixture(scope=&quot;function&quot;)
def start(request):
    print(&#39;\n-----开始执行function----&#39;)


def test_a(start):
    print(&quot;-------用例a执行-------&quot;)




class Test_aaa():

    def test_01(self, start):
        print(&#39;-----------用例01--------------&#39;)

    def test_02(self, start):
        print(&#39;-----------用例02------------&#39;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_06.py&quot;])
</code></pre>
<h1 id="装饰器usefixtures"><a href="#装饰器usefixtures" class="headerlink" title="装饰器usefixtures"></a>装饰器usefixtures</h1><p>方法二：使用装饰器@pytest.mark.usefixtures()修饰需要运行的用例</p>
<pre><code class="python"># content of test_07.py
import time
import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

@pytest.fixture(scope=&quot;function&quot;)
def start(request):
    print(&#39;\n-----开始执行function----&#39;)


@pytest.mark.usefixtures(&quot;start&quot;)
def test_a():
    print(&quot;-------用例a执行-------&quot;)

@pytest.mark.usefixtures(&quot;start&quot;)
class Test_aaa():

    def test_01(self):
        print(&#39;-----------用例01--------------&#39;)

    def test_02(self):
        print(&#39;-----------用例02------------&#39;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_07.py&quot;])
</code></pre>
<h1 id="设置autouse-x3D-True"><a href="#设置autouse-x3D-True" class="headerlink" title="设置autouse&#x3D;True"></a>设置autouse&#x3D;True</h1><p>方法三、autouse设置为True，自动调用fixture功能</p>
<ul>
<li>start设置scope为module级别，在当前.py用例模块只执行一次，autouse&#x3D;True自动使用</li>
<li>open_home设置scope为function级别，每个用例前都调用一次，自动使用</li>
</ul>
<pre><code class="python"># content of test_08.py
import time
import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

@pytest.fixture(scope=&quot;module&quot;, autouse=True)
def start(request):
    print(&#39;\n-----开始执行moule----&#39;)
    print(&#39;module      : %s&#39; % request.module.__name__)
    print(&#39;----------启动浏览器---------&#39;)
    yield
    print(&quot;------------结束测试 end!-----------&quot;)



@pytest.fixture(scope=&quot;function&quot;, autouse=True)
def open_home(request):
    print(&quot;function：%s \n--------回到首页--------&quot; % request.function.__name__)


def test_01():
    print(&#39;-----------用例01--------------&#39;)

def test_02():
    print(&#39;-----------用例02------------&#39;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_08.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="sql">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\, inifile:
plugins: metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

..\..\..\..\..\..\YOYO\peizhi\test_08.py 
-----开始执行moule----
module      : YOYO.peizhi.test_08
----------启动浏览器---------
function：test_01 
--------回到首页--------
-----------用例01--------------
.function：test_02 
--------回到首页--------
-----------用例02------------
.------------结束测试-----------


========================== 2 passed in 0.01 seconds ===========================
</code></pre>
<p>上面是函数去实现用例，写的class里也是一样可以的</p>
<pre><code class="python"># content of test_09.py
import time
import pytest

# ** 作者：上海-悠悠 QQ交流群：588402570**

@pytest.fixture(scope=&quot;module&quot;, autouse=True)
def start(request):
    print(&#39;\n-----开始执行moule----&#39;)
    print(&#39;module      : %s&#39; % request.module.__name__)
    print(&#39;----------启动浏览器---------&#39;)
    yield
    print(&quot;------------结束测试 end!-----------&quot;)



class Test_aaa():
    @pytest.fixture(scope=&quot;function&quot;, autouse=True)
    def open_home(self, request):
        print(&quot;function：%s \n--------回到首页--------&quot; % request.function.__name__)


    def test_01(self):
        print(&#39;-----------用例01--------------&#39;)

    def test_02(self):
        print(&#39;-----------用例02------------&#39;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_09.py&quot;])
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档18-配置文件pytest.ini</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A318-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6pytest.ini/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest配置文件可以改变pytest的运行方式，它是一个固定的文件pytest.ini文件，读取配置信息，按指定的方式去运行。</p>
<h1 id="ini配置文件"><a href="#ini配置文件" class="headerlink" title="ini配置文件"></a>ini配置文件</h1><p>pytest里面有些文件是非test文件</p>
<ul>
<li>pytest.ini pytest的主配置文件，可以改变pytest的默认行为</li>
<li>conftest.py 测试用例的一些fixture配置</li>
<li>_ <em>init</em> _.py 识别该文件夹为python的package包</li>
<li>tox.ini 与pytest.ini类似，用tox工具时候才有用</li>
<li>setup.cfg 也是ini格式文件，影响setup.py的行为</li>
</ul>
<p>ini文件基本格式</p>
<pre><code class="ini"># 保存为pytest.ini文件

[pytest]

addopts = -rsxX
xfail_strict = true
</code></pre>
<p>使用pytest –help指令可以查看pytest.ini的设置选项</p>
<pre><code class="mipsasm">[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:

  markers (linelist)       markers for test functions
  empty_parameter_set_mark (string) default marker for empty parametersets
  norecursedirs (args)     directory patterns to avoid for recursion
  testpaths (args)         directories to search for tests when no files or dire

  console_output_style (string) console output: classic or with additional progr

  usefixtures (args)       list of default fixtures to be used with this project

  python_files (args)      glob-style file patterns for Python test module disco

  python_classes (args)    prefixes or glob names for Python test class discover

  python_functions (args)  prefixes or glob names for Python test function and m

  xfail_strict (bool)      default for the strict parameter of 
  addopts (args)           extra command line options
  minversion (string)      minimally required pytest version

</code></pre>
<p><strong>–rsxX 表示pytest报告所有测试用例被跳过、预计失败、预计失败但实际被通过的原因</strong></p>
<h1 id="mark标记"><a href="#mark标记" class="headerlink" title="mark标记"></a>mark标记</h1><p>如下案例，使用了2个标签：webtest和hello,使用mark标记功能对于以后分类测试非常有用处</p>
<pre><code class="python"># content of test_mark.py
import pytest

@pytest.mark.webtest
def test_send_http():
    print(&quot;mark web test&quot;)

def test_something_quick():
    pass

def test_another():
    pass

@pytest.mark.hello
class TestClass:
    def test_01(self):
        print(&quot;hello :&quot;)

    def test_02(self):
        print(&quot;hello world!&quot;)

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-v&quot;, &quot;test_mark.py&quot;, &quot;-m=hello&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="php">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0 -- D:\soft\python3.6\python.exe
cachedir: .pytest_cache
metadata: &#123;&#39;Python&#39;: &#39;3.6.0&#39;, &#39;Platform&#39;: &#39;Windows-7-6.1.7601-SP1&#39;, &#39;Packages&#39;: &#123;&#39;pytest&#39;: &#39;3.6.3&#39;, &#39;py&#39;: &#39;1.5.4&#39;, &#39;pluggy&#39;: &#39;0.6.0&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;metadata&#39;: &#39;1.7.0&#39;, &#39;html&#39;: &#39;1.19.0&#39;, &#39;allure-adaptor&#39;: &#39;1.7.10&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;D:\\soft\\jdk18\\jdk18v&#39;&#125;
rootdir: D:\YOYO, inifile:
plugins: metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collecting ... collected 5 items / 3 deselected

test_mark.py::TestClass::test_01 PASSED                                  [ 50%]
test_mark.py::TestClass::test_02 PASSED                                  [100%]

=================== 2 passed, 3 deselected in 0.11 seconds ====================
</code></pre>
<p>有时候标签多了，不容易记住，为了方便后续执行指令的时候能准确使用mark的标签，可以写入到pytest.ini文件</p>
<pre><code class="dockerfile"># pytest.ini
[pytest]

markers =
  webtest:  Run the webtest case
  hello: Run the hello case
</code></pre>
<p>标记好之后，可以使用pytest –markers查看到</p>
<blockquote>
<p>$ pytest –markers</p>
</blockquote>
<pre><code class="fsharp">D:\YOYO&gt;pytest --markers
@pytest.mark.webtest:  Run the webtest case

@pytest.mark.hello: Run the hello case

@pytest.mark.skip(reason=None): skip the given test function with an optional re
ason. Example: skip(reason=&quot;no way of currently testing this&quot;) skips the test.

@pytest.mark.skipif(condition): skip the given test function if eval(condition)
results in a True value.  Evaluation happens within the module global context. E
xample: skipif(&#39;sys.platform == &quot;win32&quot;&#39;) skips the test if we are on the win32
platform. see http://pytest.org/latest/skipping.html

@pytest.mark.xfail(condition, reason=None, run=True, raises=None, strict=False):
 mark the test function as an expected failure if eval(condition) has a True val
ue. Optionally specify a reason for better reporting and run=False if you don&#39;t
even want to execute the test function. If only specific exception(s) are expect
ed, you can list them in raises, and if the test fails in other ways, it will be
 reported as a true failure. See http://pytest.org/latest/skipping.html

@pytest.mark.parametrize(argnames, argvalues): call a test function multiple tim
es passing in different arguments in turn. argvalues generally needs to be a lis
t of values if argnames specifies only one name or a list of tuples of values if
 argnames specifies multiple names. Example: @parametrize(&#39;arg1&#39;, [1,2]) would l
ead to two calls of the decorated test function, one with arg1=1 and another wit
h arg1=2.see http://pytest.org/latest/parametrize.html for more info and example
s.

@pytest.mark.usefixtures(fixturename1, fixturename2, ...): mark tests as needing
 all of the specified fixtures. see http://pytest.org/latest/fixture.html#usefix
tures

@pytest.mark.tryfirst: mark a hook implementation function such that the plugin
machinery will try to call it first/as early as possible.

@pytest.mark.trylast: mark a hook implementation function such that the plugin m
achinery will try to call it last/as late as possible.
</code></pre>
<p>最上面两个就是刚才写入到pytest.ini的配置了</p>
<h1 id="禁用xpass"><a href="#禁用xpass" class="headerlink" title="禁用xpass"></a>禁用xpass</h1><p>设置xfail_strict &#x3D; true可以让那些标记为@pytest.mark.xfail但实际通过的测试用例被报告为失败</p>
<p>什么叫标记为@pytest.mark.xfail但实际通过，这个比较绕脑，看以下案例</p>
<pre><code class="python"># content of test_xpass.py
import pytest
** 作者：上海-悠悠 QQ交流群：588402570**

def test_hello():
    print(&quot;hello world!&quot;)
    assert 1

@pytest.mark.xfail()
def test_yoyo1():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a == b

@pytest.mark.xfail()
def test_yoyo2():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a != b

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-v&quot;, &quot;test_xpass.py&quot;])
</code></pre>
<p>测试结果</p>
<pre><code class="cpp">collecting ... collected 3 items

test_xpass.py::test_hello PASSED    [ 33%]
test_xpass.py::test_yoyo1 xfail     [ 66%]
test_xpass.py::test_yoyo2 XPASS     [100%]

=============== 1 passed, 1 xfailed, 1 xpassed in 0.27 seconds ================
</code></pre>
<p>test_yoyo1和test_yoyo2这2个用例一个是a &#x3D;&#x3D; b一个是a !&#x3D; b,两个都标记失败了，我们希望两个用例不用执行全部显示xfail。实际上最后一个却显示xpass.为了让两个都显示xfail，那就加个配置<br>xfail_strict &#x3D; true</p>
<pre><code class="csharp"># pytest.ini
[pytest]

markers =
  webtest:  Run the webtest case
  hello: Run the hello case

xfail_strict = true
</code></pre>
<p>再次运行，结果就变成</p>
<pre><code class="markdown">collecting ... collected 3 items

test_xpass.py::test_hello PASSED        [ 33%]
test_xpass.py::test_yoyo1 xfail         [ 66%]
test_xpass.py::test_yoyo2 FAILED        [100%]

================================== FAILURES ===================================
_________________________________ test_yoyo2 __________________________________
[XPASS(strict)] 
================ 1 failed, 1 passed, 1 xfailed in 0.05 seconds ================
</code></pre>
<p>这样标记为xpass的就被强制性变成failed的结果</p>
<h1 id="配置文件如何放"><a href="#配置文件如何放" class="headerlink" title="配置文件如何放"></a>配置文件如何放</h1><p>一般一个工程下方一个pytest.ini文件(不要瞎jb拍脑袋乱命名，瞎jb命名是找不到的)就可以了，放到顶层文件夹下</p>
<p><img src="/assets/2/image-20220516002959-0dmzdpd.png" alt="image.png"></p>
<h1 id="addopts"><a href="#addopts" class="headerlink" title="addopts"></a>addopts</h1><p>addopts参数可以更改默认命令行选项，这个当我们在cmd输入指令去执行用例的时候，会用到，比如我想测试完生成报告，指令比较长</p>
<blockquote>
<p>$ pytest -v –reruns 1 –html&#x3D;report.html –self-contained-html</p>
</blockquote>
<p>每次输入这么多，不太好记住，于是可以加到pytest.ini里</p>
<pre><code class="csharp"># pytest.ini
[pytest]

markers =
  webtest:  Run the webtest case
  hello: Run the hello case

 xfail_strict = true

 addopts = -v --reruns 1 --html=report.html --self-contained-html
</code></pre>
<p>这样我下次打开cmd，直接输入pytest，它就能默认带上这些参数了</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档19-doctest测试框架</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A319-doctest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>doctest从字面意思上看，那就是文档测试。doctest是python里面自带的一个模块，它实际上是单元测试的一种。<br>官方解释：doctest 模块会搜索那些看起来像交互式会话的 Python 代码片段，然后尝试执行并验证结果</p>
<p>doctest测试用例可以放在两个地方</p>
<ul>
<li>函数或者方法下的注释里面</li>
<li>模块的开头</li>
</ul>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>先看第一个案例，将需要测试的片段,标准格式，需要运行的代码前面加&gt;&gt;&gt; ,相当于进入cmd这种交互环境执行，期望的结果前面不需要加&gt;&gt;&gt;</p>
<pre><code class="python-repl">&gt;&gt;&gt; multiply(4, 3)
    12
&gt;&gt;&gt; multiply(&#39;a&#39;, 3)
    &#39;aaa&#39;
</code></pre>
<p>放到multiply函数的注释里</p>
<pre><code class="python">def multiply(a, b):
    &quot;&quot;&quot;
    fuction: 两个数相乘
    &gt;&gt;&gt; multiply(4, 3)
    12
    &gt;&gt;&gt; multiply(&#39;a&#39;, 3)
    &#39;aaa&#39;
    &quot;&quot;&quot;
    return a * b
if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod(verbose=True)
</code></pre>
<p>运行结果</p>
<pre><code class="vbnet">Trying:
    multiply(4, 3)
Expecting:
    12
ok
Trying:
    multiply(&#39;a&#39;, 3)
Expecting:
    &#39;aaa&#39;
ok
1 items had no tests:
    __main__
1 items passed all tests:
   2 tests in __main__.multiply
2 tests in 2 items.
2 passed and 0 failed.
Test passed.
</code></pre>
<p>从运行的结果可以看出，虽然函数下方的注释里面有其它内容“fuction: 两个数相乘”，但不会去执行，只识别“&gt;&gt;&gt;”这种符号。2个测试用例都是通过的，实际的结果与期望的结果一致。</p>
<h1 id="失败案例"><a href="#失败案例" class="headerlink" title="失败案例"></a>失败案例</h1><p>doctest的内容放到.py模块的开头也是可以识别到的</p>
<pre><code class="python"># 保存为xxx.py
&#39;&#39;&#39;
fuction: 两个数相乘
&gt;&gt;&gt; multiply(4, 8)
12
&gt;&gt;&gt; multiply(&#39;a&#39;, 5)
&#39;aaa&#39;
&#39;&#39;&#39;

def multiply(a, b):
    &quot;&quot;&quot;
    fuction: 两个数相乘
    &quot;&quot;&quot;
    return a * b
if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod(verbose=True)
</code></pre>
<p>运行结果2个都失败</p>
<pre><code class="markdown">**********************************************************************
1 items had failures:
   2 of   2 in __main__
2 tests in 2 items.
0 passed and 2 failed.
***Test Failed*** 2 failures.
</code></pre>
<p><strong>verbose参数，设置为True则在执行测试的时候会输出详细信息</strong></p>
<h1 id="cmd执行"><a href="#cmd执行" class="headerlink" title="cmd执行"></a>cmd执行</h1><p>以上案例是在编辑器直接运行的，如果在cmd里面，也可以用指令去执行</p>
<blockquote>
<p>$ python -m doctest -v xxx.py</p>
</blockquote>
<ul>
<li>m 参数指定运行方式doctest</li>
<li>-v参数是verbose，带上-v参数相当于verbose&#x3D;True</li>
</ul>
<p><img src="/assets/2/image-20220516003111-bb4t75z.png" alt="image.png"></p>
<h1 id="pytest运行"><a href="#pytest运行" class="headerlink" title="pytest运行"></a>pytest运行</h1><p>pytest框架是可以兼容doctest用例，执行的时候加个参数 –doctest-modules ,这样它就能自动搜索到doctest的用例</p>
<blockquote>
<p>$ pytest -v –doctest-modules xxx.py</p>
</blockquote>
<p><img src="/assets/2/image-20220516003118-vm2sy2c.png" alt="image.png"></p>
<p>如下是函数下的文档</p>
<pre><code class="python-repl">fuction: 两个数相乘
&gt;&gt;&gt; multiply(4, 3)
12
&gt;&gt;&gt; multiply(&#39;a&#39;, 5)
&#39;aaa&#39;
</code></pre>
<p>运行结果</p>
<pre><code class="bash">D:\test1122\a&gt;pytest -v --doctest-modules  xxx.py
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0 -- d:\soft\
python3.6\python.exe
cachedir: .pytest_cache
metadata: &#123;&#39;Python&#39;: &#39;3.6.0&#39;, &#39;Platform&#39;: &#39;Windows-7-6.1.7601-SP1&#39;, &#39;Packages&#39;:
&#123;&#39;pytest&#39;: &#39;3.6.3&#39;, &#39;py&#39;: &#39;1.5.4&#39;, &#39;pluggy&#39;: &#39;0.6.0&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;metadata&#39;: &#39;
1.7.0&#39;, &#39;html&#39;: &#39;1.19.0&#39;, &#39;allure-adaptor&#39;: &#39;1.7.10&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;D:\\soft\\j
dk18\\jdk18v&#39;&#125;
rootdir: D:\test1122\a, inifile:
plugins: metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 1 item

xxx.py::xxx.multiply FAILED                                              [100%]

================================== FAILURES ===================================
___________________________ [doctest] xxx.multiply ____________________________
004
005     fuction: 两个数相乘
006     &gt;&gt;&gt; multiply(4, 3)
007     12
008     &gt;&gt;&gt; multiply(&#39;a&#39;, 5)
Expected:
    &#39;aaa&#39;
Got:
    &#39;aaaaa&#39;

D:\test1122\a\xxx.py:8: DocTestFailure
========================== 1 failed in 0.16 seconds ===========================
</code></pre>
<p>结果可以看出，文档里面的每一行都被执行了，当遇到测试不通过的用例时，就不会继续往下执行了</p>
<h1 id="doctest独立文件"><a href="#doctest独立文件" class="headerlink" title="doctest独立文件"></a>doctest独立文件</h1><p>doctest内容也可以和代码抽离开，单独用一个.txt文件保存<br><img src="/assets/2/image-20220516003128-4n0p8om.png" alt="image.png"></p>
<p>在当前xxx.py同一目录新建一个xxx.txt文件，写入测试的文档，要先导入该功能，导入代码前面也要加&gt;&gt;&gt;</p>
<pre><code class="python-repl">&gt;&gt;&gt; from xxx import multiply
&gt;&gt;&gt; multiply(4, 3)
12
&gt;&gt;&gt; multiply(&#39;a&#39;, 3)
&#39;aaa&#39;
</code></pre>
<p>cmd执行“python -m doctest -v xxx.txt”测试结果</p>
<pre><code class="vbnet">
D:\test1122&gt;python -m doctest -v  xxx.txt
Trying:
    from xxx import multiply
Expecting nothing
ok
Trying:
    multiply(4, 3)
Expecting:
    12
ok
Trying:
    multiply(&#39;a&#39;, 3)
Expecting:
    &#39;aaa&#39;
ok
1 items passed all tests:
   3 tests in xxx.txt
3 tests in 1 items.
3 passed and 0 failed.
Test passed.
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档20-pytest-html报告优化（添加Description）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A320-pytest-html%E6%8A%A5%E5%91%8A%E4%BC%98%E5%8C%96%EF%BC%88%E6%B7%BB%E5%8A%A0Description%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest-html测试报告默认是不展示用例描述Description内容，之前用unittest生成的报告是可以展示用例的描述，也就是test开头的用例下三个引号里面的注释（docstring）内容。<br>pytest-html框架是可以修改生成的报告内容的，可以自己添加和删除html报告的table内容。</p>
<h1 id="修改报告"><a href="#修改报告" class="headerlink" title="修改报告"></a>修改报告</h1><p>pytest-html官方文档地址<a href="https://pypi.org/project/pytest-html/">【https://pypi.org/project/pytest-html/】</a><br>l可以通过为标题行实现自定义钩子来修改列，下面的示例在conftest.py脚本中使用测试函数docstring添加描述（Description）列，添加可排序时间（Time）列，并删除链接(Link)列：</p>
<pre><code class="python">from datetime import datetime
from py.xml import html
import pytest

@pytest.mark.optionalhook
def pytest_html_results_table_header(cells):
    cells.insert(2, html.th(&#39;Description&#39;))
    cells.insert(1, html.th(&#39;Time&#39;, class_=&#39;sortable time&#39;, col=&#39;time&#39;))
    cells.pop()

@pytest.mark.optionalhook
def pytest_html_results_table_row(report, cells):
    cells.insert(2, html.td(report.description))
    cells.insert(1, html.td(datetime.utcnow(), class_=&#39;col-time&#39;))
    cells.pop()

@pytest.mark.hookwrapper
def pytest_runtest_makereport(item, call):
    outcome = yield
    report = outcome.get_result()
    report.description = str(item.function.__doc__)
</code></pre>
<p>还可以通过pytest_html_results_table_row 挂钩删除所有单元格来删除结果。下面的示例从报表中删除所有测试通过的结果：</p>
<pre><code class="python">import pytest

@pytest.mark.optionalhook
def pytest_html_results_table_row(report, cells):
    if report.passed:
      del cells[:]
</code></pre>
<p>日志输出和附加HTML可以通过pytest_html_results_table_html挂钩来修改。下面的示例清空测试通过的日志输出：</p>
<pre><code class="haskell">import pytest

@pytest.mark.optionalhook
def pytest_html_results_table_html(report, data):
    if report.passed:
        del data[:]
        data.append(html.div(&#39;No log output captured.&#39;, class_=&#39;empty log&#39;))
</code></pre>
<h1 id="添加Description"><a href="#添加Description" class="headerlink" title="添加Description"></a>添加Description</h1><p>通过上面的官方文档，可以自己修改下测试报告，在报告里面添加一列的内容，添加到第二列，于是修改如下，红色代码全部注释掉</p>
<p><img src="/assets/2/image-20220516003232-kbpbefx.png" alt="image.png"></p>
<p>第三个@pytest.mark.hookwrapper，这个在之前测试报告里面添加截图时候，已经写过了，只需在最后加一句代码即可</p>
<blockquote>
<p>report.description &#x3D; str(item.function. <strong>doc</strong> )</p>
</blockquote>
<p><img src="/assets/2/image-20220516003239-ww9889v.png" alt="image.png"></p>
<h1 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h1><p>项目根目录下新建conftest.py</p>
<pre><code class="python"># conftest.py


from datetime import datetime
from py.xml import html
import pytest

@pytest.mark.hookwrapper
def pytest_runtest_makereport(item):
    &quot;&quot;&quot;
    当测试失败的时候，自动截图，展示到html报告中
    :param item:
    &quot;&quot;&quot;
    pytest_html = item.config.pluginmanager.getplugin(&#39;html&#39;)
    outcome = yield
    report = outcome.get_result()
    extra = getattr(report, &#39;extra&#39;, [])

    if report.when == &#39;call&#39; or report.when == &quot;setup&quot;:
        xfail = hasattr(report, &#39;wasxfail&#39;)
        if (report.skipped and xfail) or (report.failed and not xfail):
            file_name = report.nodeid.replace(&quot;::&quot;, &quot;_&quot;)+&quot;.png&quot;
            screen_img = _capture_screenshot()
            if file_name:
                html = &#39;&lt;div&gt;&lt;img src=&quot;data:image/png;base64,%s&quot; alt=&quot;screenshot&quot; style=&quot;width:600px;height:300px;&quot; &#39; \
                       &#39;onclick=&quot;window.open(this.src)&quot; align=&quot;right&quot;/&gt;&lt;/div&gt;&#39; % screen_img
                extra.append(pytest_html.extras.html(html))
        report.extra = extra
        report.description = str(item.function.__doc__)

@pytest.mark.optionalhook
def pytest_html_results_table_header(cells):
    cells.insert(1, html.th(&#39;Description&#39;))

@pytest.mark.optionalhook
def pytest_html_results_table_row(report, cells):
    cells.insert(1, html.td(report.description))
</code></pre>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>修改完之后cmd运行</p>
<blockquote>
<p>pytest –html&#x3D;report.html –self-contained-html</p>
</blockquote>
<p><img src="/assets/2/image-20220516003247-62zrhvw.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档21-pytest-html报告优化（nodeid中文显示[\u6350\u52a9\u6211\u4eec]问题解决）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A321-pytest-html%E6%8A%A5%E5%91%8A%E4%BC%98%E5%8C%96(%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest-html报告中当用到参数化时候，获取用例的nodeid里面有中文时候，会显示[\u6350\u52a9\u6211\u4eec]这种编码（再次声明，这个不叫乱码，这是unicode编码）<br>关于python2和python3里面Unicode编码转化可以参考之前写的一篇<a href="https://www.cnblogs.com/yoyoketang/p/8058873.html">【python笔记6-%u60A0和\u60a0类似unicode解码】</a><br>本篇以python3.6版本为例</p>
<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p><img src="/assets/2/image-20220516003831-bilwjhk.png" alt="image.png"></p>
<p>官网文档<a href="https://github.com/pytest-dev/pytest-html">https://github.com/pytest-dev/pytest-html</a>上说明如下:<br>注意ANSI代码支持取决于<a href="https://pypi.org/project/ansi2html/">ansi2html</a>包,此包不作为依赖项包含在内。如果你安装了这个软件包，那么ANSI代码会在你的报告中被转换成HTML。<br>试过了，安装ansi2html包也无法解决问题，于是只有自己解码，重新优化报告内容了</p>
<h1 id="编码转化"><a href="#编码转化" class="headerlink" title="编码转化"></a>编码转化</h1><p>相关转化参考这篇<a href="https://www.cnblogs.com/yoyoketang/p/8058873.html">【python笔记6-%u60A0和\u60a0类似unicode解码】</a></p>
<pre><code class="python"># coding:utf-8
# a是str类型
a = r&quot;case/test_houtai.py::TestHouTai::()::test_aboutzenta[\u6350\u52a9\u6211\u4eec]&quot;
print(type(a))
# 转码
print(a.encode(&quot;utf-8&quot;).decode(&quot;unicode_escape&quot;))
</code></pre>
<p>运行结果</p>
<p>&lt;class ‘str’&gt;<br>case&#x2F;test_houtai.py::TestHouTai:😦)::test_aboutzenta[捐助我们]</p>
<h1 id="pytest-html报告优化"><a href="#pytest-html报告优化" class="headerlink" title="pytest-html报告优化"></a>pytest-html报告优化</h1><p>源码地址<a href="https://github.com/pytest-dev/pytest-html/blob/master/pytest_html/plugin.py">【https://github.com/pytest-dev/pytest-html/blob/master/pytest_html&#x2F;plugin.py】</a></p>
<p>Test这一列显示的内容是用例的nodeid,nodeid获取方法从源码可以看出是通过report.nodeid获取到的</p>
<p><img src="/assets/2/image-20220516003848-2i9pvuz.png" alt="image.png"></p>
<p>于是我们可以在conftest.py里面新增一列，重新命名Test_nodeid,然后删除原有的Test列，具体参考前面一篇内容<a href="https://www.cnblogs.com/yoyoketang/p/9748718.html">【pytest文档20-pytest-html报告优化（添加Description）】</a></p>
<p><img src="/assets/2/image-20220516003854-jgztv5h.png" alt="image.png"></p>
<pre><code class="python">from datetime import datetime
from py.xml import html
import pytest

@pytest.mark.hookwrapper
def pytest_runtest_makereport(item):
    &quot;&quot;&quot;
    当测试失败的时候，自动截图，展示到html报告中
    :param item:
    &quot;&quot;&quot;
    pytest_html = item.config.pluginmanager.getplugin(&#39;html&#39;)
    outcome = yield
    report = outcome.get_result()
    extra = getattr(report, &#39;extra&#39;, [])

    if report.when == &#39;call&#39; or report.when == &quot;setup&quot;:
        xfail = hasattr(report, &#39;wasxfail&#39;)
        if (report.skipped and xfail) or (report.failed and not xfail):
            file_name = report.nodeid.replace(&quot;::&quot;, &quot;_&quot;)+&quot;.png&quot;
            screen_img = _capture_screenshot()
            if file_name:
                html = &#39;&lt;div&gt;&lt;img src=&quot;data:image/png;base64,%s&quot; alt=&quot;screenshot&quot; style=&quot;width:600px;height:300px;&quot; &#39; \
                       &#39;onclick=&quot;window.open(this.src)&quot; align=&quot;right&quot;/&gt;&lt;/div&gt;&#39; % screen_img
                extra.append(pytest_html.extras.html(html))
        report.extra = extra
        report.description = str(item.function.__doc__)
        report.nodeid = report.nodeid.encode(&quot;utf-8&quot;).decode(&quot;unicode_escape&quot;)


@pytest.mark.optionalhook
def pytest_html_results_table_header(cells):
    cells.insert(1, html.th(&#39;Description&#39;))
    cells.insert(2, html.th(&#39;Test_nodeid&#39;))
    # cells.insert(1, html.th(&#39;Time&#39;, class_=&#39;sortable time&#39;, col=&#39;time&#39;))
    cells.pop(2)

@pytest.mark.optionalhook
def pytest_html_results_table_row(report, cells):
    cells.insert(1, html.td(report.description))
    cells.insert(2, html.td(report.nodeid))
    # cells.insert(1, html.td(datetime.utcnow(), class_=&#39;col-time&#39;))
    cells.pop(2)
</code></pre>
<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p>修改之后结果展示如下</p>
<p><img src="/assets/2/image-20220516003918-udfamgp.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档22-fixture详细介绍-作为参数传入,error和failed区别</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A322-fixture%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E5%85%A5,error%E5%92%8Cfailed%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>fixture是pytest的核心功能，也是亮点功能，熟练掌握fixture的使用方法，pytest用起来才会得心应手！</p>
<h1 id="fixture简介"><a href="#fixture简介" class="headerlink" title="fixture简介"></a>fixture简介</h1><p>fixture的目的是提供一个固定基线，在该基线上测试可以可靠地和重复地执行。fixture提供了区别于传统单元测试（setup&#x2F;teardown）有显著改进：</p>
<ul>
<li>有独立的命名，并通过声明它们从测试函数、模块、类或整个项目中的使用来激活。</li>
<li>按模块化的方式实现，每个fixture都可以互相调用。</li>
<li>fixture的范围从简单的单元扩展到复杂的功能测试，允许根据配置和组件选项对fixture和测试用例进行参数化，或者跨函数 function、类class、模块module或整个测试会话sessio范围。</li>
</ul>
<h1 id="fixture作为参数传入"><a href="#fixture作为参数传入" class="headerlink" title="fixture作为参数传入"></a>fixture作为参数传入</h1><p>定义fixture跟定义普通函数差不多，唯一区别就是在函数上加个装饰器@pytest.fixture()，fixture命名不要用test_开头，跟用例区分开。用例才是test_开头的命名。</p>
<p>fixture是可以有返回值的，如果没return默认返回None。用例调用fixture的返回值，直接就是把fixture的函数名称当成变量名称，如下案例</p>
<pre><code class="python"># test_fixture1.py
import pytest

@pytest.fixture()
def user():
    print(&quot;获取用户名&quot;)
    a = &quot;yoyo&quot;
    return a

def test_1(user):
    assert user == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture1.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="yaml">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO\fixt, inifile:
plugins: rerunfailures-4.1, metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 1 item

test_fixture1.py 获取用户名
.

========================== 1 passed in 0.20 seconds ===========================
</code></pre>
<h1 id="error和failed区别"><a href="#error和failed区别" class="headerlink" title="error和failed区别"></a>error和failed区别</h1><p>测试结果一般有三种：passed、failed、error。（skip的用例除外）</p>
<p>如果在test_用例里面断言失败，那就是failed</p>
<pre><code class="python"># test_fixture2.py
import pytest

@pytest.fixture()
def user():
    print(&quot;获取用户名&quot;)
    a = &quot;yoyo&quot;
    return a

def test_1(user):
    assert user == &quot;yoyo111&quot;  # 用例失败就是failed

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture2.py&quot;])
</code></pre>
<p>如果在fixture里面断言失败了，那就是error</p>
<pre><code class="python">test_fixture3.py
import pytest

@pytest.fixture()
def user():
    print(&quot;获取用户名&quot;)
    a = &quot;yoyo&quot;
    assert a == &quot;yoyo123&quot;  # fixture失败就是error
    return a

def test_1(user):
    assert user == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture3.py&quot;])
</code></pre>
<p>还有一种情况也会出现error，那就是自己代码写的有问题，自己本身代码报错，那就是error了。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档23-使用多个fixture和fixture直接互相调用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A323-%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAfixture%E5%92%8Cfixture%E7%9B%B4%E6%8E%A5%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="使用多个fixture"><a href="#使用多个fixture" class="headerlink" title="使用多个fixture"></a>使用多个fixture</h1><p>如果用例需要用到多个fixture的返回数据，fixture也可以return一个元组、list或字典，然后从里面取出对应数据。</p>
<pre><code class="python"># test_fixture4.py
import pytest

@pytest.fixture()
def user():
    print(&quot;获取用户名&quot;)
    a = &quot;yoyo&quot;
    b = &quot;123456&quot;
    return (a, b)


def test_1(user):
    u = user[0]
    p = user[1]
    print(&quot;测试账号：%s, 密码：%s&quot; % (u, p))
    assert u == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture4.py&quot;])
</code></pre>
<p>当然也可以分开定义成多个fixture，然后test_用例传多个fixture参数</p>
<pre><code class="python"># test_fixture5.py
import pytest

@pytest.fixture()
def user():
    print(&quot;获取用户名&quot;)
    a = &quot;yoyo&quot;
    return a

@pytest.fixture()
def psw():
    print(&quot;获取密码&quot;)
    b = &quot;123456&quot;
    return b

def test_1(user, psw):
    &#39;&#39;&#39;传多个fixture&#39;&#39;&#39;
    print(&quot;测试账号：%s, 密码：%s&quot; % (user, psw))
    assert user == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture5.py&quot;])
</code></pre>
<h1 id="fixture与fixture互相调用"><a href="#fixture与fixture互相调用" class="headerlink" title="fixture与fixture互相调用"></a>fixture与fixture互相调用</h1><p>fixture与fixture直接也能互相调用的</p>
<pre><code class="python">import pytest

@pytest.fixture()
def first():
    print(&quot;获取用户名&quot;)
    a = &quot;yoyo&quot;
    return a

@pytest.fixture()
def sencond(first):
    &#39;&#39;&#39;psw调用user fixture&#39;&#39;&#39;
    a = first
    b = &quot;123456&quot;
    return (a, b)

def test_1(sencond):
    &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
    print(&quot;测试账号：%s, 密码：%s&quot; % (sencond[0], sencond[1]))

    assert sencond[0] == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture6.py&quot;])
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档24-fixture的作用范围(scope)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A324-fixture%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4(scope)/</url>
    <content><![CDATA[<h1 id="fixture作用范围"><a href="#fixture作用范围" class="headerlink" title="fixture作用范围"></a>fixture作用范围</h1><p>fixture里面有个scope参数可以控制fixture的作用范围:session &gt; module &gt; class &gt; function</p>
<pre><code class="sql">fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None):
    &quot;&quot;&quot;使用装饰器标记fixture的功能
     ** 作者：上海-悠悠 QQ交流群：588402570**
     可以使用此装饰器（带或不带参数）来定义fixture功能。 fixture功能的名称可以在以后使用
     引用它会在运行测试之前调用它：test模块或类可以使用pytest.mark.usefixtures（fixturename标记。 
     测试功能可以直接使用fixture名称作为输入参数，在这种情况下，夹具实例从fixture返回功能将被注入。

    :arg scope: scope 有四个级别参数 &quot;function&quot; (默认), &quot;class&quot;, &quot;module&quot; or &quot;session&quot;.

    :arg params: 一个可选的参数列表，它将导致多个参数调用fixture功能和所有测试使用它

    :arg autouse:  如果为True，则为所有测试激活fixture func 可以看到它。 如果为False（默认值）则显式需要参考来激活fixture

    :arg ids: 每个字符串id的列表，每个字符串对应于params 这样他们就是测试ID的一部分。 如果没有提供ID它们将从params自动生成

    :arg name:   fixture的名称。 这默认为装饰函数的名称。 如果fixture在定义它的同一模块中使用，夹具的功能名称将被请求夹具的功能arg遮蔽; 解决这个问题的一种方法是将装饰函数命名
                       “fixture_ &lt;fixturename&gt;”然后使用”@ pytest.fixture（name =&#39;&lt;fixturename&gt;&#39;）“”。
</code></pre>
<ul>
<li>function 每一个函数或方法都会调用</li>
<li>class 每一个类调用一次，一个类可以有多个方法</li>
<li>module，每一个.py文件调用一次，该文件内又有多个function和class</li>
<li>session 是多个文件调用一次，可以跨.py文件调用，每个.py文件就是module</li>
</ul>
<h1 id="scope-x3D-”function”"><a href="#scope-x3D-”function”" class="headerlink" title="scope&#x3D;”function”"></a>scope&#x3D;”function”</h1><p>@pytest.fixture()如果不写参数，默认就是scope&#x3D;”function”，它的作用范围是每个测试用例来之前运行一次，销毁代码在测试用例运行之后运行。</p>
<pre><code class="python">import pytest

@pytest.fixture()
def first():
    print(&quot;\n获取用户名&quot;)
    a = &quot;yoyo&quot;
    return a

@pytest.fixture(scope=&quot;function&quot;)
def sencond():
    print(&quot;\n获取密码&quot;)
    b = &quot;123456&quot;
    return b

def test_1(first):
    &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
    print(&quot;测试账号：%s&quot; %first)
    assert first == &quot;yoyo&quot;

def test_2(sencond):
    &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
    print(&quot;测试密码：%s&quot; %sencond)
    assert sencond == &quot;123456&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture7.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="yaml">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO\fixt, inifile:
plugins: rerunfailures-4.1, metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

test_fixture7.py 
获取用户名
测试账号：yoyo
.
获取密码
测试密码：123456
.

========================== 2 passed in 0.01 seconds ===========================
</code></pre>
<p>用例放到类里面也一样</p>
<pre><code class="python">import pytest

@pytest.fixture()
def first():
    print(&quot;\n获取用户名&quot;)
    a = &quot;yoyo&quot;
    return a

@pytest.fixture(scope=&quot;function&quot;)
def sencond():
    print(&quot;\n获取密码&quot;)
    b = &quot;123456&quot;
    return b

class TestCase():
    def test_1(self, first):
        &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
        print(&quot;测试账号：%s&quot; % first)
        assert first == &quot;yoyo&quot;

    def test_2(self, sencond):
        &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
        print(&quot;测试密码：%s&quot; % sencond)
        assert sencond == &quot;123456&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture7.py&quot;])
</code></pre>
<h1 id="scope-x3D-”class”"><a href="#scope-x3D-”class”" class="headerlink" title="scope&#x3D;”class”"></a>scope&#x3D;”class”</h1><p>fixture为class级别的时候，如果一个class里面有多个用例，都调用了此fixture，那么此fixture只在该class里所有用例开始前执行一次</p>
<pre><code class="python">import pytest

@pytest.fixture(scope=&quot;class&quot;)
def first():
    print(&quot;\n获取用户名,scope为class级别只运行一次&quot;)
    a = &quot;yoyo&quot;
    return a

class TestCase():
    def test_1(self, first):
        &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
        print(&quot;测试账号：%s&quot; % first)
        assert first == &quot;yoyo&quot;

    def test_2(self, first):
        &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
        print(&quot;测试账号：%s&quot; % first)
        assert first == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture9.py&quot;])
</code></pre>
<p>运行结果：</p>
<pre><code class="vbnet">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO\fixt, inifile:
plugins: rerunfailures-4.1, metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

test_fixture9.py 
获取用户名,scope为class级别只运行一次
测试账号：yoyo
.测试账号：yoyo
.

========================== 2 passed in 0.13 seconds ===========================
</code></pre>
<h1 id="scope-x3D-”module”"><a href="#scope-x3D-”module”" class="headerlink" title="scope&#x3D;”module”"></a>scope&#x3D;”module”</h1><p>fixture为module级别时，在当前.py脚本里面所有用例开始前只执行一次</p>
<pre><code class="python">import pytest

@pytest.fixture(scope=&quot;module&quot;)
def first():
    print(&quot;\n获取用户名,scope为module级别当前.py模块只运行一次&quot;)
    a = &quot;yoyo&quot;
    return a


def test_1(first):
    &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
    print(&quot;测试账号：%s&quot; % first)
    assert first == &quot;yoyo&quot;

class TestCase():
    def test_2(self, first):
        &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
        print(&quot;测试账号：%s&quot; % first)
        assert first == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture10.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="sql">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO\fixt, inifile:
plugins: rerunfailures-4.1, metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

test_fixture10.py 
获取用户名,scope为module级别当前.py模块只运行一次
测试账号：yoyo
.测试账号：yoyo
.

========================== 2 passed in 0.14 seconds ===========================
</code></pre>
<h1 id="scope-x3D-”session”"><a href="#scope-x3D-”session”" class="headerlink" title="scope&#x3D;”session”"></a>scope&#x3D;”session”</h1><p>fixture为session级别是可以跨.py模块调用的,也就是当我们有多个.py文件的用例时候，如果多个用例只需调用一次fixture，那就可以设置为scope&#x3D;”session”，并且写到conftest.py文件里</p>
<p>conftest.py文件名称是固定的，pytest会自动识别该文件。放到工程的根目录下，就可以全局调用了，如果放到某个package包下，那就只在该package内有效</p>
<pre><code class="python">conftest.py

import pytest

@pytest.fixture(scope=&quot;session&quot;)
def first():
    print(&quot;\n获取用户名,scope为session级别多个.py模块只运行一次&quot;)
    a = &quot;yoyo&quot;
    return a
</code></pre>
<p>test_fixture11.py和test_fixture12.py用例脚本</p>
<pre><code class="python"># test_fixture11.py

import pytest
def test_1(first):
    &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
    print(&quot;测试账号：%s&quot; % first)
    assert first == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture11.py&quot;])


# test_fixture12.py
import pytest

def test_2(first):
    &#39;&#39;&#39;用例传fixture&#39;&#39;&#39;
    print(&quot;测试账号：%s&quot; % first)
    assert first == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture12.py&quot;])
</code></pre>
<p>如果想同时运行test_fixture11.py和test_fixture12.py，在cmd执行</p>
<blockquote>
<p>pytest -s test_fixture11.py test_fixture12.py</p>
</blockquote>
<pre><code class="yaml">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO\fixt, inifile:
plugins: rerunfailures-4.1, metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

test_fixture11.py .                                                      [ 50%]
test_fixture12.py .                                                      [100%]

========================== 2 passed in 0.03 seconds ===========================

D:\YOYO\fixt&gt;pytest -s test_fixture11.py test_fixture12.py
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: D:\YOYO\fixt, inifile:
plugins: rerunfailures-4.1, metadata-1.7.0, html-1.19.0, allure-adaptor-1.7.10
collected 2 items

test_fixture11.py
获取用户名,scope为session级别多个.py模块只运行一次
测试账号：yoyo
.
test_fixture12.py 测试账号：yoyo
.

========================== 2 passed in 0.03 seconds ===========================
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>025_pytest文档25-conftest.py作用范围</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A325-conftest.py%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个测试工程下是可以有多个conftest.py的文件，一般在工程根目录放一个conftest.py起到全局作用。<br>在不同的测试子目录也可以放conftest.py，作用范围只在该层级以及以下目录生效。</p>
<h1 id="conftest层级关系"><a href="#conftest层级关系" class="headerlink" title="conftest层级关系"></a>conftest层级关系</h1><p>在web_conf_py项目工程下建两个子项目baidu、blog，并且每个目录下都放一个conftest.py和__init__.py（python的每个package必须要有__init__.py）</p>
<pre><code class="markdown">web_conf_py是工程名称

├─baidu
│  │  conftest.py
│  │  test_1_baidu.py
│  │  __init__.py
│  
│        
├─blog
│  │  conftest.py
│  │  test_2_blog.py
│  │  __init__.py
│   
│  conftest.py
│  __init__.py
      
</code></pre>
<p><img src="/assets/2/image-20220516004023-2gn5knt.png" alt="image.png"></p>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>web_conf_py工程下conftest.py文件代码案例</p>
<pre><code class="python"># web_conf_py/conftest.py
import pytest

@pytest.fixture(scope=&quot;session&quot;)
def start():
    print(&quot;\n打开首页&quot;)
</code></pre>
<p>baidu目录下conftest.py和test_1_baidu.py</p>
<pre><code class="python"># web_conf_py/baidu/conftest.py
import pytest

@pytest.fixture(scope=&quot;session&quot;)
def open_baidu():
    print(&quot;打开百度页面_session&quot;)


# web_conf_py/baidu/test_1_baidu.py

import pytest

def test_01(start, open_baidu):
    print(&quot;测试用例test_01&quot;)
    assert 1

def test_02(start, open_baidu):
    print(&quot;测试用例test_02&quot;)
    assert 1

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_1_baidu.py&quot;])
</code></pre>
<p>运行test_1_baidu.py结果可以看出，start和open_baidu是session级别的，只运行一次</p>
<pre><code class="yaml">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py\baidu, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 2 items

test_1_baidu.py 
打开首页
打开百度页面_session
测试用例test_01
.测试用例test_02
.

========================== 2 passed in 0.01 seconds ===========================
</code></pre>
<p>blog目录下conftest.py和test_2_blog.py代码</p>
<pre><code class="python"># web_conf_py/blog/conftest.py
import pytest

@pytest.fixture(scope=&quot;function&quot;)
def open_blog():
    print(&quot;打开blog页面_function&quot;)


# web_conf_py/blog/test_2_blog.py

import pytest

def test_03(start, open_blog):
    print(&quot;测试用例test_03&quot;)
    assert 1

def test_04(start, open_blog):
    print(&quot;测试用例test_04&quot;)
    assert 1

def test_05(start, open_baidu):
    &#39;&#39;&#39;跨模块调用baidu模块下的conftest&#39;&#39;&#39;
    print(&quot;测试用例test_05,跨模块调用baidu&quot;)
    assert 1

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_2_blog.py&quot;])
</code></pre>
<p>运行结果可以看出，start起到全局作用，blog目录下的open_blog是function级别，每个用例调用一次。<br>test_05(start, open_baidu)用例不能跨模块调用baidu模块下的open_baidu，所以test_05用例会运行失败</p>
<pre><code class="markdown">============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py\blog, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 3 items

test_2_blog.py 
打开首页
打开blog页面_function
测试用例test_03
.打开blog页面_function
测试用例test_04
.E

=================================== ERRORS ====================================
__________________________ ERROR at setup of test_05 __________________________
file E:\YOYO\web_conf_py\blog\test_2_blog.py, line 11
  def test_05(start, open_baidu):
E       fixture &#39;open_baidu&#39; not found
&gt;       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, doctest_namespace, metadata, monkeypatch, open_blog, pytestconfig, record_property, record_xml_attribute, record_xml_property, recwarn, start, tmpdir, tmpdir_factory
&gt;       use &#39;pytest --fixtures [testpath]&#39; for help on them.

E:\YOYO\web_conf_py\blog\test_2_blog.py:11
====================== 2 passed, 1 error in 0.02 seconds ======================
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档26-运行上次失败用例(--lf 和 --ff）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A326-%E8%BF%90%E8%A1%8C%E4%B8%8A%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%94%A8%E4%BE%8B(--lf%20%E5%92%8C%20--ff%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“80%的bug集中在20%的模块，越是容易出现bug的模块，bug是越改越多“平常我们做手工测试的时候，比如用100个用例需要执行，其中10个用例失败了，<br>当开发修复完bug后，我们一般是重点测上次失败的用例。<br>那么自动化测试也一样，当用例特别多时，为了节省时间，第一次部分用例失败了，修复完之后，可以只测上次失败的用例。</p>
<h1 id="pytest-h"><a href="#pytest-h" class="headerlink" title="pytest -h"></a>pytest -h</h1><p>命令行输入pytest -h，找到里面两个命令行参数： –lf 和 –ff</p>
<ul>
<li>–lf, –last-failed 只重新运行上次运行失败的用例（或如果没有失败的话会全部跑）</li>
<li>–ff, –failed-first 运行所有测试，但首先运行上次运行失败的测试（这可能会重新测试，从而导致重复的fixture setup&#x2F;teardown）</li>
</ul>
<p><img src="/assets/2/image-20220516004133-zvfzrs1.png" alt="image.png"></p>
<h1 id="–lf-和-–ff"><a href="#–lf-和-–ff" class="headerlink" title="–lf 和 –ff"></a>–lf 和 –ff</h1><p>lf是last-failed的缩写，我第一次运行全部测试用例有4个通过passed， 2个失败failed，1个error</p>
<pre><code class="markdown">E:\YOYO\web_conf_py&gt;pytest
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 7 items

baidu\test_1_baidu.py ..                                                 [ 28%]
baidu\test_2.py FF                                                       [ 57%]
blog\test_2_blog.py ..E                                                  [100%]

=================================== ERRORS ====================================
__________________________ ERROR at setup of test_05 __________________________
file E:\YOYO\web_conf_py\blog\test_2_blog.py, line 11
  def test_05(start, open_baidu):
E       fixture &#39;open_baidu&#39; not found
&gt;       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, doctest_namespace, metadata, monkeypatch, open_blog, pytestconfig, record_property, record_xml_attribute, record_xml_property, recwarn, start, tmpdir, tmpdir_factory
&gt;       use &#39;pytest --fixtures [testpath]&#39; for help on them.

E:\YOYO\web_conf_py\blog\test_2_blog.py:11
================================== FAILURES ===================================
___________________________________ test_06 ___________________________________

start = None, open_baidu = None

    def test_06(start, open_baidu):
        print(&quot;测试用例test_01&quot;)
&gt;       assert 1==2
E       assert 1 == 2

baidu\test_2.py:5: AssertionError
---------------------------- Captured stdout call -----------------------------
测试用例test_01
___________________________________ test_07 ___________________________________

start = None, open_baidu = None

    def test_07(start, open_baidu):
        print(&quot;测试用例test_02&quot;)
&gt;       assert 1==2
E       assert 1 == 2

baidu\test_2.py:9: AssertionError
---------------------------- Captured stdout call -----------------------------
测试用例test_02
================= 2 failed, 4 passed, 1 error in 0.21 seconds =================
</code></pre>
<p>如果只想运行其中2个failed的和1error用例，那么可以直接在cmd输入指令</p>
<blockquote>
<p>pytest –lf</p>
</blockquote>
<pre><code class="makefile">E:\YOYO\web_conf_py&gt;pytest --lf
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 7 items / 4 deselected
run-last-failure: rerun previous 3 failures

baidu\test_2.py FF                                                       [ 66%]
blog\test_2_blog.py E                                                    [100%]

========================== 2 failed, 4 deselected, 1 error in 0.16 seconds===========================
</code></pre>
<p>如果想先运行上次失败的，后运行其它通过的用例</p>
<blockquote>
<p>pytest –ff</p>
</blockquote>
<pre><code class="makefile">E:\YOYO\web_conf_py&gt;pytest --ff
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: metadata-1.7.0, html-1.19.0
collected 7 items
run-last-failure: rerun previous 3 failures first

baidu\test_2.py FF                                                       [ 28%]
blog\test_2_blog.py E                                                    [ 42%]
baidu\test_1_baidu.py ..                                                 [ 71%]
blog\test_2_blog.py ..                                                   [100%]

================= 2 failed, 4 passed, 1 error in 0.14 seconds =================
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档27-pytest分布式执行（pytest-xdist）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A327-pytest%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%A7%E8%A1%8C%EF%BC%88pytest-xdist%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常我们手工测试用例非常多时，比如有1千条用例，假设每个用例执行需要1分钟。如果一个测试人员执行需要1000分钟才能执行完，当项目非常紧急的时候，<br>我们会用测试人力成本换取时间成本，这个时候多找个小伙伴把任务分成2部分，于是时间缩减一半。如果是十个人一起执行，1000个用例理论上只需100分钟就能完成，时间缩短到了1&#x2F;10。大大节省的测试时间，为项目节省了时间成本。</p>
<ul>
<li>pytest 3.6.3</li>
<li>pytest-xdist 1.23.2</li>
</ul>
<p>同样道理，当我们测试用例非常多的时候，一条条执行，很显然会比较慢，那么如何让测试用例并行执行呢，这就是我们接下来要讲的pytest分布式执行插件pytest-xdist</p>
<h1 id="pytest-xdist"><a href="#pytest-xdist" class="headerlink" title="pytest-xdist"></a>pytest-xdist</h1><p>cmd里面使用pip安装,目前版本号Version: 1.23.2</p>
<blockquote>
<p>pip install pytest-xdist</p>
</blockquote>
<pre><code class="makefile">&gt;pip show pytest-xdist
Name: pytest-xdist
Version: 1.23.2
Summary: pytest xdist plugin for distributed testing and loop-on-failing modes
Home-page: https://github.com/pytest-dev/pytest-xdist
Author: holger krekel and contributors
Author-email: pytest-dev@python.org,holger@merlinux.eu
License: MIT
Location: e:\python36\lib\site-packages
Requires: execnet, pytest-forked, six, pytest
</code></pre>
<p>pytest-xdist官网地址：<a href="https://github.com/pytest-dev/pytest-xdist">【Home-page: https://github.com/pytest-dev/pytest-xdist】</a></p>
<p>该pytest-xdist插件扩展了一些独特的测试执行模式pytest：</p>
<ul>
<li>测试运行并行化：如果有多个CPU或主机，则可以将它们用于组合测试运行。会加快运行速度</li>
<li>–looponfail：在子进程中重复运行测试。每次运行之后，pytest会等待，直到项目中的文件发生更改，然后重新运行以前失败的测试。<br>重复此过程直到所有测试通过，之后再次执行完整运行。</li>
<li>多平台覆盖：您可以指定不同的Python解释器或不同的平台，并在所有平台上并行运行测试。<br>在远程运行测试之前，pytest有效地将您的程序源代码“rsyncs”到远程位置。报告所有测试结果并显示给您的本地终端。您可以指定不同的Python版本和解释器。<br>如果您想知道pytest-xdist如何在幕后工作，可以看这里<a href="https://github.com/pytest-dev/pytest-xdist/blob/master/OVERVIEW.md">【OVERVIEW】</a></li>
</ul>
<h1 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h1><p>多cpu并行执行用例，直接加个-n参数即可，后面num参数就是并行数量，比如num设置为3</p>
<blockquote>
<p>pytest -n 3</p>
</blockquote>
<p>运行以下代码，项目结构如下</p>
<pre><code class="markdown">web_conf_py是项目工程名称
│  conftest.py
│  __init__.py
│            
├─baidu
│  │  conftest.py
│  │  test_1_baidu.py
│  │  test_2.py
│  │  __init__.py 
│        
├─blog
│  │  conftest.py
│  │  test_2_blog.py
│  │  __init__.py    
</code></pre>
<p>代码参考：</p>
<pre><code class="python"># web_conf_py/conftest.py
import pytest

@pytest.fixture(scope=&quot;session&quot;)
def start():
    print(&quot;\n打开首页&quot;)
    return &quot;yoyo&quot;

# web_conf_py/baidu/conftest.py
import pytest

@pytest.fixture(scope=&quot;session&quot;)
def open_baidu():
    print(&quot;打开百度页面_session&quot;)

# web_conf_py/baidu/test_1_baidu.py
import pytest
import time

def test_01(start, open_baidu):
    print(&quot;测试用例test_01&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

def test_02(start, open_baidu):
    print(&quot;测试用例test_02&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_1_baidu.py&quot;])


# web_conf_py/baidu/test_2.py
import pytest
import time

def test_06(start, open_baidu):
    print(&quot;测试用例test_01&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;
def test_07(start, open_baidu):
    print(&quot;测试用例test_02&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_2.py&quot;])


# web_conf_py/blog/conftest.py
import pytest

@pytest.fixture(scope=&quot;function&quot;)
def open_blog():
    print(&quot;打开blog页面_function&quot;)

# web_conf_py/blog/test_2_blog.py

import pytest
import time
def test_03(start, open_blog):
    print(&quot;测试用例test_03&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

def test_04(start, open_blog):
    print(&quot;测试用例test_04&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

def test_05(start, open_blog):
    &#39;&#39;&#39;跨模块调用baidu模块下的conftest&#39;&#39;&#39;
    print(&quot;测试用例test_05,跨模块调用baidu&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_2_blog.py&quot;])
</code></pre>
<p>正常运行需要消耗时间：7.12 seconds</p>
<pre><code class="makefile">E:\YOYO\web_conf_py&gt;pytest
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: xdist-1.23.2, metadata-1.7.0, html-1.19.0, forked-0.2
collected 7 items

baidu\test_1_baidu.py ..                                                 [ 28%]
baidu\test_2.py ..                                                       [ 57%]
blog\test_2_blog.py ...                                                  [100%]

========================== 7 passed in 7.12 seconds ===========================
</code></pre>
<p>设置并行运行数量为3，消耗时间：3.64 seconds，大大的缩短了用例时间</p>
<pre><code class="makefile">E:\YOYO\web_conf_py&gt;pytest -n 3
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: xdist-1.23.2, metadata-1.7.0, html-1.19.0, forked-0.2
gw0 [7] / gw1 [7] / gw2 [7]
scheduling tests via LoadScheduling
.......                                                                  [100%]
========================== 7 passed in 3.64 seconds ===========================
</code></pre>
<h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><p>使用pytest-xdist插件也能生成html报告,完美支持pytest-html插件</p>
<blockquote>
<p>pytest -n 3 –html&#x3D;report.html –self-contained-html</p>
</blockquote>
<p><img src="/assets/2/image-20220516004245-v3l6k9j.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档28-重复执行用例（pytest-repeat）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A328-%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%94%A8%E4%BE%8B%EF%BC%88pytest-repeat%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平常在做功能测试的时候，经常会遇到某个模块不稳定，偶然会出现一些bug，对于这种问题我们会针对此用例反复执行多次，最终复现出问题来。<br>自动化运行用例时候，也会出现偶然的bug，可以针对单个用例，或者针对某个模块的用例重复执行多次。</p>
<h1 id="pytest-repeat"><a href="#pytest-repeat" class="headerlink" title="pytest-repeat"></a>pytest-repeat</h1><p>pytest-repeat是pytest的一个插件，用于重复执行单个用例，或多个测试用例，并指定重复次数，pytest-repeat支持的版本：</p>
<ul>
<li>Python 2.7, 3.4+ 或 PyPy</li>
<li>py.test 2.8或更高</li>
</ul>
<p>使用pip安装pytest-repeat</p>
<blockquote>
<p>pip install pytest-repeat</p>
</blockquote>
<p>使用–count命令行选项指定要运行测试用例和测试次数</p>
<blockquote>
<p>py.test –count&#x3D;10 test_file.py</p>
</blockquote>
<h1 id="重复执行–count"><a href="#重复执行–count" class="headerlink" title="重复执行–count"></a>重复执行–count</h1><p>运行以下代码，项目结构如下</p>
<pre><code class="markdown">web_conf_py是项目工程名称
│  conftest.py  
│  __init__.py
│            
├─baidu
│  │  conftest.py
│  │  test_1_baidu.py
│  │  test_2.py
│  │  __init__.py 
│        
├─blog
│  │  conftest.py
│  │  test_2_blog.py
│  │  __init__.py    
</code></pre>
<p>代码参考：</p>
<pre><code class="python"># web_conf_py/conftest.py
import pytest

@pytest.fixture(scope=&quot;session&quot;)
def start():
    print(&quot;\n打开首页&quot;)
    return &quot;yoyo&quot;

# web_conf_py/baidu/conftest.py
import pytest

@pytest.fixture(scope=&quot;session&quot;)
def open_baidu():
    print(&quot;打开百度页面_session&quot;)

# web_conf_py/baidu/test_1_baidu.py
import pytest
import time

def test_01(start, open_baidu):
    print(&quot;测试用例test_01&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

def test_02(start, open_baidu):
    print(&quot;测试用例test_02&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_1_baidu.py&quot;])


# web_conf_py/baidu/test_2.py
import pytest
import time

def test_06(start, open_baidu):
    print(&quot;测试用例test_01&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;
def test_07(start, open_baidu):
    print(&quot;测试用例test_02&quot;)
    time.sleep(1)
    assert start == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_2.py&quot;])
</code></pre>
<p>cmd进入到工程目录后，不带–count参数只会执行一次</p>
<blockquote>
<p>pytest baidu&#x2F;test_1_baidu.py -s</p>
</blockquote>
<pre><code class="makefile">E:\YOYO\web_conf_py&gt;pytest baidu/test_1_baidu.py -s
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: xdist-1.23.2, repeat-0.7.0, metadata-1.7.0, html-1.19.0, forked-0.2
collected 2 items

baidu\test_1_baidu.py
打开首页
打开百度页面_session
测试用例test_01
.测试用例test_02
.

========================== 2 passed in 1.03 seconds ===========================
</code></pre>
<p>加上参数–count&#x3D;5，用例会重复执行5次</p>
<blockquote>
<p>pytest baidu&#x2F;test_1_baidu.py -s –count&#x3D;5</p>
</blockquote>
<pre><code class="lua">E:\YOYO\web_conf_py&gt;pytest baidu/test_1_baidu.py -s --count=5
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: xdist-1.23.2, repeat-0.7.0, metadata-1.7.0, html-1.19.0, forked-0.2
collected 10 items

baidu\test_1_baidu.py
打开首页
打开百度页面_session
测试用例test_01
.测试用例test_01
.测试用例test_01
.测试用例test_01
.测试用例test_01
.测试用例test_02
.测试用例test_02
.测试用例test_02
.测试用例test_02
.测试用例test_02
.

========================== 10 passed in 5.06 seconds ==========================
</code></pre>
<p>从运行的用例结果看，是先重复5次test_01，再重复5次test_02，有时候我们希望执行的顺序是test_01,test_02按这样顺序重复五次，接下来就用到一个参数–repeat-scope</p>
<h1 id="–repeat-scope"><a href="#–repeat-scope" class="headerlink" title="–repeat-scope"></a>–repeat-scope</h1><p>–repeat-scope类似于pytest fixture的scope参数，–repeat-scope也可以设置参数： <code>session</code> ， <code>module</code>，<code>class</code>或者<code>function</code>（默认值）</p>
<ul>
<li><code>function</code>（默认）范围针对每个用例重复执行，再执行下一个用例</li>
<li><code>class</code> 以class为用例集合单位，重复执行class里面的用例，再执行下一个</li>
<li><code>module</code> 以模块为单位，重复执行模块里面的用例，再执行下一个</li>
<li><code>session</code> 重复整个测试会话，即所有收集的测试执行一次，然后所有这些测试再次执行等等</li>
</ul>
<p>使用<code>--repeat-scope=session</code>重复执行整个会话用例</p>
<blockquote>
<p>pytest baidu&#x2F;test_1_baidu.py -s –count&#x3D;5 –repeat-scope&#x3D;session</p>
</blockquote>
<pre><code class="mipsasm">E:\YOYO\web_conf_py&gt;pytest baidu/test_1_baidu.py -s --count=5 --repeat-scope=session
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: xdist-1.23.2, repeat-0.7.0, metadata-1.7.0, html-1.19.0, forked-0.2
collected 10 items

baidu\test_1_baidu.py
打开首页
打开百度页面_session
测试用例test_01
.测试用例test_02
.测试用例test_01
.测试用例test_02
.测试用例test_01
.测试用例test_02
.测试用例test_01
.测试用例test_02
.测试用例test_01
.测试用例test_02
.

========================== 10 passed in 5.07 seconds ==========================
</code></pre>
<h1 id="pytest-mark-repeat-count"><a href="#pytest-mark-repeat-count" class="headerlink" title="@pytest.mark.repeat(count)"></a>@pytest.mark.repeat(count)</h1><p>如果要在代码中标记要重复多次的测试，可以使用<code>@pytest.mark.repeat(count)</code>装饰器</p>
<pre><code class="python"># test_1_baidu.py
import pytest
import time

def test_01(start, open_baidu):
    print(&quot;测试用例test_01&quot;)
    time.sleep(0.5)
    assert start == &quot;yoyo&quot;

@pytest.mark.repeat(5)
def test_02(start, open_baidu):
    print(&quot;测试用例test_02&quot;)
    time.sleep(0.5)
    assert start == &quot;yoyo&quot;

if __name__ == &quot;__main__&quot;:
    pytest.main([&quot;-s&quot;, &quot;test_1_baidu.py&quot;])
</code></pre>
<p>这样执行用例时候，就不用带上–count参数，只针对test_02重复执行5次</p>
<pre><code class="makefile">E:\YOYO\web_conf_py&gt;pytest baidu/test_1_baidu.py -s
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0
rootdir: E:\YOYO\web_conf_py, inifile:
plugins: xdist-1.23.2, repeat-0.7.0, metadata-1.7.0, html-1.19.0, forked-0.2
collected 6 items

baidu\test_1_baidu.py
打开首页
打开百度页面_session
测试用例test_01
.测试用例test_02
.测试用例test_02
.测试用例test_02
.测试用例test_02
.测试用例test_02
.

========================== 6 passed in 3.05 seconds ===========================
</code></pre>
<h1 id="重复测试直到失败"><a href="#重复测试直到失败" class="headerlink" title="重复测试直到失败"></a>重复测试直到失败</h1><p>如果您正在尝试诊断间歇性故障，那么一遍又一遍地运行相同的测试直到失败是有用的。您可以将pytest的-x选项与pytest-repeat结合使用，以强制测试运行器在第一次失败时停止。例如：</p>
<blockquote>
<p>py.test –count&#x3D;1000 -x test_file.py</p>
</blockquote>
<p>这将尝试运行test_file.py 1000次，但一旦发生故障就会停止</p>
<h1 id="UnitTest样式测试"><a href="#UnitTest样式测试" class="headerlink" title="UnitTest样式测试"></a>UnitTest样式测试</h1><p>不幸的是，此插件不支持unittest框架的用例，pytest-repeat无法使用unittest.TestCase测试类。无论如何，这些测试将始终运行一次–count，并显示警告<br>更多资料参考<a href="https://pypi.org/project/pytest-repeat/">【官方文档：https://pypi.org/project/pytest-repeat/】</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档29-allure-pytest(最新最全，保证能搞成功！)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A329-allure-pytest(%E6%9C%80%E6%96%B0%E6%9C%80%E5%85%A8%EF%BC%8C%E4%BF%9D%E8%AF%81%E8%83%BD%E6%90%9E%E6%88%90%E5%8A%9F%EF%BC%81)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写了个pytest的allure相关的教程，只是停留在环境搭建完成，后续一直没用，小编一直不喜欢这种花里胡哨的报告。<br>没办法，领导就喜欢这种，小伙伴们也喜欢，所以还是得把allure用起来，年底了，给领导一个漂亮的报告，也好加鸡腿<br>之前用的是pytest-allure-adaptor插件，一年多前写的了，很古老了，跟不上时代了，不能吸引当代的小青年，这里用最新的allure-pytest，符合当代小青年的口味。</p>
<h1 id="allure-pytest-环境准备"><a href="#allure-pytest-环境准备" class="headerlink" title="allure-pytest 环境准备"></a>allure-pytest 环境准备</h1><p>windows环境相关：</p>
<p>python 3.6版本<br>pytest 4.5.0版本<br>allure-pytest 2.8.6 最新版</p>
<p>使用pip安装pytest和allure-pytest,加上–index-url地址，下载会快一些</p>
<pre><code class="perl">pip install pytest==4.5.0 --index-url https://pypi.douban.com/simple
pip install allure-pytest==2.8.6 --index-url https://pypi.douban.com/simple
</code></pre>
<p>安装完成之后，打开一个你之前写的pytest脚本，看能不正常使用，如果报错：AttributeError: module ‘allure’ has no attribute ‘severity_level’<br>这个是之前 pytest-allure-adaptor 这个插件与 allure-pytest 不能共存，卸载掉 pytest-allure-adaptor</p>
<blockquote>
<p>pip uninstall pytest-allure-adaptor</p>
</blockquote>
<h1 id="allure命令行工具"><a href="#allure命令行工具" class="headerlink" title="allure命令行工具"></a>allure命令行工具</h1><p>allure是一个命令行工具，需要去github上下载最新版<a href="https://github.com/allure-framework/allure2/releases">https://github.com/allure-framework/allure2/releases</a></p>
<p><img src="/assets/2/image-20220516004510-2prmh2q.png" alt="image.png"></p>
<p>下载完成之后，解压到本地电脑</p>
<p><img src="/assets/2/image-20220516004520-5eeluzh.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220516004526-c2xld4z.png" alt="image.png"></p>
<p>把bin目录添加到环境变量Path下</p>
<p><img src="/assets/2/image-20220516004532-jxrievq.png" alt="image.png"></p>
<h1 id="用例demo"><a href="#用例demo" class="headerlink" title="用例demo"></a>用例demo</h1><p>conftest.py内容</p>
<pre><code class="python">import pytest


@pytest.fixture(scope=&quot;session&quot;)
def login():
    print(&quot;用例先登录&quot;)
</code></pre>
<p>test_allure_demo.py内容</p>
<pre><code class="python">import allure
import pytest

@allure.step(&quot;步骤1:点xxx&quot;)
def step_1():
    print(&quot;111&quot;)

@allure.step(&quot;步骤2:点xxx&quot;)
def step_2():
    print(&quot;222&quot;)

@allure.feature(&quot;编辑页面&quot;)
class TestEditPage():
    &#39;&#39;&#39;编辑页面&#39;&#39;&#39;

    @allure.story(&quot;这是一个xxx的用例&quot;)
    def test_1(self, login):
        &#39;&#39;&#39;用例描述：先登录，再去执行xxx&#39;&#39;&#39;
        step_1()
        step_2()
        print(&quot;xxx&quot;)


    @allure.story(&quot;打开a页面&quot;)
    def test_2(self, login):
        &#39;&#39;&#39;用例描述：先登录，再去执行yyy&#39;&#39;&#39;
        print(&quot;yyy&quot;)
</code></pre>
<h1 id="运行用例"><a href="#运行用例" class="headerlink" title="运行用例"></a>运行用例</h1><p>cd到test_allure_demo.py所在的目录文件，命令行执行</p>
<blockquote>
<p>pytest –alluredir .&#x2F;report&#x2F;allure_raw</p>
</blockquote>
<pre><code class="vbnet">D:\soft\code\xuexipytest&gt;pytest --alluredir ./report/allure_raw
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\soft\code\xuexipytest
plugins: allure-pytest-2.8.6, forked-0.2, html-1.19.0, metadata-1.7.0, repeat-0.7.0, xdist-1.23.2
collected 9 items

case\test_allure_demo.py ..                                              [ 22%]
case\test_x.py ......                                                    [ 88%]
case\test_y.py .                                                         [100%]

============================== 9 passed in 0.21s ==============================
</code></pre>
<p>执行完成后，在当前目录下，report目录会生成一个allure_raw的原始文件，这个只是测试报告的原始文件，不能打开成html的报告</p>
<p><img src="/assets/2/image-20220516004542-1s5b72c.png" alt="image.png"></p>
<p>打开html的报告需要启动allure服务，启动命令如下</p>
<blockquote>
<p>allure serve report&#x2F;allure_raw</p>
</blockquote>
<p>启动服务,它会自动给个端口，直接用默认浏览器打开了</p>
<pre><code class="vhdl">D:\soft\code\xuexipytest&gt;allure serve report/allure_raw
Generating report to temp directory...
Report successfully generated to C:\Users\dell\AppData\Local\Temp\6056757827461248074\allure-report
Starting web server...
2019-12-08 00:41:09.921:INFO::main: Logging initialized @2228ms to org.eclipse.jetty.util.log.StdErrLog
Server started at &lt;http://192.168.1.125:35346/&gt;. Press &lt;Ctrl+C&gt; to exit
</code></pre>
<h1 id="查看报告"><a href="#查看报告" class="headerlink" title="查看报告"></a>查看报告</h1><p>浏览器上打开的报告内容</p>
<p><img src="/assets/2/image-20220516004623-3nuu6zi.png" alt="image.png"></p>
<p>点 EN 按钮可以查看中文报告</p>
<p><img src="/assets/2/image-20220516004616-w3wg00v.png" alt="image.png"></p>
<p>打开测试套件，可以查看报告的详情，显示的还是很详细的</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档30-功能用例与自动化用例完美对接(allure)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A330-%E5%8A%9F%E8%83%BD%E7%94%A8%E4%BE%8B%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%A8%E4%BE%8B%E5%AE%8C%E7%BE%8E%E5%AF%B9%E6%8E%A5(allure)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做自动化做久了，经常会思考一个问题，到底别人是怎么做的自动化，跟自己的有啥不一样，看过不少书和资料，都是停留在demo的层面。<br>真正把自动化做的好的大牛又不屑于分享自己的劳动成果，所以大部分情况就是一群菜鸡在群里互啄，停留在初级入门的demo层面上。<br>到底自动化要达到什么样的效果呢？这里我把最近的研究成果分享下，有经验的小伙伴也可以一起交流下。</p>
<h1 id="功能用例"><a href="#功能用例" class="headerlink" title="功能用例"></a>功能用例</h1><p>我一直认为一切的自动化用例是基于功能测试用例的， 脱离了功能测试用例，你的代码写的再漂亮，那也仅仅是show代码的。<br>面试的时候经常会遇到一个问题，一般领导型的面试官会问：你们自动化做到了什么程度？自动化用例覆盖率达到了多少？</p>
<p>自动化用例覆盖率是一个很好的衡量标准，比如你功能测试用例有100条，你的自动化用例写了90条，用例覆盖率是90%？当然不是！！！<br>你的自动化用例如果跟功能用例搭不上边，那都是无效用例，覆盖率也许是0%，仅仅是你自己瞎写的！</p>
<p>所以自动化用例是去翻译你的功能用例 ，一个一个去覆盖，让功能case,变成自动化用例的case,一一对应起来的（没写过功能用例的，后面就不用看了）。</p>
<p>写功能用例的平台有很多，比如jira,禅道，testlink等，这里以禅道系统为例，比如我的”编辑文章分类”模块下了3个用例</p>
<p><img src="/assets/2/image-20220516004738-oderaez.png" alt="image.png"></p>
<p>其中的一条用例是这样的，有前置条件，用例的步骤和期望结果，这才是一个标准的用例</p>
<p><img src="/assets/2/image-20220516004745-d744bam.png" alt="image.png"></p>
<h1 id="自动化用例"><a href="#自动化用例" class="headerlink" title="自动化用例"></a>自动化用例</h1><p>功能用例写完之后，接着是如何去用代码去实现功能用例，这里用的是pytest框架+allure报告，其中一条用例的部分代码应该如下</p>
<ul>
<li>feature 对应模块名称</li>
<li>story 对应用例的标题</li>
<li>testcase 对应禅道系统的bug用例url地址，关联起来</li>
<li>issue 如果这个用例有bug，应该关联对应的bug地址</li>
<li>用例描述： 对应def下的描述步骤</li>
</ul>
<pre><code class="python">import allure
# 上海-悠悠，QQ交流群：750815713
# 博客地址：https://www.cnblogs.com/yoyoketang/

@allure.feature(&quot;编辑分类文章&quot;)
class TestArticleclassify():
    &#39;&#39;&#39;编辑文章分类&#39;&#39;&#39;


    @allure.story(&quot;登录-编辑文章分类，重复保存，保存失败&quot;)
    @allure.issue(&quot;http://49.235.92.12:8080/zentao/bug-view-1.html&quot;)  # 禅道bug地址
    @allure.testcase(&quot;http://49.235.92.12:8080/zentao/testcase-view-5-1.html&quot;)  # 禅道用例连接地址
    def test_edit_classify5(self, login):
        &#39;&#39;&#39;用例描述：编辑文章分类-输入重复的分类，保存失败，不能添加重复的
        setup: 登录login
        step1: 编辑文章分类，输入文章类别，如：计算机
        step2: 点保存按钮
        step3: 重新打开编辑页，输入：计算机
        step4: 再次点保存按钮
        assert: 保存失败，提示：已存在
        &#39;&#39;&#39;
        driver = login
        edit = ArticleclassifyPage(driver)
        edit.click_classify_nav()
        edit.edit_classify(&quot;计算机&quot;)
        res2 = edit.is_edit_classify_success(&quot;计算机&quot;)
        print(&quot;编辑是否成功：%s&quot;%res2)
        assert res2  # 断言
</code></pre>
<p>前置条件：login,应该是单独抽出来的写到conftest.py，作为一个前置fixture功能</p>
<pre><code class="python">import pytest
from selenium import webdriver
from pages.login_page import LoginPage
import time
# 上海-悠悠，QQ交流群：750815713
# 博客地址：https://www.cnblogs.com/yoyoketang/

# request 内置的fixture

@pytest.fixture(scope=&quot;session&quot;)
def driver(request):
    &#39;&#39;&#39;只打开浏览器和关闭浏览器&#39;&#39;&#39;
    driver = webdriver.Chrome()
    driver.maximize_window() # 最大化

    def end():
        print(&quot;全部用例执行完后 teardown quit dirver&quot;)
        time.sleep(5)
        driver.quit()

    request.addfinalizer(end)
    return driver

@pytest.fixture(scope=&quot;session&quot;)
def login(driver):
    web = LoginPage(driver)
    web.login()
    return driver
</code></pre>
<p>LoginPage 页面的封装，可以添加操作步骤,step对应每个步骤，我这里登录几个步骤写一起了，也可写的更详细</p>
<pre><code class="python"># 上海-悠悠，QQ交流群：750815713
# 博客地址：https://www.cnblogs.com/yoyoketang/

class LoginPage(Base):

    loc_用户名 = (&quot;id&quot;, &quot;id_username&quot;)
    loc_密码 = (&quot;id&quot;, &quot;id_password&quot;)
    loc_登录按钮 = (&quot;xpath&quot;, &quot;//*[text()=&#39;登录&#39;]&quot;)

    # 判断登录成功
    loc_后台页面 = (&quot;xpath&quot;, &quot;//*[text()=&#39;后台页面&#39;]&quot;)

    @allure.step(&quot;登录&quot;)
    def login(self, username=&quot;admin&quot;, password=&quot;yoyo123456&quot;):
        &#39;&#39;&#39;登录&#39;&#39;&#39;
        self.driver.get(login_url)
        self.send(self.loc_用户名, username)
        self.send(self.loc_密码, password)
        self.click(self.loc_登录按钮)

    @allure.step(&quot;登录结果判断&quot;)
    def is_login_success(self):
        &#39;&#39;&#39;判断是否登录成功 True  False&#39;&#39;&#39;
        result = self.is_element_exist(self.loc_后台页面)
        return result
</code></pre>
<h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><p>接着查看运行结果的测试报告，展示效果如下</p>
<p><img src="/assets/2/image-20220516004804-o68hnmu.png" alt="image.png"></p>
<p>这样我们只需拿着测试报告，就可以交出完美的答案了！</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档31-allure标记用例级别severity</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A331-allure%E6%A0%87%E8%AE%B0%E7%94%A8%E4%BE%8B%E7%BA%A7%E5%88%ABseverity/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在做功能测试的时候，执行完一轮测试用例，输出测试报告的时候，会有统计缺陷的数量和等级。<br>在做自动化测试的过程中，当你的测试用例越来越多的时候，如果执行一轮测试发现了几个测试不通过，我们也希望能快速统计出缺陷的等级。<br>pytest结合allure框架可以对用例的等级做详细的划分。</p>
<h1 id="用例等级"><a href="#用例等级" class="headerlink" title="用例等级"></a>用例等级</h1><p>allure对用例的等级划分成五个等级</p>
<ul>
<li>blocker　 阻塞缺陷（功能未实现，无法下一步）</li>
<li>critical　　严重缺陷（功能点缺失）</li>
<li>normal　　 一般缺陷（边界情况，格式错误）</li>
<li>minor　 次要缺陷（界面错误与ui需求不符）</li>
<li>trivial　　 轻微缺陷（必须项无提示，或者提示不规范）</li>
</ul>
<p>比如我的用例有以下4条</p>
<p><img src="/assets/2/image-20220516004947-1jem1kq.png" alt="image.png"><br>那么对应的用例的等级应该是</p>
<ul>
<li>修改个人信息-sex参数为空 这个属于边界值情况的测试，应该是normal级别</li>
<li>修改个人信息-sex参数传F和M两种类型，成功(枚举类型) 这个是针对接口的功能点详细测试 critical级别</li>
<li>修改个人信息-修改不是本人的用户信息，无权限操作 这个是针对接口的功能点详细测试 critical级别</li>
<li>修改个人信息-修改自己的个人信息，修改成功 这是用例是测试主流程 blocker级别</li>
</ul>
<h1 id="pytest用例"><a href="#pytest用例" class="headerlink" title="pytest用例"></a>pytest用例</h1><p>根据测试用例的重要性划分测试用例等级，如果没指定等级，默认为normal级别</p>
<pre><code class="python">import pytest
import allure
&#39;&#39;&#39;
作者：上海-悠悠 qq交流群：874033608

@allure.severity装饰器按严重性级别来标记case　　　
执行指定测试用例 --allure-severities blocker
BLOCKER = &#39;blocker&#39;　　阻塞缺陷
CRITICAL = &#39;critical&#39;　严重缺陷
NORMAL = &#39;normal&#39;　　  一般缺陷
MINOR = &#39;minor&#39;　　    次要缺陷
TRIVIAL = &#39;trivial&#39;　　轻微缺陷　
&#39;&#39;&#39;


@allure.severity(&quot;normal&quot;)
def test_case_1():
    &#39;&#39;&#39;修改个人信息-sex参数为空&#39;&#39;&#39;
    print(&quot;test case 11111111&quot;)
  

@allure.severity(&quot;critical&quot;)
def test_case_2():
    &#39;&#39;&#39;修改个人信息-sex参数传F和M两种类型，成功(枚举类型)&#39;&#39;&#39;
    print(&quot;test case 222222222&quot;)


@allure.severity(&quot;critical&quot;)
def test_case_3():
    &#39;&#39;&#39;修改个人信息-修改不是本人的用户信息，无权限操作&#39;&#39;&#39;
    print(&quot;test case 333333333&quot;)

@allure.severity(&quot;blocker&quot;)
def test_case_4():
    &#39;&#39;&#39;修改个人信息-修改自己的个人信息，修改成功&#39;&#39;&#39;
    print(&quot;test case 4444444&quot;)


def test_case_5():
    &#39;&#39;&#39;没标记severity的用例默认为normal&#39;&#39;&#39;
    print(&quot;test case 5555555555&quot;)
</code></pre>
<p>cd到用例的目录，执行用例，查看报告</p>
<blockquote>
<p>pytest –alluredir .&#x2F;report&#x2F;allure<br>allure serve .&#x2F;report&#x2F;allure<br>查看报告详情<br><img src="/assets/2/image-20220516005001-2wizonj.png" alt="image.png"></p>
</blockquote>
<h1 id="统计缺陷"><a href="#统计缺陷" class="headerlink" title="统计缺陷"></a>统计缺陷</h1><p>如果执行用例的过程中有测试用例不通过的情况，也可以统计缺陷的严重等级</p>
<pre><code class="python"># 修改上面2个用例，故意让用例失败
@allure.severity(&quot;blocker&quot;)
def test_case_4():
    &#39;&#39;&#39;修改个人信息-修改自己的个人信息，修改成功&#39;&#39;&#39;
    print(&quot;test case 4444444&quot;)
    assert 1==2


def test_case_5():
    &#39;&#39;&#39;没标记severity的用例默认为normal&#39;&#39;&#39;
    print(&quot;test case 5555555555&quot;)
    assert 1==2
</code></pre>
<p>重新执行用例，查看报告-图表</p>
<p><img src="/assets/2/image-20220516005010-7byortg.png" alt="image.png"></p>
<h1 id="allure命令行参数allure-severities"><a href="#allure命令行参数allure-severities" class="headerlink" title="allure命令行参数allure-severities"></a>allure命令行参数allure-severities</h1><p>pytest -h可以查看到allure相关的几个命令行参数<br>–allure-severities&#x3D;SEVERITIES_SET<br>Comma-separated list of severity names. Tests only<br>with these severities will be run. Possible values<br>are: blocker, critical, normal, minor, trivial.<br>如果有很多测试用例，现在只想做个快速的回归测试，只测试用例级别为blocker和critical级别的测试用例</p>
<blockquote>
<p>pytest –alluredir .&#x2F;report&#x2F;allure –allure-severities blocker,critical</p>
</blockquote>
<p>也可以这样写</p>
<blockquote>
<p>pytest –alluredir&#x3D;.&#x2F;report&#x2F;allure –allure-severities&#x3D;blocker,critical</p>
</blockquote>
<p>如果只执行blocker级别的用例</p>
<blockquote>
<p>pytest –alluredir&#x3D;.&#x2F;report&#x2F;allure –allure-severities&#x3D;blocker</p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档1-环境准备与入门</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A332-allure%E6%8F%8F%E8%BF%B0%E7%94%A8%E4%BE%8B%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest+allure是最完美的结合了，关于allure的使用，本篇做一个总结。<br>allure报告可以很多详细的信息描述测试用例，包括epic、feature、story、title、issue、testcase、severity等<br>环境准备</p>
<ul>
<li>python 3.6</li>
<li>pytest 4.5.0</li>
<li>allure-pytest 2.8.6</li>
</ul>
<h1 id="allure用例描述"><a href="#allure用例描述" class="headerlink" title="allure用例描述"></a>allure用例描述</h1><table>
<thead>
<tr>
<th>使用方法</th>
<th>参数值</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>@allure.epic()</td>
<td>epic描述</td>
<td>敏捷里面的概念，定义史诗，往下是feature</td>
</tr>
<tr>
<td>@allure.feature()</td>
<td>模块名称</td>
<td>功能点的描述，往下是story</td>
</tr>
<tr>
<td>@allure.story()</td>
<td>用户故事</td>
<td>用户故事，往下是title</td>
</tr>
<tr>
<td>@allure.title(用例的标题)</td>
<td>用例的标题</td>
<td>重命名html报告名称</td>
</tr>
<tr>
<td>@allure.testcase()</td>
<td>测试用例的链接地址</td>
<td>对应功能测试用例系统里面的case</td>
</tr>
<tr>
<td>@allure.issue()</td>
<td>缺陷</td>
<td>对应缺陷管理系统里面的链接</td>
</tr>
<tr>
<td>@allure.description()</td>
<td>用例描述</td>
<td>测试用例的描述</td>
</tr>
<tr>
<td>@allure.step()</td>
<td>操作步骤</td>
<td>测试用例的步骤</td>
</tr>
<tr>
<td>@allure.severity()</td>
<td>用例等级</td>
<td>blocker，critical，normal，minor，trivial</td>
</tr>
<tr>
<td>@allure.link()</td>
<td>链接</td>
<td>定义一个链接，在测试报告展现</td>
</tr>
<tr>
<td>@allure.attachment()</td>
<td>附件</td>
<td>报告添加附件</td>
</tr>
</tbody></table>
<h1 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h1><p>pytest结合allure测试用例</p>
<pre><code class="python">import pytest
import allure
# 作者：上海-悠悠 qq交流群：874033608

@pytest.fixture(scope=&quot;session&quot;)
def login_fixture():
    print(&quot;前置条件：登录&quot;)


@allure.step(&quot;步骤1&quot;)
def step_1():
    print(&quot;操作步骤---------------1&quot;)


@allure.step(&quot;步骤2&quot;)
def step_2():
    print(&quot;操作步骤---------------2&quot;)


@allure.step(&quot;步骤3&quot;)
def step_3():
    print(&quot;操作步骤---------------3&quot;)


@allure.epic(&quot;epic对大Story的一个描述性标签&quot;)
@allure.feature(&quot;测试模块&quot;)
class TestDemoAllure():

    @allure.testcase(&quot;http://49.235.x.x:8080/zentao/testcase-view-6-1.html&quot;)
    @allure.issue(&quot;http://49.235.x.x:8080/zentao/bug-view-1.html&quot;)
    @allure.title(&quot;用例的标题&quot;)
    @allure.story(&quot;用户故事：1&quot;)
    @allure.severity(&quot;critical&quot;)
    def test_case_1(self, login_fixture):
        &#39;&#39;&#39;case description:作者：上海-悠悠 qq交流群：874033608
        1.点文章分类导航标签 -跳转编辑页面
        2.编辑页面输入，分类名称，如:上海-悠悠-可以输入
        3.点保存按钮保存成功
        &#39;&#39;&#39;
        step_1()
        step_2()

    @allure.story(&quot;用户故事：2&quot;)
    def test_case_2(self, login_fixture):
        print(&quot;测试用例1&quot;)
        step_1()
        step_3()


@allure.epic(&quot;epic对大Story的一个描述性标签&quot;)
@allure.feature(&quot;模块2&quot;)
class TestDemo2():


    @allure.story(&quot;用户故事：3&quot;)
    def test_case_3(self, login_fixture):
        print(&quot;测试用例1&quot;)
        step_1()


    @allure.story(&quot;用户故事：4&quot;)
    def test_case_4(self, login_fixture):
        print(&quot;测试用例1&quot;)
        step_3()
</code></pre>
<h1 id="报告展示"><a href="#报告展示" class="headerlink" title="报告展示"></a>报告展示</h1><p>cd到用例目录执行用例生成allure报告</p>
<blockquote>
<p>pytest –alluredir .&#x2F;report&#x2F;allure<br>allure serve .&#x2F;report&#x2F;allure</p>
</blockquote>
<p>报告展示内容<br><img src="/assets/2/image-20220516005120-jeswpew.png" alt="image.png"></p>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><p>pytest运行用例的时候可以加上allure标记用例的参数</p>
<pre><code class="sql">--allure-severities=SEVERITIES_SET
                        Comma-separated list of severity names. Tests only
                        with these severities will be run. Possible values
                        are: blocker, critical, normal, minor, trivial.
--allure-epics=EPICS_SET
                        Comma-separated list of epic names. Run tests that
                        have at least one of the specified feature labels.
--allure-features=FEATURES_SET
                        Comma-separated list of feature names. Run tests that
                        have at least one of the specified feature labels.
--allure-stories=STORIES_SET
                        Comma-separated list of story names. Run tests that
                        have at least one of the specified story labels.
--allure-link-pattern=LINK_TYPE:LINK_PATTERN
                        Url pattern for link type. Allows short links in test,
                        like &#39;issue-1&#39;. Text will be formatted to full url
                        with python str.format().
</code></pre>
<p>选择运行你要执行epic的用例</p>
<blockquote>
<p>pytest –alluredir .&#x2F;report&#x2F;allure –allure-epics&#x3D;epic对大Story的一个描述性标签</p>
</blockquote>
<p>选择运行你要执行features的用例</p>
<blockquote>
<p>pytest –alluredir .&#x2F;report&#x2F;allure –allure-features&#x3D;模块2</p>
</blockquote>
<p>选择运行你要执行stories的用例</p>
<blockquote>
<p>pytest –alluredir .&#x2F;report&#x2F;allure –allure-stories&#x3D;”用户故事：1”</p>
</blockquote>
<p>关于allure的使用基本上就是这些了</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档33-Hooks函数获取用例执行结果(pytest_runtest_makereport)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A333-Hooks%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C(pytest_runtest_makereport)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest提供的很多钩子(Hooks)方法方便我们对测试用例框架进行二次开发，可以根据自己的需求进行改造。<br>先学习下pytest_runtest_makereport这个钩子方法，可以更清晰的了解用例的执行过程，并获取到每个用例的执行结果。</p>
<h1 id="pytest-runtest-makereport"><a href="#pytest-runtest-makereport" class="headerlink" title="pytest_runtest_makereport"></a>pytest_runtest_makereport</h1><p>先看下相关的源码，在<code>_pytest/runner.py</code>下，可以导入之后，点进去查看</p>
<pre><code class="python">from _pytest import runner

# 对应源码
def pytest_runtest_makereport(item, call):
    &quot;&quot;&quot; return a :py:class:`_pytest.runner.TestReport` object
    for the given :py:class:`pytest.Item` and
    :py:class:`_pytest.runner.CallInfo`.
    &quot;&quot;&quot;
</code></pre>
<p>这里item是测试用例，call是测试步骤，具体执行过程如下：</p>
<ul>
<li>先执行when&#x3D;’setup’ 返回setup 的执行结果</li>
<li>然后执行when&#x3D;’call’ 返回call 的执行结果</li>
<li>最后执行when&#x3D;’teardown’返回teardown 的执行结果</li>
</ul>
<h1 id="运行案例"><a href="#运行案例" class="headerlink" title="运行案例"></a>运行案例</h1><p>conftest.py 写 pytest_runtest_makereport 内容，打印运行过程和运行结果</p>
<pre><code class="python"># conftest.py 
import pytest


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_makereport(item, call):
    print(&#39;------------------------------------&#39;)

    # 获取钩子方法的调用结果
    out = yield
    print(&#39;用例执行结果&#39;, out)

    # 3. 从钩子方法的调用结果中获取测试报告
    report = out.get_result()

    print(&#39;测试报告：%s&#39; % report)
    print(&#39;步骤：%s&#39; % report.when)
    print(&#39;nodeid：%s&#39; % report.nodeid)
    print(&#39;description:%s&#39; % str(item.function.__doc__))
    print((&#39;运行结果: %s&#39; % report.outcome))
</code></pre>
<p>test_a.py写一个简单的用例</p>
<pre><code class="python">def test_a():
    &#39;&#39;&#39;用例描述:test_a&#39;&#39;&#39;
    print(&quot;上海-悠悠&quot;)
</code></pre>
<p>运行结果如下</p>
<pre><code class="ruby">D:\soft\code\pytest_jenkins_demo\demo&gt;pytest -s
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\demo
plugins: html-1.19.0,
collected 1 item

test_a.py ------------------------------------
用例执行结果 &lt;pluggy.callers._Result object at 0x0000027C547332B0&gt;
测试报告：&lt;TestReport &#39;test_a.py::test_a&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;
步骤：setup
nodeid：test_a.py::test_a
description:用例描述:test_a
运行结果: passed
上海-悠悠
------------------------------------
用例执行结果 &lt;pluggy.callers._Result object at 0x0000027C547332B0&gt;
测试报告：&lt;TestReport &#39;test_a.py::test_a&#39; when=&#39;call&#39; outcome=&#39;passed&#39;&gt;
步骤：call
nodeid：test_a.py::test_a
description:用例描述:test_a
运行结果: passed
.------------------------------------
用例执行结果 &lt;pluggy.callers._Result object at 0x0000027C54750A20&gt;
测试报告：&lt;TestReport &#39;test_a.py::test_a&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;
步骤：teardown
nodeid：test_a.py::test_a
description:用例描述:test_a
运行结果: passed


========================== 1 passed in 0.06 seconds ===========================
</code></pre>
<p>从运行结果可以看出，运行用例的过程会经历三个阶段:setup-call-teardown,每个阶段都会返回的 Result 对象和 TestReport 对象，以及对象属性。<br>setup和teardown上面的用例默认都没有，结果都是passed。</p>
<h1 id="setup和teardown"><a href="#setup和teardown" class="headerlink" title="setup和teardown"></a>setup和teardown</h1><p>给用例写个fixture增加用例的前置和后置操作，conftest.py内容如下</p>
<pre><code class="python">import pytest


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_makereport(item, call):
    print(&#39;------------------------------------&#39;)

    # 获取钩子方法的调用结果
    out = yield
    print(&#39;用例执行结果&#39;, out)

    # 3. 从钩子方法的调用结果中获取测试报告
    report = out.get_result()

    print(&#39;测试报告：%s&#39; % report)
    print(&#39;步骤：%s&#39; % report.when)
    print(&#39;nodeid：%s&#39; % report.nodeid)
    print(&#39;description:%s&#39; % str(item.function.__doc__))
    print((&#39;运行结果: %s&#39; % report.outcome))

@pytest.fixture(scope=&quot;session&quot;, autouse=True)
def fix_a():
    print(&quot;setup 前置操作&quot;)
    yield 
    print(&quot;teardown 后置操作&quot;)
</code></pre>
<p>运行结果如下</p>
<p><img src="/assets/2/image-20220516005238-j90pcl3.png" alt="image.png"></p>
<h1 id="setup失败情况"><a href="#setup失败情况" class="headerlink" title="setup失败情况"></a>setup失败情况</h1><p>当setup执行失败了，setup的执行结果的failed,后面的call用例和teardown都不会执行了</p>
<p><img src="/assets/2/image-20220516005247-zordwtx.png" alt="image.png"></p>
<p>此时用例的状态是:error, 也就是用例(call)都还没开始执行，就异常了。</p>
<h1 id="call失败情况"><a href="#call失败情况" class="headerlink" title="call失败情况"></a>call失败情况</h1><p>如果setup正常执行，但是测试用例call失败了</p>
<pre><code class="python">@pytest.fixture(scope=&quot;session&quot;, autouse=True)
def fix_a():
    print(&quot;setup 前置操作&quot;)
    yield
    print(&quot;teardown 后置操作&quot;)
</code></pre>
<p>test_a.py用例</p>
<pre><code class="python">def test_a():
    &#39;&#39;&#39;用例描述:test_a&#39;&#39;&#39;
    print(&quot;上海-悠悠&quot;)
    assert 1==0
</code></pre>
<p><img src="/assets/2/image-20220516005255-0atsqoz.png" alt="image.png"></p>
<p>那么此时运行的结果就是failed</p>
<h1 id="teardown失败了"><a href="#teardown失败了" class="headerlink" title="teardown失败了"></a>teardown失败了</h1><p>如果setup正常执行，测试用例call正常执行，teardown失败了，这种情况</p>
<pre><code class="python">@pytest.fixture(scope=&quot;session&quot;, autouse=True)
def fix_a():
    print(&quot;setup 前置操作&quot;)
    yield
    print(&quot;teardown 后置操作&quot;)
    raise Exception(&quot;teardown 失败了&quot;)
</code></pre>
<p>teat_a.py用例</p>
<pre><code class="python">def test_a():
    &#39;&#39;&#39;用例描述:test_a&#39;&#39;&#39;
    print(&quot;上海-悠悠&quot;)
</code></pre>
<p><img src="/assets/2/image-20220516005303-b2wp2j0.png" alt="image.png"></p>
<p>最终统计的结果： 1 passed, 1 error in 0.16 seconds</p>
<p><img src="/assets/2/image-20220516005309-0a4eu6f.png" alt="image.png"></p>
<h1 id="只获取call的结果"><a href="#只获取call的结果" class="headerlink" title="只获取call的结果"></a>只获取call的结果</h1><p>我们在写用例的时候，如果保证setup和teardown不报错情况，只关注测试用例本身的运行结果，前面的 pytest_runtest_makereport 钩子方法执行了三次。<br>可以加个判断：if report.when &#x3D;&#x3D; “call”</p>
<pre><code class="python">import pytest
from _pytest import runner
&#39;&#39;&#39;
# 对应源码
def pytest_runtest_makereport(item, call):
    &quot;&quot;&quot; return a :py:class:`_pytest.runner.TestReport` object
    for the given :py:class:`pytest.Item` and
    :py:class:`_pytest.runner.CallInfo`.
    &quot;&quot;&quot;
&#39;&#39;&#39;

@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_makereport(item, call):
    print(&#39;------------------------------------&#39;)

    # 获取钩子方法的调用结果
    out = yield
    # print(&#39;用例执行结果&#39;, out)

    # 3. 从钩子方法的调用结果中获取测试报告
    report = out.get_result()
    if report.when == &quot;call&quot;:
        print(&#39;测试报告：%s&#39; % report)
        print(&#39;步骤：%s&#39; % report.when)
        print(&#39;nodeid：%s&#39; % report.nodeid)
        print(&#39;description:%s&#39; % str(item.function.__doc__))
        print((&#39;运行结果: %s&#39; % report.outcome))

@pytest.fixture(scope=&quot;session&quot;, autouse=True)
def fix_a():
    print(&quot;setup 前置操作&quot;)
    yield
    print(&quot;teardown 后置操作&quot;)
</code></pre>
<p>运行结果<br><img src="/assets/2/image-20220516005317-omjdgc5.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档34-Hooks函数改变用例执行顺序(pytest_collection_modifyitems)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A334-Hooks%E5%87%BD%E6%95%B0%E6%94%B9%E5%8F%98%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F(pytest_collection_modifyitems)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有一些小伙伴一直想改变pytest用例的执行顺序，实际上我们在用例设计原则上用例就不要有依赖顺序。<br>pytest默认执行用例是先根据项目下的文件夹名称按ascii码去收集的，module里面的用例是从上往下执行的.<br>pytest_collection_modifyitems 这个钩子函数顾名思义就是改变用例的执行顺序。</p>
<h1 id="pytest-collection-modifyitems"><a href="#pytest-collection-modifyitems" class="headerlink" title="pytest_collection_modifyitems"></a>pytest_collection_modifyitems</h1><p>pytest_collection_modifyitems 功能是当测试用例收集完成后，可以改变测试用例集合(items)的顺序</p>
<pre><code class="python">def pytest_collection_modifyitems(session, config,items):
    &#39;&#39;&#39;called after collection is completed. 
    you can modify the ``items`` list
    :param _pytest.main.Session session: the pytest session object
    :param _pytest.config.Config config: pytest config object
    :param List[_pytest.nodes.Item] items: list of item objects
    &#39;&#39;&#39;
</code></pre>
<p>items是用例对象的一个列表，改变items里面用例的顺序就可以改变用例的执行顺序了。</p>
<h1 id="pytest默认执行顺序"><a href="#pytest默认执行顺序" class="headerlink" title="pytest默认执行顺序"></a>pytest默认执行顺序</h1><p>先设计一个简单的 pytest 项目，有a和b两个包，分别在 test_a.py 和 test_b.py 写测试用例<br><img src="/assets/2/image-20220516005428-9qarxl8.png" alt="image.png"></p>
<p>conftest.py内容</p>
<pre><code class="python">import pytest
# 上海-悠悠

def pytest_collection_modifyitems(session, items):
    print(&quot;收集到的测试用例:%s&quot;%items)
</code></pre>
<p>test_a.py内容</p>
<pre><code class="python">def test_a_1():
    print(&quot;测试用例a_1&quot;)

def test_a_2():
    print(&quot;测试用例a_2&quot;)
</code></pre>
<p>test_b.py内容</p>
<pre><code class="python">def test_b_2():
    print(&quot;测试用例b_2&quot;)

def test_b_1():
    print(&quot;测试用例b_1&quot;)
</code></pre>
<p>运行完成后可以看到收集到的测试用例，会在测试用例开始执行执行</p>
<pre><code class="vbnet">D:\demo2&gt;pytest
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\soft\code\pytest_jenkins_demo\demo2
plugins: allure-pytest-2.8.6
collecting ... 收集到的测试用例:[&lt;Function test_a_1&gt;, &lt;Function test_a_2&gt;, &lt;Function test_b_2&gt;, &lt;Function test_b_1&gt;]
collected 4 items

a\test_aaa.py ..                                                         [ 50%]
b\test_bbb.py ..                                                         [100%]

========================== 4 passed in 0.06 seconds ===========================
</code></pre>
<p>从结果可以看出运行的时候先按模块名称ascii码去收集，单个py文件里面的用例按从上到下写的顺序收集。</p>
<h1 id="items用例排序"><a href="#items用例排序" class="headerlink" title="items用例排序"></a>items用例排序</h1><p>如果我想改变上面的用例执行顺序，以用例名称ascii码排序。先获取到用例的名称，以用例名称排序就可以了。</p>
<pre><code class="python"># 上海-悠悠
def pytest_collection_modifyitems(session, items):
    print(type(items))
    print(&quot;收集到的测试用例:%s&quot; % items)
    # sort排序，根据用例名称item.name 排序
    items.sort(key=lambda x: x.name)
    print(&quot;排序后的用例：%s&quot; % items)
    for item in items:
        print(&quot;用例名:%s&quot; % item.name)
</code></pre>
<p>重新执行后结果</p>
<pre><code class="vbnet">
D:\soft\code\pytest_jenkins_demo\demo2&gt;pytest -s
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\soft\code\pytest_jenkins_demo\demo2
plugins:
collecting ... &lt;class &#39;list&#39;&gt;
收集到的测试用例:[&lt;Function test_a_1&gt;, &lt;Function test_a_2&gt;, &lt;Function test_b_2&gt;, &lt;Function test_b_1&gt;]
排序后的用例：[&lt;Function test_a_1&gt;, &lt;Function test_a_2&gt;, &lt;Function test_b_1&gt;, &lt;Function test_b_2&gt;]
用例名:test_a_1
用例名:test_a_2
用例名:test_b_1
用例名:test_b_2
collected 4 items

a\test_aaa.py 测试用例a_1
.测试用例a_2
.
b\test_bbb.py 测试用例b_1
.测试用例b_2
.

========================== 4 passed in 0.06 seconds ===========================
</code></pre>
<p>重新排序后就可以按用例的名称顺序执行了。</p>
<p>有个 pytest-ordering 插件也可以自定义用例的顺序<a href="https://github.com/ftobia/pytest-ordering">https://github.com/ftobia/pytest-ordering</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档35-Hooks函数之统计测试结果(pytest_terminal_summary)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A335-Hooks%E5%87%BD%E6%95%B0%E4%B9%8B%E7%BB%9F%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C(pytest_terminal_summary)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用例执行完成后，我们希望能获取到执行的结果，这样方便我们快速统计用例的执行情况。<br>也可以把获取到的结果当成总结报告，发邮件的时候可以先统计测试结果，再加上html的报告。</p>
<h1 id="pytest-terminal-summary"><a href="#pytest-terminal-summary" class="headerlink" title="pytest_terminal_summary"></a>pytest_terminal_summary</h1><p>关于TerminalReporter类可以在_pytest.terminal中查看到</p>
<pre><code class="scss">from _pytest import terminal

pytest_terminal_summary(terminalreporter, exitstatus, config)
最后的结果汇总,可以拿到所有的执行结果
参数：
- terminalreporter (_pytest.terminal.TerminalReporter) – 内部使用的终端测试报告对象
- exitstatus (int) – 返回给操作系统的返回码
- config(_pytest.config.Config) - pytest config对象
</code></pre>
<p>TerminalReporter部分代码</p>
<pre><code class="python">class TerminalReporter(object):
    def __init__(self, config, file=None):
        import _pytest.config

        self.config = config
        self._numcollected = 0
        self._session = None
        self._showfspath = None

        self.stats = &#123;&#125;
        self.startdir = config.invocation_dir


    def report_collect(self, final=False):
        if self.config.option.verbose &lt; 0:
            return

        if not final:
            # Only write &quot;collecting&quot; report every 0.5s.
            t = time.time()
            if (
                self._collect_report_last_write is not None
                and self._collect_report_last_write &gt; t - REPORT_COLLECTING_RESOLUTION
            ):
                return
            self._collect_report_last_write = t

        errors = len(self.stats.get(&quot;error&quot;, []))
        skipped = len(self.stats.get(&quot;skipped&quot;, []))
        deselected = len(self.stats.get(&quot;deselected&quot;, []))
        selected = self._numcollected - errors - skipped - deselected
        if final:
            line = &quot;collected &quot;
        else:
            line = &quot;collecting &quot;
        line += (
            str(self._numcollected) + &quot; item&quot; + (&quot;&quot; if self._numcollected == 1 else &quot;s&quot;)
        )
        if errors:
            line += &quot; / %d errors&quot; % errors
        if deselected:
            line += &quot; / %d deselected&quot; % deselected
        if skipped:
            line += &quot; / %d skipped&quot; % skipped
        if self._numcollected &gt; selected &gt; 0:
            line += &quot; / %d selected&quot; % selected
        if self.isatty:
            self.rewrite(line, bold=True, erase=True)
            if final:
                self.write(&quot;\n&quot;)
        else:
            self.write_line(line)
</code></pre>
<h1 id="案例参考"><a href="#案例参考" class="headerlink" title="案例参考"></a>案例参考</h1><p>先在test_a.py写几个用例</p>
<pre><code class="python"># test_a.py
import pytest
# 上海-悠悠

def test_1():
    print(&quot;测试用例1111&quot;)
    assert 1 == 1


@pytest.mark.skip(&quot;跳过&quot;)
def test_2():
    print(&quot;测试用例22222&quot;)
    assert 1 == 1


def test_3():
    print(&quot;测试用例3333&quot;)


def test_4():
    print(&quot;测试用例44444444&quot;)
    assert 1 == 2
</code></pre>
<p>test_b.py用例参考</p>
<pre><code class="python"># test_b.py
import time
# 上海-悠悠

def test_5():
    print(&quot;测试用例55555555&quot;)
    time.sleep(3)


def test_6():
    print(&quot;测试用例66666666&quot;)
    time.sleep(3)
    assert 1 == 2
</code></pre>
<p>于是在conftest.py中写个 pytest_terminal_summary 函数收集测试结果</p>
<pre><code class="python">import time
from _pytest import terminal
# 上海-悠悠


def pytest_terminal_summary(terminalreporter, exitstatus, config):
    &#39;&#39;&#39;收集测试结果&#39;&#39;&#39;
    print(terminalreporter.stats)
    print(&quot;total:&quot;, terminalreporter._numcollected)
    print(&#39;passed:&#39;, len(terminalreporter.stats.get(&#39;passed&#39;, [])))
    print(&#39;failed:&#39;, len(terminalreporter.stats.get(&#39;failed&#39;, [])))
    print(&#39;error:&#39;, len(terminalreporter.stats.get(&#39;error&#39;, [])))
    print(&#39;skipped:&#39;, len(terminalreporter.stats.get(&#39;skipped&#39;, [])))
    # terminalreporter._sessionstarttime 会话开始时间
    duration = time.time() - terminalreporter._sessionstarttime
    print(&#39;total times:&#39;, duration, &#39;seconds&#39;)
</code></pre>
<p>运行结果</p>
<pre><code class="rust">D:\soft\pytest_xuexi_demo&gt;pytest
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\soft\pytest_xuexi_demo
plugins: allure-pytest-2.8.6, PyTestReport-0.1.9.3, forked-0.2, html-1.19.0, metadata-1.7.0, repeat-0.7.0, rerunfailures-8.0, xdist-1.23.2
collected 6 items

test_a.py .s.F                                                           [ 66%]
test_b.py .F                                                             [100%]

================================== FAILURES ===================================
___________________________________ test_4 ____________________________________

    def test_4():
        print(&quot;测试用例44444444&quot;)
&gt;       assert 1==2
E       assert 1 == 2

test_a.py:21: AssertionError
---------------------------- Captured stdout call -----------------------------
测试用例44444444
___________________________________ test_6 ____________________________________

    def test_6():
        print(&quot;测试用例66666666&quot;)
        time.sleep(3)
&gt;       assert 1 == 2
E       assert 1 == 2

test_b.py:18: AssertionError
---------------------------- Captured stdout call -----------------------------
测试用例66666666
&#123;&#39;&#39;: [&lt;TestReport &#39;test_a.py::test_1&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_1&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_2&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_3&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_3&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_4&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_4&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_5&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_5&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_6&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_6&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;], &#39;passed&#39;: [&lt;TestReport &#39;test_a.py::test_1&#39; when=&#39;call&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_3&#39; when=&#39;call&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_5&#39; when=&#39;call&#39; outcome=&#39;passed&#39;&gt;], &#39;skipped&#39;: [&lt;TestReport &#39;test_a.py::test_2&#39; when=&#39;setup&#39; outcome=&#39;skipped&#39;&gt;], &#39;failed&#39;: [&lt;TestReport &#39;test_a.py::test_4&#39; when=&#39;call&#39; outcome=&#39;failed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_6&#39; when=&#39;call&#39; outcome=&#39;failed&#39;&gt;]&#125;
total: 6
passed: 3
failed: 2
error: 0
skipped: 1
total times: 6.150860786437988 seconds
================ 2 failed, 3 passed, 1 skipped in 6.15 seconds ================
</code></pre>
<h1 id="setup和teardown异常情况"><a href="#setup和teardown异常情况" class="headerlink" title="setup和teardown异常情况"></a>setup和teardown异常情况</h1><p>如果setup出现异常，test_b.py代码修改下</p>
<pre><code class="python"># test_b.py
import time
import pytest
# 上海-悠悠


@pytest.fixture(scope=&quot;function&quot;)
def setup_demo():
    raise TypeError(&quot;ERROR!&quot;)


def test_5(setup_demo):
    print(&quot;测试用例55555555&quot;)
    time.sleep(3)


def test_6():
    print(&quot;测试用例66666666&quot;)
    time.sleep(3)
    assert 1 == 2
</code></pre>
<p>重新运行用例,结果如下</p>
<pre><code class="vbnet">total: 6
passed: 2
failed: 2
error: 1
skipped: 1
成功率：33.33%
total times: 3.1817877292633057 seconds
=========== 2 failed, 2 passed, 1 skipped, 1 error in 3.18 seconds ============
</code></pre>
<p>此时统计结果没什么问题，接下来看teardown异常情况</p>
<pre><code class="python"># test_b.py
import time
import pytest
# 上海-悠悠


@pytest.fixture(scope=&quot;function&quot;)
def setup_demo():
    yield 
    raise TypeError(&quot;ERROR!&quot;)


def test_5(setup_demo):
    print(&quot;测试用例55555555&quot;)
    time.sleep(3)


def test_6():
    print(&quot;测试用例66666666&quot;)
    time.sleep(3)
    assert 1 == 2
</code></pre>
<p>运行结果</p>
<pre><code class="rust">&#123;&#39;&#39;: [&lt;TestReport &#39;test_a.py::test_1&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_1&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_2&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_3&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_3&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_4&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_4&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_5&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_6&#39; when=&#39;setup&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_6&#39; when=&#39;teardown&#39; outcome=&#39;passed&#39;&gt;], &#39;passed&#39;: [&lt;TestReport &#39;test_a.py::test_1&#39; when=&#39;call&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_a.py::test_3&#39; when=&#39;call&#39; outcome=&#39;passed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_5&#39; when=&#39;call&#39; outcome=&#39;passed&#39;&gt;], &#39;skipped&#39;: [&lt;TestReport &#39;test_a.py::test_2&#39; when=&#39;setup&#39; outcome=&#39;skipped&#39;&gt;], &#39;failed&#39;: [&lt;TestReport &#39;test_a.py::test_4&#39; when=&#39;call&#39; outcome=&#39;failed&#39;&gt;, &lt;TestReport &#39;test_b.py::test_6&#39; when=&#39;call&#39; outcome=&#39;failed&#39;&gt;], &#39;error&#39;: [&lt;TestReport &#39;test_b.py::test_5&#39; when=&#39;teardown&#39; outcome=&#39;failed&#39;&gt;]&#125;
total: 6
passed: 3
failed: 2
error: 1
skipped: 1
成功率：50.00%
total times: 6.18759298324585 seconds
=========== 2 failed, 3 passed, 1 skipped, 1 error in 6.19 seconds ============
</code></pre>
<p>这个时候总用例是6，但是<code>2 failed, 3 passed, 1 skipped, 1 error</code>加起来的个数是7，这个为什么？</p>
<p>从 terminalreporter.stats 可以看出 passed 里面 when&#x3D;’call’ 时候统计了一次 test_5 用例</p>
<pre><code class="csharp">&lt;TestReport &#39;test_b.py::test_5&#39; when=&#39;call&#39; outcome=&#39;passed&#39;&gt;
</code></pre>
<p>error 里面 when&#x3D;’teardown’ 又统计了一次 test_5 用例</p>
<pre><code class="csharp">&#39;error&#39;: [&lt;TestReport &#39;test_b.py::test_5&#39; when=&#39;teardown&#39; outcome=&#39;failed&#39;&gt;]
</code></pre>
<p>when&#x3D;’teardown’ 是测试用例的后置操作，一般用于数据的清理，报错了的话不影响测试用例的执行结果，所以可以忽略掉</p>
<p>修改后的最终代码如下</p>
<pre><code class="python">import time
from _pytest import terminal
# 上海-悠悠


def pytest_terminal_summary(terminalreporter, exitstatus, config):
    &#39;&#39;&#39;收集测试结果&#39;&#39;&#39;
    # print(terminalreporter.stats)
    print(&quot;total:&quot;, terminalreporter._numcollected)
    print(&#39;passed:&#39;, len([i for i in terminalreporter.stats.get(&#39;passed&#39;, []) if i.when != &#39;teardown&#39;]))
    print(&#39;failed:&#39;, len([i for i in terminalreporter.stats.get(&#39;failed&#39;, []) if i.when != &#39;teardown&#39;]))
    print(&#39;error:&#39;, len([i for i in terminalreporter.stats.get(&#39;error&#39;, []) if i.when != &#39;teardown&#39;]))
    print(&#39;skipped:&#39;, len([i for i in terminalreporter.stats.get(&#39;skipped&#39;, []) if i.when != &#39;teardown&#39;]))
    print(&#39;成功率：%.2f&#39; % (len(terminalreporter.stats.get(&#39;passed&#39;, []))/terminalreporter._numcollected*100)+&#39;%&#39;)

    # terminalreporter._sessionstarttime 会话开始时间
    duration = time.time() - terminalreporter._sessionstarttime
    print(&#39;total times:&#39;, duration, &#39;seconds&#39;)
</code></pre>
<p>运行后的结果</p>
<pre><code class="vbnet">total: 6
passed: 3
failed: 2
error: 0
skipped: 1
成功率：50.00%
total times: 6.20133113861084 seconds
=========== 2 failed, 3 passed, 1 skipped, 1 error in 6.20 seconds ============
</code></pre>
<h1 id="拿到测试结果"><a href="#拿到测试结果" class="headerlink" title="拿到测试结果"></a>拿到测试结果</h1><p>很多小伙伴问到如何拿到测试结果，这里我把测试结果保存为txt文件，你们也可以保存json文件</p>
<pre><code class="python">import time
from _pytest import terminal
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


def pytest_terminal_summary(terminalreporter, exitstatus, config):
    &#39;&#39;&#39;收集测试结果&#39;&#39;&#39;
    # print(terminalreporter.stats)
    total = terminalreporter._numcollected
    passed= len([i for i in terminalreporter.stats.get(&#39;passed&#39;, []) if i.when != &#39;teardown&#39;])
    failed=len([i for i in terminalreporter.stats.get(&#39;failed&#39;, []) if i.when != &#39;teardown&#39;])
    error=len([i for i in terminalreporter.stats.get(&#39;error&#39;, []) if i.when != &#39;teardown&#39;])
    skipped=len([i for i in terminalreporter.stats.get(&#39;skipped&#39;, []) if i.when != &#39;teardown&#39;])
    successful = len(terminalreporter.stats.get(&#39;passed&#39;, []))/terminalreporter._numcollected*100
    # terminalreporter._sessionstarttime 会话开始时间
    duration = time.time() - terminalreporter._sessionstarttime
    print(&#39;total times: %.2f&#39; % duration, &#39;seconds&#39;)

    with open(&quot;result.txt&quot;, &quot;w&quot;) as fp:
        fp.write(&quot;TOTAL=%s&quot; % total+&quot;\n&quot;)
        fp.write(&quot;PASSED=%s&quot; % passed+&quot;\n&quot;)
        fp.write(&quot;FAILED=%s&quot; % failed+&quot;\n&quot;)
        fp.write(&quot;ERROR=%s&quot; % error+&quot;\n&quot;)
        fp.write(&quot;SKIPPED=%s&quot; % skipped+&quot;\n&quot;)
        fp.write(&quot;SUCCESSFUL=%.2f%%&quot; % successful+&quot;\n&quot;)
        fp.write(&quot;TOTAL_TIMES=%.2fs&quot; % duration)
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档36-断言失败后还能继续执行pytest-assume</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A336-%E6%96%AD%E8%A8%80%E5%A4%B1%E8%B4%A5%E5%90%8E%E8%BF%98%E8%83%BD%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8Cpytest-assume/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest的断言失败后，后面的代码就不会执行了，通常一个用例我们会写多个断言，有时候我们希望第一个断言失败后，后面能继续断言。<br>pytest-assume插件可以解决断言失败后继续断言的问题。github地址<a href="https://github.com/astraw38/pytest-assume">https://github.com/astraw38/pytest-assume</a></p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>先安装pytest-assume依赖包</p>
<blockquote>
<p>pip install pytest-assume</p>
</blockquote>
<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>以下是一个简单案例，输入的测试数据有3种，我们需要断言同时满足三种情况</p>
<ul>
<li>x &#x3D;&#x3D; y</li>
<li>x+y &gt; 1</li>
<li>x &gt; 1</li>
</ul>
<pre><code class="python">import pytest
# 上海-悠悠

@pytest.mark.parametrize((&#39;x&#39;, &#39;y&#39;),
                         [(1, 1), (1, 0), (0, 1)])
def test_simple_assume(x, y):
    print(&quot;测试数据x=%s, y=%s&quot; % (x, y))
    assert x == y
    assert x+y &gt; 1
    assert x &gt; 1
</code></pre>
<p>运行结果</p>
<pre><code class="python">D:\demo\test_yoyo.py:9: AssertionError


================================== FAILURES ===================================
___________________________ test_simple_assume[1-1] ___________________________

x = 1, y = 1

    @pytest.mark.parametrize((&#39;x&#39;, &#39;y&#39;),
                             [(1, 1), (1, 0), (0, 1)])
    def test_simple_assume(x, y):
        print(&quot;测试数据x=%s, y=%s&quot; % (x, y))
        assert x == y
        assert x+y &gt; 1
&gt;       assert x &gt; 1
E       assert 1 &gt; 1

D:\soft\code\pytest_api_2020_03\demo\test_yoyo.py:11: AssertionError
___________________________ test_simple_assume[1-0] ___________________________

x = 1, y = 0

    @pytest.mark.parametrize((&#39;x&#39;, &#39;y&#39;),
                             [(1, 1), (1, 0), (0, 1)])
    def test_simple_assume(x, y):
        print(&quot;测试数据x=%s, y=%s&quot; % (x, y))
&gt;       assert x == y
E       assert 1 == 0

D:\soft\code\pytest_api_2020_03\demo\test_yoyo.py:9: AssertionError
___________________________ test_simple_assume[0-1] ___________________________

x = 0, y = 1

    @pytest.mark.parametrize((&#39;x&#39;, &#39;y&#39;),
                             [(1, 1), (1, 0), (0, 1)])
    def test_simple_assume(x, y):
        print(&quot;测试数据x=%s, y=%s&quot; % (x, y))
&gt;       assert x == y
E       assert 0 == 1

D:\demo\test_yoyo.py:9: AssertionError
========================== 3 failed in 0.26 seconds ===========================
</code></pre>
<p>如果第一个断言就失败了，后面的2个断言都不会执行了</p>
<h1 id="pytest-assume使用案例"><a href="#pytest-assume使用案例" class="headerlink" title="pytest-assume使用案例"></a>pytest-assume使用案例</h1><p>使用pytest.assume断言</p>
<pre><code class="python">import pytest
# 上海-悠悠

@pytest.mark.parametrize((&#39;x&#39;, &#39;y&#39;),
                         [(1, 1), (1, 0), (0, 1)])
def test_simple_assume(x, y):
    print(&quot;测试数据x=%s, y=%s&quot; % (x, y))
    pytest.assume(x == y)
    pytest.assume(x+y &gt; 1)
    pytest.assume(x &gt; 1)
    print(&quot;测试完成！&quot;)
</code></pre>
<p>运行结果</p>
<pre><code class="markdown">================================== FAILURES ===================================
___________________________ test_simple_assume[1-1] ___________________________

tp = &lt;class &#39;pytest_assume.plugin.FailedAssumption&#39;&gt;
value = FailedAssumption(&#39;\demo\\test_yoyo.py:11: AssumptionFailure\n&gt;&gt;\tpytest.assume(x &gt; 1)\n
AssertionError: assert False\n\n&#39;,)
tb = &lt;traceback object at 0x00000216CA579B08&gt;

    def reraise(tp, value, tb=None):
        if value is None:
            value = tp()
        if value.__traceback__ is not tb:
&gt;           raise value.with_traceback(tb)
E           pytest_assume.plugin.FailedAssumption: 
E           1 Failed Assumptions:
E         
E           ..\..\..\..\..\soft\code\pytest_api_2020_03\demo\test_yoyo.py:11: AssumptionFailure
E           &gt;&gt;	pytest.assume(x &gt; 1)
E           AssertionError: assert False

E:\python36\lib\site-packages\six.py:685: FailedAssumption
___________________________ test_simple_assume[1-0] ___________________________

tp = &lt;class &#39;pytest_assume.plugin.FailedAssumption&#39;&gt;
value = FailedAssumption(&#39;\demo\\test_yoyo.py:9:...st_api_2020_03\\demo\\test_yoyo.py:11: 
AssumptionFailure\n&gt;&gt;\tpytest.assume(x &gt; 1)\nAssertionError: assert False\n\n&#39;,)
tb = &lt;traceback object at 0x00000216CA579448&gt;

    def reraise(tp, value, tb=None):
        if value is None:
            value = tp()
        if value.__traceback__ is not tb:
&gt;           raise value.with_traceback(tb)
E           pytest_assume.plugin.FailedAssumption: 
E           3 Failed Assumptions:
E         
E           ..\..\..\..\..\soft\code\pytest_api_2020_03\demo\test_yoyo.py:9: AssumptionFailure
E           &gt;&gt;	pytest.assume(x == y)
E           AssertionError: assert False
E         
E           ..\..\..\..\..\soft\code\pytest_api_2020_03\demo\test_yoyo.py:10: AssumptionFailure
E           &gt;&gt;	pytest.assume(x+y &gt; 1)
E           AssertionError: assert False
E         
E           ..\..\..\..\..\soft\code\pytest_api_2020_03\demo\test_yoyo.py:11: AssumptionFailure
E           &gt;&gt;	pytest.assume(x &gt; 1)
E           AssertionError: assert False

E:\python36\lib\site-packages\six.py:685: FailedAssumption
___________________________ test_simple_assume[0-1] ___________________________

tp = &lt;class &#39;pytest_assume.plugin.FailedAssumption&#39;&gt;
value = FailedAssumption(&#39;\n3 Failed Assumptions:\demo\\test_yoyo.py:11:
 AssumptionFailure\n&gt;&gt;\tpytest.assume(x &gt; 1)\nAssertionError: assert False\n\n&#39;,)
tb = &lt;traceback object at 0x00000216CA74D2C8&gt;

    def reraise(tp, value, tb=None):
        if value is None:
            value = tp()
        if value.__traceback__ is not tb:
&gt;           raise value.with_traceback(tb)
E           pytest_assume.plugin.FailedAssumption: 
E           3 Failed Assumptions:
E         
E           ..\..\..\..\..\soft\code\pytest_api_2020_03\demo\test_yoyo.py:9: AssumptionFailure
E           &gt;&gt;	pytest.assume(x == y)
E           AssertionError: assert False
E         
E           ..\..\..\..\..\soft\code\pytest_api_2020_03\demo\test_yoyo.py:10: AssumptionFailure
E           &gt;&gt;	pytest.assume(x+y &gt; 1)
E           AssertionError: assert False
E         
E           ..\..\..\..\..\soft\code\pytest_api_2020_03\demo\test_yoyo.py:11: AssumptionFailure
E           &gt;&gt;	pytest.assume(x &gt; 1)
E           AssertionError: assert False

E:\python36\lib\site-packages\six.py:685: FailedAssumption
========================== 3 failed in 0.44 seconds ===========================
</code></pre>
<p>从运行结果可以看出，三个断言都会执行</p>
<h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><p>pytest.assume 也可以使用上下文管理器去断言</p>
<pre><code class="python">import pytest
from pytest import assume
# 上海-悠悠

@pytest.mark.parametrize((&#39;x&#39;, &#39;y&#39;),
                         [(1, 1), (1, 0), (0, 1)])
def test_simple_assume(x, y):
    print(&quot;测试数据x=%s, y=%s&quot; % (x, y))
    with assume: assert x == y
    with assume: assert x+y &gt; 1
    with assume: assert x &gt; 1
    print(&quot;测试完成！&quot;)
</code></pre>
<p>这样看起来会更优雅一点，对之前写的代码改起来也方便一些</p>
<p>需要注意的是每个with块只能有一个断言，如果一个with下有多个断言，当第一个断言失败的时候，后面的断言就不会起作用的.</p>
<pre><code class="python">import pytest
from pytest import assume
# 以下这种是错误的示例，不要一个with下写多个断言
# 上海-悠悠


@pytest.mark.parametrize((&#39;x&#39;, &#39;y&#39;),
                         [(1, 1), (1, 0), (0, 1)])
def test_simple_assume(x, y):
    print(&quot;测试数据x=%s, y=%s&quot; % (x, y))
    with assume:
        assert x == y
        assert x+y &gt; 1
        assert x &gt; 1
    print(&quot;测试完成！&quot;)
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档37-自定义用例顺序(pytest-ordering)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A337-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E4%BE%8B%E9%A1%BA%E5%BA%8F(pytest-ordering)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>测试用例在设计的时候，我们一般要求不要有先后顺序，用例是可以打乱了执行的，这样才能达到测试的效果.<br>有些同学在写用例的时候，用例写了先后顺序， 有先后顺序后，后面还会有新的问题（如：上个用例返回数据作为下个用例传参，等等一系列的问题。。。）<br>github 上有个 pytest-ordering 插件可以控制用例的执行顺序，github插件地址<a href="https://github.com/ftobia/pytest-ordering">https://github.com/ftobia/pytest-ordering</a></p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>先安装依赖包</p>
<blockquote>
<p>pip install pytest-ordering</p>
</blockquote>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>先看pytest默认的执行顺序，是按 test_ording.py 文件写的用例先后顺序执行的</p>
<pre><code class="python"># test_ording.py
import pytest
# 上海-悠悠


def test_foo():
    print(&quot;用例11111111111&quot;)
    assert True


def test_bar():
    print(&quot;用例22222222222&quot;)
    assert True


def test_g():
    print(&quot;用例333333333333333&quot;)
    assert True
</code></pre>
<p>运行结果</p>
<pre><code class="makefile">D:\demo&gt;pytest test_ording.py -vs
============================= test session starts =============================
platform win32 -- Python 3.6.0
cachedir: .pytest_cache
metadata: 
plugins: ordering-0.6,
collected 3 items

test_ording.py::test_foo 用例11111111111
PASSED
test_ording.py::test_bar 用例22222222222
PASSED
test_ording.py::test_g 用例333333333333333
PASSED

========================== 3 passed in 0.07 seconds ===========================
</code></pre>
<p>使用 pytest-ordering 插件后改变测试用例顺序</p>
<pre><code class="python"># test_ording.py
import pytest
# 上海-悠悠


@pytest.mark.run(order=2)
def test_foo():
    print(&quot;用例11111111111&quot;)
    assert True


@pytest.mark.run(order=1)
def test_bar():
    print(&quot;用例22222222222&quot;)
    assert True


@pytest.mark.run(order=3)
def test_g():
    print(&quot;用例333333333333333&quot;)
    assert True
</code></pre>
<p>运行结果</p>
<pre><code class="makefile">D:\demo&gt;pytest test_ording.py -vs
============================= test session starts =============================
platform win32 -- Python 3.6.0
cachedir: .pytest_cache
metadata: 
plugins: ordering-0.6,
collected 3 items

test_ording.py::test_bar 用例22222222222
PASSED
test_ording.py::test_foo 用例11111111111
PASSED
test_ording.py::test_g 用例333333333333333
PASSED

========================== 3 passed in 0.04 seconds ===========================
</code></pre>
<p>这样就是按指定的顺序执行的用例</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档38-allure.step()添加测试用例步骤</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A338-allure.step()%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一般流程性的测试用例，写成自动化用例时，步骤较多写起来会比较长。在测试用例里面添加详细的步骤有助于更好的阅读，也方便报错后快速的定位到问题。<br>举个常见的测试场景用例：从登陆开始，到浏览商品添加购物车，最后下单支付<br>用例步骤：1.登陆， 2.浏览商品 3.添加购物车 4.生成订单 5.支付成功</p>
<h1 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h1><p>先把上面的每个环节，写成函数放到common_fucntion.py</p>
<pre><code class="python"># common_fucntion.py
import allure
import pytest
&#39;&#39;&#39;
流程性的用例，添加测试步骤，让用例更清晰
用例步骤：1.登陆， 2.浏览商品 3.添加购物车  4.生成订单  5.支付成功
作者：上海-悠悠 QQ交流群：779429633
&#39;&#39;&#39;

def login(username, password):
    &#39;&#39;&#39;登陆&#39;&#39;&#39;
    print(&quot;前置操作：先登陆&quot;)


def open_goods():
    &#39;&#39;&#39;浏览商品&#39;&#39;&#39;
    print(&quot;浏览商品&quot;)


def add_shopping_cart(goods_id=&quot;10086&quot;):
    &#39;&#39;&#39;添加购物车&#39;&#39;&#39;
    print(&quot;添加购物车&quot;)


def buy_goods():
    &#39;&#39;&#39;生成订单&#39;&#39;&#39;
    print(&quot;buy&quot;)


def pay_goods():
    &#39;&#39;&#39;支付&#39;&#39;&#39;
    print(&quot;pay&quot;)
  
</code></pre>
<p>接下来测试用例设计，登陆可以单独拿出来，当成前置操作，后面的步骤合起来就是一个用例test_allure_step.py</p>
<pre><code class="python"># test_allure_step.py
import allure
import pytest
from .common_function import *

&#39;&#39;&#39;
流程性的用例，添加测试步骤，让用例更清晰
用例步骤：1.登陆， 2.浏览商品 3.添加购物车  4.生成订单  5.支付成功
作者：上海-悠悠 QQ交流群：779429633
&#39;&#39;&#39;

@pytest.fixture(scope=&quot;session&quot;)
def login_setup():
    login(&quot;yoyo&quot;, &quot;123456&quot;)


@allure.feature(&quot;功能模块&quot;)
@allure.story(&quot;测试用例小模块-成功案例&quot;)
@allure.title(&quot;测试用例名称：流程性的用例，添加测试步骤&quot;)
def test_add_goods_and_buy(login_setup):
    &#39;&#39;&#39;
    用例描述：
    前置：登陆
    用例步骤：1.浏览商品 2.添加购物车  3.购买  4.支付成功
    &#39;&#39;&#39;
    with allure.step(&quot;step1：浏览商品&quot;):
        open_goods()

    with allure.step(&quot;step2：添加购物车&quot;):
        add_shopping_cart()

    with allure.step(&quot;step3：生成订单&quot;):
        buy_goods()

    with allure.step(&quot;step4：支付&quot;):
        pay_goods()

    with allure.step(&quot;断言&quot;):
        assert 1 == 1
</code></pre>
<p>执行用例，生成allure报告</p>
<pre><code class="shell">&gt; pytest --alluredir ./allure_report test_allure_step.py
&gt; allure serve ./allure_report
</code></pre>
<p>报告展示效果如下</p>
<p><img src="/assets/2/image-20220516014937-e803vbq.png" alt="image.png"></p>
<h1 id="测试步骤-allure-step"><a href="#测试步骤-allure-step" class="headerlink" title="测试步骤@allure.step()"></a>测试步骤@allure.step()</h1><p>测试步骤也可以在 common_fucntion.py 里面定义的函数上加上装饰器实现：@allure.step()</p>
<pre><code class="python">import allure
import pytest
&#39;&#39;&#39;
流程性的用例，添加测试步骤，让用例更清晰
用例步骤：1.登陆， 2.浏览商品 3.添加购物车  4.生成订单  5.支付成功
&#39;&#39;&#39;


@allure.step(&quot;setup:登陆&quot;)
def login(username, password):
    &#39;&#39;&#39;登陆&#39;&#39;&#39;
    print(&quot;前置操作：先登陆&quot;)


@allure.step(&quot;step:浏览商品&quot;)
def open_goods():
    &#39;&#39;&#39;浏览商品&#39;&#39;&#39;
    print(&quot;浏览商品&quot;)


@allure.step(&quot;step:添加购物车&quot;)
def add_shopping_cart(goods_id=&quot;10086&quot;):
    &#39;&#39;&#39;添加购物车&#39;&#39;&#39;
    print(&quot;添加购物车&quot;)


@allure.step(&quot;step:生成订单&quot;)
def buy_goods():
    &#39;&#39;&#39;生成订单&#39;&#39;&#39;
    print(&quot;buy&quot;)


@allure.step(&quot;step:支付&quot;)
def pay_goods():
    &#39;&#39;&#39;支付&#39;&#39;&#39;
    print(&quot;pay&quot;)
</code></pre>
<p>测试用例设计 test_allure_step_x.py</p>
<pre><code class="python">import allure
import pytest
from .common_function import *
# 作者：上海-悠悠 QQ交流群：779429633

@pytest.fixture(scope=&quot;session&quot;)
def login_setup():
    login(&quot;yoyo&quot;, &quot;123456&quot;)


@allure.feature(&quot;功能模块&quot;)
@allure.story(&quot;测试用例小模块-成功案例&quot;)
@allure.title(&quot;第二种实现方式：流程性的用例，添加测试步骤&quot;)
def test_add_goods_and_buy_2(login_setup):
    &#39;&#39;&#39;
    用例描述：
    前置：登陆
    用例步骤：1.浏览商品 2.添加购物车  3.购买  4.支付成功
    &#39;&#39;&#39;
    open_goods()
    add_shopping_cart(goods_id=&quot;10086&quot;)
    buy_goods()
    pay_goods()
    assert 1 == 1

</code></pre>
<p>执行用例，生成allure报告</p>
<pre><code class="shell">&gt; pytest --alluredir ./allure_report test_allure_step_x.py
&gt; allure serve ./allure_report
</code></pre>
<p>报告展示效果如下</p>
<p><img src="/assets/2/image-20220516014947-0tm5kff.png" alt="image.png"></p>
<h1 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a>两种方式对比</h1><p>使用 <code>with allure.step(&quot;step:步骤&quot;)</code> 这种方式代码可读性更好一点，但不会带上函数里面的传参和对应的值。<br>使用 <code>@allure.step(&quot;step:步骤&quot;)</code> 这种方式会带上函数的传参和对应的值。<br>这两种方式结合起来使用，才能更好的展示测试报告！</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档39-参数化(parametrize)结合allure.title()生成不同标题报告</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A339-%E5%8F%82%E6%95%B0%E5%8C%96(parametrize)%E7%BB%93%E5%90%88allure.title()%E7%94%9F%E6%88%90%E4%B8%8D%E5%90%8C%E6%A0%87%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest的参数化(parametrize)可以实现只需维护测试数据，就能生成不同的测试用例目的。可以在参数化的时候加 ids 参数对每个用例说明使用场景。<br>最终我们希望在 allure 报告上能详细的展示出每个用例的标题描述，这样才能更直观的知道每个用例是干什么的。</p>
<h1 id="参数化parametrize"><a href="#参数化parametrize" class="headerlink" title="参数化parametrize"></a>参数化parametrize</h1><p>先看一个简单的pytest参数化案例演示test_a.py</p>
<pre><code class="python"># test_a.py
import pytest
import allure
# 作者：上海-悠悠 QQ交流群：779429633


def login(username, password):
    &#39;&#39;&#39;登录&#39;&#39;&#39;
    print(&quot;输入账号：%s&quot; % username)
    print(&quot;输入密码：%s&quot; % password)
    # 返回
    return &#123;&quot;code&quot;: 0, &quot;msg&quot;: &quot;success!&quot;&#125;


# 测试数据
test_datas = [
    (&#123;&quot;username&quot;: &quot;yoyo1&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo2&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;failed!&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo3&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;),
]


@allure.story(&quot;登录用例&quot;)
@pytest.mark.parametrize(&quot;test_input,expected&quot;,
                         test_datas
                         )
def test_login(test_input, expected):
    &#39;&#39;&#39;测试登录用例&#39;&#39;&#39;
    # 获取函数返回结果
    result = login(test_input[&quot;username&quot;], test_input[&quot;password&quot;])
    # 断言
    assert result[&quot;msg&quot;] == expected
</code></pre>
<p>cmd命令行运行用例</p>
<pre><code class="shell">&gt; pytest --alluredir ./report test_a.py
&gt; allure serve ./report
</code></pre>
<p>生成报告</p>
<p><img src="/assets/2/image-20220516014806-kq01pk5.png" alt="image.png"></p>
<p>这样生成的报告在用例列表里面并不能很友好的展示出每个用例的执行场景，只知道哪个用例报错了。<br>于是需要对每个用例加上描述，加一个 ids 参数</p>
<h1 id="ids-参数使用"><a href="#ids-参数使用" class="headerlink" title="ids 参数使用"></a>ids 参数使用</h1><p>在上面用例部分代码里面加个 ids 参数，用于描述每个用例的运行场景。</p>
<pre><code class="python"># 作者：上海-悠悠 QQ交流群：779429633
@allure.story(&quot;登录用例&quot;)
@pytest.mark.parametrize(&quot;test_input,expected&quot;,
                         test_datas,
                         ids=[
                             &quot;输入正确账号，密码，登录成功&quot;,
                             &quot;输入错误账号，密码，登录失败&quot;,
                             &quot;输入正确账号，密码，登录成功&quot;,
                         ]
                         )
def test_login(test_input, expected):
    &#39;&#39;&#39;测试登录用例&#39;&#39;&#39;
    # 获取函数返回结果
    result = login(test_input[&quot;username&quot;], test_input[&quot;password&quot;])
    # 断言
    assert result[&quot;msg&quot;] == expected
</code></pre>
<p>cmd命令行运行用例</p>
<pre><code class="shell">&gt; pytest --alluredir ./report test_a.py
&gt; allure serve ./report
</code></pre>
<p>生成报告<br><img src="/assets/2/image-20220516014816-e7oah48.png" alt="image.png"></p>
<h1 id="allure-title描述用例"><a href="#allure-title描述用例" class="headerlink" title="allure.title描述用例"></a>allure.title描述用例</h1><p>上面是通过在 parametrize 里面添加 ids 参数解决，接下来再讲一个用 allure.title(“用例描述”) 添加用例描述的方式解决。<br>使用 @allure.title(“用例描述”) 时，可以加上传入的参数，如传入的参数 <code>&quot;test_input,expected&quot;</code> ,需拼接test_input参数的值，可以这样写</p>
<blockquote>
<p>@allure.title(“用例描述,测试输入：{test_input}”)</p>
</blockquote>
<p>在 allure_pytest&#x2F;utils.py 源码里面可以找到对应的代码</p>
<pre><code class="python"># allure_pytest/utils.py

def allure_name(item, parameters):
    name = escape_name(item.name)
    title = allure_title(item)
    return title.format(**parameters) if title else name
</code></pre>
<p>当没有加allure.title()时候，用例的描述就是 item.name 值（也就是上面的 ids 用例的名称），<br>如果加了allure.title(),那么用例的描述就是添加的title值，这两个地方取其中的一个。</p>
<pre><code class="python">import pytest
import allure
# 作者：上海-悠悠 QQ交流群：779429633

def login(username, password):
    &#39;&#39;&#39;登录&#39;&#39;&#39;
    print(&quot;输入账号：%s&quot; % username)
    print(&quot;输入密码：%s&quot; % password)
    # 返回
    return &#123;&quot;code&quot;: 0, &quot;msg&quot;: &quot;success!&quot;&#125;


# 测试数据
test_datas = [
    (&#123;&quot;username&quot;: &quot;yoyo1&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo2&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;failed!&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo3&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;),
]


@allure.story(&quot;登录用例&quot;)
@allure.title(&quot;用例描述,测试输入：&#123;test_input&#125;&quot;)
@pytest.mark.parametrize(&quot;test_input,expected&quot;,
                         test_datas,
                         ids=[
                             &quot;输入正确账号，密码，登录成功&quot;,
                             &quot;输入错误账号，密码，登录失败&quot;,
                             &quot;输入正确账号，密码，登录成功&quot;,
                         ]
                         )
def test_login(test_input, expected):
    &#39;&#39;&#39;测试登录用例&#39;&#39;&#39;
    # 获取函数返回结果
    result = login(test_input[&quot;username&quot;], test_input[&quot;password&quot;])
    # 断言
    assert result[&quot;msg&quot;] == expected
</code></pre>
<p>cmd命令行运行用例</p>
<pre><code class="shell">&gt; pytest --alluredir ./report test_a.py
&gt; allure serve ./report
</code></pre>
<p>生成报告<br><img src="/assets/2/image-20220516014829-cg7k5fy.png" alt="image.png"></p>
<h1 id="优化用例title"><a href="#优化用例title" class="headerlink" title="优化用例title"></a>优化用例title</h1><p>结合上面两种实现方式，把用例描述当成一个测试输入的参数，继续优化后如下<br>需注意的是 parametrize 里面三个参数 <code>test_input,expected,title</code> 跟 test_login(test_input, expected, title) 里面三个参数保持一致</p>
<pre><code class="python">import pytest
import allure
# 作者：上海-悠悠 QQ交流群：779429633

def login(username, password):
    &#39;&#39;&#39;登录&#39;&#39;&#39;
    print(&quot;输入账号：%s&quot; % username)
    print(&quot;输入密码：%s&quot; % password)
    # 返回
    return &#123;&quot;code&quot;: 0, &quot;msg&quot;: &quot;success!&quot;&#125;


# 测试数据
test_datas = [
    (&#123;&quot;username&quot;: &quot;yoyo1&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;, &quot;输入正确账号，密码，登录成功&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo2&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;failed!&quot;, &quot;输入错误账号，密码，登录失败&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo3&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;, &quot;输入正确账号，密码，登录成功&quot;),
]


@allure.story(&quot;登录用例&quot;)
@allure.title(&quot;&#123;title&#125;&quot;)
@pytest.mark.parametrize(&quot;test_input,expected,title&quot;,
                         test_datas
                         )
def test_login(test_input, expected, title):
    &#39;&#39;&#39;测试登录用例&#39;&#39;&#39;
    # 获取函数返回结果
    result = login(test_input[&quot;username&quot;], test_input[&quot;password&quot;])
    # 断言
    assert result[&quot;msg&quot;] == expected
</code></pre>
<p><img src="/assets/2/image-20220516014837-zfrzpkn.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档40-pytest.ini配置用例查找规则(面试题)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A340-pytest.ini%E9%85%8D%E7%BD%AE%E7%94%A8%E4%BE%8B%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99(%E9%9D%A2%E8%AF%95%E9%A2%98)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试题:pytest如何执行不是test开头的用例？如执行 xxx_*.py这种文件的用例。<br>pytest.ini 配置文件可以修改用例的匹配规则。</p>
<h1 id="pytest命令行参数"><a href="#pytest命令行参数" class="headerlink" title="pytest命令行参数"></a>pytest命令行参数</h1><p>cmd打开输入pytest -h 查看命令行参数找到 [pytest] ini-options</p>
<ul>
<li>python_files (args) 匹配 python 用例文件， 如test_*.py、 *_test.py</li>
<li>python_classes (args) 匹配 class 类名称 如Test*.py</li>
<li>python_functions (args) 匹配函数和class里面方法 如test_*</li>
</ul>
<pre><code class="sql">[pytest] ini-options in the first pytest.ini|tox.ini|setup.cfg file found:

  markers (linelist)       markers for test functions
  empty_parameter_set_mark (string) default marker for empty parametersets
  norecursedirs (args)     directory patterns to avoid for recursion
  testpaths (args)         directories to search for tests when no files or dire
  usefixtures (args)       list of default fixtures to be used with this project
  python_files (args)      glob-style file patterns for Python test module disco
  python_classes (args)    prefixes or glob names for Python test class discover
  python_functions (args)  prefixes or glob names for Python test function and m
  disable_test_id_escaping_and_forfeit_all_rights_to_community_support (bool) di
  console_output_style (string) console output: &quot;classic&quot;, or with additional pr
  xfail_strict (bool)      default for the strict parameter of xfail markers whe
  junit_suite_name (string) Test suite name for JUnit report
  junit_logging (string)   Write captured log messages to JUnit report: one of n
  junit_duration_report (string) Duration time to report: one of total|call
  junit_family (string)    Emit XML for schema: one of legacy|xunit1|xunit2
  doctest_optionflags (args) option flags for doctests
  doctest_encoding (string) encoding used for doctest files
  cache_dir (string)       cache directory path.
  filterwarnings (linelist) Each line specifies a pattern for warnings.filterwar
  log_print (bool)         default value for --no-print-logs
  log_level (string)       default value for --log-level
  log_format (string)      default value for --log-format
  log_date_format (string) default value for --log-date-format
  log_cli (bool)           enable log display during test run (also known as &quot;li
  log_cli_level (string)   default value for --log-cli-level
  log_cli_format (string)  default value for --log-cli-format
  log_cli_date_format (string) default value for --log-cli-date-format
  log_file (string)        default value for --log-file
  log_file_level (string)  default value for --log-file-level
  log_file_format (string) default value for --log-file-format
  log_file_date_format (string) default value for --log-file-date-format
  addopts (args)           extra command line options
  minversion (string)      minimally required pytest version
  rsyncdirs (pathlist)     list of (relative) paths to be rsynced for remote dis
  rsyncignore (pathlist)   list of (relative) glob-style paths to be ignored for
  looponfailroots (pathlist) directories to check for changes
</code></pre>
<h1 id="修改匹配规则"><a href="#修改匹配规则" class="headerlink" title="修改匹配规则"></a>修改匹配规则</h1><p>pytest 默认查找用例匹配规则</p>
<ul>
<li>测试文件以test_开头（以_test结尾也可以）</li>
<li>测试类以Test开头，并且不能带有 <strong>init</strong> 方法</li>
<li>测试函数以test_开头</li>
</ul>
<p>如果我们想匹配以 xxx_*.py的文件，pytest.ini 文件放到项目的根目录。<br>在 pytest.ini 文件添加一项 python_files 即可</p>
<pre><code class="ini">[pytest]

python_files =  xxx_*.py
</code></pre>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>写一个 xxx_yoyo.py 的文件用例</p>
<pre><code class="python">#  xxx_yoyo.py
# 作者：上海-悠悠 QQ交流群：779429633
def test_1():
    print(&quot;hello&quot;)


def test_2():
    print(&quot;world&quot;)
</code></pre>
<p>cmd 输入 pytest 执行，就可以匹配到了</p>
<pre><code class="makefile">D:\soft\demo&gt;pytest
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\soft\code\web_pytest_2020, inifile: pytest.ini
plugins: allure-pytest-2.8.6
collected 2 items

xxx_yoyo.py hello
.world
.

========================== 2 passed in 0.13 seconds ===========================
</code></pre>
<p>匹配测试用例类和方法相关配置参考如下</p>
<pre><code class="ini">[pytest]

python_files =  xxx_*.py *_xxx.py
python_classes = Test*
python_functions = test_*
</code></pre>
<p>多个匹配规则中间用空格隔开,其它配置参考这篇<a href="https://www.cnblogs.com/yoyoketang/p/9550648.html">https://www.cnblogs.com/yoyoketang/p/9550648.html</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档41-参数化 ids 用例描述为中文时控制台输出unicode编码问题</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A341-%E5%8F%82%E6%95%B0%E5%8C%96%20ids%20%E7%94%A8%E4%BE%8B%E6%8F%8F%E8%BF%B0%E4%B8%BA%E4%B8%AD%E6%96%87%E6%97%B6%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BAunicode%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 pytest.mark.parametrize 参数化的时候，加 ids 参数用例描述有中文时，在控制台输出会显示unicode编码，中文不能正常显示。<br>使用 pytest_collection_modifyitems 钩子函数，对输出的 item.name 和 item.nodeid 重新编码。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>参数化 ids 用例描述有中文</p>
<pre><code class="python">import pytest


# test_ids.py
import pytest
# 作者：上海-悠悠


def login(username, password):
    &#39;&#39;&#39;登录&#39;&#39;&#39;
    # 返回
    return &#123;&quot;code&quot;: 0, &quot;msg&quot;: &quot;success!&quot;&#125;


# 测试数据
test_datas = [
    (&#123;&quot;username&quot;: &quot;yoyo1&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo2&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo3&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;),
]


@pytest.mark.parametrize(&quot;test_input,expected&quot;,
                         test_datas,
                         ids=[
                             &quot;输入正确账号，密码，登录成功&quot;,
                             &quot;输入错误账号，密码，登录失败&quot;,
                             &quot;输入正确账号，密码，登录成功&quot;,
                         ]
                         )
def test_login(test_input, expected):
    &#39;&#39;&#39;测试登录用例&#39;&#39;&#39;
    # 获取函数返回结果
    result = login(test_input[&quot;username&quot;], test_input[&quot;password&quot;])
    # 断言
    assert result[&quot;msg&quot;] == expected
</code></pre>
<p>cmd终端运行 <code>pytest test_ids.py -v</code><br><img src="/assets/2/image-20220516014630-mx82trb.png" alt="image.png"></p>
<p><strong>注意 [\u8f93\u5165\u6b63 …] 这种不叫乱码，这叫 unicode 编码</strong></p>
<h1 id="pytest-collection-modifyitems"><a href="#pytest-collection-modifyitems" class="headerlink" title="pytest_collection_modifyitems"></a>pytest_collection_modifyitems</h1><p>在项目的根目录写个 conftest.py 文件，加以下代码</p>
<pre><code class="python">def pytest_collection_modifyitems(items):
    &quot;&quot;&quot;
    测试用例收集完成时，将收集到的item的name和nodeid的中文显示在控制台上
    :return:
    &quot;&quot;&quot;
    for item in items:
        item.name = item.name.encode(&quot;utf-8&quot;).decode(&quot;unicode_escape&quot;)
        print(item.nodeid)
        item._nodeid = item.nodeid.encode(&quot;utf-8&quot;).decode(&quot;unicode_escape&quot;)
</code></pre>
<p>cmd 控制台重新运行</p>
<p><img src="/assets/2/image-20220516014637-0r3omd5.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档42-fixture参数化params</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A342-fixture%E5%8F%82%E6%95%B0%E5%8C%96params/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参数化是自动化测试里面必须掌握的一个知识点，用过 unittest 框架的小伙伴都知道使用 ddt 来实现测试用例的参数化。<br>pytest 测试用例里面对应的参数可以用 parametrize 实现，随着用例的增多，我们的需求也会越来越多，那么如何在 fixture 中使用参数呢？</p>
<h1 id="fixture-源码"><a href="#fixture-源码" class="headerlink" title="fixture 源码"></a>fixture 源码</h1><p>先看下 fixture 源码，有这几个参数：scope，params，autouse，ids，name。</p>
<pre><code class="smalltalk">def fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None):
    &quot;&quot;&quot;Decorator to mark a fixture factory function.

    This decorator can be used, with or without parameters, to define a
    fixture function.

    The name of the fixture function can later be referenced to cause its
    invocation ahead of running tests: test
    modules or classes can use the ``pytest.mark.usefixtures(fixturename)``
    marker.

    Test functions can directly use fixture names as input
    arguments in which case the fixture instance returned from the fixture
    function will be injected.

    Fixtures can provide their values to test functions using ``return`` or ``yield``
    statements. When using ``yield`` the code block after the ``yield`` statement is executed
    as teardown code regardless of the test outcome, and must yield exactly once.

    :arg scope: the scope for which this fixture is shared, one of
                ``&quot;function&quot;`` (default), ``&quot;class&quot;``, ``&quot;module&quot;``,
                ``&quot;package&quot;`` or ``&quot;session&quot;``.

                ``&quot;package&quot;`` is considered **experimental** at this time.

    :arg params: an optional list of parameters which will cause multiple
                invocations of the fixture function and all of the tests
                using it.
                The current parameter is available in ``request.param``.

    :arg autouse: if True, the fixture func is activated for all tests that
                can see it.  If False (the default) then an explicit
                reference is needed to activate the fixture.

    :arg ids: list of string ids each corresponding to the params
                so that they are part of the test id. If no ids are provided
                they will be generated automatically from the params.

    :arg name: the name of the fixture. This defaults to the name of the
                decorated function. If a fixture is used in the same module in
                which it is defined, the function name of the fixture will be
                shadowed by the function arg that requests the fixture; one way
                to resolve this is to name the decorated function
                ``fixture_&lt;fixturename&gt;`` and then use
                ``@pytest.fixture(name=&#39;&lt;fixturename&gt;&#39;)``.
    &quot;&quot;&quot;
    if callable(scope) and params is None and autouse is False:
        # direct decoration
        return FixtureFunctionMarker(&quot;function&quot;, params, autouse, name=name)(scope)
    if params is not None and not isinstance(params, (list, tuple)):
        params = list(params)
    return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)
</code></pre>
<p>重点看 params 参数：一个可选的参数列表，它将导致多次调用fixture函数和使用它的所有测试<br>获取当前参数可以使用 <code>request.param</code></p>
<pre><code class="sql">    :arg params: an optional list of parameters which will cause multiple
                invocations of the fixture function and all of the tests
                using it.
                The current parameter is available in ``request.param``.
</code></pre>
<h1 id="fixture-之-params-使用示例"><a href="#fixture-之-params-使用示例" class="headerlink" title="fixture 之 params 使用示例"></a>fixture 之 params 使用示例</h1><p>request 是pytest的内置 fixture ，主要用于传递参数</p>
<pre><code class="python"># test_fixture_params.py
import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


# 测试数据，存放在list
user_data = [&quot;user1&quot;, &quot;user2&quot;]

@pytest.fixture(scope=&quot;function&quot;, params=user_data)
def users(request):
    &#39;&#39;&#39;注册用户参数化&#39;&#39;&#39;
    return request.param


def test_register(users):
    print(&quot;注册用户：%s&quot;%users)

if __name__ == &#39;__main__&#39;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture_params&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="diff">&gt;pytest test_fixture_params.py -s
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\soft\demo
plugins: allure-pytest-2.8.6
collected 2 items

test_fixture_params.py 注册用户：user1
.注册用户：user2
.

========================== 2 passed in 0.02 seconds ===========================
</code></pre>
<h1 id="前置与后置"><a href="#前置与后置" class="headerlink" title="前置与后置"></a>前置与后置</h1><p>如果每次注册用户之前，需先在前置操作里面清理用户注册表的数据，可以执行SQL,传不同用户的参数</p>
<pre><code class="python"># test_fixture_params.py
import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def delete_sql(user):
    &#39;&#39;&#39;这里执行SQL&#39;&#39;&#39;
    sql = &quot;delete from auth_user WHERE username = &#39;%s&#39;;&quot;%user
    print(&quot;执行的sql:%s&quot;%sql)
    # 调用执行SQL的封装函数


# 测试数据，存放在list
user_data = [&quot;user1&quot;, &quot;user2&quot;]

@pytest.fixture(scope=&quot;function&quot;, params=user_data)
def users(request):
    &#39;&#39;&#39;注册用户参数化&#39;&#39;&#39;

    # 前置操作
    delete_sql(request.param)

    yield request.param

    # # 后置操作
    # delete_sql(request.param)


def test_register(users):
    print(&quot;注册用户：%s&quot;%users)

if __name__ == &#39;__main__&#39;:
    pytest.main([&quot;-s&quot;, &quot;test_fixture_params.py&quot;])
</code></pre>
<p>运行结果</p>
<pre><code class="sql">collected 2 items

test_fixture_params.py 执行的sql:delete from auth_user WHERE username = &#39;user1&#39;;
注册用户：user1
.执行的sql:delete from auth_user WHERE username = &#39;user2&#39;;
注册用户：user2
.

========================== 2 passed in 0.06 seconds ===========================
</code></pre>
<p>后置操作可以写到 yield 后面，参考上面的格式。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档43-元数据使用(pytest-metadata)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A343-%E5%85%83%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8(pytest-metadata)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是元数据？元数据是关于数据的描述，存储着关于数据的信息，为人们更方便地检索信息提供了帮助。<br>pytest 框架里面的元数据可以使用 pytest-metadata 插件实现。文档地址<a href="https://pypi.org/project/pytest-metadata/">https://pypi.org/project/pytest-metadata/</a></p>
<h1 id="pytest-metadata-环境准备"><a href="#pytest-metadata-环境准备" class="headerlink" title="pytest-metadata 环境准备"></a>pytest-metadata 环境准备</h1><p>使用 pip 安装 pytest-metadata</p>
<blockquote>
<p>pip install pytest-metadata</p>
</blockquote>
<h1 id="查看-pytest-元数据"><a href="#查看-pytest-元数据" class="headerlink" title="查看 pytest 元数据"></a>查看 pytest 元数据</h1><p>使用pytest 执行用例的时候加上 <code>-v</code> 参数(或<code>--verbose</code>),在控制台输出报告的头部就会输出元数据(metadata)</p>
<pre><code class="lua">&gt;pytest --verbose
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1 -- e:\python36\python.exe
cachedir: .pytest_cache
metadata: &#123;&#39;Python&#39;: &#39;3.6.0&#39;, &#39;Platform&#39;: &#39;Windows-10-10.0.17134-SP0&#39;, &#39;Packages&#39;: &#123;&#39;pytest&#39;: &#39;4.5.0&#39;, &#39;py&#39;: &#39;1.5.4&#39;, &#39;pluggy&#39;: &#39;0.13.1&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;allure-pytest&#39;: &#39;2.8.6&#39;, &#39;PyTestReport&#39;: &#39;0.1.9.3&#39;, &#39;assume&#39;: &#39;2.2.1&#39;, &#39;forked&#39;: &#39;0.2&#39;, &#39;html&#39;: &#39;1.19.0&#39;, &#39;metadata&#39;: &#39;1.7.0&#39;, &#39;ordering&#39;: &#39;0.6&#39;, &#39;repeat&#39;: &#39;0.7.0&#39;, &#39;rerunfailures&#39;: &#39;8.0&#39;, &#39;xdist&#39;: &#39;1.23.2&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;D:\\java\\jdk1.8&#39;&#125;
rootdir: D:\soft\code\pytest_api_2020_03
plugins: allure-pytest-2.8.6
</code></pre>
<p>可以获取到的元数据</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>Python</td>
<td>Python 版本</td>
<td>‘3.6.0’</td>
</tr>
<tr>
<td>Platform</td>
<td>运行平台</td>
<td>‘Windows-10-10.0.17134-SP0’</td>
</tr>
<tr>
<td>Packages</td>
<td>pytest 包相关信息</td>
<td>{‘pytest’: ‘4.5.0’, ‘py’: ‘1.5.4’, ‘pluggy’: ‘0.13.1’}</td>
</tr>
<tr>
<td>Plugins</td>
<td>pytest 插件</td>
<td>{‘allure-pytest’: ‘2.8.6’, ‘PyTestReport’: ‘0.1.9.3’}</td>
</tr>
<tr>
<td>JAVA_HOME</td>
<td>JAVA环境变量</td>
<td>‘D:\java\jdk1.8’</td>
</tr>
</tbody></table>
<p>元数据是以键值对(key-value)方式存储的</p>
<h1 id="添加-metadata"><a href="#添加-metadata" class="headerlink" title="添加 metadata"></a>添加 metadata</h1><p>我们可以在命令行用 <code>--metadata</code> 参数添加键值对(key, value)的元数据。<br>比如当我们完成了一个项目，需要添加作者信息，于是就可以添加元数据</p>
<blockquote>
<p>pytest –metadata auther yoyo</p>
</blockquote>
<p>如果需要添加多个元数据，可以使用多次 <code>--metadata</code> 参数添加</p>
<blockquote>
<p>pytest –metadata auther yoyo –metadata version v1.0</p>
</blockquote>
<p>从文档上看可以支持json格式，一次性传多组元数据，使用<code>--metadata-from-json</code>,但我自己试了下，并不支持这个参数,这种方式可以忽略！</p>
<blockquote>
<p>pytest –metadata-from-json ‘{“cat_says”: “bring the cat nip”, “human_says”: “yes kitty”}’</p>
</blockquote>
<h1 id="pytest-metadata-hook函数"><a href="#pytest-metadata-hook函数" class="headerlink" title="pytest_metadata hook函数"></a>pytest_metadata hook函数</h1><p>在代码里面也可以新增&#x2F;修改&#x2F;删除 元数据，我们可以使用 pytest_metadata hook函数</p>
<pre><code class="python">import pytest
@pytest.mark.optionalhook
def pytest_metadata(metadata):
    metadata.pop(&quot;password&quot;, None)
</code></pre>
<p>我们可以使用 metadata fixture，用于测试用例或fixture 访问元数据（metadata）</p>
<pre><code class="python">def test_metadata(metadata):
    assert &#39;metadata&#39; in metadata[&#39;Plugins&#39;]
</code></pre>
<p>在插件里面访问 metadata，可以在config对象使用 _metadata 属性来新增&#x2F;修改&#x2F;删除 元数据</p>
<pre><code class="lua">def pytest_configure(config):
  if hasattr(config, &#39;_metadata&#39;):
      config._metadata[&#39;foo&#39;] = &#39;bar&#39;
</code></pre>
<h1 id="插件集成"><a href="#插件集成" class="headerlink" title="插件集成"></a>插件集成</h1><p>下面是一个方便的插件列表，这些插件要么读取元数据，要么对元数据有贡献：</p>
<ul>
<li>pytest-base-url - Adds the base URL to the metadata.</li>
<li>pytest-html - Displays the metadata at the start of each report.</li>
<li>pytest-selenium - Adds the driver, capabilities, and remote server to the metadata.</li>
</ul>
<h1 id="pytest-ini-管理元数据"><a href="#pytest-ini-管理元数据" class="headerlink" title="pytest.ini 管理元数据"></a>pytest.ini 管理元数据</h1><p>如果新增的元数据较多，在命令行输入不太方便，可以在pytest.ini配置里面配置你的项目元数据</p>
<pre><code class="haskell"># pytest.ini
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

[pytest]
addopts = -v 
  --html=report.html 
  --self-contained-html
  --metadata auther yoyo 
  --metadata version v1.0
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档44-allure.dynamic动态生成用例标题</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A344-allure.dynamic%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%94%A8%E4%BE%8B%E6%A0%87%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 结合 allure 描述用例的时候我们一般使用 <code>@allure.title</code> 和 <code>@allure.description</code> 描述测试用例的标题和详情。<br>在用例里面也可以动态更新标题和详情，使用allure.dynamic方法实现。</p>
<h1 id="allure-dynamic-动态属性"><a href="#allure-dynamic-动态属性" class="headerlink" title="allure.dynamic 动态属性"></a>allure.dynamic 动态属性</h1><p>feature 模块</p>
<blockquote>
<p>allure.dynamic.feature(feature_name)</p>
</blockquote>
<p>功能点 story</p>
<blockquote>
<p>allure.dynamic.story(case_story)</p>
</blockquote>
<p>用例标题 title</p>
<blockquote>
<p>allure.dynamic.title(case_title)</p>
</blockquote>
<p>用例描述：请求URL 请求类型 期望结果 实际结果描述</p>
<pre><code class="xml">desc = &quot;&lt;font color=&#39;red&#39;&gt;请求URL:&lt;/font&gt;&#123;&#125;&lt;Br/&gt;&quot; \
           &quot;&lt;font color=&#39;red&#39;&gt;请求类型:&lt;/font&gt;&#123;&#125;&lt;Br/&gt;&quot; \
           &quot;&lt;font color=&#39;red&#39;&gt;期望结果:&lt;/font&gt;&#123;&#125;&lt;Br/&gt;&quot; \
           &quot;&lt;font color=&#39;red&#39;&gt;实际结果描述:&lt;/font&gt;&#123;&#125;&lt;Br/&gt;&quot;.format(url,method,expect,expect_result)
allure.dynamic.description(desc)
</code></pre>
<h1 id="description-用例描述"><a href="#description-用例描述" class="headerlink" title="description 用例描述"></a>description 用例描述</h1><p>可以在测试主体内部动态更新描述 <code>allure.dynamic.description</code></p>
<pre><code class="python">import allure

@allure.description(&quot;&quot;&quot;
This description will be replaced at the end of the test.
&quot;&quot;&quot;)
def test_dynamic_description():
    assert 42 == int(6 * 7)
    allure.dynamic.description(&#39;A final description.&#39;)
</code></pre>
<p>最后用例的描述被更新为 ‘A final description.’</p>
<p><img src="/assets/2/image-20220516014417-26tu0cz.png" alt="image.png"></p>
<h1 id="title-用例标题"><a href="#title-用例标题" class="headerlink" title="title 用例标题"></a>title 用例标题</h1><p>用例标题也可以被动态更新</p>
<pre><code class="python">@allure.title(&quot;This title will be replaced in a test body&quot;)
def test_with_dynamic_title():
    assert 2 + 2 == 4
    allure.dynamic.title(&#39;After a successful test finish, the title was replaced with this line.&#39;)
</code></pre>
<p>最终用例的title更新为’After a successful test finish, the title was replaced with this line.’<br><img src="/assets/2/image-20220516014427-1o27dwz.png" alt="image.png"></p>
<h1 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h1><p>参数化时候，可以使用@allure.title给用例不同标题</p>
<pre><code class="less">@allure.title(&quot;Parameterized test title: adding &#123;param1&#125; with &#123;param2&#125;&quot;)
@pytest.mark.parametrize(&#39;param1,param2,expected&#39;, [
    (2, 2, 4),
    (1, 2, 5)
])
def test_with_parameterized_title(param1, param2, expected):
    assert param1 + param2 == expected
</code></pre>
<p>也可以在用例里面使用allure.dynamic.title更新用例的标题</p>
<pre><code class="python">import pytest
import allure
# 作者：上海-悠悠 QQ交流群：779429633

def login(username, password):
    &#39;&#39;&#39;登录&#39;&#39;&#39;
    print(&quot;输入账号：%s&quot; % username)
    print(&quot;输入密码：%s&quot; % password)
    # 返回
    return &#123;&quot;code&quot;: 0, &quot;msg&quot;: &quot;success!&quot;&#125;


# 测试数据
test_datas = [
    (&#123;&quot;username&quot;: &quot;yoyo1&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;, &quot;输入正确账号，密码，登录成功&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo2&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;failed!&quot;, &quot;输入错误账号，密码，登录失败&quot;),
    (&#123;&quot;username&quot;: &quot;yoyo3&quot;, &quot;password&quot;: &quot;123456&quot;&#125;, &quot;success!&quot;, &quot;输入正确账号，密码，登录成功&quot;),
]


@allure.story(&quot;登录用例&quot;)
@pytest.mark.parametrize(&quot;test_input,expected,title&quot;,
                         test_datas
                         )
def test_login(test_input, expected, title):
    &#39;&#39;&#39;测试登录用例&#39;&#39;&#39;
    # 获取函数返回结果
    result = login(test_input[&quot;username&quot;], test_input[&quot;password&quot;])
    # 断言
    assert result[&quot;msg&quot;] == expected
    allure.dynamic.title(title)
</code></pre>
<p>最终生成报告效果</p>
<p><img src="/assets/2/image-20220516014437-xwows12.png" alt="image.png"></p>
<h1 id="其它属性"><a href="#其它属性" class="headerlink" title="其它属性"></a>其它属性</h1><p>allure.dynamic.feature<br>allure.dynamic.link<br>allure.dynamic.issue<br>allure.dynamic.testcase<br>allure.dynamic.story<br>allure.dynamic.title<br>allure.dynamic.description</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档45-allure添加环境配置(environment)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A345-allure%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE(environment)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 allure 报告首页 ENVIRONMENT 显示 ‘There are no environment variables’ 没有环境变量的配置信息。<br>环境变量配置可以添加报告相关的配置参数，如运行的系统环境，版本号，测试环境，测试人员等基本信息</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>allure 报告首页 ENVIRONMENT</p>
<p><img src="/assets/2/image-20220516014258-illdavw.png" alt="image.png"></p>
<p>接下来就讲如何添加 ENVIRONMENT</p>
<h1 id="environment-配置文件"><a href="#environment-配置文件" class="headerlink" title="environment 配置文件"></a>environment 配置文件</h1><p>方法一：environment.properties 文件<br>在allure的report根目录下添加一个 environment.properties 文件</p>
<p><img src="/assets/2/image-20220516014305-knt2tb4.png" alt="image.png"></p>
<p>文件里面添加环境配置，格式如下</p>
<pre><code class="ini">systemVersion=win10
pythonVersion=3.6.0
allureVersion=2.13.0
baseUrl=http://192.168.1.x:8080
projectName=test
author=YOYO
email=283340479@qq.com
blog=https://www.cnblogs.com/yoyoketang/
</code></pre>
<p>方法二：environment.xml</p>
<p>也可以用 environment.xml 文件，格式如下</p>
<pre><code class="xml">&lt;environment&gt;
    &lt;parameter&gt;
        &lt;key&gt;Browser&lt;/key&gt;
        &lt;value&gt;Chrome&lt;/value&gt;
    &lt;/parameter&gt;
    &lt;parameter&gt;
        &lt;key&gt;Browser.Version&lt;/key&gt;
        &lt;value&gt;63.0&lt;/value&gt;
    &lt;/parameter&gt;
    &lt;parameter&gt;
        &lt;key&gt;Stand&lt;/key&gt;
        &lt;value&gt;Production&lt;/value&gt;
    &lt;/parameter&gt;
&lt;/environment&gt;
</code></pre>
<h1 id="报告展示"><a href="#报告展示" class="headerlink" title="报告展示"></a>报告展示</h1><p>运行测试用例，生成 allure 报告</p>
<pre><code class="shell">&gt; pytest test_allure.py --alluredir ./report
&gt; allure serve ./report
</code></pre>
<p>报告内容显示<br><img src="/assets/2/image-20220516014314-uojfwpo.png" alt="image.png"></p>
<p>这个地方是不支持中文的，如果有中文报告会显示乱码<br><img src="/assets/2/image-20220516014320-0xsch7g.png" alt="image.png"></p>
<h1 id="copy命令"><a href="#copy命令" class="headerlink" title="copy命令"></a>copy命令</h1><p>在运行 pytest 生成 allure 报告的时候，有时候需要加 <code>--clean</code> 参数，清楚之前的报告记录，这样会之前清空 report 目录，environment.properties文件也会被删除。<br>为了不让 environment.properties 文件删除掉，可以把 environment.properties 文件放项目根目录，在运行报告的时候，先 copy 到 report 目录</p>
<p>以windows10系统为例</p>
<pre><code class="shell">&gt; pytest test_allure.py --alluredir ./report --clean

&gt; copy environment.properties report\environment.properties

&gt; allure serve ./report
</code></pre>
<p>linux系统用cp</p>
<pre><code class="shell">&gt; pytest test_allure.py --alluredir ./report --clean
&gt; cp environment.properties ./report/environment.properties
&gt; allure serve ./report
</code></pre>
<p>备注：早期的 allure 1.x 版本可以用以下方式添加</p>
<pre><code class="python">import allure

# allure 添加 environment 配置
allure.environment(base_url=&#39;http://192.168.1.x:8080&#39;)
allure.environment(project_name=&#39;test&#39;)
allure.environment(author=&#39;上海-悠悠&#39;)
allure.environment(email=&#39;283340479@qq.com&#39;)
allure.environment(blog=&#39;https://www.cnblogs.com/yoyoketang/&#39;)
</code></pre>
<p>但最新的 2.x 版本 allure 没这个方法了，有点遗憾！</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档46-关于https请求警告问题</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A346-%E5%85%B3%E4%BA%8Ehttps%E8%AF%B7%E6%B1%82%E8%AD%A6%E5%91%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 pytest 执行 https 请求用例的时候，控制台会出现警告：InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised.<br>当出现这个警告的时候，我们第一反应是加忽略警告：urllib3.disable_warnings()，然而并不管用。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>使用requests库发https请求，添加verify&#x3D;False忽略证书</p>
<pre><code class="python"># test_https.py
import requests
import urllib3
urllib3.disable_warnings()


def test_h():
    &#39;&#39;&#39;
    author: 上海-悠悠 QQ交流群：779429633
    blog: https://www.cnblogs.com/yoyoketang
    :return: 
    &#39;&#39;&#39;
    url = &quot;https://www.cnblogs.com/yoyoketang&quot;
    s = requests.session()
    s.verify = False
    r = s.get(url)
    assert &quot;上海-悠悠&quot; in r.text
</code></pre>
<p>命令行使用pytest运行用例</p>
<pre><code class="avrasm">D:\demo&gt;pytest test_https.py
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\demo
plugins: allure-pytest-2.8.6
collected 1 item

test_https.py .                                                          [100%]

============================== warnings summary ===============================
test_https.py::test_h
  e:\python36\lib\site-packages\urllib3\connectionpool.py:858: InsecureRequestWarning: Unverified HTTPS request is being made. 
Adding certificate verification is strongly advised. 
See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings InsecureRequestWarning)

-- Docs: https://docs.pytest.org/en/latest/warnings.html
==================== 1 passed, 1 warnings in 0.35 seconds =====================
</code></pre>
<p>这时候会出现 InsecureRequestWarning 警告，去百度搜都是上加上这句</p>
<blockquote>
<p>urllib3.disable_warnings()</p>
</blockquote>
<p>然而你会发现不管用</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>出现这个问题，并不是因为 ‘urllib3.disable_warnings()’ 不生效，主要是小伙伴门对 pytest 的运行规则不熟悉，pytest 框架运行的时候会查找test_ <em>.py文件下的test_</em> ()函数或方法的用例<br>也就是只会执行 <code>test_h()</code> 下面的代码，所以根本就不会执行它上面的代码，可以试试换个位置，放到test_h() 以下，就会生效</p>
<pre><code class="python">import requests
import urllib3
# urllib3.disable_warnings()

def test_h():
    &#39;&#39;&#39;
    author: 上海-悠悠 QQ交流群：779429633
    blog: https://www.cnblogs.com/yoyoketang
    :return:
    &#39;&#39;&#39;
    urllib3.disable_warnings()  # 换个位置
    url = &quot;https://www.cnblogs.com/yoyoketang&quot;
    s = requests.session()
    s.verify = False
    r = s.get(url)
    assert &quot;上海-悠悠&quot; in r.text
</code></pre>
<p>再次运行 <code>pytest test_https.py</code> 警告就没有了</p>
<h1 id="warnings-文档"><a href="#warnings-文档" class="headerlink" title="warnings 文档"></a>warnings 文档</h1><p>上面的警告内容有个doc文档地址<a href="https://docs.pytest.org/en/latest/warnings.html">Docs: https://docs.pytest.org/en/latest/warnings.html</a>，点开查询解决方案</p>
<p>文档上有对于警告出现的详细描述，在命令行添加<code>--disable-warnings</code> 参数忽略警告</p>
<blockquote>
<p>pytest test_https.py –disable-warnings</p>
</blockquote>
<pre><code class="makefile">D:\demo&gt;pytest test_https.py --disable-warnings
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\demo
plugins: allure-pytest-2.8.6
collected 1 item

test_https.py .                                                          [100%]

==================== 1 passed, 1 warnings in 0.24 seconds =====================
</code></pre>
<p>虽然警告内容没有了，但是警告还是会显示：1 passed, 1 warnings</p>
<p>也许你想彻底的不想看到warnings，可以不加载 warnings 插件，使用-p参数忽略插件加载</p>
<pre><code class="perl"> -p name               early-load given plugin module name or entry point
                        (multi-allowed). To avoid loading of plugins, use the
                        `no:` prefix, e.g. `no:doctest`.
</code></pre>
<p>带上 -p 参数运行</p>
<blockquote>
<p>pytest test_https.py -p no:warnings</p>
</blockquote>
<pre><code class="makefile">D:\demo&gt;pytest test_https.py -p no:warnings
============================= test session starts =============================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
rootdir: D:\demo
plugins: allure-pytest-2.8.6
collected 1 item

test_https.py .                                                          [100%]

========================== 1 passed in 0.29 seconds ===========================
</code></pre>
<p>现在可以看到运行结果里面完全没有 warnings 字样了</p>
<p>可以在项目根目录放一个pytest.ini文件，内容如下</p>
<pre><code class="ini">[pytest]
addopts = -p no:warnings
</code></pre>
<p>这样使用命令行执行的时候，就可以不用每次都带-p参数了</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档47-allure报告添加用例失败截图</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A347-allure%E6%8A%A5%E5%91%8A%E6%B7%BB%E5%8A%A0%E7%94%A8%E4%BE%8B%E5%A4%B1%E8%B4%A5%E6%88%AA%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 selenium 做 web 自动化的时候，很多小伙伴希望用例失败的时候能截图，把异常截图展示到allure报告里面。<br>pytest 有个很好的钩子函数 pytest_runtest_makereport 可以获取到用例执行的结果，所以我们在这个钩子函数里面判断用例失败后截图就可以了。<br>allure报告添加截图可以使用 allure.attach 方法</p>
<h1 id="失败截图"><a href="#失败截图" class="headerlink" title="失败截图"></a>失败截图</h1><p>关于 pytest_runtest_makereport 获取用例执行结果的钩子函数介绍可以看前面这篇<a href="https://www.cnblogs.com/yoyoketang/p/12609871.html">https://www.cnblogs.com/yoyoketang/p/12609871.html</a><br>在 conftest.py 文件写用例执行的钩子函数</p>
<pre><code class="python">import pytest
from selenium import webdriver
import os
import allure
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


_driver = None


@pytest.hookimpl(tryfirst=True, hookwrapper=True)
def pytest_runtest_makereport(item, call):
    &#39;&#39;&#39;
    获取每个用例状态的钩子函数
    :param item:
    :param call:
    :return:
    &#39;&#39;&#39;
    # 获取钩子方法的调用结果
    outcome = yield
    rep = outcome.get_result()
    # 仅仅获取用例call 执行结果是失败的情况, 不包含 setup/teardown
    if rep.when == &quot;call&quot; and rep.failed:
        mode = &quot;a&quot; if os.path.exists(&quot;failures&quot;) else &quot;w&quot;
        with open(&quot;failures&quot;, mode) as f:
            # let&#39;s also access a fixture for the fun of it
            if &quot;tmpdir&quot; in item.fixturenames:
                extra = &quot; (%s)&quot; % item.funcargs[&quot;tmpdir&quot;]
            else:
                extra = &quot;&quot;
            f.write(rep.nodeid + extra + &quot;\n&quot;)
        # 添加allure报告截图
        if hasattr(_driver, &quot;get_screenshot_as_png&quot;):
            with allure.step(&#39;添加失败截图...&#39;):
                allure.attach(_driver.get_screenshot_as_png(), &quot;失败截图&quot;, allure.attachment_type.PNG)


@pytest.fixture(scope=&#39;session&#39;)
def browser():
    global _driver
    if _driver is None:
        _driver =webdriver.Chrome()
    yield _driver
    print(&quot;1111111111&quot;)
    _driver.quit()
</code></pre>
<h1 id="用例运行"><a href="#用例运行" class="headerlink" title="用例运行"></a>用例运行</h1><p>整个目录结构如下</p>
<p><img src="/assets/2/image-20220516014145-z1dc3dx.png" alt="image.png"></p>
<p>test_login.py文件内容如下</p>
<pre><code class="python">import pytest
from selenium import webdriver
import allure
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


def test_login(browser):
    with allure.step(&quot;step1：打开登录首页&quot;):
        browser.get(&quot;http://ip:6009/admin/login/?next=/admin/&quot;)
    with allure.step(&quot;step2：输入账号：admin&quot;):
        browser.find_element_by_name(&quot;username&quot;).send_keys(&quot;admin&quot;)
    with allure.step(&quot;step2：输入密码：123456&quot;):
        browser.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)
    # 故意断言失败，看是否会截图
    assert browser.title == &quot;悠悠&quot;
</code></pre>
<p>运行用例后，截图会存到.&#x2F;report 报告目录，allure报告展示</p>
<p><img src="/assets/2/image-20220516014153-pfkj64t.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档48-切换 base_url 测试环境(pytest-base-url)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A348-%E5%88%87%E6%8D%A2%20base_url%20%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83(pytest-base-url)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们自动化代码写完成之后，期望能在不同的环境测试，这时候应该把 base_url 单独拿出来，能通过配置文件和支持命令行参数执行。<br>pytest-base-url 是 pytest 里面提供的一个管理 base-url 的一个非常实用的插件，参考文档<a href="https://pypi.org/project/pytest-base-url/">https://pypi.org/project/pytest-base-url/</a></p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>先安装 pytest-base-url 插件</p>
<blockquote>
<p>pip install pytest-base-url</p>
</blockquote>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>直接在用例里面使用 base_url参数 当成一个fixture使用</p>
<pre><code class="python"># test_demo.py
import requests
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def test_example(base_url):
    assert 200 == requests.get(base_url).status_code
</code></pre>
<p>命令行执行的时候加上 <code>--base-url</code> 参数</p>
<blockquote>
<p>pytest –base-url <a href="http://www.example.com/">http://www.example.com</a></p>
</blockquote>
<pre><code class="csharp">D:\soft\web_base&gt;pytest --base-url http://www.example.com
=========== test session starts ==============
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
baseurl: http://www.example.com
rootdir: D:\soft\web_base
plugins: allure-pytest-2.8.6, base-url-1.4.2
collected 1 item

test_demo.py .                               [100%]

============= 1 passed in 0.73 seconds ============
</code></pre>
<h1 id="pytest-ini-配置文件"><a href="#pytest-ini-配置文件" class="headerlink" title="pytest.ini 配置文件"></a>pytest.ini 配置文件</h1><p>也可以在 pytest.ini 配置文件中添加 base_url 地址</p>
<pre><code class="ini"># pytest.ini文件内容
[pytest]
base_url = http://www.example.com
</code></pre>
<p>这样在命令行执行时候就可以不用带上 <code>--base-url</code> 参数</p>
<pre><code class="makefile">D:\soft\web_base&gt;pytest
============== test session starts ================
platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1
baseurl: http://www.example.com
rootdir: D:\soft\web_base, inifile: pytest.ini
plugins: allure-pytest-2.8.6,  base-url-1.4.2
collected 1 item

test_demo.py .           [100%]

============ 1 passed in 1.72 seconds ==========
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档49-命令行参数--tb的使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A349-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--tb%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 使用命令行执行用例的时候，有些用例执行失败的时候，屏幕上会出现一大堆的报错内容，不方便快速查看是哪些用例失败。<br><code>--tb=style</code> 参数可以设置报错的时候回溯打印内容，可以设置参数(auto&#x2F;long&#x2F;short&#x2F;line&#x2F;native&#x2F;no)</p>
<h1 id="–tb-x3D-style"><a href="#–tb-x3D-style" class="headerlink" title="–tb&#x3D;style"></a>–tb&#x3D;style</h1><p><code>pytest -h</code> 查看命令行参数，关于 <code>--tb=style</code> 参数的使用方式</p>
<pre><code class="java">&gt;pytest -h

 --tb=style            traceback print mode (auto/long/short/line/native/no).
</code></pre>
<p>style 的值可以设置6种打印模式：auto&#x2F;long&#x2F;short&#x2F;line&#x2F;native&#x2F;no</p>
<h1 id="–tb-x3D-no"><a href="#–tb-x3D-no" class="headerlink" title="–tb&#x3D;no"></a>–tb&#x3D;no</h1><p>先写个简单的pytest用例，让他断言报错</p>
<pre><code class="csharp"># test_tb.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def test_01():
    result = &quot;hello&quot;
    expected = &quot;world&quot;
    assert result == expected
</code></pre>
<p>命令行执行<code>pytest test_tb.py</code> 此时屏幕上会显示整个用例的回溯信息</p>
<pre><code class="markdown">test_tb.py F                                                             [100%]

================================== FAILURES ===================================
___________________________________ test_01 ___________________________________

    def test_01():
        result = &quot;hello&quot;
        expected = &quot;world&quot;
&gt;       assert result == expected
E       AssertionError: assert &#39;hello&#39; == &#39;world&#39;
E         - hello
E         + world

test_tb.py:8: AssertionError
========================== 1 failed in 0.08 seconds ===========================
</code></pre>
<p>加上 <code>--tb=no</code> 参数执行</p>
<pre><code class="diff">test_tb.py F                                                             [100%]

========================== 1 failed in 0.05 seconds ===========================
</code></pre>
<p><code>--tb=no</code> 是不显示报错的回溯内容</p>
<h1 id="–tb-x3D-line"><a href="#–tb-x3D-line" class="headerlink" title="–tb&#x3D;line"></a>–tb&#x3D;line</h1><p>line 模式使用一行输出所有的错误信息</p>
<pre><code class="java">test_tb.py F                                                             [100%]

================================== FAILURES ===================================
D:\soft\kecheng202004\demo\test_tb.py:8: AssertionError: assert &#39;hello&#39; == &#39;world&#39;
========================== 1 failed in 0.06 seconds ===========================
</code></pre>
<h1 id="–tb-x3D-short"><a href="#–tb-x3D-short" class="headerlink" title="–tb&#x3D;short"></a>–tb&#x3D;short</h1><p>short 模式显示断言报错的位置，不显示用例前面的代码</p>
<pre><code class="markdown">test_tb.py F                                                             [100%]

================================== FAILURES ===================================
___________________________________ test_01 ___________________________________
test_tb.py:8: in test_01
    assert result == expected
E   AssertionError: assert &#39;hello&#39; == &#39;world&#39;
E     - hello
E     + world
========================== 1 failed in 0.06 seconds ===========================
</code></pre>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>–tb&#x3D;auto 有多个用例失败的时候，只打印第一个和最后一个用例的回溯信息<br>–tb&#x3D;long 输出最详细的回溯信息<br>–tb&#x3D;short 输入assert的一行和系统判断内容<br>–tb&#x3D;line 使用一行显示错误信息<br>–tb&#x3D;native 只输出python标准库的回溯信息<br>–tb&#x3D;no 不显示回溯信息</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档50-命令行参数--durations统计用例运行时间</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A350-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--durations%E7%BB%9F%E8%AE%A1%E7%94%A8%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写完一个项目的自动化用例之后，发现有些用例运行较慢，影响整体的用例运行速度，于是领导说找出运行慢的那几个用例优化下。<br><code>--durations</code> 参数可以统计出每个用例运行的时间，对用例的时间做个排序。</p>
<h1 id="–durations-x3D-N"><a href="#–durations-x3D-N" class="headerlink" title="–durations&#x3D;N"></a>–durations&#x3D;N</h1><p><code>pytest -h</code> 查看命令行参数，关于 <code>--durations=N</code> 参数的使用方式</p>
<pre><code class="bash">&gt;pytest -h

reporting:
  --durations=N         show N slowest setup/test durations (N=0 for all).
</code></pre>
<p>当 N&#x3D;0 的时候显示全部用例的运行时间</p>
<h1 id="–durations-x3D-0"><a href="#–durations-x3D-0" class="headerlink" title="–durations&#x3D;0"></a>–durations&#x3D;0</h1><p>先写几个pytest的用例，在用例里面加sleep时间，这样方便看到每个用例运行的持续时间</p>
<pre><code class="python">import pytest
import time
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture()
def set_up_fixture():
    time.sleep(0.1)
    yield
    time.sleep(0.2)


def test_01(set_up_fixture):
    print(&quot;用例1&quot;)
    time.sleep(1.0)


def test_02(set_up_fixture):
    print(&quot;用例2&quot;)
    time.sleep(0.6)


def test_03(set_up_fixture):
    print(&quot;用例3&quot;)
    time.sleep(1.2)


def test_04(set_up_fixture):
    print(&quot;用例4&quot;)
    time.sleep(0.3)


def test_05(set_up_fixture):
    print(&quot;用例5&quot;)
    time.sleep(2.3)
</code></pre>
<p>当 N&#x3D;0 的时候显示全部用例的运行时间</p>
<pre><code class="php">&gt;pytest test_dur.py --durations=0 -v
============================= test session starts =============================
collected 5 items

test_dur.py::test_01 PASSED                                              [ 20%]
test_dur.py::test_02 PASSED                                              [ 40%]
test_dur.py::test_03 PASSED                                              [ 60%]
test_dur.py::test_04 PASSED                                              [ 80%]
test_dur.py::test_05 PASSED                                              [100%]

=========================== slowest test durations ============================
2.30s call     test_dur.py::test_05
1.20s call     test_dur.py::test_03
1.00s call     test_dur.py::test_01
0.60s call     test_dur.py::test_02
0.30s call     test_dur.py::test_04
0.20s teardown test_dur.py::test_05
0.20s teardown test_dur.py::test_01
0.20s teardown test_dur.py::test_02
0.20s teardown test_dur.py::test_03
0.20s teardown test_dur.py::test_04
0.10s setup    test_dur.py::test_03
0.10s setup    test_dur.py::test_01
0.10s setup    test_dur.py::test_02
0.10s setup    test_dur.py::test_05
0.10s setup    test_dur.py::test_04
========================== 5 passed in 7.05 seconds ===========================
</code></pre>
<p>用例运行的时候会经历3个阶段：setup,call,teardown。call就是测试用例，setup和teardown就是用例的fixture部分。</p>
<h1 id="–durations-x3D-3"><a href="#–durations-x3D-3" class="headerlink" title="–durations&#x3D;3"></a>–durations&#x3D;3</h1><p>如果我们只需要筛选出运行时间最慢的3条用例，可以设置<code>--durations=3</code></p>
<pre><code class="php">&gt;pytest test_dur.py --durations=3 -v
============================= test session starts =============================

collected 5 items

test_dur.py::test_01 PASSED                                              [ 20%]
test_dur.py::test_02 PASSED                                              [ 40%]
test_dur.py::test_03 PASSED                                              [ 60%]
test_dur.py::test_04 PASSED                                              [ 80%]
test_dur.py::test_05 PASSED                                              [100%]

========================== slowest 3 test durations ===========================
2.30s call     test_dur.py::test_05
1.20s call     test_dur.py::test_03
1.00s call     test_dur.py::test_01
========================== 5 passed in 7.00 seconds ===========================
</code></pre>
<p>这样就可以对运行慢的用例针对性优化。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档51-内置fixture之cache使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A351-%E5%86%85%E7%BD%AEfixture%E4%B9%8Bcache%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 运行完用例之后会生成一个 .pytest_cache 的缓存文件夹，用于记录用例的ids和上一次失败的用例。<br>方便我们在运行用例的时候加上–lf 和 –ff 参数，快速运行上一次失败的用例。<br>–lf, –last-failed 只重新运行上次运行失败的用例（或如果没有失败的话会全部跑）<br>–ff, –failed-first 运行所有测试，但首先运行上次运行失败的测试（这可能会重新测试，从而导致重复的fixture setup&#x2F;teardown）<br>–lf 和 –ff 相关介绍查看之前的这篇<a href="https://www.cnblogs.com/yoyoketang/p/9769559.html">https://www.cnblogs.com/yoyoketang/p/9769559.html</a></p>
<h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><p><code>pytest -h</code> 查看命令行参数，关于 cache 参数的使用方式</p>
<pre><code class="vhdl">&gt;pytest -h

--lf, --last-failed   rerun only the tests that failed at the last run (or
                        all if none failed)
--ff, --failed-first  run all tests but run the last failures first. This
                        may re-order tests and thus lead to repeated fixture
--nf, --new-first     run tests from new files first, then the rest of the
                        tests sorted by file mtime
--cache-show=[CACHESHOW]
                        show cache contents, don&#39;t perform collection or
                        tests. Optional argument: glob (default: &#39;*&#39;).
--cache-clear         remove all cache contents at start of test run.
</code></pre>
<p>参数说明：</p>
<ul>
<li>–lf 也可以使用 <code>--last-failed</code> 仅运行上一次失败的用例</li>
<li>–ff 也可以使用 <code>--failed-first</code> 运行全部的用例，但是上一次失败的用例先运行</li>
<li>–nf 也可以使用 <code>--new-first</code> 根据文件插件的时间，新的测试用例会先运行</li>
<li>–cache-show&#x3D;[CACHESHOW] 显示.pytest_cache文件内容，不会收集用例也不会测试用例，选项参数: glob (默认: ‘*’)</li>
<li>–cache-clear 测试之前先清空.pytest_cache文件</li>
</ul>
<h1 id="–cache-show"><a href="#–cache-show" class="headerlink" title="–cache-show"></a>–cache-show</h1><p>测试案例代码test_x.py</p>
<pre><code class="armasm"># test_x.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


def test_01():
    a = &quot;hello&quot;
    b = &quot;hello&quot;
    assert a == b


def test_02():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a == b


def test_03():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a in b


def test_04():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a not in b
</code></pre>
<p>命令行输入 运行完成后，会有2个用例失败，2个用例成功</p>
<pre><code class="diff">&gt;pytest test_x.py --tb=no
============================= test session starts =============================
collected 4 items

test_x.py .F.F                                                           [100%]

===================== 2 failed, 2 passed in 0.11 seconds ======================
</code></pre>
<p>运行完成后，会在当前的目录生成一个 <code>.pytest_cache</code> 的缓存文件夹,层级结构如下<br><img src="/assets/2/image-20220516013951-vgcsno0.png" alt="image.png"></p>
<p>lastfailed 文件记录上一次运行失败的用例</p>
<pre><code class="json">&#123;
  &quot;test_x.py::test_02&quot;: true,
  &quot;test_x.py::test_04&quot;: true
&#125;
</code></pre>
<p>nodeids 文件记录所有用例的节点</p>
<pre><code class="bash">[
  &quot;test_x.py::test_01&quot;,
  &quot;test_x.py::test_02&quot;,
  &quot;test_x.py::test_03&quot;,
  &quot;test_x.py::test_04&quot;
]
</code></pre>
<p>于是可以通过 pytest –cache-show 命令查看cache目录</p>
<pre><code class="rust">D:\soft\kecheng202004\xuexi&gt;pytest --cache-show
============================= test session starts =============================
cachedir: \.pytest_cache
---------------------------- cache values for &#39;*&#39; -----------------------------
cache\lastfailed contains:
  &#123;&#39;test_x.py::test_02&#39;: True, &#39;test_x.py::test_04&#39;: True&#125;
cache\nodeids contains:
  [&#39;test_x.py::test_01&#39;,
   &#39;test_x.py::test_02&#39;,
   &#39;test_x.py::test_03&#39;,
   &#39;test_x.py::test_04&#39;]
cache\stepwise contains:
  []

======================== no tests ran in 0.02 seconds =========================
</code></pre>
<h1 id="–cache-clear"><a href="#–cache-clear" class="headerlink" title="–cache-clear"></a>–cache-clear</h1><p>–cache-clear 用于在测试用例开始之前清空cache的内容</p>
<blockquote>
<p>pytest –cache-clear</p>
</blockquote>
<p>查看pytest关于cache的更多文档 <a href="https://docs.pytest.org/en/latest/cache.html">https://docs.pytest.org/en/latest/cache.html</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档52-命令行参数--setup-show查看fixture的执行过程</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A352-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--setup-show%E6%9F%A5%E7%9C%8Bfixture%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用命令行运行 pytest 用例的时候，看不到 fixture 的执行过程.<br>如果我们想知道fixture的执行过程和先后顺序，可以加上 <code>--setup-show</code> 命令行参数，帮助查看 fixture 的执行过程.</p>
<h1 id="–setup-show"><a href="#–setup-show" class="headerlink" title="–setup-show"></a>–setup-show</h1><p>案例参考test_s.py</p>
<pre><code class="python"># test_s.py
import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture()
def login():
    print(&quot;前置操作：准备数据&quot;)
    yield
    print(&quot;后置操作：清理数据&quot;)


def test_01(login):
    a = &quot;hello&quot;
    b = &quot;hello&quot;
    assert a == b


def test_02(login):
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a in b
</code></pre>
<p>命令行执行 pytest test_s.py</p>
<pre><code class="diff">&gt;pytest test_s.py
============================= test session starts =============================

collected 2 items

test_s.py ..                                                             [100%]

========================== 2 passed in 0.10 seconds ===========================
</code></pre>
<p>加上 <code>--setup-show</code> 命令行参数后执行</p>
<pre><code class="r">&gt;pytest test_s.py --setup-show
============================= test session starts =============================
collected 2 items

test_s.py
SETUP    S base_url
SETUP    S _verify_url (fixtures used: base_url)
        SETUP    F __pytest_repeat_step_number
        SETUP    F login
        test_s.py::test_01 (fixtures used: __pytest_repeat_step_number, _verify_url, base_url, login).
        TEARDOWN F login
        TEARDOWN F __pytest_repeat_step_number
        SETUP    F __pytest_repeat_step_number
        SETUP    F login
        test_s.py::test_02 (fixtures used: __pytest_repeat_step_number, _verify_url, base_url, login).
        TEARDOWN F login
        TEARDOWN F __pytest_repeat_step_number
TEARDOWN S _verify_url
TEARDOWN S base_url

========================== 2 passed in 0.04 seconds ===========================
</code></pre>
<p>这样就可以方便查看用例调用了哪些fixture，上面用例里面只写了一个<code>login</code>，<br>但是从回溯信息上看到还有几个是内置的fixture会自动调用：__pytest_repeat_step_number, _verify_url, base_url。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档53-命令行实时输出错误信息(pytest-instafail)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A353-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E6%97%B6%E8%BE%93%E5%87%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF(pytest-instafail)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 运行全部用例的时候，在控制台会先显示用例的运行结果(.或F), 用例全部运行完成后最后把报错信息全部一起抛出到控制台。<br>这样我们每次都需要等用例运行结束，才知道为什么报错，不方便实时查看报错信息。<br>pytest-instafail 插件可以在运行用例的时候，需实时查看用例报错内容，这样方便跟踪问题。</p>
<h1 id="–instafail"><a href="#–instafail" class="headerlink" title="–instafail"></a>–instafail</h1><p>执行全部用例，报错内容等用例运行完成才显示出来</p>
<pre><code class="markdown">&gt;pytest
============================= test session starts =============================

collected 11 items

test_s.py ..                                                             [ 18%]
test_t.py ...                                                            [ 45%]
test_x.py .F.F                                                           [ 81%]
test_y.py ..                                                             [100%]

================================== FAILURES ===================================
___________________________________ test_02 ___________________________________

    def test_02():
        a = &quot;hello&quot;
        b = &quot;hello world&quot;
&gt;       assert a == b
E       AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;
E         - hello
E         + hello world

test_x.py:12: AssertionError
___________________________________ test_04 ___________________________________

    def test_04():
        a = &quot;hello&quot;
        b = &quot;hello world&quot;
&gt;       assert a not in b
E       AssertionError: assert &#39;hello&#39; not in &#39;hello world&#39;
E         &#39;hello&#39; is contained here:
E           hello world

test_x.py:24: AssertionError
===================== 2 failed, 9 passed in 1.32 seconds ======================
</code></pre>
<p>当用例很多的时候，不方便我们查看具体哪个报错对应哪条用例，加上<code>--instafail</code>参数，方便实时查看报错内容</p>
<pre><code class="markdown">&gt;pytest --instafail
============================= test session starts =============================

collected 11 items

test_s.py ..                                                             [ 18%]
test_t.py ...                                                            [ 45%]
test_x.py .F

___________________________________ test_02 ___________________________________

    def test_02():
        a = &quot;hello&quot;
        b = &quot;hello world&quot;
&gt;       assert a == b
E       AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;
E         - hello
E         + hello world

test_x.py:12: AssertionError

test_x.py .F

___________________________________ test_04 ___________________________________

    def test_04():
        a = &quot;hello&quot;
        b = &quot;hello world&quot;
&gt;       assert a not in b
E       AssertionError: assert &#39;hello&#39; not in &#39;hello world&#39;
E         &#39;hello&#39; is contained here:
E           hello world

test_x.py:24: AssertionError

test_y.py ..                                                             [100%]

===================== 2 failed, 9 passed in 1.37 seconds ======================
</code></pre>
<p>结合<code>--tb=line</code>参数，看起来更直观</p>
<pre><code class="java">&gt;pytest --instafail --tb=line
============================= test session starts =============================
collected 11 items

test_s.py ..                                                             [ 18%]
test_t.py ...                                                            [ 45%]
test_x.py .F

D:\test_x.py:12: AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;

test_x.py .F

D:\test_x.py:24: AssertionError: assert &#39;hello&#39; not in &#39;hello world&#39;

test_y.py ..                                                             [100%]

===================== 2 failed, 9 passed in 1.30 seconds ======================
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档54-Hooks函数terminal打印测试结果(pytest_report_teststatus)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A354-Hooks%E5%87%BD%E6%95%B0terminal%E6%89%93%E5%8D%B0%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C(pytest_report_teststatus)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用命令行执行pytest用例的时候，会在 terminal 终端打印整个用例的测试结果：</p>
<ul>
<li>.代表通过的用例</li>
<li>F代表失败的用例</li>
<li>E代表异常的用例<br>如果我们不喜欢这种报告结果，可以通过 pytest_report_teststatus 钩子函数改变测试报告的内容，接下来试试吧.改成√，把F改成x，这样更直观。</li>
</ul>
<h1 id="pytest-report-teststatus"><a href="#pytest-report-teststatus" class="headerlink" title="pytest_report_teststatus"></a>pytest_report_teststatus</h1><p>pytest_report_teststatus(report, config): 返回各个测试阶段的result, 可以用when属性来区分不同阶段。</p>
<ul>
<li>when&#x3D;&#x3D;’setup’ 用例的前置操作</li>
<li>when&#x3D;&#x3D;’call’ 用例的执行</li>
<li>when&#x3D;&#x3D;’teardown’ 用例的后置操作</li>
</ul>
<p>运行案例test_x.py</p>
<pre><code class="armasm">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def test_01():
    a = &quot;hello&quot;
    b = &quot;hello&quot;
    assert a == b


def test_02():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a == b


def test_03():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a in b


def test_04():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a not in b
</code></pre>
<p>命令行执行<code>pytest test_x.py --tb=line</code></p>
<pre><code class="java">&gt;pytest test_x.py --tb=line
============================= test session starts =============================

collected 4 items

test_x.py .F.F                                                           [100%]

================================== FAILURES ===================================
D:\test_x.py:13: AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;
D:\test_x.py:25: AssertionError: assert &#39;hello&#39; not in &#39;hello world&#39;
===================== 2 failed, 2 passed in 0.07 seconds ======================
</code></pre>
<p>运行的结果是.和F,我们希望改成√和x,在conftest.py文件写钩子函数</p>
<pre><code class="python"># conftest.py
import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def pytest_report_teststatus(report, config):
    &#39;&#39;&#39;turn . into √，turn F into x&#39;&#39;&#39;
    if report.when == &#39;call&#39; and report.failed:
        return (report.outcome, &#39;x&#39;, &#39;failed&#39;)
    if report.when == &#39;call&#39; and report.passed:
        return (report.outcome, &#39;√&#39;, &#39;passed&#39;)
</code></pre>
<p>重新运行<code>pytest test_x.py --tb=line</code></p>
<pre><code class="verilog">&gt;pytest test_x.py --tb=line
collected 4 items

test_x.py √x√x                                                           [100%]

================================== FAILURES ===================================
D:\soft\kecheng202004\xuexi\test_x.py:13: AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;
D:\soft\kecheng202004\xuexi\test_x.py:25: AssertionError: assert &#39;hello&#39; not in &#39;hello world&#39;
===================== 2 failed, 2 passed in 0.07 seconds ======================
</code></pre>
<h1 id="关于Error异常"><a href="#关于Error异常" class="headerlink" title="关于Error异常"></a>关于Error异常</h1><p>前面这篇<a href="https://www.cnblogs.com/yoyoketang/p/12609871.html">https://www.cnblogs.com/yoyoketang/p/12609871.html</a>讲到关于测试用例的执行结果,<br>当 setup 出现异常的时候，用例才会Error,于是可以通过report.when &#x3D;&#x3D; ‘setup’ 判断到前置操作的结果</p>
<pre><code class="python"># test_x.py
import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.fixture()
def login():
    print(&quot;前置操作：准备数据&quot;)
    assert 1 == 2   # 前置出现异常
    yield
    print(&quot;后置操作：清理数据&quot;)


def test_01(login):
    a = &quot;hello&quot;
    b = &quot;hello&quot;
    assert a == b


def test_02():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a == b


def test_03():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a in b


def test_04():
    a = &quot;hello&quot;
    b = &quot;hello world&quot;
    assert a not in b
</code></pre>
<p>运行结果</p>
<pre><code class="markdown">&gt;pytest test_x.py --tb=line
============================= test session starts =============================

collected 4 items

test_x.py Ex√x                                                           [100%]

=================================== ERRORS ====================================
__________________________ ERROR at setup of test_01 __________________________
E   assert 1 == 2
---------------------------- Captured stdout setup ----------------------------
前置操作：准备数据
================================== FAILURES ===================================
D:\soft\kecheng202004\xuexi\test_x.py:21: AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;
D:\soft\kecheng202004\xuexi\test_x.py:33: AssertionError: assert &#39;hello&#39; not in &#39;hello world&#39;
================= 2 failed, 1 passed, 1 error in 0.09 seconds =================
</code></pre>
<p>当前置失败的时候，改成0</p>
<pre><code class="python"># conftest.py
import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


def pytest_report_teststatus(report, config):
    &#39;&#39;&#39;turn . into √，turn F into x, turn E into 0&#39;&#39;&#39;
    if report.when == &#39;call&#39; and report.failed:
        return (report.outcome, &#39;x&#39;, &#39;failed&#39;)
    if report.when == &#39;call&#39; and report.passed:
        return (report.outcome, &#39;√&#39;, &#39;passed&#39;)
    if report.when == &#39;setup&#39; and report.failed:
        return (report.outcome, &#39;0&#39;, &#39;error&#39;)
</code></pre>
<p>于是控制台的结果，就可以改了</p>
<pre><code class="verilog">&gt;pytest test_x.py --tb=line
============================= test session starts =============================

collected 4 items

test_x.py 0x√x                                                           [100%]

================================== FAILURES ===================================
D:\soft\kecheng202004\xuexi\test_x.py:7: assert 1 == 2
D:\soft\kecheng202004\xuexi\test_x.py:21: AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;
D:\soft\kecheng202004\xuexi\test_x.py:33: AssertionError: assert &#39;hello&#39; not in &#39;hello world&#39;
===================== 3 failed, 1 passed in 0.07 seconds ======================
</code></pre>
<p>skip的用例可以通过report.skiped获取到,可以这样写</p>
<pre><code class="kotlin">if report.skipped:
        return (report.outcome, &#39;/&#39;, &#39;skipped&#39;)
</code></pre>
<h1 id="report相关的属性"><a href="#report相关的属性" class="headerlink" title="report相关的属性"></a>report相关的属性</h1><p>report相关的属性，参考以下<br>‘_from_json’,<br>‘_get_verbose_word’,<br>‘_to_json’,<br>‘caplog’,<br>‘capstderr’,<br>‘capstdout’,<br>‘count_towards_summary’,<br>‘duration’,<br>‘failed’,<br>‘from_item_and_call’,<br>‘fspath’,<br>‘get_sections’,<br>‘head_line’,<br>‘keywords’,<br>‘location’,<br>‘longrepr’,<br>‘longreprtext’,<br>‘nodeid’,<br>‘outcome’,<br>‘passed’,<br>‘sections’,<br>‘skipped’,<br>‘toterminal’,<br>‘user_properties’,<br>‘when’</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档55-plugins插件开发</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A355-plugins%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面一篇已经学会了使用hook函数改变pytest运行的结果，代码写在conftest.py文件，实际上就是本地的插件了。<br>当有一天你公司的小伙伴觉得你写的还不错，或者更多的小伙伴想要你这个功能，于是你就想着放到github上，写成一个插件，方便小伙伴使用pip去安装。</p>
<h1 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h1><p>先新建一个工程，工程名称就是插件名称，一般以pytest-开头命名，目录结构如下</p>
<p><img src="/assets/2/image-20220516013721-oru1t3c.png" alt="image.png"></p>
<ul>
<li>setup.py 在安装python的相关模块和库时，我们一般使用<code>pip install 模块名</code>或者<code>python setup.py install</code>，前者是在线安装，会安装该包的相关依赖包；<br>后者是下载源码包然后在本地安装，不会安装该包的相关依赖包</li>
<li>README.rst README 文档，告诉用户如何使用你的插件，具体能实现什么功能</li>
<li>pytest_change_report.py 也就是之前conftest.py里面写的hook函数实现的功能</li>
<li>tests 用于测试本插件的相关功能，属于自测的内容</li>
<li>tests&#x2F;conftest.py 开启需要的插件pytester</li>
<li>tests&#x2F;test_change_report.py 测试插件的代码</li>
</ul>
<h1 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h1><p>在安装python的相关模块和库时，我们一般使用<code>pip install 模块名</code>或者<code>python setup.py install</code>，前者是在线安装，会安装该包的相关依赖包；<br>后者是下载源码包然后在本地安装，不会安装该包的相关依赖包.<br>setup.py 描述安装包相关的信息</p>
<pre><code class="python">from setuptools import setup

&quot;&quot;&quot;The setup script.
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/
&quot;&quot;&quot;

setup(
    name=&#39;pytest-change-report&#39;,
    url=&#39;https://github.com/yoyoketang/pytest-change-report&#39;,
    version=&#39;1.0&#39;,
    author=&quot;yoyo&quot;,
    author_email=&#39;283340479@qq.com&#39;,
    description=&#39;turn . into √，turn F into x&#39;,
    long_description=&#39;print result on terminal turn . into √，turn F into x using hook&#39;,
    classifiers=[
        &#39;Framework :: Pytest&#39;,
        &#39;Programming Language :: Python&#39;,
        &#39;Topic :: Software Development :: Testing&#39;,
        &#39;Programming Language :: Python :: 3.6&#39;,
    ],
    license=&#39;proprietary&#39;,
    py_modules=[&#39;pytest_change_report&#39;],
    keywords=[
        &#39;pytest&#39;, &#39;py.test&#39;, &#39;pytest-change-report&#39;,
    ],

    install_requires=[
        &#39;pytest&#39;
    ],
    entry_points=&#123;
        &#39;pytest11&#39;: [
            &#39;change-report = pytest_change_report&#39;,
        ]
    &#125;
)
</code></pre>
<h1 id="pytest-change-report-py"><a href="#pytest-change-report-py" class="headerlink" title="pytest_change_report.py"></a>pytest_change_report.py</h1><p>插件的核心功能，也就是之前在conftest.py用hook函数实现的功能。<br>我们现在实现的功能:<br>1.把测试的结果.改成√，F改成x<br>2.命令行加个<code>--change</code>参数开关，默认不开启，当加上参数&#96;–change on·的时候才生效</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


def pytest_addoption(parser):
    parser.addoption(
        &quot;--change&quot;,
        action=&quot;store&quot;,
        default=&quot;off&quot;,
        help=&quot;&#39;Default &#39;off&#39; for change, option: on or off&quot;
    )


def pytest_report_teststatus(report, config):
    &#39;&#39;&#39;turn . into √，turn F into x, turn E into 0&#39;&#39;&#39;
    if config.getoption(&quot;--change&quot;) == &quot;on&quot;:
        if report.when == &#39;call&#39; and report.failed:
            return (report.outcome, &#39;x&#39;, &#39;failed&#39;)
        if report.when == &#39;call&#39; and report.passed:
            return (report.outcome, &#39;√&#39;, &#39;passed&#39;)
</code></pre>
<h1 id="测试插件"><a href="#测试插件" class="headerlink" title="测试插件"></a>测试插件</h1><p>当插件功能实现完成后，需要在tests目录测试自己写的插件</p>
<p>tests&#x2F;conftest.py 文件开启pytester,专门用于测试插件的</p>
<pre><code class="python">&#39;&#39;&#39;pytester is needed for testing plgugins.&#39;&#39;&#39;


pytest_plugins = [&#39;pytester&#39;]
</code></pre>
<p>tests&#x2F;test_change_report.py 文件写测试用例</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def test_raw_report(testdir):
    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;
    # create a temporary pytest test file
    testdir.makepyfile(
        &quot;&quot;&quot;
        def test_01():
            a = &quot;hello&quot;
            b = &quot;hello&quot;
            assert a == b

        def test_02():
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
            assert a == b
         &quot;&quot;&quot;
            )

    # run all tests with pytest
    result = testdir.runpytest()

    # check that 1 test passed, 1 test failed.
    result.assert_outcomes(passed=1, failed=1)
    result.stdout.fnmatch_lines([&quot;*.F*&quot;, ])

def test_change_on_report(testdir):
    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;
    # create a temporary pytest test file
    testdir.makepyfile(
        &quot;&quot;&quot;
        def test_01():
            a = &quot;hello&quot;
            b = &quot;hello&quot;
            assert a == b

        def test_02():
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
            assert a == b
         &quot;&quot;&quot;
            )

    # run all tests with pytest
    result = testdir.runpytest(&quot;--change&quot;, &quot;on&quot;)

    # check that 1 test passed, 1 test failed.
    result.stdout.fnmatch_lines([&#39;*√x*&#39;, ])


def test_change_off_report(testdir):
    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;
    # create a temporary pytest test file
    testdir.makepyfile(
        &quot;&quot;&quot;
        def test_01():
            a = &quot;hello&quot;
            b = &quot;hello&quot;
            assert a == b

        def test_02():
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
            assert a == b
         &quot;&quot;&quot;
            )

    # run all tests with pytest
    result = testdir.runpytest(&quot;--change&quot;, &quot;off&quot;)

    # check that 1 test passed, 1 test failed.
    result.stdout.fnmatch_lines([&#39;*.F*&#39;, ])


def test_change_default_report(testdir):
    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;
    # create a temporary pytest test file
    testdir.makepyfile(
        &quot;&quot;&quot;
        def test_01():
            a = &quot;hello&quot;
            b = &quot;hello&quot;
            assert a == b

        def test_02():
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
            assert a == b
         &quot;&quot;&quot;
            )

    # run all tests with pytest
    result = testdir.runpytest(&quot;--change&quot;)

    # check stderr pytest: error: argument --change: expected one argument
    result.stderr.fnmatch_lines([&#39;*argument --change: expected one argument*&#39;, ])


def test_verbose_report(testdir):
    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;
    # create a temporary pytest test file
    testdir.makepyfile(
        &quot;&quot;&quot;
        def test_01():
            a = &quot;hello&quot;
            b = &quot;hello&quot;
            assert a == b

        def test_02():
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
            assert a == b
         &quot;&quot;&quot;
            )

    # run all tests with pytest
    result = testdir.runpytest(&quot;-v&quot;)

    # check that 1 test passed, 1 test failed.
    result.stdout.fnmatch_lines([&#39;*::test_01 PASSED*&#39;, &#39;*::test_02 FAILED*&#39;])



def test_change_verbose_report(testdir):
    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;
    # create a temporary pytest test file
    testdir.makepyfile(
        &quot;&quot;&quot;
        def test_01():
            a = &quot;hello&quot;
            b = &quot;hello&quot;
            assert a == b

        def test_02():
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
            assert a == b
         &quot;&quot;&quot;
            )

    # run all tests with pytest
    result = testdir.runpytest(&quot;--change&quot;, &quot;on&quot;, &quot;-v&quot;)

    # check that 1 test passed, 1 test failed.
    result.stdout.fnmatch_lines([&#39;*::test_01 passed*&#39;, &#39;*::test_02 failed*&#39;])


def test_help(testdir):
    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;
    # create a temporary pytest test file
    testdir.makepyfile(
        &quot;&quot;&quot;
        def test_01():
            a = &quot;hello&quot;
            b = &quot;hello&quot;
            assert a == b
         &quot;&quot;&quot;
            )

    # run all tests with pytest
    result = testdir.runpytest(&quot;--help&quot;)

    # check --help
    result.stdout.fnmatch_lines([&quot;*--change=*&quot;, ])
</code></pre>
<h1 id="本地安装插件"><a href="#本地安装插件" class="headerlink" title="本地安装插件"></a>本地安装插件</h1><p>cd到插件的项目目录，使用pip安装</p>
<blockquote>
<p>pip install .</p>
</blockquote>
<pre><code class="powershell">&gt;pip install .
Processing d:\soft\pytest-change-report
Using legacy setup.py install for pytest-change-report, since package &#39;wheel&#39; is not installed.
Installing collected packages: pytest-change-report
  Attempting uninstall: pytest-change-report
    Found existing installation: pytest-change-report 1.0
    Uninstalling pytest-change-report-1.0:
      Successfully uninstalled pytest-change-report-1.0
    Running setup.py install for pytest-change-report ... done
Successfully installed pytest-change-report-1.0
</code></pre>
<p>安装完成后，在cmd输入 pip show pytest-change-report就可以看到前面setup.py里面的描述内容</p>
<pre><code class="makefile">&gt;pip show pytest-change-report
Name: pytest-change-report
Version: 1.0
Summary: turn . into √，turn F into x
Home-page: https://github.com/yoyoketang/pytest-change-report
Author: yoyo
Author-email: 283340479@qq.com
License: proprietary
Location: e:\python36\lib\site-packages\pytest_change_report-1.0-py3.6.egg
Requires: pytest
Required-by:
</code></pre>
<p>安装完成后，输入pytest测试tests&#x2F;test_change_report.py</p>
<pre><code class="diff">&gt;pytest
============================= test session starts =============================

collected 7 items

tests\test_change_report.py .......                                      [100%]

========================== 7 passed in 0.89 seconds ===========================
</code></pre>
<p>测试文件里面的用例全部通过</p>
<h1 id="README-rst"><a href="#README-rst" class="headerlink" title="README.rst"></a>README.rst</h1><p>最后需要写个 README.rst 使用教程文档，这样你写的插件就能被其它小伙伴学习和使用了。</p>
<pre><code class="csharp">==============
pytest-change-report: pytest plugin
==============


**This pytest plugin turn . into √，turn F into x**


Usage
=====

从github源码安装

   pip install git+https://github.com/yoyoketang/pytest-change-report.git

命令行运行示例

   pytest --change on


demo
====

先写pytest用例test_demo.py

    def test_01():
        a = &quot;hello&quot;
        b = &quot;hello&quot;
        assert a == b


    def test_02(login):
        a = &quot;hello&quot;
        b = &quot;hello world&quot;
        assert a == b

命令行执行pytest, 默认不会改变之前的报告内容

    &gt;pytest test_demo.py
    ============================= test session starts =============================
    collected 2 items

    test_demo.py .F                                                          [100%]

    ================================== FAILURES ===================================
    ___________________________________ test_02 ___________________________________

        def test_02():
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
    &gt;       assert a == b
    E       AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;
    E         - hello
    E         + hello world

    test_demo.py:10: AssertionError
    ===================== 1 failed, 1 passed in 0.11 seconds ======================

加上 --change on 参数后运行

    &gt;pytest test_demo.py --change on
    ============================= test session starts =============================
    collected 2 items

    test_demo.py √x                                                          [100%]

    ================================== FAILURES ===================================
    ___________________________________ test_02 ___________________________________

        def test_02():
            a = &quot;hello&quot;
            b = &quot;hello world&quot;
    &gt;       assert a == b
    E       AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;
    E         - hello
    E         + hello world

    test_demo.py:10: AssertionError
    ===================== 1 failed, 1 passed in 0.08 seconds ======================



pytest.ini
==========

可以添加到pytest.ini配置文件，这样默认就会带上--change参数

      [pytest]
      --change = on

# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/
</code></pre>
<h1 id="提交github"><a href="#提交github" class="headerlink" title="提交github"></a>提交github</h1><p>最后把插件代码提交到github仓库，方便下载<a href="https://github.com/yoyoketang/pytest-change-report">https://github.com/yoyoketang/pytest-change-report</a></p>
<p><img src="/assets/2/image-20220516013742-6wff5ee.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档56-插件打包上传到 pypi 库</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A356-%E6%8F%92%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%88%B0%20pypi%20%E5%BA%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 的插件完成之后，可以上传到 github，方便其他小伙伴通过 pip 源码安装。如果我们想通过 <code>pip install packages</code> 这种方式安装的话，需上传到 pypi 仓库</p>
<h1 id="pypi仓库"><a href="#pypi仓库" class="headerlink" title="pypi仓库"></a>pypi仓库</h1><p>pip，全称是：python install packages，它是一个通用的 Python 包管理工具，是easy_install的替代品, 主要是用于安装 PyPI 上的软件包。<br>PyPI，全称是：Python Package Index，它是Python官方的第三方库的仓库，所有人都可以下载第三方库或上传自己开发的库到PyPI。<br>PyPI推荐使用pip包管理器来下载第三方库。</p>
<p>我们想把python包上传到pypi,需在 <a href="https://pypi.org/">https://pypi.org/</a> 注册一个账号</p>
<p><img src="/assets/2/image-20220516013547-usjebga.png" alt="image.png"></p>
<h1 id="整理项目结构"><a href="#整理项目结构" class="headerlink" title="整理项目结构"></a>整理项目结构</h1><p>前面这篇<a href="https://www.cnblogs.com/yoyoketang/p/13638661.html">https://www.cnblogs.com/yoyoketang/p/13638661.html</a>pytest 插件的开发，就是一个半成品了</p>
<p>整个目录结构如下</p>
<pre><code class="markdown">pytest-change-report
├── LICENSE
├── README.rst
├── requirements.txt
├── setup.py
├── pytest_change_report.py
├── tests
│   ├──__init__.py
│   ├──conftest.py
│   └──test_change_report.py
</code></pre>
<ul>
<li>pytest-change-report 是项目的包名</li>
<li>LICENSE LICENSE文件是授权文件，比如：MIT license， APACHE license</li>
<li>requirements.txt 依赖包，比如这个插件依赖pytest模块，可以写pytest&#x3D;&#x3D;4.5.0</li>
<li>README.rst 其实就是项目介绍和使用说明帮助文档</li>
<li>setup.py python模块安装所需要的文件</li>
<li>tests 是测试的目录</li>
<li>pytest_change_report.py 插件实现功能的核心模块</li>
</ul>
<p>代码写完测试没问题后，上传到github仓库，并打个v1.0的标签<br><img src="/assets/2/image-20220516013556-80bz1es.png" alt="image.png"><br>打完 tag 标签，push 到 github 仓库，这样在 tag 目录就能看到 release 的记录了<br><img src="/assets/2/image-20220516013603-anemu9c.png" alt="image.png"></p>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>cd到项目的根目录，执行</p>
<blockquote>
<p>python setup.py sdist build</p>
</blockquote>
<p>执行完成后，在dist目录，会生成一个.tar.gz的压缩包，这个压缩包就可以通过 pip 安装了</p>
<p><img src="/assets/2/image-20220516013609-4l2x0gw.png" alt="image.png"></p>
<p>也可以打包一个wheels格式的包，需要安装wheel包：</p>
<blockquote>
<p>pip install wheel</p>
</blockquote>
<p>执行以下命令打包</p>
<blockquote>
<p>python setup.py bdist_wheel –universal</p>
</blockquote>
<p>这样在dist目录生成一个 pytest_change_report-1.0-py2.py3-none-any.whl 文件，.whl 后置的文件也可以通过 pip 直接安装</p>
<h1 id="上传发布"><a href="#上传发布" class="headerlink" title="上传发布"></a>上传发布</h1><p>使用twine上传,先安装twine</p>
<blockquote>
<p>pip install twine</p>
</blockquote>
<p>上传输入指令，接着会提示输入账号和密码</p>
<blockquote>
<p>twine upload dist&#x2F;*</p>
</blockquote>
<pre><code class="shell">&gt;twine upload dist/*
Uploading distributions to https://upload.pypi.org/legacy/
Enter your username: yoyoketang
Enter your password:
Uploading pytest_change_report-1.0-py2.py3-none-any.whl
100%|█████████████████████████████████████████████████████████ ████████████████████| 5.56k/5.56k [00:00&lt;00:00, 6.17kB/s]
Uploading pytest-change-report-1.0.tar.gz
100%|█████████████████████████████████████████████████████████ ████████████████████| 5.15k/5.15k [00:01&lt;00:00, 4.71kB/s]

View at:
https://pypi.org/project/pytest-change-report/1.0/
</code></pre>
<p>上传后访问地址 <a href="https://pypi.org/project/pytest-change-report/1.0/">https://pypi.org/project/pytest-change-report/1.0/</a></p>
<h1 id="查看pypi"><a href="#查看pypi" class="headerlink" title="查看pypi"></a>查看pypi</h1><p>打开上面的访问地址可以查看到已经上传成功<br><img src="/assets/2/image-20220516013621-wdscgqx.png" alt="image.png"></p>
<p>点 Homepage 可以跳转到 github 仓库去</p>
<p>这样小伙伴们就能直接使用 pip 安装了</p>
<blockquote>
<p>pip install pytest-change-report</p>
</blockquote>
<p>python 打包发布到 pypi 的就完成了，是不是很激动！</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档57-计算单元测试代码覆盖率(pytest-cov)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A357-%E8%AE%A1%E7%AE%97%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87(pytest-cov)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在做测试的时候，经常遇到领导的灵魂拷问：你的测试用例覆盖率是多少，达到100%了么？你如何保证你的测试质量？<br>测试用例的覆盖率如何统计呢，如何知道开发的代码，我们都测到了，不会存在漏测的情况。</p>
<h1 id="pytest-cov"><a href="#pytest-cov" class="headerlink" title="pytest-cov"></a>pytest-cov</h1><p>先命令行安装 pytest-cov 2.10.1版本</p>
<blockquote>
<p>pip install pytest-cov&#x3D;&#x3D;2.10.1</p>
</blockquote>
<p>环境要求：<br>1.python3.6.6 版本<br>备注：其它版本没试过</p>
<p>python3.6.0会遇到以下问题</p>
<pre><code class="rust">INTERNALERROR&gt;raise CoverageException(&quot;Couldn&#39;t use data file &#123;!r&#125;:&#123;&#125;&quot;.format(self.filename, msg))
INTERNALERROR&gt; coverage.misc.CoverageException: Couldn&#39;t use data file&#39;C:\\Users\\Desktop\\Pytest\\.coverage&#39;: 
Safety level may not be changed inside a transaction
</code></pre>
<p>解决办法：安装3.6.1以上版本</p>
<h1 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h1><p>在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，<br>比如，代码覆盖率必须达到80％或 90％。于是乎，测试人员费尽心思设计案例覆盖代码。<br>单元测试的方法有：语句覆盖&#x2F;判定覆盖&#x2F;条件覆盖&#x2F;路径覆盖</p>
<p>先看一个简单的案例，前端实现一个功能，根据接口返回的不同code值，判断支付的结果，给用户返回提示友好的信息</p>
<pre><code class="css">前端实现功能：根据接口返回的不同code值，判断支付的结果，给用户返回提示友好的信息
接口返回格式：
&#123;
    &quot;code&quot;: 0,
    &quot;msg&quot;: &quot;success!&quot;,
    &quot;data&quot;: []
&#125;

错误码参照
0 - 成功
30000 - 参数错误
30001 - 余额不足
30002 - 达到当天最大额度
201102 - 银行卡被冻结
</code></pre>
<p>实现代码</p>
<pre><code class="python">
&#39;&#39;&#39;
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/
接口返回格式
&#123;
    &quot;code&quot;: 0,
    &quot;msg&quot;: &quot;success!&quot;,
    &quot;data&quot;: []
&#125;

错误码参照
0 - 成功
30000 - 参数错误
30001 - 余额不足
30002 - 达到当天最大额度
201102 - 银行卡被冻结
&#39;&#39;&#39;
# pay.py
def pay_status(result):
    &#39;&#39;&#39;根据接口返回code状态，给用户提示对应的结果&#39;&#39;&#39;
    if result.get(&quot;code&quot;) == 0:
        return &quot;支付成功&quot;
    elif result.get(&quot;code&quot;) == 30000:
        return &quot;支付失败: %s&quot; % result.get(&quot;msg&quot;)
    elif result.get(&quot;code&quot;) == 30001:
        return &quot;支付失败: %s&quot; % result.get(&quot;msg&quot;)
    elif result.get(&quot;code&quot;) == 30002:
        return &quot;支付失败: %s&quot; % result.get(&quot;msg&quot;)
    elif result.get(&quot;code&quot;) == 201102:
        return &quot;支付失败: %s&quot; % result.get(&quot;msg&quot;)
    else:
        return &quot;支付失败: 系统异常，未知错误&quot;
</code></pre>
<p>整个项目目录结构如下</p>
<ul>
<li>src 是项目的源码</li>
<li>tests 是我们写的单元测试用例</li>
<li>src和tests放同一个项目的根目录下<br><img src="/assets/2/image-20220516013401-smr4gd9.png" alt="image.png"></li>
</ul>
<h1 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h1><p>在tests&#x2F;test_pay.py下写测试用例,先只写一个支付成功的案例</p>
<pre><code class="cpp">from src.pay import pay_status
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


def test_pay_success():
    result = &#123;
            &quot;code&quot;: 0,
            &quot;msg&quot;: &quot;success!&quot;,
            &quot;data&quot;: []
        &#125;
    assert pay_status(result) == &quot;支付成功&quot;
</code></pre>
<h1 id="运行用例"><a href="#运行用例" class="headerlink" title="运行用例"></a>运行用例</h1><p>运行用例的时候加上 –cov 参数</p>
<blockquote>
<p>pytest –cov</p>
</blockquote>
<p>运行结果</p>
<pre><code class="vhdl">&gt;pytest --cov
================================================= test session starts =================================================
platform win32 -- Python 3.6.6, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: D:\soft\pytest-demo-cov
plugins: change-report-1.0, cov-2.10.1, html-1.19.0, metadata-1.8.0
collected 1 item

tests\test_pay.py .                                                                                              [100%]

----------- coverage: platform win32, python 3.6.6-final-0 -----------
Name                Stmts   Miss  Cover
---------------------------------------
src\__init__.py         0      0   100%
src\pay.py             13      9    31%
tests\__init__.py       0      0   100%
tests\test_pay.py       4      0   100%
---------------------------------------
TOTAL                  17      9    47%


================================================== 1 passed in 0.10s ==================================================
</code></pre>
<p>从报告可以看出src\pay.py 的代码测试覆盖率是31%，其它文件都是100%覆盖，这就说明我们单元测试代码测试覆盖率是31%<br>还有一个指标是 <strong>测试用例的执行率</strong> ，测试用例在test_pay.py文件，执行率是100%，说明用例全部执行了。</p>
<h1 id="coverage生成html报告"><a href="#coverage生成html报告" class="headerlink" title="coverage生成html报告"></a>coverage生成html报告</h1><p>coverage 相关参数查看，使用pytest -h</p>
<pre><code class="vhdl">&gt; pytest -h
coverage reporting with distributed testing support:
  --cov=[SOURCE]        Path or package name to measure during execution (multi-allowed). Use --cov= to not do any
                        source filtering and record everything.
  --cov-report=TYPE     Type of report to generate: term, term-missing, annotate, html, xml (multi-allowed). term, term-
                        missing may be followed by &quot;:skip-covered&quot;. annotate, html and xml may be followed by &quot;:DEST&quot;
                        where DEST specifies the output location. Use --cov-report= to not generate any output.
  --cov-config=PATH     Config file for coverage. Default: .coveragerc
  --no-cov-on-fail      Do not report coverage if test run fails. Default: False
  --no-cov              Disable coverage report completely (useful for debuggers). Default: False
  --cov-fail-under=MIN  Fail if the total coverage is less than MIN.
  --cov-append          Do not delete coverage but append to current. Default: False
  --cov-branch          Enable branch coverage.
  --cov-context=CONTEXT
                        Dynamic contexts to use. &quot;test&quot; for now.
</code></pre>
<p>生成html的报告</p>
<blockquote>
<p>pytest –cov –cov-report&#x3D;html</p>
</blockquote>
<p>执行完成，在项目根目录会生成 htmlcov 目录</p>
<p><img src="/assets/2/image-20220516013411-2t4xqcx.png" alt="image.png"></p>
<p>运行 index.html 文件查看代码覆盖率</p>
<p><img src="/assets/2/image-20220516013417-u7bccyr.png" alt="image.png"></p>
<p>点开src\pay.py</p>
<p><img src="/assets/2/image-20220516013424-w56kw1s.png" alt="image.png"></p>
<p>想覆盖率达到100%，那得再继续写用例，让每个if分支情况都覆盖到</p>
<h1 id="指定被测代码"><a href="#指定被测代码" class="headerlink" title="指定被测代码"></a>指定被测代码</h1><p>如果我们想指定执行项目里面的某个模块，可以通过–cov&#x3D;模块 来运行</p>
<blockquote>
<p>pytest –cov&#x3D;src</p>
</blockquote>
<pre><code class="vhdl">&gt;pytest --cov=src
================================================= test session starts =================================================
platform win32 -- Python 3.6.6, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: D:\soft\pytest-demo-cov
plugins: change-report-1.0, cov-2.10.1, html-1.19.0, metadata-1.8.0
collected 1 item

tests\test_pay.py .                                                                                              [100%]

----------- coverage: platform win32, python 3.6.6-final-0 -----------
Name              Stmts   Miss  Cover
-------------------------------------
src\__init__.py       0      0   100%
src\pay.py           13      9    31%
-------------------------------------
TOTAL                13      9    31%


================================================== 1 passed in 0.07s ==================================================
</code></pre>
<p>也可以指定具体的py模块名称</p>
<blockquote>
<p>pytest –cov&#x3D;src.pay</p>
</blockquote>
<p>但不能写成<code>pytest --cov=src/pay.py</code></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档58-随机执行测试用例(pytest-random-order)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A358-%E9%9A%8F%E6%9C%BA%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B(pytest-random-order)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常我们认为每个测试用例都是相互独立的，因此需要保证测试结果不依赖于测试顺序，以不同的顺序运行测试用例，可以得到相同的结果。<br>pytest默认运行用例的顺序是按模块和用例命名的 ASCII 编码顺序执行的，这就意味着每次运行用例的顺序都是一样的。<br>app 测试里面有个 monkey 测试，随机在页面点点点，不按常理的点点点能找到更多的不稳定性 bug。那么我们在写pytest用例的时候，既然每个用例都是相互独立的，<br>那就可以打乱用例的顺序随机执行，用到 pytest 的插件 pytest-random-order 可以实现此目的，github 地址<a href="https://github.com/jbasko/pytest-random-order">https://github.com/jbasko/pytest-random-order</a></p>
<h1 id="pytest-random-order-插件"><a href="#pytest-random-order-插件" class="headerlink" title="pytest-random-order 插件"></a>pytest-random-order 插件</h1><p>pytest-random-order是一个pytest插件，用于随机化测试顺序。这对于检测通过的测试可能是有用的，因为该测试恰好在不相关的测试之后运行，从而使系统处于良好状态。<br>该插件允许用户控制他们想要引入的随机性级别，并禁止对测试子集进行重新排序。通过传递先前测试运行中报告的种子值，可以按特定顺序重新运行测试。<br><img src="/assets/2/image-20220516013239-698u34c.png" alt="image.png"></p>
<p>使用pip安装</p>
<blockquote>
<p>pip install pytest-random-order</p>
</blockquote>
<p>在pytest -h查看，命令行可以有三个参数选择</p>
<pre><code class="mipsasm">pytest-random-order options:
  --random-order        Randomise test order (by default, it is disabled) with default configuration.
  --random-order-bucket=&#123;global,package,module,class,parent,grandparent,none&#125;
                        Randomise test order within specified test buckets.
  --random-order-seed=RANDOM_ORDER_SEED
                        Randomise test order using a specific seed.
</code></pre>
<p>从v1.0.0开始，默认情况下，此插件不再将测试随机化。要启用随机化，您必须以下列方式之一运行pytest：</p>
<pre><code class="mipsasm">pytest --random-order
pytest --random-order-bucket=&lt;bucket_type&gt;
pytest --random-order-seed=&lt;seed&gt;
</code></pre>
<p>如果要始终随机化测试顺序，请配置pytest。有很多方法可以做到这一点，我最喜欢的一种方法是addopts &#x3D; –random-order在pytest选项（通常是[pytest]或[tool:pytest]部分）下添加特定于项目的配置文件。</p>
<pre><code class="ini"># pytest.ini文件内容
[pytest]
addopts = --random-order
</code></pre>
<h1 id="–random-order-随机测试"><a href="#–random-order-随机测试" class="headerlink" title="–random-order 随机测试"></a>–random-order 随机测试</h1><p>先写几个简单的用例，目录结构如下<br><img src="/assets/2/image-20220516013247-b6rzntb.png" alt="image.png"></p>
<p>module1&#x2F;test_order1.py内容</p>
<pre><code class="python"># module1/test_order1.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


class TestRandom():

    def test_01(self):
        print(&quot;用例1&quot;)

    def test_02(self):
        print(&quot;用例2&quot;)

    def test_03(self):
        print(&quot;用例3&quot;)
</code></pre>
<p>module2&#x2F;test_order2.py内容</p>
<pre><code class="python"># module2/test_order2.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


class TestDemo():

    def test_04(self):
        print(&quot;用例4&quot;)

    def test_05(self):
        print(&quot;用例5&quot;)

    def test_06(self):
        print(&quot;用例6&quot;)
</code></pre>
<p>带上<code>--random-order</code>参数运行用例</p>
<pre><code class="ruby">&gt;pytest --random-order -v
================================================= test session starts =================================================
Using --random-order-bucket=module
Using --random-order-seed=357703
collected 6 items

module2/test_order2.py::TestDemo::test_04 PASSED                                                                 [ 16%]
module2/test_order2.py::TestDemo::test_05 PASSED                                                                 [ 33%]
module2/test_order2.py::TestDemo::test_06 PASSED                                                                 [ 50%]
module1/test_order1.py::TestRandom::test_03 PASSED                                                               [ 66%]
module1/test_order1.py::TestRandom::test_02 PASSED                                                               [ 83%]
module1/test_order1.py::TestRandom::test_01 PASSED                                                               [100%]

================================================== 6 passed in 0.05s ==================================================
</code></pre>
<p>从运行的结果可以看出，默认使用<code>--random-order-bucket=module</code>,模块下的用例会被打乱随机执行，每次运行会重新生成<code>--random-order-seed=357703</code>,seed值不一样，用例的顺序也会不一样</p>
<h1 id="–random-order-bucket-随机范围"><a href="#–random-order-bucket-随机范围" class="headerlink" title="–random-order-bucket 随机范围"></a>–random-order-bucket 随机范围</h1><p>要更改重新排序与范围，运行pytest –random-order-bucket&#x3D;选项，其中可以是global,package,module,class,parent,grandparent：</p>
<p>插件组在存储桶中进行测试，在存储桶中进行混洗，然后对存储桶进行混洗，设计原理如图</p>
<p><img src="/assets/2/image-20220516013256-3pd29dg.png" alt="image.png"></p>
<p>给定上面的测试套件，以下是一些可能生成的测试顺序中的两个：</p>
<p><img src="/assets/2/image-20220516013302-8cxglx8.png" alt="image.png"></p>
<p>可以从以下几种类型的存储桶中进行选择：</p>
<ul>
<li>class 测试将在一个类中进行混洗，而各类将被混洗，但是来自一个类的测试将永远不会在其他类或模块之间运行来自其他类的测试。</li>
<li>module 模块级别。如果仅使用–random-order运行pytest，同时带上参数–random-order-seed&#x3D;。</li>
<li>package 程序包级别。请注意，属于package的模块（以及这些模块内的测试）x.y.z不属于package x.y，因此在对存储package桶类型进行随机分配时，它们将落入不同的存储桶中。</li>
<li>parent 如果使用的是不属于任何模块的自定义测试项，则可以使用此项将测试项的重新排序限制在它们所属的父级中。对于正常测试函数，父级是声明它们的模块。</li>
<li>grandparent 类似于上面的parent，但是使用测试项的父级作为bucket key。</li>
<li>global 所有测试属于同一存储桶，完全随机，测试可能需要更长的时间才能运行。</li>
<li>none (已弃用) 禁用混洗。自1.0.4起不推荐使用，因为此插件默认不再重做测试，因此没有禁用的功能。</li>
</ul>
<p>如果你有测试三个桶A，B和C三个测试1和2，并3在他们每个人，那么许多潜在的排序的一个非全局随机化可以产生可能是：</p>
<blockquote>
<p>c2，c1，c3，a3，a1，a2，b3，b2，b1</p>
</blockquote>
<p>运行示例，带上参数<code>--random-order-bucket=global</code>,所有的用例都会被打乱。</p>
<pre><code class="php">&gt;pytest --random-order -v --random-order-bucket=global
================================================= test session starts =================================================
Using --random-order-bucket=global
Using --random-order-seed=255529

collected 6 items

module1/test_order1.py::TestRandom::test_02 PASSED                                                               [ 16%]
module1/test_order1.py::TestRandom::test_01 PASSED                                                               [ 33%]
module2/test_order2.py::TestDemo::test_06 PASSED                                                                 [ 50%]
module2/test_order2.py::TestDemo::test_04 PASSED                                                                 [ 66%]
module2/test_order2.py::TestDemo::test_05 PASSED                                                                 [ 83%]
module1/test_order1.py::TestRandom::test_03 PASSED                                                               [100%]

================================================== 6 passed in 0.05s ==================================================
</code></pre>
<p>最好从最小的存储桶类型开始（class或module取决于您是否有基于类的测试），并在确定测试可以处理较大的存储桶类型时切换为更大的存储桶类型。<br>如果您的测试依赖模块或会话范围的fixture，则测试的随机性越高，测试速度就越慢。您可能不想在编码时随机global或随机分组，package并且需要快速确认没有什么大问题。&#96;&#96;</p>
<h1 id="模块或类中禁用随机"><a href="#模块或类中禁用随机" class="headerlink" title="模块或类中禁用随机"></a>模块或类中禁用随机</h1><p>如果我们在一个模块或类中，不想让里面的用例随机，可以设置 <code>disabled=True</code> 来禁用随机参数</p>
<pre><code class="python"># 写在.py文件最上面即可
pytestmark = pytest.mark.random_order(disabled=True)

def test_number_one():
    assert True

def test_number_two():
    assert True
</code></pre>
<p>也可以写在class里面</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


class TestRandom():
    pytestmark = pytest.mark.random_order(disabled=True)

    def test_01(self):
        print(&quot;用例1&quot;)

    def test_02(self):
        print(&quot;用例2&quot;)

    def test_03(self):
        print(&quot;用例3&quot;)
</code></pre>
<p>这样在执行的时候，TestRandom里面的用例顺序就是test_01，test_02，test_03不会被打乱</p>
<h1 id="–random-order-seed-随机种子"><a href="#–random-order-seed-随机种子" class="headerlink" title="–random-order-seed 随机种子"></a>–random-order-seed 随机种子</h1><p>如果由于重新排序测试而发现测试失败，则可能希望能够以相同的失败顺序重新运行测试。为了允许重现测试订单，该插件报告其与伪随机数生成器一起使用的种子值：</p>
<pre><code class="vbnet">============================= test session starts ==============================
..
Using --random-order-bucket=module
Using --random-order-seed=24775
...
</code></pre>
<p>现在，您可以使用该–random-order-seed&#x3D;…位作为下一次运行的参数以产生相同的顺序：</p>
<blockquote>
<p>pytest -v –random-order-seed &#x3D; 24775</p>
</blockquote>
<h1 id="禁用插件"><a href="#禁用插件" class="headerlink" title="禁用插件"></a>禁用插件</h1><p>如果你觉得这个插件不好用，或者对你的其它功能会有影响，则可以将其禁用</p>
<blockquote>
<p>pytest -p no：random_order</p>
</blockquote>
<p>请注意，默认情况下禁用随机化。通过传递，-p no:random_order您将阻止插件的注册，因此其钩子将不会被注册，并且命令行选项也不会出现在中–help</p>
<h1 id="首先运行最后失败的测试"><a href="#首先运行最后失败的测试" class="headerlink" title="首先运行最后失败的测试"></a>首先运行最后失败的测试</h1><p>另外 <code>--failed-first</code> 标志-上一次运行失败的测试将在通过测试之前运行，而不管改组存储桶类型如何。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档59-运行未提交git的用例(pytest-picked)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A359-%E8%BF%90%E8%A1%8C%E6%9C%AA%E6%8F%90%E4%BA%A4git%E7%9A%84%E7%94%A8%E4%BE%8B(pytest-picked)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们每天写完自动化用例后都会提交到 git 仓库，随着用例的增多，为了保证仓库代码的干净，当有用例新增的时候，我们希望只运行新增的未提交 git 仓库的用例。<br>pytest-picked 插件可以实现只运行未提交到git仓库的代码。</p>
<h1 id="pytest-picked"><a href="#pytest-picked" class="headerlink" title="pytest-picked"></a>pytest-picked</h1><p>使用命令行安装</p>
<blockquote>
<p>pip install pytest-picked</p>
</blockquote>
<p>可使用参数</p>
<pre><code class="vhdl">picked:
  --picked=[&#123;only,first&#125;]
                        Run the tests related to the changed files either on their own, or first
  --mode=PICKED_MODE    Options: unstaged, branch
</code></pre>
<p>使用示例：</p>
<pre><code class="ruby">$ pytest --picked

$ pytest --picked=first

$ pytest --picked --mode=branch

$ pytest --picked --mode=unstaged  # default
</code></pre>
<p>github仓库地址<a href="https://github.com/anapaulagomes/pytest-picked">https://github.com/anapaulagomes/pytest-picked</a></p>
<h1 id="–picked-参数"><a href="#–picked-参数" class="headerlink" title="–picked 参数"></a>–picked 参数</h1><p>我们在已提交过 git 仓库的用例里面新增了 2 个文件 test_new.py 和 test_new_2.py</p>
<p><img src="/assets/2/image-20220516013155-8fbanan.png" alt="image.png"></p>
<p>cd到项目根目录，使用 <code>git status</code> 查看当前分支状态</p>
<pre><code class="vhdl"># 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

&gt;git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   pytest_demo/test_new.py
        new file:   pytest_demo/test_new_2.py

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   pytest_demo/test_new.py
        modified:   pytest_demo/test_new_2.py
</code></pre>
<p>可以看到有2个文件，使用 <code>pytest --picked</code> 运行用例</p>
<pre><code class="sql">&gt;pytest --picked

Changed test files... 2. [&#39;pytest_demo/test_new.py&#39;, &#39;pytest_demo/test_new_2.py&#39;]
Changed test folders... 0. []
================================================= test session starts =================================================
platform win32 -- Python 3.6.6, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
Test order randomisation NOT enabled. Enable with --random-order or --random-order-bucket=&lt;bucket_type&gt;
rootdir: D:\demo\code\xuexi_pytest
collected 4 items

pytest_demo\test_new.py ..                                                                                       [ 50%]
pytest_demo\test_new_2.py ..                                                                                     [100%]
================================================== 4 passed in 0.20s ==================================================
</code></pre>
<p>所有测试都将从已修改但尚未提交的文件和文件夹中运行。</p>
<h1 id="–picked-x3D-first"><a href="#–picked-x3D-first" class="headerlink" title="–picked&#x3D;first"></a>–picked&#x3D;first</h1><p>首先运行修改后的测试文件中的测试，然后运行所有未修改的测试</p>
<pre><code class="erlang">&gt;pytest --picked=first
================================================= test session starts =================================================
platform win32 -- Python 3.6.6, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
rootdir: D:\demo\code\xuexi_pytest
collected 11 items

pytest_demo\test_new.py ..                                                                                       [ 18%]
pytest_demo\test_new_2.py ..                                                                                     [ 36%]
pytest_demo\test_b.py ......                                                                                     [ 90%]
pytest_demo\test_c.py .                                                                                          [100%]

================================================= 11 passed in 0.10s ==================================================
</code></pre>
<h1 id="–mode-x3D-PICKED-MODE"><a href="#–mode-x3D-PICKED-MODE" class="headerlink" title="–mode&#x3D;PICKED_MODE"></a>–mode&#x3D;PICKED_MODE</h1><p><code>--mode</code> 有2个参数可选 unstaged, branch, 默认是<code>--mode=unstaged</code></p>
<p>git 文件的2个状态</p>
<ul>
<li>untrack 没加到git里面的新文件</li>
<li>unstaged staged：暂存状态, unstage就是未暂存状态，也就是没git add 过的文件</li>
</ul>
<p>先弄清楚什么是 untrack 状态，当我们 pycharm 打开 git 项目，新增一个文件的时候，会弹出询问框：是否加到 git 文件</p>
<p><img src="/assets/2/image-20220516013145-7w3u47z.png" alt="image.png"></p>
<p>如果选择是，文件会变绿色，也就是 unstage 状态（没git add 过）；选择否，那就是一个新文件，未被加到当前分支的 git 目录里面，文件颜色是棕色。<br><code>git status</code> 查看当前分支的状态,此时会看到 pytest_demo&#x2F;test_3.py 是 Untracked files</p>
<pre><code class="vhdl"># 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

&gt;git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

        new file:   pytest_demo/test_new.py
        new file:   pytest_demo/test_new_2.py

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

        modified:   pytest_demo/test_new.py
        modified:   pytest_demo/test_new_2.py

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

        .idea/
        pytest_demo/__pycache__/
        pytest_demo/test_3.py
</code></pre>
<p>运行 <code>pytest --picked</code> 会默认执行所有的 Untracked 文件和 not staged 文件，默认是<code>--mode=unstaged</code>。</p>
<pre><code class="bash">&gt;pytest --picked

Changed test files... 3. [&#39;pytest_demo/test_new.py&#39;, &#39;pytest_demo/test_new_2.py&#39;, &#39;pytest_demo/test_3.py&#39;]
Changed test folders... 2. [&#39;.idea/&#39;, &#39;pytest_demo/__pycache__/&#39;]
================================================= test session starts =================================================
platform win32 -- Python 3.6.6, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
collected 5 items

pytest_demo\test_new.py ..                                                                                       [ 40%]
pytest_demo\test_new_2.py ..                                                                                     [ 80%]
pytest_demo\test_3.py .                                                                                          [100%]

================================================== 5 passed in 0.06s ==================================================
</code></pre>
<p>如果我们只需运行当前分支上已经被暂存，但尚未提交的文件（不包含 Untracked files），使用 git diff 查看分支代码的差异</p>
<pre><code class="bash">&gt;git diff --name-only master
pytest_demo/test_new.py
pytest_demo/test_new_2.py
</code></pre>
<p>运行 <code>pytest --picked --mode=branch</code>, 运行分支上已经被暂存但尚未提交的代码</p>
<pre><code class="bash">&gt;pytest --picked --mode=branch

Changed test files... 2. [&#39;pytest_demo/test_new.py&#39;, &#39;pytest_demo/test_new_2.py&#39;]
Changed test folders... 0. []
================================================= test session starts =================================================
platform win32 -- Python 3.6.6, pytest-6.0.2, py-1.9.0, pluggy-0.13.1
collected 4 items

pytest_demo\test_new.py ..                                                                                       [ 50%]
pytest_demo\test_new_2.py ..                                                                                     [100%]

================================================== 4 passed in 0.04s ==================================================
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档60-pytest.main()的使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A360-pytest.main()%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 运行用例的时候，一般用命令行去执行，有些小伙伴不太习惯命令行运行用例，可能是之前深受 unittest 框架的影响，习惯在项目的根目录下写一个 run_all.py 的文件。<br>运行的时候，使用 python 运行 run_all.py 来执行测试用例。</p>
<h1 id="pytest-main"><a href="#pytest-main" class="headerlink" title="pytest.main()"></a>pytest.main()</h1><p>先看看 pytest.main() 的源码, main 函数的内容</p>
<ul>
<li>args 传一个list对象，list 里面是多个命令行的参数</li>
<li>plugins 传一个list对象，list 里面是初始化的时候需注册的插件</li>
</ul>
<pre><code class="python">def main(args=None, plugins=None):
    &quot;&quot;&quot; return exit code, after performing an in-process test run.

    :arg args: list of command line arguments.

    :arg plugins: list of plugin objects to be auto-registered during
                  initialization.
    &quot;&quot;&quot;
    from _pytest.main import EXIT_USAGEERROR

    try:
        try:
            config = _prepareconfig(args, plugins)
        except ConftestImportFailure as e:
            exc_info = ExceptionInfo(e.excinfo)
            tw = py.io.TerminalWriter(sys.stderr)
            tw.line(
                &quot;ImportError while loading conftest &#39;&#123;e.path&#125;&#39;.&quot;.format(e=e), red=True
            )
            exc_info.traceback = exc_info.traceback.filter(filter_traceback)
            exc_repr = (
                exc_info.getrepr(style=&quot;short&quot;, chain=False)
                if exc_info.traceback
                else exc_info.exconly()
            )
            formatted_tb = safe_str(exc_repr)
            for line in formatted_tb.splitlines():
                tw.line(line.rstrip(), red=True)
            return 4
        else:
            try:
                return config.hook.pytest_cmdline_main(config=config)
            finally:
                config._ensure_unconfigure()
    except UsageError as e:
        tw = py.io.TerminalWriter(sys.stderr)
        for msg in e.args:
            tw.line(&quot;ERROR: &#123;&#125;\n&quot;.format(msg), red=True)
        return EXIT_USAGEERROR
</code></pre>
<p>如果不带任何参数，那么执行的效果跟我们在 cmd 直接运行 pytest 命令一样，默认运行的是当前目录及子目录的所有文件夹的测试用例</p>
<pre><code class="markdown">&gt; pytest
</code></pre>
<h1 id="run-all-py"><a href="#run-all-py" class="headerlink" title="run_all.py"></a>run_all.py</h1><p>在项目的根目录，新建一个 run_all.py 的文件</p>
<p><img src="/assets/2/image-20220516013052-n4ydf9k.png" alt="image.png"></p>
<p>只需写简单的2行代码</p>
<pre><code class="haskell">import pytest

# 默认运行的是当前目录及子目录的所有文件夹的测试用例
pytest.main()
</code></pre>
<p>这样就能在 pycharm 里面右键运行，不带参数默认运行当前目录及子目录的所有文件夹的测试用例</p>
<h1 id="带参数运行"><a href="#带参数运行" class="headerlink" title="带参数运行"></a>带参数运行</h1><p>在运行的时候，也可以指定参数运行</p>
<p>-s： 显示程序中的 print&#x2F;logging 输出<br>-v: 丰富信息模式, 输出更详细的用例执行信息<br>-k： 运行包含某个字符串的测试用例。如：pytest -k add XX.py 表示运行 XX.py 中包含 add 的测试用例。<br>-q: 简单输出模式, 不输出环境信息<br>-x: 出现一条测试用例失败就退出测试。在调试阶段非常有用，当测试用例失败时，应该先调试通过，而不是继续执行测试用例。</p>
<p>在命令行运行带上 -s 参数</p>
<pre><code class="markdown">&gt; pytest -s
</code></pre>
<p>那么在 pytest.main() 里面等价于</p>
<pre><code class="haskell">import pytest

# 带上-s参数
pytest.main([&quot;-s&quot;])
</code></pre>
<p>在命令行运行带上多个参数时</p>
<pre><code class="markdown">&gt; pytest -s -x
</code></pre>
<p>那么在 pytest.main() 里面等价于</p>
<pre><code class="haskell">import pytest

# 带上-s -x参数
pytest.main([&quot;-s&quot;, &quot;-x&quot;])
</code></pre>
<h1 id="指定运行某个用例"><a href="#指定运行某个用例" class="headerlink" title="指定运行某个用例"></a>指定运行某个用例</h1><p>指定运行 cases&#x2F;module1 文件夹下的全部用例, 在命令行运行时, 先 cd 到项目的根目录</p>
<pre><code class="shell">&gt;pytest cases/module1
</code></pre>
<p>那么在 pytest.main() 里面等价于</p>
<pre><code class="haskell">import pytest

# 运行指定文件夹目录
pytest.main([&quot;cases/module1&quot;])
</code></pre>
<p>运行指定的 cases&#x2F;module1&#x2F;test_x1.py 下的全部用例,在命令行运行时, 先cd到项目的根目录</p>
<pre><code class="shell">&gt;pytest cases/module1/test_x1.py
</code></pre>
<p>那么在 pytest.main() 里面等价于</p>
<pre><code class="haskell">import pytest

# 运行指定py文件
pytest.main([&quot;cases/module1/test_x1.py&quot;])
</code></pre>
<p>运行指定的 cases&#x2F;module1&#x2F;test_x1.py 下的某一个用例 test_x, 在命令行运行时, 先cd到项目的根目录</p>
<pre><code class="shell">&gt;pytest cases/module1/test_x1.py::test_x
</code></pre>
<p>那么在 pytest.main() 里面等价于</p>
<pre><code class="haskell">import pytest

# 运行指定py文件下的test_x
pytest.main([&quot;cases/module1/test_x1.py::test_x&quot;])
</code></pre>
<p>通过上面跟命令行运行的对比，对 pytest.main() 的使用也就基本掌握了</p>
<h1 id="plugins参数的使用"><a href="#plugins参数的使用" class="headerlink" title="plugins参数的使用"></a>plugins参数的使用</h1><p>一般我们写插件的代码放到 conftest.py 会被pytest查找到，如果不是写到 conftest.py 的插件内容，可以通过 plugins 参数指定加载</p>
<pre><code class="python"># run_all.py 
import pytest


# 在run_all.py下自定义插件
class MyPlugin(object):
    def pytest_sessionstart(self):
        print(&quot;*** test run start blog地址 https://www.cnblogs.com/yoyoketang/&quot;)


# plugins指定加载插件

pytest.main([&quot;cases/module1&quot;], plugins=[MyPlugin()])
</code></pre>
<p>运行后会看到在参数用例开始之前答应上面的内容</p>
<pre><code class="sql">*** test run start blog地址 https://www.cnblogs.com/yoyoketang/
============================= test session starts =============================
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
Test order randomisation NOT enabled. Enable with --random-order or --random-order-bucket=&lt;bucket_type&gt;
rootdir: D:\wangyiyun\web
plugins: repeat-0.8.0, rerunfailures-9.1, xdist-2.1.0
collected 5 items

cases\module1\test_x1.py .                                               [ 20%]
cases\module1\test_x2.py ....                                            [100%]

========================== 5 passed in 0.05 seconds ===========================
</code></pre>
<p>plugins参数的作用就是指定需加载的插件，也可以指定多个。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档61-fixture之name参数使用别名</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A361-fixture%E4%B9%8Bname%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇讲 fixture 里面的 name 参数如何使用，使用别名后代码更容易理解。</p>
<h1 id="fixture使用案例"><a href="#fixture使用案例" class="headerlink" title="fixture使用案例"></a>fixture使用案例</h1><p>定义一个fixture打开浏览器，测试用例需用到这个fixture的前置操作</p>
<pre><code class="python">from selenium import webdriver
import pytest
import time
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture(scope=&quot;module&quot;)
def open_broswer():
    &#39;&#39;&#39;打开浏览器&#39;&#39;&#39;
    driver = webdriver.Chrome()
    yield driver
    driver.close()


def test_blog(open_broswer):
    &#39;&#39;&#39;打开我的blog: https://www.cnblogs.com/yoyoketang/&#39;&#39;&#39;
    open_broswer.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)
    time.sleep(3)
</code></pre>
<p>open_broswer 这个fixture 返回打开浏览器的实例 driver,后面的测试用例传 open_broswer 参数，此时 open_broswer 就相当于我们之前写代码的 driver 了。<br>小伙伴们习惯了 driver.get() 这种代码，突然看到 open_broswer.get() 这样的代码会不太适应，不知道后面该如何写了。</p>
<p>于是我给open_broswer 重命名为name, 让代码看起来更容易理解一点</p>
<pre><code class="python">def test_blog(open_broswer):
    &#39;&#39;&#39;打开我的blog: https://www.cnblogs.com/yoyoketang/&#39;&#39;&#39;
    driver = open_broswer   # 这个地方是重命名，不是调用函数
    driver.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)
    time.sleep(3)
</code></pre>
<p>这样写的话又有一个误区，有的同学会认为这里是调用函数了。。。（注意调用函数的时候后面是有括号的，这里没括号，只是重命名换个名称而已）</p>
<h1 id="fixture里面的name参数"><a href="#fixture里面的name参数" class="headerlink" title="fixture里面的name参数"></a>fixture里面的name参数</h1><p>为了实现上面的效果，又不引起误解，可以在 fixture 里面使用 name 参数，给 fixture 使用别名</p>
<pre><code class="python">from selenium import webdriver
import pytest
import time
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture(scope=&quot;module&quot;, name=&quot;driver&quot;)
def open_broswer():
    &#39;&#39;&#39;打开浏览器&#39;&#39;&#39;
    driver = webdriver.Chrome()
    yield driver
    driver.close()


def test_blog(driver):
    &#39;&#39;&#39;打开我的blog: https://www.cnblogs.com/yoyoketang/&#39;&#39;&#39;
    driver.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)
    time.sleep(3)
</code></pre>
<p>这样就可以使用 driver 继续操作了。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档62-内置fixture之request</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A362-%E5%86%85%E7%BD%AEfixture%E4%B9%8Brequest/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>request 是 pytest 的内置 fixture ， “为请求对象提供对请求测试上下文的访问权，并且在fixture被间接参数化的情况下具有可选的“param”属性。”<br>这是官方文档对request的描述，可参考的文档不多。</p>
<h1 id="FixtureRequest"><a href="#FixtureRequest" class="headerlink" title="FixtureRequest"></a>FixtureRequest</h1><p>FixtureRequest 是来自 fixture 或者 测试用例的请求，它有访问测试上下文的权限, FixtureRequest<a href="https://docs.pytest.org/en/latest/_modules/_pytest/fixtures.html#FixtureRequest">源代码</a>。</p>
<pre><code class="python">class FixtureRequest[源代码](https://docs.pytest.org/en/latest/_modules/_pytest/fixtures.html#FixtureRequest)

请求对象提供对请求的测试上下文的访问，并且具有可选的 param 属性，以防设备被间接参数化。

fixturename
正在为其执行此请求的 fixture 名称。

scope
作用域字符串，“function”、“class”、“module”、“session”之一。

fixturenames
此请求中所有活动状态的 fixture 的名称。

node
基础集合节点（取决于当前请求范围）。

config
与此请求关联的 pytest 配置对象。

function
如果请求具有每个函数范围，则测试函数对象。

cls
类（可以是None），其中收集了测试函数。

instance
在其上收集测试函数的实例（可以是None）。

module
收集测试函数的Python模块对象。

fspath
收集此测试的测试模块的文件系统路径。

keywords
基础节点的关键字/标记词典。

session
Pytest会话对象。

addfinalizer(finalizer: Callable[], object]) → None[源代码]
添加finalizer/teardown函数，以便在请求的测试上下文中的最后一个测试完成执行后调用。

applymarker(marker) → None[源代码]
对单个测试函数调用应用标记。

如果不希望在所有函数调用上都有关键字/标记，则此方法非常有用。

参数
marker -- A _pytest.mark.MarkDecorator 调用创建的对象 pytest.mark.NAME(...) .

raiseerror(msg: Optional[str]) → NoReturn[源代码]
使用给定的消息引发FixtureLookupError。

getfixturevalue(argname: str) → Any[源代码]
动态运行命名的fixture函数。

如果可能，建议通过函数参数声明fixtures。但是，如果您只能在测试设置时决定是否使用另一个fixture，那么您可以使用此函数在fixture或测试函数体中检索它。

引发
pytest.FixtureLookupError -- 如果找不到给定的固定装置。
</code></pre>
<h1 id="request-param"><a href="#request-param" class="headerlink" title="request.param"></a>request.param</h1><p>前面讲fixture参数化的时候，有接触到 “request.param” 用于获取测试的请求参数，以下示例</p>
<pre><code class="python">&#39;&#39;&#39;
request 是 pytest的内置fixture
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/
&#39;&#39;&#39;
import pytest

# 测试数据
test_data = [&quot;user1&quot;, &quot;user2&quot;]


@pytest.fixture(params=test_data)
def register_users(request):
     # 获取当前的测试数据
     user = request.param
     print(&quot;\n拿着这个账号去注册：%s&quot;%user)
     result = &quot;success&quot;
     return user, result


def test_register(register_users):
    user, result = register_users
    print(&quot;在测试用例里面里面获取到当前测试数据：%s&quot;%user)
    print(result)
    assert result == &quot;success&quot;
</code></pre>
<p>此案例里面我们可以在fixture参数化的时候，通过request.param获取到测试的请求参数，但是在用例里面用 request.param 却不能获取到测试的请求参数</p>
<pre><code class="python">def test_register_x(register_users, request):
    print(request.param)
</code></pre>
<p>这样运行，会抛异常：’FixtureRequest’ object has no attribute ‘param’</p>
<pre><code class="python">拿着这个账号去注册：user1
F
register_users = (&#39;user1&#39;, &#39;success&#39;)
request = &lt;FixtureRequest for &lt;Function test_register_x[user1]&gt;&gt;

    def test_register_x(register_users, request):
&gt;       print(request.param)
E       AttributeError: &#39;FixtureRequest&#39; object has no attribute &#39;param&#39;

D:\test_x7.py:27: AttributeError
</code></pre>
<h1 id="request-config"><a href="#request-config" class="headerlink" title="request.config"></a>request.config</h1><p>request.config 是获取测试的配置文件参数，这个在前面讲命令行参数的时候有用到过.</p>
<p>在 conftest.py 写一个 hook函数， pytest_addoption 的作用是用于获取命令行参数，request.config 用于读取测试的配置数据</p>
<pre><code class="python"># content of conftest.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/
import pytest


def pytest_addoption(parser):
    parser.addoption(
        &quot;--cmdopt&quot;, action=&quot;store&quot;, default=&quot;type1&quot;, help=&quot;my option: type1 or type2&quot;
    )

@pytest.fixture
def cmdopt(request):
    return request.config.getoption(&quot;--cmdopt&quot;)
</code></pre>
<p>于是在测试用例里面可以通过 request.config 来获取到配置参数，也可以通过自己定义的 cmdopt 来获取。</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def test_answer_1(request):
    type = request.config.getoption(&quot;--cmdopt&quot;)
    print(&quot;获取到命令行参数：%s&quot; % type)


def test_answer_2(cmdopt):
    print(&quot;获取到命令行参数：%s&quot; % cmdopt)
</code></pre>
<h1 id="request-module"><a href="#request-module" class="headerlink" title="request.module"></a>request.module</h1><p>fixture 函数可以通过接受 request 对象来反向获取请求中的测试函数、类或模块上下文，进一步扩展之前的 smtp fixture示例，让我们从fixture的测试模块读取可选的服务器URL<br>这是官方文档的一个示例</p>
<pre><code class="python"># conftest.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture(scope=&quot;module&quot;)
def smtp(request):
    server = getattr(request.module, &quot;smtpserver&quot;, &quot;smtp.qq.com&quot;)
    print(&quot;fixture 获取到的server :%s&quot; %server)
    smtp = smtplib.SMTP(server, 587, timeout=5)
    yield smtp
    print(&quot;完成 %s (%s)&quot; % (smtp, server))
    smtp.close()
</code></pre>
<p>我们使用request.module属性来从测试模块中选择性地获取smtpserver属性<br>快速创建另一个测试模块，在其模块名称空间中实际设置服务器URL，新建一个test_anothersmtp.py文件，输入以下代码：</p>
<pre><code class="python"># test_anothersmtp.py
smtpserver = &quot;mail.python.org&quot;

def test_showhelo(smtp):

    print(&quot;case showhelo&quot;)
</code></pre>
<p>这时候运行用例，会获取到 test_anothersmtp.py 里面定义的 smtpserver</p>
<pre><code class="mipsasm">============================= test session starts =============================
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
Test order randomisation NOT enabled. Enable with --random-order or --random-order-bucket=&lt;bucket_type&gt;
rootdir: D:\
rerunfailures-9.1, xdist-2.1.0
collected 1 item

..\..\..\..\module2\test_anothersmtp.py 
fixture 获取到的server :mail.python.org
case showhelo
.完成 &lt;smtplib.SMTP object at 0x000001D00754CB00&gt; (mail.python.org)


========================== 1 passed in 0.64 seconds ===========================
</code></pre>
<p>用例里面没定义 smtpserver 的话，会用默认属性 “smtp.qq.com”</p>
<h1 id="request的相关成员对象"><a href="#request的相关成员对象" class="headerlink" title="request的相关成员对象"></a>request的相关成员对象</h1><p>在conftest.py 写一个fixture 可以获取到request的一些成员对象相关信息</p>
<pre><code class="python"># conftest.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.fixture(autouse=True)
def print_request(request):
    print(&quot;\n=======================request start=================================&quot;)
    print(request.module)
    print(request.function)
    print(request.cls)
    print(request.fspath)
    print(request.fixturenames)
    print(request.fixturename)
    print(request.scope)
    print(&quot;\n=======================request end=================================&quot;)
</code></pre>
<p>使用命令行”pytest -s text_x.py”运行用例,会看到打印的结果</p>
<pre><code class="sql">test_1.py
=======================request start=================================
&lt;module &#39;web.cases.module2.test_1&#39; from &#39;D:\\web\\cases\\module2\\test_1.py&#39;&gt;
&lt;function test_answer_1 at 0x0000012D1C9FD9D8&gt;
None
D:\web\cases\module2\test_1.py
[&#39;_verify_url&#39;, &#39;base_url&#39;, &#39;__pytest_repeat_step_number&#39;, &#39;show_request&#39;, &#39;request&#39;]
show_request
function

=======================request end=================================
获取到命令行参数：type1
.
=======================request start=================================
&lt;module &#39;web.cases.module2.test_1&#39; from &#39;D:\\web\\cases\\module2\\test_1.py&#39;&gt;
&lt;function test_answer_2 at 0x0000012D1C9FD730&gt;
None
D:\web\cases\module2\test_1.py
[&#39;_verify_url&#39;, &#39;base_url&#39;, &#39;__pytest_repeat_step_number&#39;, &#39;show_request&#39;, &#39;cmdopt&#39;, &#39;request&#39;]
show_request
function

=======================request end=================================
</code></pre>
<p>在打印测试用例的详细日志的时候，还是很有用的。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档63-内置fixture之pytestconfig</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A363-%E5%86%85%E7%BD%AEfixture%E4%B9%8Bpytestconfig/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面讲 request 是pytest的一个内置 fixture ，作用是获取测试的上下文，可以通过request.config 获取配置对象。<br>pytestconfig 的作用跟 request.config 是一样的，都是获取配置对象</p>
<h1 id="pytestconfig-源码分析"><a href="#pytestconfig-源码分析" class="headerlink" title="pytestconfig 源码分析"></a>pytestconfig 源码分析</h1><p>pytestconfig 是一个内置fixture，用于获取配置对象 <a href="https://docs.pytest.org/en/latest/_modules/_pytest/fixtures.html#pytestconfig">pytestconfig 源码</a><br>pytestconfig 有2个常用的方法</p>
<ul>
<li>.getoption() 获取命令行参数</li>
<li>.getini() 获取ini配置文件的参数</li>
</ul>
<pre><code class="less">@fixture(scope=&quot;session&quot;)
def pytestconfig(request: FixtureRequest) -&gt; Config:
    &quot;&quot;&quot;Session-scoped fixture that returns the :class:`_pytest.config.Config` object.

    Example::

        def test_foo(pytestconfig):
            if pytestconfig.getoption(&quot;verbose&quot;) &gt; 0:
                ...

    &quot;&quot;&quot;
    return request.config
</code></pre>
<p>从上面的源码看出，实际返回的就是 request.config</p>
<p>使用示例</p>
<pre><code class="python">def test_foo(pytestconfig):
    if pytestconfig.getoption(&quot;verbose&quot;) &gt; 0:
        ...
</code></pre>
<h1 id="getoption-获取命令行参数"><a href="#getoption-获取命令行参数" class="headerlink" title="getoption() 获取命令行参数"></a>getoption() 获取命令行参数</h1><p>获取命令行参数的案例，在前面讲过很多次了，这个也是用的最广泛的</p>
<pre><code class="python"># content of conftest.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/
import pytest


def pytest_addoption(parser):
    parser.addoption(
        &quot;--cmdopt&quot;, action=&quot;store&quot;, default=&quot;type1&quot;, help=&quot;my option: type1 or type2&quot;
    )

@pytest.fixture
def cmdopt(pytestconfig):
    return pytestconfig.getoption(&quot;--cmdopt&quot;)
</code></pre>
<p>测试用例</p>
<pre><code class="python"># test_cmdopt.py
import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def test_answer_1(pytestconfig):
    type = pytestconfig.getoption(&quot;--cmdopt&quot;)
    print(&quot;获取到命令行参数：%s&quot; % type)


def test_answer_2(cmdopt):
    print(&quot;获取到命令行参数：%s&quot; % cmdopt)
</code></pre>
<p>命令行运行用例的时候，可以用 –cmdopt 参数</p>
<pre><code class="diff">&gt;pytest -s test_cmdopt.py --cmdopt type2
================== test session starts =======
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
rootdir: D:\wangyiyun\web\cases\module2
rerunfailures-9.1, xdist-2.1.0
collected 2 items

test_cmdopt.py 获取到命令行参数：type2
.获取到命令行参数：type2
.

================== 2 passed in 0.06 seconds ==========
</code></pre>
<h1 id="getini-从-pytest-ini-配置文件获取参数"><a href="#getini-从-pytest-ini-配置文件获取参数" class="headerlink" title="getini() 从 pytest.ini 配置文件获取参数"></a>getini() 从 pytest.ini 配置文件获取参数</h1><p>在项目的根目录一般会放一个 pytest.ini 写一些配置参数</p>
<pre><code class="ini">[pytest]

log_cli = 1

addopts = -v -x
</code></pre>
<p>我们想读取 pytest.ini 里面的配置信息，可以用 pytestconfig.getini() 来获取，使用示例</p>
<pre><code class="python"># conftest.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture(autouse=True)
def get_ini(pytestconfig):
    &#39;&#39;&#39;读取ini配置信息&#39;&#39;&#39;
    # 读取 log_cli配置
    log_cli = pytestconfig.getini(&#39;log_cli&#39;)
    print(&quot;获取到markers ：%s&quot; % log_cli)
    addopts = pytestconfig.getini(&#39;addopts&#39;)
    print(&quot;获取到addopts的配置：%s &quot; % addopts)
</code></pre>
<p>在命令行运行后，可以看到打印的内容</p>
<pre><code class="less">test_cmdopt.py::test_answer_1 获取到markers ：True
获取到db的配置：[&#39;-v&#39;, &#39;-x&#39;]
获取到命令行参数：type1
PASSED
</code></pre>
<p>addopts 参数可以更改默认命令行选项，这个当我们在 cmd 输入一堆指令去执行用例的时候，就可以用该参数代替了，省去重复性的敲命令工作<br>比如上面的配置， 命令行输入pytest运行的时候，会默认带上的参数，如 ‘pytest -v -x’<br>log_cli 是控制台实时输出日志，可以设置True 和 False，也可以设置1 和 0</p>
<h1 id="log-cli"><a href="#log-cli" class="headerlink" title="log_cli"></a>log_cli</h1><p>log_cli 是控制台实时输出日志，可以设置True 和 False，也可以设置1 和 0，默认是关闭状态（False）</p>
<p>当 log_cli &#x3D; 0 或默认的 False 状态时，命令行输入 pytest 运行用例，在控制台输出是按每个模块显示运行结果</p>
<pre><code class="erlang">collected 6 items

test_1.py ..                                                                    [ 33%]
test_anothersmtp.py .                                                           [ 50%]
test_cmdopt.py ..                                                               [ 83%]
test_y.py .                                                                     [100%]

============================== 6 passed in 1.80 seconds ==============================
</code></pre>
<p>当log_cli &#x3D; 1后 运行 pytest 命令</p>
<pre><code class="cpp">collected 6 items

test_1.py::test_answer_1 PASSED                                                 [ 16%]
test_1.py::test_answer_2 PASSED                                                 [ 33%]
test_anothersmtp.py::test_showhelo PASSED                                       [ 50%]
test_cmdopt.py::test_answer_1 PASSED                                            [ 66%]
test_cmdopt.py::test_answer_2 PASSED                                            [ 83%]
test_y.py::test_i PASSED                                                        [100%]

============================== 6 passed in 0.84 seconds ==============================
</code></pre>
<p>这时候报告会按每条用例显示结果</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档64-内置 pytestconfig 动态添加和获取 pytest.ini 配置参数</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A364-%E5%86%85%E7%BD%AE%20pytestconfig%20%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E8%8E%B7%E5%8F%96%20pytest.ini%20%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面讲 pytestconfig 的时候，可以获取到 pytest.ini 里面的配置参数。<br>我们在写项目自动化用例的时候，有一些配置参数希望能加到配置里面，如configid, productid,以及测试环境的base_url地址，和账号相关信息。</p>
<h1 id="addini的源码阅读"><a href="#addini的源码阅读" class="headerlink" title="addini的源码阅读"></a>addini的源码阅读</h1><p>addini有四个参数：name, help, type&#x3D;None, default&#x3D;None</p>
<pre><code class="python">    def addini(self, name, help, type=None, default=None):
        &quot;&quot;&quot; register an ini-file option.

        :name: name of the ini-variable
        :type: type of the variable, can be ``pathlist``, ``args``, ``linelist``
               or ``bool``.
        :default: default value if no ini-file option exists but is queried.

        The value of ini-variables can be retrieved via a call to
        :py:func:`config.getini(name) &lt;_pytest.config.Config.getini&gt;`.
        &quot;&quot;&quot;
        assert type in (None, &quot;pathlist&quot;, &quot;args&quot;, &quot;linelist&quot;, &quot;bool&quot;)
        self._inidict[name] = (help, type, default)
        self._ininames.append(name)
</code></pre>
<h1 id="动态添加配置信息"><a href="#动态添加配置信息" class="headerlink" title="动态添加配置信息"></a>动态添加配置信息</h1><p>前面一篇讲添加命令行参数，可以用 addoption 来添加命令行参数，这里我们是添加 pytest.ini 的配置信息<br>adddini里面参数说明</p>
<ul>
<li>第一个’url’ 是参数的名称</li>
<li>type 是类型，默认None，可以设置：None, “pathlist”, “args”, “linelist”, “bool”</li>
<li>default 是设置的默认值</li>
<li>help 是设置帮助文档，方便查阅</li>
</ul>
<pre><code class="python"># conftest.py
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def pytest_addoption(parser):
    parser.addoption(
        &quot;--cmdopt&quot;, action=&quot;store&quot;, default=&quot;type1&quot;, help=&quot;my option: type1 or type2&quot;
    )
    # 添加参数到pytest.ini
    parser.addini(&#39;url&#39;, type=None, default=&quot;http://49.235.92.12:8200/&quot;, help=&#39;添加 url 访问地址参数&#39;)


# 获取 pytest.ini 配置参数
@pytest.fixture(scope=&quot;session&quot;)
def home_url(pytestconfig):
    url = pytestconfig.getini(&#39;url&#39;)
    print(&quot;\n读取到配置文件的url地址：%s&quot; % url)
    return url
</code></pre>
<p>参数用例传 home_url</p>
<pre><code class="python"># test_y.py

def test_h(home_url):
    print(&quot;用例：%s&quot; % home_url)
</code></pre>
<p>运行结果</p>
<pre><code class="java">============================= test session starts =============================
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
rootdir: D:\wangyiyun\web
collected 1 item

..\..\..\..\..\wangyiyun\web\test_y.py 
读取到配置文件的url地址：http://49.235.92.12:8200/
用例：http://49.235.92.12:8200/
.

========================== 1 passed in 0.02 seconds ===========================
</code></pre>
<h1 id="pytest-ini-配置-url地址"><a href="#pytest-ini-配置-url地址" class="headerlink" title="pytest.ini 配置 url地址"></a>pytest.ini 配置 url地址</h1><p>如果有一天我们的测试环境发生了改变，这时候不需要去改代码，只需在 pytest.ini 配置一个环境地址</p>
<pre><code class="ini">[pytest]


url = https://www.cnblogs.com/yoyoketang/
</code></pre>
<p>重新运行，我们得到的结果是</p>
<pre><code class="bash">============================= test session starts =============================
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
rootdir: D:\wangyiyun\web
collected 1 item

..\..\..\..\..\wangyiyun\test_y.py 
读取到配置文件的url地址：https://www.cnblogs.com/yoyoketang/
用例：https://www.cnblogs.com/yoyoketang/
.

========================== 1 passed in 0.02 seconds ===========================
</code></pre>
<h1 id="type参数的几种类型"><a href="#type参数的几种类型" class="headerlink" title="type参数的几种类型"></a>type参数的几种类型</h1><p>默认None，可以设置：None, “pathlist”, “args”, “linelist”, “bool”</p>
<ul>
<li>type&#x3D;None 默认读的是字符串</li>
<li>type&#x3D;”pathlist” 可以设置多个路径，会自动拼接ini文件这一层目录</li>
<li>type&#x3D;”args” 多个参数</li>
<li>type&#x3D;”linelist” 可以是多个命令行参数</li>
<li>type&#x3D;”bool” bool值，设置1或0</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档65-内置 request 读取项目的根目录 rootdir</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A365-%E5%86%85%E7%BD%AE%20request%20%E8%AF%BB%E5%8F%96%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%20rootdir/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写自动化测试项目的时候，经常要用到配置文件，比如读取数据库相关的配置，希望单独放到 config 配置文件，方便维护。<br>pytest 的内置 fixture 可以获取到配置相关的信息，request.config.rootdir 用于获取项目的跟目录。</p>
<h1 id="config-配置文件"><a href="#config-配置文件" class="headerlink" title="config 配置文件"></a>config 配置文件</h1><p>再项目下新建一个 config 文件，相关配置信息用 yaml 文件维护数据</p>
<p><img src="/assets/2/image-20220516012759-esjf6gy.png" alt="image.png"></p>
<p>在conftest.py 下写读取配置文件的 fixture, 这里我设置为 autouse&#x3D;True 主要是为了查看打印读取到的目录</p>
<pre><code class="python">import pytest
import os
import yaml
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture(scope=&quot;session&quot;, autouse=True)
def dbinfo(request):
    dbfile = os.path.join(request.config.rootdir,
                        &quot;config&quot;,
                        &quot;dbenv.yml&quot;)
    print(&quot;dbinfo file path :%s&quot; % dbfile)
    with open(dbfile) as f:
        dbenv_config = yaml.load(f.read(), Loader=yaml.SafeLoader)
    print(dbenv_config)
    return dbenv_config
</code></pre>
<h1 id="rootdir-读取"><a href="#rootdir-读取" class="headerlink" title="rootdir 读取"></a>rootdir 读取</h1><p>打开 cmd 命令行，在项目的跟目录运行用例</p>
<blockquote>
<p>pytest -s</p>
</blockquote>
<pre><code class="bash">D:\wangyiyun\webauto&gt;pytest -s
================================================= test session starts =================================================
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
rootdir: D:\wangyiyun\webauto
plugins: allure-pytest-2.8.6
collected 5 items

case\test_1.py dbinfo file path :D:\wangyiyun\webauto\config\dbenv.yml
&#123;&#39;host&#39;: &#39;47.104.x.x&#39;, &#39;port&#39;: 3306, &#39;user&#39;: &#39;root&#39;, &#39;passwd&#39;: 123456, &#39;db&#39;: &#39;test&#39;&#125;
test xxx
.
case\test_x1.py test 111111
.test 22222222
.test 3333333
.test 444444444
.

=================
</code></pre>
<p>这时候可以看到读取到的配置文件地址：D:\wangyiyun\webauto\config\dbenv.yml</p>
<p>在项目根目录运行用例是标准的运行姿势，但是有些小伙伴会 cd 到 case 目录，运行单个用例</p>
<pre><code class="markdown">D:\wangyiyun\webauto&gt;cd case

D:\wangyiyun\webauto\case&gt;pytest test_1.py
================================================= test session starts =================================================
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
rootdir: D:\wangyiyun\webauto\case
plugins: allure-pytest-2.8.6
collected 1 item

test_1.py E                                                                                                      [100%]

======================================================= ERRORS ========================================================
______________________________________________ ERROR at setup of test_x _______________________________________________

request = &lt;SubRequest &#39;dbinfo&#39; for &lt;Function test_x&gt;&gt;

    @pytest.fixture(scope=&quot;session&quot;, autouse=True)
    def dbinfo(request):
        dbfile = os.path.join(request.config.rootdir,
                            &quot;config&quot;,
                            &quot;dbenv.yml&quot;)
        print(&quot;dbinfo file path :%s&quot; % dbfile)
&gt;       with open(dbfile) as f:
E       FileNotFoundError: [Errno 2] No such file or directory: &#39;D:\\wangyiyun\\webauto\\case\\config\\dbenv.yml&#39;

..\conftest.py:14: FileNotFoundError
------------------------------------------------ Captured stdout setup ------------------------------------------------
dbinfo file path :D:\wangyiyun\webauto\case\config\dbenv.yml
=============================================== 1 error in 0.08 seconds ===============================================
</code></pre>
<p>这个时候就会出现报错：No such file or directory: ‘D:\wangyiyun\webauto\case\config\dbenv.yml’<br>因为此时的项目跟目录就变成了 rootdir: D:\wangyiyun\webauto\case<br>接下来我们需要解决的问题时，不管在哪个目录运行，它的项目跟目录应该都是我们的工程目录 D:\wangyiyun\webauto</p>
<h1 id="pytest-ini"><a href="#pytest-ini" class="headerlink" title="pytest.ini"></a>pytest.ini</h1><p>pytest 运行用例的时候项目的 rootdir 当没有 pytest.ini 配置文件的时候会根据 conftest.py 找到它的跟目录。<br>由于前面没有用到pytest.ini 配置文件，导致不同目录运行用例的 rootdir 不一样。</p>
<p>当项目下存在 pytest.ini 配置文件的时候，会认为 pytest.ini 所在的目录是 rootdir 目录， 所以我们一般会把 pytest.ini 配置文件放到项目的跟目录。<br>如果里面没有内容，放个空的也行</p>
<p><img src="/assets/2/image-20220516012808-zhfwwtv.png" alt="image.png"></p>
<p>这时候不管在哪个目录运行用例都不会有问题了</p>
<pre><code class="vbnet">D:\wangyiyun\webauto\case&gt;pytest test_1.py
======================== test session starts ==============
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
rootdir: D:\wangyiyun\webauto, inifile: pytest.ini
plugins: allure-pytest-2.8.6
collected 1 item

test_1.py .                                            [100%]

========================1 passed in 0.03 seconds =============
</code></pre>
<p>pytest的配置文件除了 pytest.ini，还有 tox.ini 和 setup.cfg 也可以当配置文件</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档66-工厂化的 fixtures</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A366-%E5%B7%A5%E5%8E%82%E5%8C%96%E7%9A%84%20fixtures/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在一个测试用例中需要多次调用同一个fixture的时候，工厂化的 fixture 的模式对于一个 fixture 在单一的测试中需要被多次调用非常有用。<br>之前写fixture是直接return一个数据，在测试用例中可以直接使用，现在我们需要返回一个生成数据的函数，这样就能在用例中多次调用了。</p>
<h1 id="Factories-as-ﬁxtures"><a href="#Factories-as-ﬁxtures" class="headerlink" title="Factories as ﬁxtures"></a>Factories as ﬁxtures</h1><p>“Factories as ﬁxtures”模式可以帮助在一次测试中多次需要一个fixture的结果的情况下。<br>fixture不是直接返回数据，而是返回一个生成数据的函数。然后可以在测试中多次调用此函数。</p>
<p>使用示例</p>
<pre><code class="python">import pytest


@pytest.fixture 
def make_customer_record(): 
    def _make_customer_record(name): 
        return &#123;&quot;name&quot;: name, &quot;orders&quot;: []&#125;
    return _make_customer_record

def test_customer_records(make_customer_record): 
    customer_1 = make_customer_record(&quot;Lisa&quot;) 
    customer_2 = make_customer_record(&quot;Mike&quot;) 
    customer_3 = make_customer_record(&quot;Meredith&quot;)
</code></pre>
<p>如果工厂创建的数据需要管理，那么fixture可以处理：</p>
<pre><code class="java">import pytest


@pytest.fixture
def make_customer_record():
  
    created_records = []
  
    def _make_customer_record(name):
        record = models.Customer(name=name, orders=[])
        created_records.append(record) 
        return record
  
    yield _make_customer_record
  
    for record in created_records:
        record.destroy()
      
def test_customer_records(make_customer_record): 
    customer_1 = make_customer_record(&quot;Lisa&quot;) 
    customer_2 = make_customer_record(&quot;Mike&quot;) 
    customer_3 = make_customer_record(&quot;Meredith&quot;)
</code></pre>
<h1 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h1><p>有个场景案例：当用户第一次注册的时候，可以注册成功，第二次注册的时候，提示用户已被注册了</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture()
def register():

    def _register(user):
        # 调用注册接口，返回结果
        print(&quot;注册用户：%s&quot; % user)
        result = &#123;&quot;code&quot;: 0,
                  &quot;message&quot;: &quot;success&quot;&#125;
        return result

    return _register



def test_case_1(register):
    &#39;&#39;&#39;测试重复注册接口案例&#39;&#39;&#39;
    # 第一次调用注册
    result1 = register(&quot;yoyo&quot;)
    assert result1[&quot;message&quot;] == &quot;success&quot;

    # 第二次调用
    result2 = register(&quot;yoyo&quot;)
    # 真实场景可以断言 已被注册了
</code></pre>
<p>这种场景把注册写到fixture的话，在测试用例里面就需要调用两次</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档67-pytest.mark.parametrize 中使用 fixture</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A367-pytest.mark.parametrize%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20fixture/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>测试用例参数化的时候，使用 pytest.mark.parametrize 参数化传测试数据，如果我们想引用前面不同fixture返回的数据当测试用例的入参。<br>可以用fixture 参数化 prams 来间接解决这个问题</p>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>我们需要在测试用例里面参数化，参数化的数据来源于前面不同fixture的返回值，示例</p>
<pre><code class="python">import pytest


@pytest.fixture
def a():
    return &#39;a&#39;


@pytest.fixture
def b():
    return &#39;b&#39;


@pytest.mark.parametrize(&#39;arg&#39;, [a, b])
def test_foo(arg):
    assert len(arg) == 1
</code></pre>
<p>这时候运行会报错</p>
<pre><code class="python">
..\test_xx.py F
arg = &lt;function a at 0x000001C7E77CE7B8&gt;

    @pytest.mark.parametrize(&#39;arg&#39;, [a, b])
    def test_foo(arg):
&gt;       assert len(arg) == 1
E       TypeError: object of type &#39;function&#39; has no len()

\test_xx.py:16: TypeError
F
arg = &lt;function b at 0x000001C7E77CE8C8&gt;

    @pytest.mark.parametrize(&#39;arg&#39;, [a, b])
    def test_foo(arg):
&gt;       assert len(arg) == 1
E       TypeError: object of type &#39;function&#39; has no len()

\test_xx.py:16: TypeError
</code></pre>
<p>关于此问题的讨论可以看github 上的issue <a href="https://github.com/pytest-dev/pytest/issues/349">Using fixtures in pytest.mark.parametrize #349</a></p>
<h1 id="使用-fixture-参数化"><a href="#使用-fixture-参数化" class="headerlink" title="使用 fixture 参数化"></a>使用 fixture 参数化</h1><p>可以使用 fixture 的参数化来解决上面的问题，通过 request.getfixturevalue(“fixture name”) 方法来获取fixture的返回值<br>有些文档看到的是 request.getfuncargvalue 那是早期的版本，目前新版本改名换成了 request.getfixturevalue<br>getfixturevalue 的作用是获取 fixture 的返回值</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.fixture
def a():
    return &#39;a&#39;


@pytest.fixture
def b():
    return &#39;b&#39;


@pytest.fixture(params=[&#39;a&#39;, &#39;b&#39;])
def arg(request):
    return request.getfixturevalue(request.param)


def test_foo(arg):
    assert len(arg) == 1
</code></pre>
<p>这样运行就不会有问题了</p>
<h1 id="实例场景"><a href="#实例场景" class="headerlink" title="实例场景"></a>实例场景</h1><p>web自动化的时候，想在 chrome 和 firefox 浏览器上测试同一功能的测试用例</p>
<pre><code class="python">import pytest
from selenium import webdriver

# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.fixture
def chrome():
    driver = webdriver.Chrome()
    yield driver
    driver.quit()

@pytest.fixture
def firefox():
    driver = webdriver.Firefox()
    yield driver
    driver.quit()


@pytest.fixture(params=[&#39;chrome&#39;, &#39;firefox&#39;])
def driver(request):
    &#39;&#39;&#39;启动浏览器参数化&#39;&#39;&#39;
    return request.getfixturevalue(request.param)


def test_foo(driver):
    &#39;&#39;&#39;测试用例&#39;&#39;&#39;
    driver.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)
</code></pre>
<p>这样就可以分别打开 chrome 和 fixfox 执行测试用例了<br>关于此问题的更多讨论可以看github 上的issue <a href="https://github.com/pytest-dev/pytest/issues/349">Using fixtures in pytest.mark.parametrize #349</a><br>还有另外一个解决方案，使用 pytest-lazy-fixture 插件解决 <a href="https://www.cnblogs.com/yoyoketang/p/14096749.html">https://www.cnblogs.com/yoyoketang/p/14096749.html</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档68-pytest-lazy-fixture 插件解决</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A368-pytest-lazy-fixture%20%E6%8F%92%E4%BB%B6%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>测试用例参数化的时候，使用 pytest.mark.parametrize 参数化传测试数据，如果我们想引用前面 不同fixture 返回的数据当测试用例的入参，前面一篇用fixture 参数化 prams 来间接解决这个问题。<br>接下来用 pytest-lazy-fixture 插件可以直接在测试用例中参数化时 pytest.mark.parametrize 中使用 fixture</p>
<h1 id="pytest-lazy-fixture-插件"><a href="#pytest-lazy-fixture-插件" class="headerlink" title="pytest-lazy-fixture 插件"></a>pytest-lazy-fixture 插件</h1><p>pytest-lazy-fixture 插件是为了解决测试用例中用 @pytest.mark.parametrize 参数化调用fixture的问题，先pip安装</p>
<blockquote>
<p>pip install pytest-lazy-fixture</p>
</blockquote>
<p>目前使用的版本是 0.6.3</p>
<pre><code class="makefile">&gt;pip show pytest-lazy-fixture
Name: pytest-lazy-fixture
Version: 0.6.3
Summary: It helps to use fixtures in pytest.mark.parametrize
Home-page: https://github.com/tvorog/pytest-lazy-fixture
Author: Marsel Zaripov
Author-email: marszaripov@gmail.com
License: MIT
Location: e:\python36\lib\site-packages
Requires: pytest
Required-by:
</code></pre>
<h1 id="parametrize-使用示例"><a href="#parametrize-使用示例" class="headerlink" title="parametrize 使用示例"></a>parametrize 使用示例</h1><p>参数化的时候，其中一些测试数据，来源于前面的 fixture</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


@pytest.fixture(params=[1, 2])
def one(request):
    return request.param


@pytest.mark.parametrize(&#39;arg1,arg2&#39;, [
    (&#39;val1&#39;, pytest.lazy_fixture(&#39;one&#39;)),
])
def test_func(arg1, arg2):
    print(arg1, arg2)
    assert arg2 in [1, 2]
</code></pre>
<p>运行结果</p>
<pre><code class="diff">..\test_y.py val1 1
.val1 2
.

============== 2 passed in 0.04 seconds ===========
</code></pre>
<h1 id="fixture-参数化-params"><a href="#fixture-参数化-params" class="headerlink" title="fixture 参数化 params"></a>fixture 参数化 params</h1><p>在 fixture 参数化的 params 中也可以使用</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.fixture
def one():
    return 1


@pytest.fixture
def two():
    return 2


@pytest.fixture(params=[
    pytest.lazy_fixture(&#39;one&#39;),
    pytest.lazy_fixture(&#39;two&#39;)
])
def some(request):
    return request.param


def test_func(some):
    assert some in [1, 2]
</code></pre>
<p>pytest-lazy-fixture 相关的使用可以查看github 地址<a href="https://github.com/TvoroG/pytest-lazy-fixture">https://github.com/TvoroG/pytest-lazy-fixture</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档69-Hook函数之参数化生成测试用例pytest_generate_tests</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A369-Hook%E5%87%BD%E6%95%B0%E4%B9%8B%E5%8F%82%E6%95%B0%E5%8C%96%E7%94%9F%E6%88%90%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8Bpytest_generate_tests/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 实现参数化有三种方式</p>
<ul>
<li>pytest.fixture() 使用 fixture 传 params 参数实现参数化</li>
<li>@ pytest.mark.parametrize 允许在测试函数或类中定义多组参数，在用例中实现参数化</li>
<li>pytest_generate_tests 允许定义自定义参数化方案或扩展。</li>
</ul>
<h1 id="pytest-generate-tests"><a href="#pytest-generate-tests" class="headerlink" title="pytest_generate_tests"></a>pytest_generate_tests</h1><p>pytest_generate_tests 在测试用例参数化收集前调用此钩子函数，根据测试配置或定义测试函数的类或模块中指定的参数值生成测试用例，<br>可以使用此钩子实现自定义参数化方案或扩展,相关文档参考官方文档<a href="https://docs.pytest.org/en/latest/parametrize.html#pytest-generate-tests">https://docs.pytest.org/en/latest/parametrize.html#pytest-generate-tests</a></p>
<p>有时您可能想要实现自己的参数化方案或实现某种动态性来确定 fixture 的参数或范围。为此，可以使用pytest_generate_tests在收集测试函数时调用的钩子。通过传入的 metafunc 对象，您可以检查请求的测试上下文，最重要的是，您可以调用 metafunc.parametrize() 引起参数化。</p>
<p>例如，假设我们要运行一个测试，并接受要通过新的 pytest 命令行选项设置的字符串输入。让我们首先编写一个接受 stringinput 函数参数的简单测试：</p>
<pre><code class="python"># content of test_strings.py


def test_valid_string(stringinput):
    assert stringinput.isalpha()
</code></pre>
<p>现在，我们添加一个conftest.py文件，其中包含命令行选项和测试函数的参数化：</p>
<pre><code class="python"># content of conftest.py


def pytest_addoption(parser):
    parser.addoption(
        &quot;--stringinput&quot;,
        action=&quot;append&quot;,
        default=[],
        help=&quot;list of stringinputs to pass to test functions&quot;,
    )


def pytest_generate_tests(metafunc):
    if &quot;stringinput&quot; in metafunc.fixturenames:
        metafunc.parametrize(&quot;stringinput&quot;, metafunc.config.getoption(&quot;stringinput&quot;))
</code></pre>
<p>如果现在传递两个stringinput值，则测试将运行两次：</p>
<pre><code class="ruby">$ pytest -q --stringinput=&quot;hello&quot; --stringinput=&quot;world&quot; test_strings.py
..                                                                   [100%]
2 passed in 0.12s
</code></pre>
<p>我们还使用一个stringinput运行，这将导致测试失败：</p>
<pre><code class="python">$ pytest -q --stringinput=&quot;!&quot; test_strings.py
F                                                                    [100%]
================================= FAILURES =================================
___________________________ test_valid_string[!] ___________________________

stringinput = &#39;!&#39;

    def test_valid_string(stringinput):
&gt;       assert stringinput.isalpha()
E       AssertionError: assert False
E        +  where False = &lt;built-in method isalpha of str object at 0xdeadbeef&gt;()
E        +    where &lt;built-in method isalpha of str object at 0xdeadbeef&gt; = &#39;!&#39;.isalpha

test_strings.py:4: AssertionError
========================= short test summary info ==========================
FAILED test_strings.py::test_valid_string[!] - AssertionError: assert False
1 failed in 0.12s
</code></pre>
<p>不出所料，我们的测试功能失败。</p>
<p>如果您未指定字符串输入，则将跳过它，因为 metafunc.parametrize()将使用空参数列表来调用它：</p>
<pre><code class="bash">$ pytest -q -rs test_strings.py
s                                                                    [100%]
========================= short test summary info ==========================
SKIPPED [1] test_strings.py: got empty parameter set [&#39;stringinput&#39;], function test_valid_string at $REGENDOC_TMPDIR/test_strings.py:2
1 skipped in 0.12s
</code></pre>
<p>请注意，当metafunc.parametrize使用不同的参数集多次调用时，这些集合中的所有参数名称都不能重复，否则会引发错误。<br>更多的参数化案例参考<a href="https://docs.pytest.org/en/latest/example/parametrize.html#paramexamples">https://docs.pytest.org/en/latest/example/parametrize.html#paramexamples</a></p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>在 conftest.py 自定义参数化的钩子, 判断当测试用例传了 param 参数，就让它生成参数化的用例</p>
<pre><code class="python">def pytest_generate_tests(metafunc):
    &quot;&quot;&quot; generate (multiple) parametrized calls to a test function.&quot;&quot;&quot;
    if &quot;param&quot; in metafunc.fixturenames:
        metafunc.parametrize(&quot;param&quot;,
                             metafunc.module.test_data,
                             ids=metafunc.module.names,
                             scope=&quot;function&quot;)
</code></pre>
<p>test_parm.py相关的测试数据和用例内容，names是用例的名称，test_data是测试数据</p>
<pre><code class="python">import requests

# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

# 用例的id名称
names = [&quot;login nam1&quot;, &quot;login name2&quot;]
# 测试数据 list of dict
test_data = [&#123;
                &quot;url&quot;: &quot;http://49.235.x.x:5000/api/v1/login/&quot;,
                &quot;method&quot;: &quot;POST&quot;,
                &quot;headers&quot;:
                    &#123;
                        &quot;Content-Type&quot;: &quot;application/json&quot;
                    &#125;,
                &quot;json&quot;:
                    &#123;
                        &quot;username&quot;: &quot;test&quot;,
                        &quot;password&quot;: &quot;123456&quot;
                    &#125;

        &#125;,
        &#123;
            &quot;url&quot;: &quot;http://49.235.x.x:5000/api/v1/login/&quot;,
            &quot;method&quot;: &quot;POST&quot;,
            &quot;headers&quot;:
                &#123;
                    &quot;Content-Type&quot;: &quot;application/json&quot;
                &#125;,
            &quot;json&quot;:
                &#123;
                    &quot;username&quot;: &quot;test&quot;,
                    &quot;password&quot;: &quot;123456&quot;
                &#125;

        &#125;
        ]


def test_login(param):
    r = requests.session().request(**param)
    print(r.text)
</code></pre>
<p>这样运行会，自动生成2条测试用例</p>
<pre><code class="bash">================= test session starts ===============
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
rootdir: D:\
collected 2 items

..\test_param.py 
&#123;&quot;code&quot;: 0, &quot;msg&quot;: &quot;login success!&quot;, &quot;username&quot;: &quot;test&quot;, &quot;token&quot;: &quot;81ae10099feaca6f0af5ba122444bea2a83a2dc9&quot;&#125;
.&#123;&quot;code&quot;: 0, &quot;msg&quot;: &quot;login success!&quot;, &quot;username&quot;: &quot;test&quot;, &quot;token&quot;: &quot;1ccfb99fd68f22da66c95660702af22d64108067&quot;&#125;
.

=============== 2 passed in 0.62 seconds ===============
</code></pre>
<p>上面是把测试数据和代码放一起，想实现代码和数据分离的话，上面的 names 和 test_data 测试数据写到 yaml 文件，写个函数去读取 yaml 文件的数据。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档70-Hook钩子函数完整API总结</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A370-Hook%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%AE%8C%E6%95%B4API%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 的钩子函数有很多，通过钩子函数的学习可以了解到pytest在执行用例的每个阶段做什么事情，也方便后续对pytest二次开发学习。<br>详细文档可以查看pytest官方文档<a href="https://docs.pytest.org/en/latest/reference.html#hooks">https://docs.pytest.org/en/latest/reference.html#hooks</a></p>
<h1 id="钩子函数总结"><a href="#钩子函数总结" class="headerlink" title="钩子函数总结"></a>钩子函数总结</h1><h2 id="第一部分：setuptools"><a href="#第一部分：setuptools" class="headerlink" title="第一部分：setuptools"></a>第一部分：setuptools</h2><p>引导挂钩要求足够早注册的插件（内部和setuptools插件），可以使用的钩子</p>
<ul>
<li>pytest_load_initial_conftests(early_config,parser,args): 在命令行选项解析之前实现初始conftest文件的加载。</li>
<li>pytest_cmdline_preparse(config,args): (不建议使用)在选项解析之前修改命令行参数。</li>
<li>pytest_cmdline_parse(pluginmanager,args): 返回一个初始化的配置对象,解析指定的args。</li>
<li>pytest_cmdline_main(config): 要求执行主命令行动作。默认实现将调用configure hooks和runtest_mainloop。</li>
</ul>
<h2 id="第二部分：-初始化挂钩"><a href="#第二部分：-初始化挂钩" class="headerlink" title="第二部分： 初始化挂钩"></a>第二部分： 初始化挂钩</h2><p>初始化钩子需要插件和conftest.py文件</p>
<ul>
<li>pytest_addoption(parser): 注册argparse样式的选项和ini样式的配置值，这些值在测试运行开始时被调用一次。</li>
<li>pytest_addhooks(pluginmanager): 在插件注册时调用，以允许通过调用来添加新的挂钩</li>
<li>pytest_configure(config): 许插件和conftest文件执行初始配置。</li>
<li>pytest_unconfigure(config): 在退出测试过程之前调用。</li>
<li>pytest_sessionstart(session): 在Session创建对象之后，执行收集并进入运行测试循环之前调用。</li>
<li>pytest_sessionfinish(session,exitstatus): 在整个测试运行完成后调用，就在将退出状态返回系统之前。</li>
<li>pytest_plugin_registered(plugin,manager):一个新的pytest插件已注册。</li>
</ul>
<h2 id="第三部分：-collection-收集钩子"><a href="#第三部分：-collection-收集钩子" class="headerlink" title="第三部分： collection 收集钩子"></a>第三部分： collection 收集钩子</h2><ul>
<li>pytest_collection(session): 执行给定会话的收集协议。</li>
<li>pytest_collect_directory(path, parent): 在遍历目录以获取集合文件之前调用。</li>
<li>pytest_collect_file(path, parent) 为给定的路径创建一个收集器，如果不相关，则创建“无”。</li>
<li>pytest_pycollect_makemodule(path: py._path.local.LocalPath, parent) 返回给定路径的模块收集器或无。</li>
<li>pytest_pycollect_makeitem(collector: PyCollector, name: str, obj: object) 返回模块中Python对象的自定义项目&#x2F;收集器，或者返回None。在第一个非无结果处停止</li>
<li>pytest_generate_tests(metafunc: Metafunc) 生成（多个）对测试函数的参数化调用。</li>
<li>pytest_make_parametrize_id(config: Config, val: object, argname: str) 返回val 将由@ pytest.mark.parametrize调用使用的给定用户友好的字符串表示形式，如果挂钩不知道，则返回None val。</li>
<li>pytest_collection_modifyitems(session: Session, config: Config, items: List[Item]) 在执行收集后调用。可能会就地过滤或重新排序项目。</li>
<li>pytest_collection_finish(session: Session) 在执行并修改收集后调用。</li>
</ul>
<h2 id="第四部分：测试运行（runtest）钩子"><a href="#第四部分：测试运行（runtest）钩子" class="headerlink" title="第四部分：测试运行（runtest）钩子"></a>第四部分：测试运行（runtest）钩子</h2><ul>
<li>pytest_runtestloop(session: Session) 执行主运行测试循环（收集完成后）。</li>
<li>pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) 对单个测试项目执行运行测试协议。</li>
<li>pytest_runtest_logstart(nodeid: str, location: Tuple[str, Optional[int], str]) 在运行单个项目的运行测试协议开始时调用。</li>
<li>pytest_runtest_logfinish(nodeid: str, location: Tuple[str, Optional[int], str])在为单个项目运行测试协议结束时调用。</li>
<li>pytest_runtest_setup(item: Item) 调用以执行测试项目的设置阶段。</li>
<li>pytest_runtest_call(item: Item) 调用以运行测试项目的测试（调用阶段）。</li>
<li>pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) 调用以执行测试项目的拆卸阶段。</li>
<li>pytest_runtest_makereport(item: Item, call: CallInfo[None]) 被称为为_pytest.reports.TestReport测试项目的每个设置，调用和拆卸运行测试阶段创建一个。</li>
<li>pytest_pyfunc_call(pyfuncitem: Function) 调用基础测试功能。</li>
</ul>
<h2 id="第五部分：Reporting-报告钩子"><a href="#第五部分：Reporting-报告钩子" class="headerlink" title="第五部分：Reporting 报告钩子"></a>第五部分：Reporting 报告钩子</h2><ul>
<li>pytest_collectstart(collector: Collector) 收集器开始收集。</li>
<li>pytest_make_collect_report(collector: Collector) 执行collector.collect()并返回一个CollectReport。</li>
<li>pytest_itemcollected(item: Item) 我们刚刚收集了一个测试项目。</li>
<li>pytest_collectreport(report: CollectReport) 收集器完成收集。</li>
<li>pytest_deselected(items: Sequence[Item]) 要求取消选择的测试项目，例如按关键字。</li>
<li>pytest_report_header(config: Config, startdir: py._path.local.LocalPath) 返回要显示为标题信息的字符串或字符串列表，以进行终端报告。</li>
<li>pytest_report_collectionfinish(config: Config, startdir: py._path.local.LocalPath, items: Sequence[Item]) 返回成功完成收集后将显示的字符串或字符串列表。</li>
<li>pytest_report_teststatus(report: Union[CollectReport, TestReport], config: Config) 返回结果类别，简写形式和详细词以进行状态报告。</li>
<li>pytest_terminal_summary(terminalreporter: TerminalReporter, exitstatus: ExitCode, config: Config) 在终端摘要报告中添加一个部分。</li>
<li>pytest_fixture_setup(fixturedef: FixtureDef[Any], request: SubRequest) 执行夹具设置执行。</li>
<li>pytest_fixture_post_finalizer(fixturedef: FixtureDef[Any], request: SubRequest) 在夹具拆除之后但在清除缓存之前调用，因此夹具结果fixturedef.cached_result仍然可用（不是 None）</li>
<li>pytest_warning_captured(warning_message: warnings.WarningMessage, when: Literal[‘config’, ‘collect’, ‘runtest’], item: Optional[Item], location: Optional[Tuple[str, int, str]]) （已弃用）处理内部pytest警告插件捕获的警告。</li>
<li>pytest_warning_recorded(warning_message: warnings.WarningMessage, when: Literal[‘config’, ‘collect’, ‘runtest’], nodeid: str, location: Optional[Tuple[str, int, str]]) 处理内部pytest警告插件捕获的警告。</li>
<li>pytest_runtest_logreport(report: TestReport) 处理项目的_pytest.reports.TestReport每个设置，调用和拆卸运行测试阶段产生的结果。</li>
<li>pytest_assertrepr_compare(config: Config, op: str, left: object, right: object) 返回失败断言表达式中的比较的说明。</li>
<li>pytest_assertion_pass(item: Item, lineno: int, orig: str, expl: str) （实验性的）在断言通过时调用。</li>
</ul>
<h2 id="第六部分：调试-x2F-相互作用钩"><a href="#第六部分：调试-x2F-相互作用钩" class="headerlink" title="第六部分：调试&#x2F;相互作用钩"></a>第六部分：调试&#x2F;相互作用钩</h2><p>很少有可以用于特殊报告或与异常交互的挂钩：</p>
<ul>
<li>pytest_internalerror(excrepr: ExceptionRepr, excinfo: ExceptionInfo[BaseException]) 要求内部错误。返回True以禁止对将INTERNALERROR消息直接打印到sys.stderr的回退处理。</li>
<li>pytest_keyboard_interrupt(excinfo: ExceptionInfo[Union[KeyboardInterrupt, Exit]]) 要求键盘中断。</li>
<li>pytest_exception_interact(node: Union[Item, Collector], call: CallInfo[Any], report: Union[CollectReport, TestReport]) 在引发可能可以交互处理的异常时调用。</li>
<li>pytest_enter_pdb(config: Config, pdb: pdb.Pdb) 调用了pdb.set_trace（）。</li>
</ul>
<p>详细文档可以查看pytest官方文档<a href="https://docs.pytest.org/en/latest/reference.html#hooks">https://docs.pytest.org/en/latest/reference.html#hooks</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档71-pytest+yaml实现接口自动化框架</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A371-pytest+yaml%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>httprunner 用 yaml 文件实现接口自动化框架很好用，最近在看 pytest 框架，于是参考 httprunner的用例格式，写了一个差不多的 pytest 版的简易框架</p>
<h1 id="项目结构设计"><a href="#项目结构设计" class="headerlink" title="项目结构设计"></a>项目结构设计</h1><p>项目结构完全符合 pytest 的项目结构，pytest 是查找 test_. <em>py 文件，我这里是查找 test_</em> .yml 文件，唯一不同的就是这个地方<br>以前写test_*.py 的测试用例，现在完全不用写了，全部写yaml 文件就行，项目结构参考</p>
<p><img src="/assets/2/image-20220516012433-6xygbwv.png" alt="image.png"></p>
<p>只需在 conftest.py 即可实现，代码量超级少</p>
<pre><code class="python">import pytest
import requests
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


def pytest_collect_file(parent, path):
    # 获取文件.yml 文件,匹配规则
    if path.ext == &quot;.yml&quot; and path.basename.startswith(&quot;test&quot;):
        # print(path)
        # print(parent)
        return YamlFile(path, parent)



class YamlFile(pytest.File):
    # 读取文件内容
    def collect(self):
        import yaml
        raw = yaml.safe_load(self.fspath.open(encoding=&#39;utf-8&#39;))
        for yaml_case in raw:
            name = yaml_case[&quot;test&quot;][&quot;name&quot;]
            values = yaml_case[&quot;test&quot;]
            yield YamlTest(name, self, values)


class YamlTest(pytest.Item):
    def __init__(self, name, parent, values):
        super(YamlTest, self).__init__(name, parent)
        self.name = name
        self.values = values
        self.request = self.values.get(&quot;request&quot;)
        self.validate = self.values.get(&quot;validate&quot;)
        self.s = requests.session()

    def runtest(self):
        # 运行用例
        request_data = self.values[&quot;request&quot;]
        # print(request_data)
        response = self.s.request(**request_data)
        print(&quot;\n&quot;, response.text)
        # 断言
        self.assert_response(response, self.validate)

    def assert_response(self, response, validate):
        &#39;&#39;&#39;设置断言&#39;&#39;&#39;
        import jsonpath
        for i in validate:
            if &quot;eq&quot; in i.keys():
                yaml_result = i.get(&quot;eq&quot;)[0]
                actual_result = jsonpath.jsonpath(response.json(), yaml_result)
                expect_result = i.get(&quot;eq&quot;)[1]
                print(&quot;实际结果：%s&quot; % actual_result)
                print(&quot;期望结果：%s&quot; % expect_result)
                assert actual_result[0] == expect_result
</code></pre>
<p>断言这部分，目前只写了判断相等，仅供参考，支持jsonpath来提取json数据</p>
<h1 id="yaml格式的用例"><a href="#yaml格式的用例" class="headerlink" title="yaml格式的用例"></a>yaml格式的用例</h1><p>在项目的任意目录，只要是符合test_开头的yml文件，我们就认为是测试用例<br>test_login.yml的内容如下</p>
<pre><code class="yaml">- test:
    name: login case1
    request:
        url: http://49.235.x.x:7000/api/v1/login/
        method: POST
        headers:
            Content-Type: application/json
            User-Agent: python-requests/2.18.4
        json:
            username: test
            password: 123456
    validate:
        - eq: [$.msg, login success!]
        - eq: [$.code, 0]


- test:
    name: login case2
    request:
        url: 49.235.x.x:7000/api/v1/login/
        method: POST
        headers:
            Content-Type: application/json
            User-Agent: python-requests/2.18.4
        json:
            username: test
            password: 123456
    validate:
        - eq: [$.msg, login success!]
        - eq: [$.code, 0]
</code></pre>
<h1 id="运行用例"><a href="#运行用例" class="headerlink" title="运行用例"></a>运行用例</h1><p>运行用例，完全符合pytest的只需用例风格，支持allure报告</p>
<blockquote>
<p>pytest -v</p>
</blockquote>
<pre><code class="haskell">D:\soft\api_pytest_1208&gt;pytest -v
====================== test session starts ======================
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0,
cachedir: .pytest_cache
rootdir: D:\soft\api_pytest_1208
plugins: allure-pytest-2.8.6
collected 4 items

data/test_login.yml::login case1 PASSED                    [ 25%]
data/test_login.yml::login case2 PASSED                    [ 50%]
data/test_login1.yml::login case1 PASSED                   [ 75%]
data/test_login1.yml::login case2 PASSED                   [100%]

=================== 4 passed in 1.34 seconds ====================
</code></pre>
<p>allure报告</p>
<blockquote>
<p>pytest –alluredir .&#x2F;report</p>
</blockquote>
<p>目前是把 yaml 文件下每个 test 当一个用例执行，后续还可以加上提取参数，参数关联更高级的功能！</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档72-使用 template 替换 yaml 文件的变量</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A372-%E4%BD%BF%E7%94%A8%20template%20%E6%9B%BF%E6%8D%A2%20yaml%20%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在接口自动化测试的时候，yaml 文件一般放测试的数据或当配置文件使用，yaml 文件存放静态的数据是没问题的，python的数据类型基本上都是支持的。<br>有时候我们想在 yaml 文件中引用变量来读取 python 代码的设置值。</p>
<h1 id="template-使用"><a href="#template-使用" class="headerlink" title="template 使用"></a>template 使用</h1><p>template 是字符串模板，用于替换字符串中的变量，是 string 的一个类引用变量有 2 种格式</p>
<ul>
<li>$variable 使用 $变量名 引用变量</li>
<li>${variable} 使用 ${变量名} 大括号包起来</li>
</ul>
<p>第一种 $variable</p>
<pre><code class="php">from string import Template
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


tempTemplate = Template(&quot;My name is $name , i like $fancy&quot;)
d = &#123;&#39;name&#39;: &#39;yoyo&#39;, &#39;fancy&#39;: &#39;python&#39;&#125;
print(tempTemplate.substitute(d))

# 运行结果
# &gt;&gt;&gt; My name is yoyo , i like python
</code></pre>
<p>第二种 ${variable}</p>
<pre><code class="bash">from string import Template
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


tempTemplate = Template(&quot;My name is $&#123;name&#125; , i like $&#123;fancy&#125;&quot;)
d = &#123;&#39;name&#39;: &#39;yoyo&#39;, &#39;fancy&#39;: &#39;python&#39;&#125;
print(tempTemplate.substitute(d))

# 运行结果
# &gt;&gt;&gt;My name is yoyo , i like python
</code></pre>
<h1 id="safe-substitute使用"><a href="#safe-substitute使用" class="headerlink" title="safe_substitute使用"></a>safe_substitute使用</h1><p>上面的方式只能严格的匹配变量，当字符串中有$符号，不想匹配变量的时候，会报错</p>
<pre><code class="bash">from string import Template
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/


tempTemplate = Template(&quot;$My name is $&#123;name&#125; , i like $&#123;fancy&#125;&quot;)
d = &#123;&#39;name&#39;: &#39;yoyo&#39;, &#39;fancy&#39;: &#39;python&#39;&#125;
print(tempTemplate.substitute(d))
</code></pre>
<p>这段，$符号加在My的前面，我只想让它是一个普通的字符串，不想引用变量，就出现了报错说找不到这个key</p>
<pre><code class="vhdl">Traceback (most recent call last):
  File &quot;D:/soft/api_pytest_1208/config/aa.py&quot;, line 12, in &lt;module&gt;
    print(tempTemplate.substitute(d))
  File &quot;E:\python36\lib\string.py&quot;, line 130, in substitute
    return self.pattern.sub(convert, self.template)
  File &quot;E:\python36\lib\string.py&quot;, line 123, in convert
    return str(mapping[named])
KeyError: &#39;My&#39;
</code></pre>
<p>Template 里面还有一个 safe_substitute 的方法，可以忽略匹配不到的变量</p>
<pre><code class="bash">from string import Template


tempTemplate = Template(&quot;$My name is $&#123;name&#125; , i like $&#123;fancy&#125;&quot;)
d = &#123;&#39;name&#39;: &#39;yoyo&#39;&#125;
print(tempTemplate.safe_substitute(d))

# 运行结果：$My name is yoyo , i like $&#123;fancy&#125;
</code></pre>
<p>虽然字符串定义了多个变量，但是引用的时候只给了name这个值，也不影响运行，没给值的当普通字符串出来，这样就很完美了</p>
<h1 id="yaml-文件引用变量"><a href="#yaml-文件引用变量" class="headerlink" title="yaml 文件引用变量"></a>yaml 文件引用变量</h1><p>通过前面 Template 的基础使用，已经掌握了基本的用法了，接下来在 yaml 文件中引用变量</p>
<pre><code class="yaml">- test:
    name: login case1
    request:
        url: http://49.235.x.x:7000/api/v1/login/
        method: POST
        headers:
            Content-Type: application/json
            User-Agent: python-requests/2.18.4
        json:
            username: $user
            password: $psw
    validate:
        - eq: [$.msg, login success!]
        - eq: [$.code, 0]
</code></pre>
<p>python读yaml文件代码</p>
<pre><code class="python">from string import Template
import yaml
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

with open(&quot;login.yml&quot;, encoding=&#39;utf-8&#39;) as fp:
    read_yml_str = fp.read()
    # print(xx)

    tempTemplate1 = Template(read_yml_str)
    c = tempTemplate1.safe_substitute(&#123;&quot;user&quot;: &quot;yoyo&quot;, &quot;psw&quot;: &quot;123456 &quot;&#125;)
    print(c)

# yml 文件数据，转 python 类型
yaml_data = yaml.safe_load(c)
print(yaml_data)
</code></pre>
<p>运行结果</p>
<pre><code class="yaml">- test:
    name: login case1
    request:
        url: http://49.235.x.x:7000/api/v1/login/
        method: POST
        headers:
            Content-Type: application/json
            User-Agent: python-requests/2.18.4
        json:
            username: user
            password: 123456 
    validate:
        - eq: [$.msg, login success!]
        - eq: [$.code, 0]

[&#123;
    &#39;test&#39;: &#123;
        &#39;name&#39;: &#39;login case1&#39;,
        &#39;request&#39;: &#123;
            &#39;url&#39;: &#39;http://49.235.x.x:7000/api/v1/login/&#39;,
            &#39;method&#39;: &#39;POST&#39;,
            &#39;headers&#39;: &#123;
                &#39;Content-Type&#39;: &#39;application/json&#39;,
                &#39;User-Agent&#39;: &#39;python-requests/2.18.4&#39;
            &#125;,
            &#39;json&#39;: &#123;
                &#39;username&#39;: &#39;user&#39;,
                &#39;password&#39;: 123456
            &#125;
        &#125;,
        &#39;validate&#39;: [&#123;
            &#39;eq&#39;: [&#39;$.msg&#39;, &#39;login success!&#39;]
        &#125;, &#123;
            &#39;eq&#39;: [&#39;$.code&#39;, 0]
        &#125;]
    &#125;
&#125;]
</code></pre>
<p>这样 yaml 文件就能引用到 python 的变量了</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档73-pytest+yaml实现接口自动化框架之用例参数关联</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A373-pytest+yaml%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%94%A8%E4%BE%8B%E5%8F%82%E6%95%B0%E5%85%B3%E8%81%94/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 yaml 文件写测试用例的时候，如何在 yaml 文件的测试用例里面实现参数关联? 这是很多做自动化测试的小伙伴经常思考的一个问题。<br>接着前面的pytest+yaml 文件实现接口自动化框架，本篇使用环境变量的方式，让测试用例参数关联。<br>实现场景：上个接口返回的接口提取变量，在写个接口中引用变量</p>
<h1 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h1><p>我现在有一个登陆接口A,登陆成功后返回一个token值。有一个获取用户信息的接口B，但是接口B必须要先登录后传登录的token才能访问<br>A接口登录接口文档基本信息</p>
<ul>
<li>访问地址：<a href="http://127.0.0.1:8000/api/v1/login/">http://127.0.0.1:8000/api/v1/login/</a></li>
<li>请求类型：POST</li>
<li>请求头部：application&#x2F;json</li>
<li>请求参数：{“username”:”test”, “password”:”123456”}</li>
</ul>
<p>B接口获取绑定卡号的接口文档基本信息</p>
<ul>
<li>访问地址：<a href="http://127.0.0.1:8000/api/v1/userinfo/">http://127.0.0.1:8000/api/v1/userinfo/</a></li>
<li>请求类型：GET</li>
<li>请求头部：Content-Type: application&#x2F;json</li>
<li>请求头部token参数： Authorization: Token xxxxx login token xxxxx</li>
</ul>
<p>先不带token去访问接口B，使用命令行工具httpie测试接口</p>
<pre><code class="makefile">C:\Users\dell&gt;http http://127.0.0.1:8000/api/v1/user/info/
HTTP/1.1 401 Unauthorized
Allow: GET, POST, HEAD, OPTIONS
Content-Length: 58
Content-Type: application/json
Date: Sat, 21 Sep 2019 14:06:15 GMT
Server: WSGIServer/0.2 CPython/3.6.0
Vary: Accept
WWW-Authenticate: Token
X-Frame-Options: SAMEORIGIN

&#123;
    &quot;detail&quot;: &quot;Authentication credentials were not provided.&quot;
&#125;
</code></pre>
<p>不带token会提示没权限访问：401 Unauthorized</p>
<h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><p>先使用接口测试工具测试下，用postman,或者fiddler都可以，我这里为了查看报文信息方便，用httpie命令行工具</p>
<p>先访问接口A获取token值<code>234af73571da46ade79ea6a74961b1d23d609b79</code></p>
<pre><code class="makefile">D:\&gt;http http://127.0.0.1:8000/api/v1/login/ username=test password=123456 -v
POST /api/v1/login/ HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 42
Content-Type: application/json
Host: 127.0.0.1:8000
User-Agent: HTTPie/1.0.3

&#123;
    &quot;password&quot;: &quot;123456&quot;,
    &quot;username&quot;: &quot;test&quot;
&#125;

HTTP/1.1 200 OK
Allow: POST, OPTIONS
Content-Length: 109
Content-Type: application/json
Date: Sat, 21 Sep 2019 15:37:06 GMT
Server: WSGIServer/0.2 CPython/3.6.0
Vary: Accept, Cookie
X-Frame-Options: SAMEORIGIN

&#123;
    &quot;code&quot;: 0,
    &quot;msg&quot;: &quot;login success!&quot;,
    &quot;token&quot;: &quot;234af73571da46ade79ea6a74961b1d23d609b79&quot;,
    &quot;username&quot;: &quot;test&quot;
&#125;
</code></pre>
<p>传给下个接口B</p>
<pre><code class="makefile">D:\&gt;http http://127.0.0.1:8000/api/v1/user/info/ Authorization:&quot;Token b7e02c959fbae4c2a0d9094f6f9b9a35fa8aaa1e&quot; -v
GET /api/v1/user/info/ HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Authorization: Token b7e02c959fbae4c2a0d9094f6f9b9a35fa8aaa1e
Connection: keep-alive
Host: 127.0.0.1:8000
User-Agent: HTTPie/1.0.3



HTTP/1.1 200 OK
Allow: GET, POST, HEAD, OPTIONS
Content-Length: 96
Content-Type: application/json
Date: Sat, 21 Sep 2019 16:04:25 GMT
Server: WSGIServer/0.2 CPython/3.6.0
Vary: Accept
X-Frame-Options: SAMEORIGIN

&#123;
    &quot;msg&quot;: &quot;sucess!&quot;,
    &quot;code&quot;: 0,
    &quot;data&quot;: [&#123;
        &quot;id&quot;: 15,
        &quot;name&quot;: &quot;test&quot;,
        &quot;sex&quot;: &quot;F&quot;,
        &quot;age&quot;: 20,
        &quot;mail&quot;: &quot;1122@qq.com&quot;,
        &quot;create_time&quot;: &quot;2020-12-18&quot;
    &#125;]
&#125;
</code></pre>
<p>传头部参数用xx:xxxx格式，中间用冒号:，如：<code>User-Agent:demo-agent/1.0 &#39;Cookie:a=b;b=c&#39;</code>,由于Authorization参数中间有空格，用双引号包起来</p>
<h1 id="conftest-py-代码实现"><a href="#conftest-py-代码实现" class="headerlink" title="conftest.py 代码实现"></a>conftest.py 代码实现</h1><p>在 conftest.py 使用环境变量保存测试的结果提取的变量，使用 template 替换 yaml 文件的变量</p>
<pre><code class="python">import pytest
import requests
import jsonpath
import json
import yaml
from string import Template
import os
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

def pytest_collect_file(parent, path):
    # 获取文件.yml 文件,匹配规则
    if path.ext == &quot;.yml&quot; and path.basename.startswith(&quot;test&quot;):
        print(path)
        print(parent)
        return YamlFile(path, parent)


class YamlFile(pytest.File):
    &#39;&#39;&#39;收集测试用例&#39;&#39;&#39;
    def collect(self):
        yml_raw = self.fspath.open(encoding=&#39;utf-8&#39;).read()
        yml_var = Template(yml_raw).safe_substitute(os.environ)
        yaml_data = yaml.safe_load(yml_var)
        for yaml_case in yaml_data:
            name = yaml_case.get(&quot;test&quot;).get(&quot;name&quot;)
            values = yaml_case.get(&quot;test&quot;)
            yield YamlTest(name, self, values)


class YamlTest(pytest.Item):
    def __init__(self, name, parent, values):
        super(YamlTest, self).__init__(name, parent)
        self.name = name
        self.values = values
        self.s = requests.session()

    def values_render_variable(self, values):
        # values 是Test用例部分
        yaml_test = Template(json.dumps(values)).safe_substitute(os.environ)
        values = yaml.safe_load(yaml_test)
        return values

    def runtest(self):
        # 运行用例
        values = self.values_render_variable(self.values)
        request_data = values.get(&quot;request&quot;)
        print(&quot;\n请求数据: &quot;, request_data)
        print(request_data)
        response = self.s.request(**request_data)
        print(&quot;接口返回&quot;, response.text)
        # 判断是否有extract提取参数
        if values.get(&quot;extract&quot;):
            for key, value in values.get(&quot;extract&quot;).items():
                os.environ[key] = jsonpath.jsonpath(response.json(), value)[0]
        self.assert_response(response, values.get(&quot;validate&quot;))

    def assert_response(self, response, validate):
        &#39;&#39;&#39;设置断言&#39;&#39;&#39;
        if validate:
            for i in validate:
                if &quot;eq&quot; in i.keys():
                    yaml_result = i.get(&quot;eq&quot;)[0]
                    actual_result = jsonpath.jsonpath(response.json(), yaml_result)
                    expect_result = i.get(&quot;eq&quot;)[1]
                    print(&quot;实际结果：%s&quot; % actual_result[0])
                    print(&quot;期望结果：%s&quot; % expect_result)
                    assert actual_result[0] == expect_result
</code></pre>
<h1 id="YAML-文件案例"><a href="#YAML-文件案例" class="headerlink" title="YAML 文件案例"></a>YAML 文件案例</h1><p>使用 extract 关键字提取变量，提取变量方式执行jsonpath表达式， 引用变量使用template 模板的引用语法$变量名</p>
<pre><code class="yaml"># 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

- test:
    name: login case1
    request:
        url: http://49.235.X.X:7000/api/v1/login/
        method: POST
        headers:
            Content-Type: application/json
            User-Agent: python-requests/2.18.4
        json:
            username: test
            password: 123456
    extract:
        token: $.token
    validate:
        - eq: [$.msg, login success!]
        - eq: [$.code, 0]

- test:
    name: get user info case1
    request:
        url: http://49.235.X.X:7000/api/v1/userinfo/
        method: GET
        headers:
            Content-Type: application/json
            User-Agent: python-requests/2.18.4
            Authorization: Token $token
    validate:
        - eq: [$.code, 0]
        - eq: [&quot;$.data[0].name&quot;, test]
        - eq: [&quot;$.data[0].mail&quot;, 1122@qq.com]
</code></pre>
<h1 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h1><p>执行方式使用命令行运行，支持pytest的命令行指令</p>
<blockquote>
<p>pytest</p>
</blockquote>
<p>运行结果</p>
<pre><code class="kotlin">&gt;pytest -s
============================= test session starts ==============================
platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1
rootdir: D:\soft\api_pytest_1208
collecting ... D:\soft\api_pytest_1208\data\test_info.yml
&lt;Package D:\soft\api_pytest_1208\data&gt;
collected 2 items

data\test_info.yml
请求数据:  &#123;&#39;url&#39;: &#39;http://49.235.X.X:7000/api/v1/login/&#39;, &#39;method&#39;: &#39;POST&#39;, 
&#39;headers&#39;: &#123;&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;python-requests/2.18.4&#39;&#125;, 
&#39;json&#39;: &#123;&#39;username&#39;: &#39;test&#39;, &#39;password&#39;: 123456&#125;&#125;
&#123;&#39;url&#39;: &#39;http://49.235.X.X:7000/api/v1/login/&#39;, &#39;method&#39;: &#39;POST&#39;, 
&#39;headers&#39;: &#123;&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;python-requests/2.18.4&#39;&#125;,
 &#39;json&#39;: &#123;&#39;username&#39;: &#39;test&#39;, &#39;password&#39;: 123456&#125;&#125;
接口返回 &#123;&quot;code&quot;: 0, &quot;msg&quot;: &quot;login success!&quot;, &quot;username&quot;: &quot;test&quot;, &quot;token&quot;: &quot;09be4368534fa6320ed77a333e34c6661a36d40e&quot;&#125;
实际结果：login success!
期望结果：login success!
实际结果：0
期望结果：0
.
请求数据:  &#123;&#39;url&#39;: &#39;http://49.235.X.X:7000/api/v1/userinfo/&#39;, &#39;method&#39;: &#39;GET&#39;, 
&#39;headers&#39;: &#123;&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;python-requests/2.18.4&#39;, 
&#39;Authorization&#39;: &#39;Token 09be4368534fa6320ed77a333e34c6661a36d40e&#39;&#125;&#125;
&#123;&#39;url&#39;: &#39;http://49.235.X.X:7000/api/v1/userinfo/&#39;, &#39;method&#39;: &#39;GET&#39;, 
&#39;headers&#39;: &#123;&#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;python-requests/2.18.4&#39;, 
&#39;Authorization&#39;: &#39;Token 09be4368534fa6320ed77a333e34c6661a36d40e&#39;&#125;&#125;
接口返回 &#123;&quot;msg&quot;:&quot;sucess!&quot;,&quot;code&quot;:0,&quot;data&quot;:[&#123;&quot;id&quot;:15,&quot;name&quot;:&quot;test&quot;,&quot;sex&quot;:&quot;F&quot;,&quot;age&quot;:20,&quot;mail&quot;:&quot;1122@qq.com&quot;,&quot;create_time&quot;:&quot;2020-12-18&quot;&#125;]&#125;
实际结果：0
期望结果：0
实际结果：test
期望结果：test
实际结果：1122@qq.com
期望结果：1122@qq.com
.

=========================== 2 passed in 0.49 seconds ===========================
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档74-参数化parametrize加marks标记（pytest.param）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A374-%E5%8F%82%E6%95%B0%E5%8C%96parametrize%E5%8A%A0marks%E6%A0%87%E8%AE%B0%EF%BC%88pytest.param%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 使用 parametrize 参数化的时候，有多组测试数据，需要对其中的一些测试数据加标记跳过，可以用pytest.param实现。</p>
<h1 id="pytest-param"><a href="#pytest-param" class="headerlink" title="pytest.param"></a>pytest.param</h1><p>先看下 pytest.param 源码,可以传三个参数</p>
<ul>
<li>param values ：按顺序传参数集值的变量args</li>
<li>keyword marks : marks关键字参数，要应用于此参数集的单个标记或标记列表。</li>
<li>keyword str id: id字符串关键字参数，测试用例的id属性</li>
</ul>
<pre><code class="python">def param(*values, **kw):
    &quot;&quot;&quot;Specify a parameter in `pytest.mark.parametrize`_ calls or
    :ref:`parametrized fixtures &lt;fixture-parametrize-marks&gt;`.

    .. code-block:: python

        @pytest.mark.parametrize(&quot;test_input,expected&quot;, [
            (&quot;3+5&quot;, 8),
            pytest.param(&quot;6*9&quot;, 42, marks=pytest.mark.xfail),
        ])
        def test_eval(test_input, expected):
            assert eval(test_input) == expected

    :param values: variable args of the values of the parameter set, in order.
    :keyword marks: a single mark or a list of marks to be applied to this parameter set.
    :keyword str id: the id to attribute to this parameter set.
    &quot;&quot;&quot;
    return ParameterSet.param(*values, **kw)
</code></pre>
<p>使用示例</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.mark.parametrize(&quot;test_input,expected&quot;, [
    (&quot;3+5&quot;, 8),
    pytest.param(&quot;6*9&quot;, 42, marks=pytest.mark.xfail),
])
def test_eval(test_input, expected):
    assert eval(test_input) == expected
</code></pre>
<p>运行结果:1 passed, 1 xfailed in 0.08 seconds</p>
<h1 id="skip跳过用例"><a href="#skip跳过用例" class="headerlink" title="skip跳过用例"></a>skip跳过用例</h1><p>上面的案例是标记xfail，想标记skip跳过用例也是可以的</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.mark.parametrize(&quot;user,psw&quot;,
                         [(&quot;yoyo1&quot;, &quot;123456&quot;),
                          (&quot;yoyo2&quot;, &quot;123456&quot;),
                          pytest.param(&quot;yoyo3&quot;, &quot;123456&quot;, marks=pytest.mark.skip)])
def test_login(user, psw):
    print(user + &quot; : &quot; + psw)
    assert 1 == 1
</code></pre>
<p>运行结果：2 passed, 1 skipped in 0.03 seconds</p>
<p>上面的2个参数也可以用pytest.param格式</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.mark.parametrize(&quot;user,psw&quot;,
                         [pytest.param(&quot;yoyo1&quot;, &quot;123456&quot;),
                          pytest.param(&quot;yoyo2&quot;, &quot;123456&quot;),
                          pytest.param(&quot;yoyo3&quot;, &quot;123456&quot;, marks=pytest.mark.skip)])
def test_login1(user, psw):
    print(user + &quot; : &quot; + psw)
    assert 1 == 1
</code></pre>
<h1 id="id参数"><a href="#id参数" class="headerlink" title="id参数"></a>id参数</h1><p>id参数是给用例添加标题内容，没加id参数的时候，用例会默认拿请求的参数当用例标题<br><img src="/assets/2/image-20220516012217-wvtuy5q.png" alt="image.png"></p>
<p>添加id参数</p>
<pre><code class="python">import pytest
# 作者-上海悠悠 QQ交流群:717225969
# blog地址 https://www.cnblogs.com/yoyoketang/

@pytest.mark.parametrize(&quot;user,psw&quot;,
                         [pytest.param(&quot;yoyo1&quot;, &quot;123456&quot;, id=&quot;test case1: yoyo1&quot;),
                          pytest.param(&quot;yoyo2&quot;, &quot;123456&quot;, id=&quot;test case2: yoyo2&quot;),
                          pytest.param(&quot;yoyo3&quot;, &quot;123456&quot;, marks=pytest.mark.skip, id=&quot;test case3: yoyo3&quot;)])
def test_login1(user, psw):
    print(user + &quot; : &quot; + psw)
    assert 1 == 1
</code></pre>
<p>运行结果<br><img src="/assets/2/image-20220516012208-6vk3vl3.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档75-生成 junit-xml 测试报告</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A375-%E7%94%9F%E6%88%90%20junit-xml%20%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 生成junit-xml 测试报告，那么生成的xml报告有什么用呢？可以集合一些持续集成工具（如jenkins…等）方便查看报告。</p>
<h1 id="junit-xml-测试报告"><a href="#junit-xml-测试报告" class="headerlink" title="junit-xml 测试报告"></a>junit-xml 测试报告</h1><p>命令行参数有2个跟 junit-xml 报告相关的参数</p>
<pre><code class="mipsasm">  --junit-xml=path      create junit-xml style report file at given path.
  --junit-prefix=str    prepend prefix to classnames in junit-xml output
</code></pre>
<p><code>--junit-xml</code> 指定报告保存地址,使用示例</p>
<pre><code class="shell">&gt; pytest demo --junit-xml=./report.xml
</code></pre>
<p>运行后会在当前目录生成一个report.xml格式报告</p>
<p><img src="/assets/2/image-20220516012053-91qylc3.png" alt="image.png"></p>
<p><code>--junit-prefix</code> 设置xml报告的class属性，使用示例</p>
<pre><code class="shell">&gt; pytest demo --junit-xml=./report.xml --junit-prefix=xxx
</code></pre>
<p><img src="/assets/2/image-20220516012101-fv7ghs0.png" alt="image.png"></p>
<h1 id="pytest-ini配置"><a href="#pytest-ini配置" class="headerlink" title="pytest.ini配置"></a>pytest.ini配置</h1><p>pytest.ini配置有5个参数可以配置</p>
<pre><code class="vhdl">  junit_suite_name (string):
                        Test suite name for JUnit report
  junit_logging (string):
                        Write captured log messages to JUnit report: one of no|log|system-out|system-err|out-err|all
  junit_log_passing_tests (bool):
                        Capture log information for passing tests to JUnit report:
  junit_duration_report (string):
                        Duration time to report: one of total|call
  junit_family (string):
                        Emit XML for schema: one of legacy|xunit1|xunit2
</code></pre>
<p>junit_suite_name 参数可以修改JUnit报告的名称，使用示例，在pytest.ini配置文件添加</p>
<pre><code class="ini">[pytest]

junit_suite_name=yoyo
</code></pre>
<p>运行后会在xml报告中修改testsuite中的name属性</p>
<p><img src="/assets/2/image-20220516012114-bkta4c4.png" alt="image.png"></p>
<p>在命令行中也可以通过传参<code>-o junit_suite_name</code>也可以改变testsuite中的name属性</p>
<pre><code class="shell">&gt; pytest demo --junit-xml=./report.xml -o junit_suite_name
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档76-命令行中神奇的-o参数使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A376-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%A5%9E%E5%A5%87%E7%9A%84-o%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 命令行中 -o 参数的作用是覆盖pytest.ini配置文件中的参数，那就意味着在ini中的参数，也可以在命令行中使用了。</p>
<h1 id="o-参数"><a href="#o-参数" class="headerlink" title="-o 参数"></a>-o 参数</h1><p>pytest -h 可以查看到-o参数的使用</p>
<pre><code class="csharp">-o OVERRIDE_INI, --override-ini=OVERRIDE_INI
   override ini option with &quot;option=value&quot; style, e.g. `-o xfail_strict=True -o cache_dir=cache`.
</code></pre>
<p>其作用是覆盖ini配置中的”option&#x3D;value”，如：<code>-o xfail_strict=True -o cache_dir=cache</code></p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>之前有小伙伴问到生成JUnit报告,在 pytest.ini 配置文件添加 junit_suite_name 参数可以实现</p>
<pre><code class="ini">[pytest]

junit_suite_name=yoyo
</code></pre>
<p>但是小伙伴想在命令行中实现，却没有这个参数，当时给的解决办法是在conftest.py中通过钩子函数把命令行参数注册到pytest.ini中</p>
<pre><code class="python"># conftest.py
def pytest_addoption(parser):
    parser.addoption(
        &quot;--suite-name&quot;,
        action=&quot;store&quot;,
        default=&quot;yoyo&quot;,
        help=&quot;&#39;Default yoyo&quot;
    )


def pytest_configure(config):
    name = config.getoption(&quot;--suite-name&quot;)
    if name:
        config._inicache[&#39;junit_suite_name&#39;]=name
</code></pre>
<p>后来翻阅各种文档发现命令行带上-o参数就能实现，原来pytest早就设计好了</p>
<pre><code class="shell">&gt; pytest demo --junit-xml=./report.xml -o junit_suite_name
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档77-parametrize 参数化跳过部分用例(pytest.param)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A377-parametrize%20%E5%8F%82%E6%95%B0%E5%8C%96%E8%B7%B3%E8%BF%87%E9%83%A8%E5%88%86%E7%94%A8%E4%BE%8B(pytest.param)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 参数化的时候，希望能跳过部分测试用例，可以用 pytest.param 来实现。</p>
<h1 id="parametrize-参数化示例"><a href="#parametrize-参数化示例" class="headerlink" title="parametrize 参数化示例"></a>parametrize 参数化示例</h1><p>parametrize 参数化</p>
<pre><code class="python">import pytest


@pytest.mark.parametrize(&#39;input1, input2, expected&#39;, [
    [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;],
    [&quot;1&quot;, &quot;2&quot;, &quot;12&quot;],
    [2, 3, 5],
    [1, 3, 4],
    ])
def test_foo(input1, input2, expected):
    assert input1 + input2 == expected
</code></pre>
<p>运行结果</p>
<pre><code class="x86asm">collected 4 items

..\..\..\..\..\demo\demo\aaa\test_x.py ....
total times: 0.13 seconds

================ 4 passed in 0.14s ==================
</code></pre>
<h1 id="pytest-param-跳过用例"><a href="#pytest-param-跳过用例" class="headerlink" title="pytest.param 跳过用例"></a>pytest.param 跳过用例</h1><p>如果想跳过其中部分用例，可以用 pytest.param()来实现，给参数化中单个用例加 marks 标记 skip。</p>
<pre><code class="python">import pytest


@pytest.mark.parametrize(&#39;input1, input2, expected&#39;, [
    [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;],
    [&quot;1&quot;, &quot;2&quot;, &quot;12&quot;],
    pytest.param(2, 3, 5, marks=pytest.mark.skip),
    [1, 3, 4],
    ])
def test_foo(input1, input2, expected):
    assert input1 + input2 == expected
</code></pre>
<p>运行结果</p>
<pre><code class="x86asm">collected 4 items

..\..\..\..\..\demo\demo\aaa\test_x.py ..s
Test ignored..
total times: 0.14 seconds

============== 3 passed, 1 skipped in 0.14s ==============
</code></pre>
<p>运行结果可以看出1个 skipped 了。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest文档78-钩子函数pytest_runtest_makereport获取用例执行报错内容和print内容</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A378-%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0pytest_runtest_makereport%E8%8E%B7%E5%8F%96%E7%94%A8%E4%BE%8B%E6%89%A7%E8%A1%8C%E6%8A%A5%E9%94%99%E5%86%85%E5%AE%B9%E5%92%8Cprint%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest在执行用例的时候，当用例报错的时候，如何获取到报错的完整内容呢？<br>当用例有print()打印的时候，如何获取到打印的内容？</p>
<h1 id="钩子函数pytest-runtest-makereport"><a href="#钩子函数pytest-runtest-makereport" class="headerlink" title="钩子函数pytest_runtest_makereport"></a>钩子函数pytest_runtest_makereport</h1><p>测试用例如下，参数化第一个用例成功，第二个失败</p>
<pre><code class="python">import pytest
import time

@pytest.fixture()
def login():
    print(&quot;login first----------&quot;)


@pytest.mark.parametrize(
    &quot;user, password&quot;,
    [
        [&quot;test1&quot;, &quot;123456&quot;],
        [&quot;test2&quot;, &quot;123456&quot;],
    ]
)
def test_a(login, user, password):
    &quot;&quot;&quot;用例描述：aaaaaa&quot;&quot;&quot;
    time.sleep(2)
    print(&quot;---------打印的内容-------&quot;)
    print(&#39;传入参数 user-&gt;&#123;&#125;, password-&gt;&#123;&#125;&#39;.format(user, password))
    assert user == &quot;test1&quot;
</code></pre>
<p>使用钩子函数pytest_runtest_makereport 可以获取用例执行过程中生成的报告</p>
<pre><code class="python">import pytest


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_makereport(item, call):

    out = yield  # 钩子函数的调用结果
    res = out.get_result()   # 获取用例执行结果
    if res.when == &quot;call&quot;:   # 只获取call用例失败时的信息
        print(&quot;item(我们说的用例case)：&#123;&#125;&quot;.format(item))
        print(&quot;description 用例描述：&#123;&#125;&quot;.format(item.function.__doc__))
        print(&quot;exception异常：&#123;&#125;&quot;.format(call.excinfo))
        print(&quot;exception详细日志：&#123;&#125;&quot;.format(res.longrepr))
        print(&quot;outcome测试结果：&#123;&#125;&quot;.format(res.outcome))
        print(&quot;duration用例耗时：&#123;&#125;&quot;.format(res.duration))
        print(res.__dict__)
</code></pre>
<p>用例运行成功的日志</p>
<pre><code class="rust">test_b.py item(我们说的用例case)：&lt;Function test_a[test1-123456]&gt;
description 用例描述：用例描述：aaaaaa
exception异常：None
exception详细日志：None
outcome测试结果：passed
duration用例耗时：2.0006444454193115
&#123;&#39;nodeid&#39;: &#39;test_b.py::test_a[test1-123456]&#39;, 
&#39;location&#39;: (&#39;test_b.py&#39;, 8, &#39;test_a[test1-123456]&#39;), 
&#39;keywords&#39;: &#123;&#39;test1-123456&#39;: 1, &#39;parametrize&#39;: 1, &#39;test_b.py&#39;: 1, &#39;test_a[test1-123456]&#39;: 1, &#39;myweb&#39;: 1, &#39;pytestmark&#39;: 1&#125;, 
&#39;outcome&#39;: &#39;passed&#39;, 
&#39;longrepr&#39;: None, 
&#39;when&#39;: &#39;call&#39;, 
&#39;user_properties&#39;: [], 
&#39;sections&#39;: [(&#39;Captured stdout setup&#39;, &#39;login first----------\n&#39;), (&#39;Captured stdout call&#39;, &#39;---------打印的内容-------\n传入参数 user-&gt;test1, password-&gt;123456\n&#39;)], 
&#39;duration&#39;: 2.0006444454193115, 
&#39;extra&#39;: []&#125;
</code></pre>
<p>用例运行失败的日志</p>
<pre><code class="lua">item(我们说的用例case)：&lt;Function test_a[test2-123456]&gt;
description 用例描述：用例描述：aaaaaa
exception异常：&lt;ExceptionInfo AssertionError(&quot;assert &#39;test2&#39; == &#39;test1&#39;\n  - test1\n  ?     ^\n  + test2\n  ?     ^&quot;,) tblen=1&gt;
exception详细日志：login = None, user = &#39;test2&#39;, password = &#39;123456&#39;

    @pytest.mark.parametrize(
        &quot;user, password&quot;,
        [
            [&quot;test1&quot;, &quot;123456&quot;],
            [&quot;test2&quot;, &quot;123456&quot;],
        ]
    )
    def test_a(login, user, password):
        &quot;&quot;&quot;用例描述：aaaaaa&quot;&quot;&quot;
        time.sleep(2)
        print(&quot;---------打印的内容-------&quot;)
        print(&#39;传入参数 user-&gt;&#123;&#125;, password-&gt;&#123;&#125;&#39;.format(user, password))
&gt;       assert user == &quot;test1&quot;
E       AssertionError: assert &#39;test2&#39; == &#39;test1&#39;
E         - test1
E         ?     ^
E         + test2
E         ?     ^

test_b.py:21: AssertionError
outcome测试结果：failed
duration用例耗时：2.003612995147705
&#123;&#39;nodeid&#39;: &#39;test_b.py::test_a[test2-123456]&#39;, 
&#39;location&#39;: (&#39;test_b.py&#39;, 8, &#39;test_a[test2-123456]&#39;), 
&#39;keywords&#39;: &#123;&#39;parametrize&#39;: 1, &#39;test2-123456&#39;: 1, &#39;test_a[test2-123456]&#39;: 1, &#39;test_b.py&#39;: 1, &#39;myweb&#39;: 1, &#39;pytestmark&#39;: 1&#125;, 
&#39;outcome&#39;: &#39;failed&#39;, 
&#39;longrepr&#39;: ExceptionChainRepr(chain=[(ReprTraceback(reprentries=[ReprEntry(lines=[&#39;    @pytest.mark.parametrize(&#39;, &#39;        &quot;user, password&quot;,&#39;, &#39;        [&#39;, &#39;            [&quot;test1&quot;, &quot;123456&quot;],&#39;, &#39;            [&quot;test2&quot;, &quot;123456&quot;],&#39;, &#39;        ]&#39;, &#39;    )&#39;, &#39;    def test_a(login, user, password):&#39;, &#39;        &quot;&quot;&quot;用例描述：aaaaaa&quot;&quot;&quot;&#39;, &#39;        time.sleep(2)&#39;, &#39;        print(&quot;---------打印的内容-------&quot;)&#39;, &quot;        print(&#39;传入参数 user-&gt;&#123;&#125;, password-&gt;&#123;&#125;&#39;.format(user, password))&quot;, &#39;&gt;       assert user == &quot;test1&quot;&#39;, &quot;E       AssertionError: assert &#39;test2&#39; == &#39;test1&#39;&quot;, &#39;E         - test1&#39;, &#39;E         ?     ^&#39;, &#39;E         + test2&#39;, &#39;E         ?     ^&#39;], reprfuncargs=ReprFuncArgs(args=[(&#39;login&#39;, &#39;None&#39;), (&#39;user&#39;, &quot;&#39;test2&#39;&quot;), (&#39;password&#39;, &quot;&#39;123456&#39;&quot;)]), reprlocals=None, reprfileloc=ReprFileLocation(path=&#39;test_b.py&#39;, lineno=21, message=&#39;AssertionError&#39;), style=&#39;long&#39;)], extraline=None, style=&#39;long&#39;), ReprFileLocation(path=&#39;D:\\demo\\myweb\\test_b.py&#39;, lineno=21, message=&quot;AssertionError: assert &#39;test2&#39; == &#39;test1&#39;\n  - test1\n  ?     ^\n  + test2\n  ?     ^&quot;), None)]), 
&#39;when&#39;: &#39;call&#39;, 
&#39;user_properties&#39;: [], 
&#39;sections&#39;: [(&#39;Captured stdout setup&#39;, &#39;login first----------\n&#39;), (&#39;Captured stdout call&#39;, &#39;---------打印的内容-------\n传入参数 user-&gt;test2, password-&gt;123456\n&#39;)], 
&#39;duration&#39;: 2.003612995147705, 
&#39;extra&#39;: []&#125;
</code></pre>
<h1 id="out-get-result-用例执行结果"><a href="#out-get-result-用例执行结果" class="headerlink" title="out.get_result() 用例执行结果"></a>out.get_result() 用例执行结果</h1><p>out.get_result() 返回用例执行的结果，主要有以下属性</p>
<ul>
<li>‘nodeid’: ‘test_b.py::test_a[test1-123456]’,</li>
<li>‘location’: (‘test_b.py’, 8, ‘test_a[test1-123456]’),</li>
<li>‘keywords’: {‘test1-123456’: 1, ‘parametrize’: 1, ‘test_b.py’: 1, ‘test_a[test1-123456]’: 1, ‘myweb’: 1, ‘pytestmark’: 1},</li>
<li>‘outcome’: ‘passed’,</li>
<li>‘longrepr’: None,</li>
<li>‘when’: ‘call’,</li>
<li>‘user_properties’: [],</li>
<li>‘sections’: [(‘Captured stdout setup’, ‘login first———-\n’), (‘Captured stdout call’, ‘———打印的内容——-\n传入参数 user-&gt;test1, password-&gt;123456\n’)],</li>
<li>‘duration’: 2.0006444454193115,</li>
<li>‘extra’: []</li>
</ul>
<p>其中sections 就是用例里面print打印的内容了</p>
<pre><code class="python">import pytest


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_makereport(item, call):

    out = yield  # 钩子函数的调用结果
    res = out.get_result()   # 获取用例执行结果
    if res.when == &quot;call&quot;:   # 只获取call用例失败时的信息
        print(&quot;获取用例里面打印的内容：&#123;&#125;&quot;.format(res.sections))
   
</code></pre>
<p>执行结果：</p>
<pre><code class="css">test_b.py 获取用例里面打印的内容：[(&#39;Captured stdout setup&#39;, &#39;login first----------\n&#39;), (&#39;Captured stdout call&#39;, &#39;---------打印的内容-------\n传入参数 user-&gt;test1, password-&gt;123456\n&#39;)]
.获取用例里面打印的内容：[(&#39;Captured stdout setup&#39;, &#39;login first----------\n&#39;), (&#39;Captured stdout call&#39;, &#39;---------打印 的内容-------\n传入参数 user-&gt;test2, password-&gt;123456\n&#39;)]
</code></pre>
<p>可以优化下输出</p>
<pre><code class="python">import pytest


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_makereport(item, call):
    out = yield  # 钩子函数的调用结果
    res = out.get_result()   # 获取用例执行结果
    if res.when == &quot;call&quot;:   # 只获取call用例失败时的信息
        for i in res.sections:
            print(&quot;&#123;&#125;: &#123;&#125;&quot;.format(*i))
</code></pre>
<p>运行结果</p>
<pre><code class="sql">collected 2 items

test_b.py Captured stdout setup: login first----------

Captured stdout call: ---------打印的内容-------
传入参数 user-&gt;test1, password-&gt;123456

.Captured stdout setup: login first----------

Captured stdout call: ---------打印的内容-------
传入参数 user-&gt;test2, password-&gt;123456
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>079_pytest文档79-内置 fixtures 之 cache 写入和读取缓存数据</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A379-%E5%86%85%E7%BD%AE%20fixtures%20%E4%B9%8B%20cache%20%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest测试用例之间的参数如何传递？如在前置操作中生成了一个数据id，在测试用例需要引用，或者用例执行完成后需要在后置操作中删除。<br>还有很多同学经常问到的case1 生成了数据a，在case2中引用这个值。这些在用例执行过程中生成的数据可以用cache缓存来解决。</p>
<h1 id="内置cache-fixture"><a href="#内置cache-fixture" class="headerlink" title="内置cache fixture"></a>内置cache fixture</h1><p>cache 是一个可以在测试会话之间保持状态的缓存对象。</p>
<pre><code class="python">@pytest.fixture
def cache(request):
    &quot;&quot;&quot;
    Return a cache object that can persist state between testing sessions.
    cache.get(key, default)
    cache.set(key, value)
    Keys must be a ``/`` separated value, where the first part is usually the
    name of your plugin or application to avoid clashes with other cache users.
    Values can be any object handled by the json stdlib module.
    &quot;&quot;&quot;
    return request.config.cache
</code></pre>
<p>cache是Cache类的一个实例对象</p>
<ul>
<li>mkdir 创建一个文件夹</li>
<li>set(key: str, value: object) 设置一个cache值</li>
<li>get(key: str, default) 得到key对应的值</li>
</ul>
<p><img src="/assets/2/image-20220516011810-ng61nyo.png" alt="image.png"></p>
<h1 id="cache的使用场景"><a href="#cache的使用场景" class="headerlink" title="cache的使用场景"></a>cache的使用场景</h1><p>场景1：当前置操作生成一个id值，在用例中获取这个id</p>
<pre><code class="python">import pytest


@pytest.fixture()
def create_id(cache):
    &quot;&quot;&quot;取值生成一个id&quot;&quot;&quot;
    id = &quot;yoyo_10086&quot;
    cache.set(&quot;id&quot;, id)
    yield id


def test_1(cache, create_id):
    # 方式1： cache获取
    get_id = cache.get(&quot;id&quot;, None)
    print(&quot;获取到的id: &#123;&#125;&quot;.format(get_id))
    # 方式2：直接通过create_id 获取返回值
    print(&quot;create_id fixture return: &#123;&#125;&quot;.format(create_id))
</code></pre>
<p>场景2：执行用例后生成一个sp_id,后置操作需要清理数据</p>
<pre><code class="python">import pytest


@pytest.fixture()
def delete_sp(cache):
    &quot;&quot;&quot;后置处理&quot;&quot;&quot;
    yield
    # 先获取用例执行后得到的sp_id
    sp_id = cache.get(&quot;sp_id&quot;, None)
    print(&quot;后置处理得到值: &#123;&#125;&quot;.format(sp_id))


def test_2(cache, delete_sp):
    # 执行用例后生成sp_id
    sp_id = &quot;yy_10086&quot;
    cache.set(&quot;sp_id&quot;, sp_id)
</code></pre>
<h1 id="用例之间的数据关联"><a href="#用例之间的数据关联" class="headerlink" title="用例之间的数据关联"></a>用例之间的数据关联</h1><p>很多同学喜欢把用例当步骤去执行，执行a用例得到id参数，后面的用例需要前面得到的值，用cache也可以实现</p>
<pre><code class="python">import pytest


def test_1(cache):
    x = &quot;yoyo_123&quot;
    cache.set(&quot;id&quot;, x)
    print(&quot;case 1 create id : &#123;&#125;&quot;.format(x))


def test_2(cache):
    a = cache.get(&quot;id&quot;, None)
    print(&quot;case2 get id: &#123;&#125;&quot;.format(a))
</code></pre>
<p>这种用例之间存在依赖的，必须要保证用例1在用例2前面先执行</p>
<h1 id="pytest-cache-缓存文件"><a href="#pytest-cache-缓存文件" class="headerlink" title=".pytest_cache 缓存文件"></a>.pytest_cache 缓存文件</h1><p>在pycharm中右键执行，不会生成.pytest_cache 缓存文件。<br>使用 pytest 命令行执行，会在项目目录生成.pytest_cache 缓存文件</p>
<pre><code class="markdown">&gt; pytest
</code></pre>
<p>v目录下的id文件就是cache设置的缓存文件,里面写的对应的value值</p>
<p><img src="/assets/2/image-20220516011829-57uh4a5.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>080_pytest文档80-内置 fixtures 之 cache 写入中文显示问题</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A380-%E5%86%85%E7%BD%AE%20fixtures%20%E4%B9%8B%20cache%20%E5%86%99%E5%85%A5%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 内置 fixtures 之 cache 写入中文的时候会在文件中写入<code>\u4e2d\u6587</code> 这种unicode编码格式。<br>如果想在文件中显示正常的中文，需重新Cache类的set方法来解决</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>pytest 用例 cache 的使用参考前面这篇<a href="https://www.cnblogs.com/yoyoketang/p/15747082.html">https://www.cnblogs.com/yoyoketang/p/15747082.html</a><br>当cache设置中文的时候,写入cache文件中文显示<br><img src="/assets/2/image-20220516011645-5oy1k0y.png" alt="image.png"></p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>出现这个问题的根本原因是python3 的json库留下来的一个坑，先看以下简单的实例</p>
<pre><code class="python">import json

a = &#39;上海-悠悠&#39;
print(json.dumps(a))

# ensure_ascii=False
print(json.dumps(a, ensure_ascii=False))
</code></pre>
<p>运行结果</p>
<pre><code class="bash">&quot;\u4e0a\u6d77-\u60a0\u60a0&quot;
&quot;上海-悠悠&quot;
</code></pre>
<p>使用json调用dumps方法的时候默认ensure_ascii参数为True</p>
<pre><code class="python">def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
        allow_nan=True, cls=None, indent=None, separators=None,
        default=None, sort_keys=False, **kw):
</code></pre>
<p>所以会导致中文在转json的时候，是以<code>\u4e0a\u6d77</code>这种编码格式显示的.</p>
<h1 id="Cache类的set方法"><a href="#Cache类的set方法" class="headerlink" title="Cache类的set方法"></a>Cache类的set方法</h1><p>pytest 内置 fixtures 之 cache 是 Cache 类的实例,看下 Cache 类的 set 方法实现</p>
<pre><code class="rust">def set(self, key: str, value: object) -&gt; None:
        &quot;&quot;&quot;Save value for the given key.

        :param key:
            Must be a ``/`` separated value. Usually the first
            name is the name of your plugin or your application.
        :param value:
            Must be of any combination of basic python types,
            including nested types like lists of dictionaries.
        &quot;&quot;&quot;
        path = self._getvaluepath(key)
        try:
            if path.parent.is_dir():
                cache_dir_exists_already = True
            else:
                cache_dir_exists_already = self._cachedir.exists()
                path.parent.mkdir(exist_ok=True, parents=True)
        except OSError:
            self.warn(&quot;could not create cache path &#123;path&#125;&quot;, path=path, _ispytest=True)
            return
        if not cache_dir_exists_already:
            self._ensure_supporting_files()
        data = json.dumps(value, indent=2, sort_keys=True)
        try:
            f = path.open(&quot;w&quot;)
        except OSError:
            self.warn(&quot;cache could not write path &#123;path&#125;&quot;, path=path, _ispytest=True)
        else:
            with f:
                f.write(data)
</code></pre>
<p>这里面有一句json.dumps没传ensure_ascii参数</p>
<pre><code class="haskell">data = json.dumps(value, indent=2, sort_keys=True)
</code></pre>
<p>问题原因找到了，接下来打个补丁，重写set方法即可</p>
<h1 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h1><p>以下这段补丁代码加到运行用例之前，放到项目根目录conftest.py文件的开始位置即可</p>
<pre><code class="sql">from _pytest.cacheprovider import Cache
import json


def new_set(self, key: str, value: object) -&gt; None:
    &quot;&quot;&quot;Save value for the given key.

    :param key:
        Must be a ``/`` separated value. Usually the first
        name is the name of your plugin or your application.
    :param value:
        Must be of any combination of basic python types,
        including nested types like lists of dictionaries.
    &quot;&quot;&quot;
    path = self._getvaluepath(key)
    try:
        if path.parent.is_dir():
            cache_dir_exists_already = True
        else:
            cache_dir_exists_already = self._cachedir.exists()
            path.parent.mkdir(exist_ok=True, parents=True)
    except OSError:
        self.warn(&quot;could not create cache path &#123;path&#125;&quot;, path=path, _ispytest=True)
        return
    if not cache_dir_exists_already:
        self._ensure_supporting_files()
    data = json.dumps(value, ensure_ascii=False, indent=2, sort_keys=True)
    try:
        f = path.open(&quot;w&quot;, encoding=&#39;utf-8&#39;)
    except OSError:
        self.warn(&quot;cache could not write path &#123;path&#125;&quot;, path=path, _ispytest=True)
    else:
        with f:
            f.write(data)

Cache.set = new_set
</code></pre>
<p>主要改动2个地方</p>
<pre><code class="ini"># 添加一个参数 ensure_ascii=False
data = json.dumps(value, ensure_ascii=False, indent=2, sort_keys=True)
# 添加一个参数 encoding=&#39;utf-8&#39;
f = path.open(&quot;w&quot;, encoding=&#39;utf-8&#39;)
</code></pre>
<p><img src="/assets/2/image-20220516011659-oo2sh40.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>081_pytest文档81-如何在yaml文件中引用python函数</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A381-%E5%A6%82%E4%BD%95%E5%9C%A8yaml%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BC%95%E7%94%A8python%E5%87%BD%E6%95%B0%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经常看到很多同学问到，如何在 yaml 文件中引用一个 python 的函数？</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>大家对yaml文件还处于比较陌生的阶段，yaml 和 json 文件本质上是一样的，都是静态的文件，当然不能直接引用 python 的函数。<br>那这时候就有人问到了，那为什么 httprunner 框架可以在yaml文件中引用函数呢？</p>
<ul>
<li>这是因为 httprunner 框架封装过对 yaml 文件的读取了，它是先读取文件内容，正则提取到 <code>$&#123;&#125;</code> 括号里面的函数内容，再把函数的值替换过去</li>
</ul>
<p>那么我们能不能实现这种效果呢？</p>
<ul>
<li>当然是可以的，可以参考httprunner的实现，也可以用到 python 的模板 jinja2 来实现。</li>
</ul>
<p>使用模板可以编写出可读性更好，更容易理解和维护的代码，并且使用范围非常广泛，因此怎么使用模板主要取决于我们的想象力和创造力。<br>python的模板库jinja2 功能是非常强大的。</p>
<h1 id="jinja2-模板库"><a href="#jinja2-模板库" class="headerlink" title="jinja2 模板库"></a>jinja2 模板库</h1><p>先需要pip安装</p>
<pre><code class="mipsasm">pip install jinja2
</code></pre>
<h1 id="render-函数实现"><a href="#render-函数实现" class="headerlink" title="render 函数实现"></a>render 函数实现</h1><p>在yaml文件中，通过 <code>&#123;&#123; 函数名称() &#125;&#125;</code> 来引用函数</p>
<p><img src="/assets/2/image-20220516011603-7krpbrh.png" alt="image.png"></p>
<p>写个 render 函数读取 yaml 文件内容</p>
<pre><code class="lua">import os
import jinja2
import yaml
import random


def render(tpl_path, **kwargs):
    path, filename = os.path.split(tpl_path)
    return jinja2.Environment(loader=jinja2.FileSystemLoader(path or &#39;./&#39;)
    ).get_template(filename).render(**kwargs)
</code></pre>
<p>读取到的yaml文件本质上都是字符串来读取的，通过jinja2 模板来读取，会先把函数的值替换进去。最后再转成python的dict结构</p>
<pre><code class="python">import os
import jinja2
import yaml
import random


def render(tpl_path, **kwargs):
    path, filename = os.path.split(tpl_path)
    return jinja2.Environment(loader=jinja2.FileSystemLoader(path or &#39;./&#39;)
    ).get_template(filename).render(**kwargs)


# yaml 文件调用以下函数
def rand_str():
    return str(random.randint(1000000, 2000000))


if __name__ == &#39;__main__&#39;:
    r = render(&quot;aa.yml&quot;, **&#123;&quot;rand_str&quot;: rand_str&#125;)
    print(r)
    print(yaml.safe_load(r))
</code></pre>
<p>运行结果</p>
<pre><code class="yaml">name: yoyo
age: 22
tel: 1616350
&#123;&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 22, &#39;rand_str&#39;: 1616350&#125;
</code></pre>
<p>上面读取函数是写死的，我们希望能自动加载类似于debugtalk.py的文件来自动加载函数</p>
<h1 id="自动加载debug-py里面的函数"><a href="#自动加载debug-py里面的函数" class="headerlink" title="自动加载debug.py里面的函数"></a>自动加载debug.py里面的函数</h1><p>写一个debug.py 文件，实现 yaml 文件里面定义的函数去替换值。</p>
<pre><code class="python">import random


# yaml 文件调用以下函数
def rand_str():
    return str(random.randint(1000000, 2000000))
</code></pre>
<p>run.py里面定义一个函数自动读取debug.py里面的函数,生成dict 键值对格式</p>
<pre><code class="python">def all_functions():
    &quot;&quot;&quot;加载debug.py模块&quot;&quot;&quot;
    debug_module = importlib.import_module(&quot;debug&quot;)
    all_function = inspect.getmembers(debug_module, inspect.isfunction)
    # print(dict(all_function))
    return dict(all_function)
</code></pre>
<p>函数返回 <code>&#123;&#39;rand_str&#39;: &lt;function rand_str at 0x0000017B72EA8488&gt;&#125;</code></p>
<p>完整的run.py文件内容</p>
<pre><code class="python">import os
import jinja2
import yaml
import importlib
import inspect


def render(tpl_path, **kwargs):
    &quot;&quot;&quot;渲染yml文件&quot;&quot;&quot;
    path, filename = os.path.split(tpl_path)
    return jinja2.Environment(loader=jinja2.FileSystemLoader(path or &#39;./&#39;)
    ).get_template(filename).render(**kwargs)


def all_functions():
    &quot;&quot;&quot;加载debug.py模块&quot;&quot;&quot;
    debug_module = importlib.import_module(&quot;debug&quot;)
    all_function = inspect.getmembers(debug_module, inspect.isfunction)
    print(dict(all_function))
    return dict(all_function)


if __name__ == &#39;__main__&#39;:
    r = render(&quot;aa.yml&quot;, **all_functions())
    print(r)
    print(yaml.safe_load(r))
</code></pre>
<p>运行结果</p>
<pre><code class="yaml">&#123;&#39;rand_str&#39;: &lt;function rand_str at 0x000001931C248488&gt;&#125;
name: yoyo
age: 22
tel: 1010421
&#123;&#39;name&#39;: &#39;yoyo&#39;, &#39;age&#39;: 22, &#39;tel&#39;: 1010421&#125;
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>04_pytest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>01_初识软件测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/01_%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/01_%E5%88%9D%E8%AF%86%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1-首先介绍下我们要进入的行业"><a href="#1-首先介绍下我们要进入的行业" class="headerlink" title="1. 首先介绍下我们要进入的行业"></a>1. 首先介绍下我们要进入的行业</h2><ol>
<li>IT已经我们公认熟知的行业，那么软件测试作为IT行业的一员也应该被大家所熟知：<ol>
<li>什么是IT<ul>
<li>IT是Information Technology英文的缩写，全称含义为“信息技术”涵盖的范围很广，主要包括：现代计算机、网络通讯等信息领域的技术。</li>
</ul>
</li>
<li>IT分类：实际上有三个层次<ul>
<li>硬件： 主要指数据存储、处理和传输的主机和网络通信设备</li>
<li>软件： 包括可用来搜集、存储、检索、分析、应用、评估信息的各种软件，它包括我们通常所指的ERP(企业资源计划)、CRM(客户关系管理)、SCM(供应链管理)等商用管理软件，也包括用来加强流程管理的WF(工作流)管理软件、辅助分析的DW&#x2F;DM(数据仓库和数据挖掘)软件等</li>
<li>应用： 指搜集、存储、检索、分析、应用、评估使用各种信息，包括应用ERP、CRM、SCM等软件直接辅助决策，也包括利用其它决策分析模型或借助DW&#x2F;DM等技术手段来进一步提高分析的质量，辅助决策者作决策</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-在各个行业都会出现“测试”一词"><a href="#2-在各个行业都会出现“测试”一词" class="headerlink" title="2. 在各个行业都会出现“测试”一词"></a>2. 在各个行业都会出现“测试”一词</h2><ol>
<li>什么是测试？<ul>
<li>测试是具有试验性质的测量，即测量和试验的综合</li>
</ul>
</li>
<li>在IT行业测试职位是怎么称呼的？<ul>
<li>硬件————–&gt;&gt;&gt;&gt;&gt;   硬件测试工程师</li>
<li>软件————–&gt;&gt;&gt;&gt;&gt;   软件测试工程师</li>
<li>应用————–&gt;&gt;&gt;&gt;&gt;   应用测试工程师</li>
</ul>
</li>
</ol>
<h2 id="3-桐桐信息技术的教学目的"><a href="#3-桐桐信息技术的教学目的" class="headerlink" title="3. 桐桐信息技术的教学目的"></a>3. 桐桐信息技术的教学目的</h2><ul>
<li>我们所要做的就是塑造&#x2F;培养软件测试工程师</li>
<li>提升软件测试工程师的技术&#x2F;技能与认知</li>
<li>为我们本地培养高技能人才</li>
</ul>
<h2 id="4-什么是软件测试工程师"><a href="#4-什么是软件测试工程师" class="headerlink" title="4. 什么是软件测试工程师"></a>4. 什么是软件测试工程师</h2><ol>
<li>软件测试工程师（Software Testing Engineer）指理解产品的功能要求，并对其进行测试，检查软件有没有错误（Bug），测试软件是否具有稳定性（Robustness），写出相应的测试规范和测试用例的专门工作人员。</li>
<li>简而言之，软件测试工程师在一家软件企业中担当的是“质量管理”角色，及时发现软件问题并及时督促更正，确保产品的正常运作。</li>
</ol>
<h2 id="5-软件测试工程师的等级划分"><a href="#5-软件测试工程师的等级划分" class="headerlink" title="5. 软件测试工程师的等级划分"></a>5. 软件测试工程师的等级划分</h2><ol>
<li>初级测试工程师</li>
<li>中级测试工程师</li>
<li>高级测试工程师</li>
<li>测试管理人员</li>
<li>测试经理</li>
<li>测试总监</li>
</ol>
<h2 id="6-在桐桐信息技术培训人才技能范围"><a href="#6-在桐桐信息技术培训人才技能范围" class="headerlink" title="6. 在桐桐信息技术培训人才技能范围"></a>6. 在桐桐信息技术培训人才技能范围</h2><ol>
<li>中级测试工程师、高级测试工程师、测试管理人员</li>
</ol>
<h2 id="7-不同等级学习的技能范围"><a href="#7-不同等级学习的技能范围" class="headerlink" title="7. 不同等级学习的技能范围"></a>7. 不同等级学习的技能范围</h2><ul>
<li><p>中级测试工程师</p>
<ul>
<li>功能测试、接口测试、抓包技能、项目管理工具使用、查看日志、分析问题</li>
</ul>
</li>
<li><p>高级测试工程师</p>
<ul>
<li>在终极测试工程师的基础上、性能测试、安全测试、自动化测试</li>
</ul>
</li>
<li><p>测试管理人员</p>
<ul>
<li>在高级测试工程师基础上、管理技能（包括项目管理、人员管理）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>01_测试基础</category>
      </categories>
      <tags>
        <tag>测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02_了解软件测试行业</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/01_%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/02_%E6%B5%8B%E8%AF%95%E8%A1%8C%E4%B8%9A/</url>
    <content><![CDATA[<p>随着中国IT行业的发展以及未来AI时代的到来。越来越多的人加入到IT行业，对于很多没有从事过IT工作的人来，或者对于很多专业跟IT扯不上关系的人来说。转行做软件测试是一个很好的选择。</p>
<p>软件开发起码要培训半年以上，才能胜任工作。 而软件测试只需要1个月。</p>
<h2 id="1-测试行业介绍"><a href="#1-测试行业介绍" class="headerlink" title="1 测试行业介绍"></a>1 测试行业介绍</h2><ul>
<li><p>目前IT企业也越来越重视软件产品的质量， 从软件，硬件到系统集成，几乎每个小中大IT企业，在产品发布之前都需要大量的测试工作。软件测试工程师，是目前IT行业非常短缺的人才，中国软件行业每年要新增几十万的测试岗位就业机会。但是学校培养出来的测试人才却不足需求量的十分之一。</p>
</li>
<li><p>目前软件测试行业的缺口非常大。 90%的测试人员是不会写代码的，但是薪资依然可观。基本上一个三年测试经验的人，薪资都在万元以上。未来的职业发展前景也非常广阔。</p>
</li>
</ul>
<h2 id="2-软件测试是做什么的"><a href="#2-软件测试是做什么的" class="headerlink" title="2 软件测试是做什么的"></a>2 软件测试是做什么的</h2><ul>
<li><p><img src="/assets/1/wpsC670.tmp-20211222145920-4awo4by.jpg"></p>
</li>
<li><p>软件测试，就是找出软件系统中的错误，并且确保软件开发人员修复这些错误， 最终移交一个质量好的软件，给客户使用。</p>
</li>
<li><p>比如下图，一个网页中的密码输入框中的字符不是用星号显示，而是明文显示。这就是一个软件的bug。软件测试就是要将这些bug找出来</p>
</li>
<li><p><img src="/assets/1/wpsC671.tmp-20211222145920-cq9ge46.jpg"></p>
</li>
<li><p>下图是一个功能性的Bug，这种Bug比较严重，会影响用户的使用，甚至会给用户造成损失，所以软件测试就是需要提前把这些Bug找出来，确保软件交付给用户使用后，没有问题。</p>
</li>
</ul>
<h2 id="3-入门门槛非常低"><a href="#3-入门门槛非常低" class="headerlink" title="3 入门门槛非常低"></a>3 入门门槛非常低</h2><ul>
<li><p>经常听想入行的朋友说，我想转软件测试，听说软件测试很简单。的确，软件测试入门是很简单。</p>
</li>
<li><p>IT行业中有几百个工种， 其中软件测试是入门门槛最低。普通人只要经过短期的培训，大概学一个月就能胜任响应的软件测试工作。软件测试人员起薪在7000元-10000元不等，工作三年后，月薪基本上能达到10000到15000。</p>
</li>
<li><p>软件测试入门虽然简单， 但是精通很难。</p>
</li>
</ul>
<h2 id="4-测试人员每天的日常工作"><a href="#4-测试人员每天的日常工作" class="headerlink" title="4 测试人员每天的日常工作"></a>4 测试人员每天的日常工作</h2><ul>
<li>大部分软件测试人员的工作可以简单的归为这几个字， “点点点，开Bug”。</li>
</ul>
<h2 id="5-一些转行实例"><a href="#5-一些转行实例" class="headerlink" title="5 一些转行实例"></a>5 一些转行实例</h2><ul>
<li><p>身边转行做测试的例子太多了， 我举几个实际的转行的例子。这些例子都是真实的。</p>
</li>
<li><p>我姑姑的儿子大学专科毕业，找不到工作，因为他们的学校一塌糊涂，大学的时候玩游戏，什么都没学到。本来他打算南下广东， 去进厂当流水线工人的。 我姑姑不甘心他儿子去进厂当流水线工人。 然后就拜托我帮帮忙。 后来我这弟弟就来到上海投奔我。 我培训了2个月软件测试。 弟弟很轻松的就进入了一家软件公司，到现在做了快5年了， 已经成长为一名高级测试工程师。</p>
</li>
<li><p>后来我就把好几个堂弟以及一些亲戚，都拉到上海来从事软件测试行业。目前家族中很多人都是从事软件测试行业。</p>
</li>
<li><p>JJO,  是96年的小姑娘， 今年24岁， 大专毕业后，一直在某酒店做前台工作人员， 月薪大概3000.， 做了2年了， 薪资只够自己开销，完全存不到钱，感觉到很迷茫。 偶然的机会由亲戚介绍，接触了软件测试。 开始跟人学习软件测试。学好出来后。</p>
</li>
<li><p>开始来到深圳做软件测试， 月薪一万。 越来越喜欢做软件测这份工作。</p>
</li>
<li><p>小明，男，大学毕业后，非常迷茫不知道做什么， 就去广东打工， 进了一个工厂，在流水线上工作，每个月也就4000多，不想做了后，又去一家鞋厂做。做了几个月，又不想做了。 觉得没有前途， 难道做到30岁，还是这么点工资吗？ 觉得自己需要改变， 后来机缘巧合，开始学习软件测试。 最终成功入行。    到现在50W一年的薪资。</p>
</li>
<li><p>小荣荣，女，大专毕业，今年30岁了，在上海一家公司做硬件检测8年了，月薪才4000多。有个女儿三岁了。 这点薪资完全不够用。后来决心赌一把，开始学习软件测试。学了大概1个月后，转行做软件测试，入行的时候薪水是1万。 工作后，又持续学习。还学了Python编程。到现在月薪已经超过2万多了。</p>
</li>
</ul>
<h2 id="6-哪些人适合转行"><a href="#6-哪些人适合转行" class="headerlink" title="6 哪些人适合转行"></a>6 哪些人适合转行</h2><ol>
<li><p>专业是计算机专业的毕业生</p>
<p> 一点问题没有， 只要不要辛苦，姿态放低一点。 很简单</p>
</li>
<li><p>非计算机专业的毕业生</p>
<p> 不是计算机专业的，从事软件测试完全没问题。</p>
</li>
<li><p>转行的人。</p>
<p> 目前软件测试行业，很多人都不是计算机专业的。 很多都是别的行业转行过来的。</p>
</li>
<li><p>在一些城市，薪资少于8000</p>
<p> 生活在一线城市，目前的薪资少于6000，并且在可遇见的未来几年，薪资不会有很大提升的职业。都可以选择转行做软件测试。</p>
</li>
</ol>
<h2 id="7-软件测试职业规划"><a href="#7-软件测试职业规划" class="headerlink" title="7 软件测试职业规划"></a>7 软件测试职业规划</h2><ul>
<li><p>本人从事软件8多年，认识的测试人员超过上千位，有很多工作超过10年的老测试，也有很多刚毕业刚进入测试行业的人。根据我认识的测试人员目前的情况，我大概列出以下软件测试的职业规划</p>
</li>
<li><p><img src="/assets/1/wpsC672.tmp-20211222145920-h98oqep.jpg"></p>
</li>
<li><p>就2018年上海地区来行情来说，一个刚毕业的本科生从事软件测试行业大概薪水是5000到7000左右， 3年测试经验薪水大概是9000-13000左右，5年测试经验的薪水大概在13000-20000左右。10年以上的老测试大概在30000以上。</p>
</li>
<li><p>根据行业的不同，薪资的差别也比较大。互联网和外企的薪水会较高。互联网的工作强度大，加班多。当然薪资要偏高。 外企要求英语好+技术好。 英语好和技术同时要好，属于复合型人才，这种人才比较稀缺。所以待遇也相应要好很多。</p>
</li>
<li><p>测试人员不但需要对软件的质量进行检测，还能接触到与软件相关的各行各业，项目管理、沟通协调、市场需求分析等能力都能得到很好的锻炼，从而为自己的多元化发展奠定了基础，经过实践几年后，很容易晋升到主管、项目经理等高级职位。</p>
</li>
</ul>
<h2 id="8-软件测试职业的优点"><a href="#8-软件测试职业的优点" class="headerlink" title="8 软件测试职业的优点"></a>8 软件测试职业的优点</h2><ul>
<li><p>个人觉得软件测试职业具备很多优点。</p>
<ol>
<li><p>优点1 非常适合女生</p>
<ul>
<li><p>女生具备很多优点，首先女生稍微细心，更容易发现Bug。女生的沟通能力比较好， 发现Bug后，找开发人员沟通的比较顺畅，90%的开发都是男的，会比较有风度。</p>
</li>
<li><p>大家会发现软件开发中女生占的比例是10%以下。而在软件测试中，女生占的比例有50%左右。</p>
</li>
<li><p>我身边很多从事软件测试的女生，生活都过得很好。很多女同事薪资都超过2W，老公的薪资更高。很多在上海生了二胎，买了二套房。</p>
</li>
<li><p>所以女生很适合做软件测试行业。</p>
</li>
</ul>
</li>
<li><p>优点2 适合平庸的人</p>
<ul>
<li><p>平常工作中接触过太多牛人了，很多刚毕业的人，写代码的水平相当高。可以独立开发很大的系统。接触了很多智商高的人。我深深的体会到，被碾压的感觉。</p>
</li>
<li><p>软件测试非常适合平庸的人。 因为不需要天才也能做。</p>
</li>
</ul>
</li>
<li><p>优点3 劳动强度和压力适中</p>
<ul>
<li><p>软件行业大家的压力都比较大， 尤其是开发人员的压力很大啊， 相比之下，软件测试的劳动强度和压力，都比软件开发小很多。  很适合女同学做。</p>
</li>
<li><p>开发人员在开发项目的时候，会碰到很多技术难题，很难保证一个全新的项目能否按时开发完。 测试就好很多，测试工作中的主要是工作量大的问题，大不了加班，不存在完不成的问题，心里压力要小很多。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="9-软件测试职业的缺点"><a href="#9-软件测试职业的缺点" class="headerlink" title="9 软件测试职业的缺点"></a>9 软件测试职业的缺点</h2><ul>
<li><p>说了这么多优点，下面来说说缺点。</p>
<ol>
<li><p>缺点1：薪资比开发工程师低</p>
<ul>
<li>测试工程师的薪资普遍要比开发工程师低20%以上。这个其实是合理的。</li>
</ul>
</li>
<li><p>缺点2：没法创业和赚外快</p>
<ul>
<li><p>身边很多人创业，很多同事是边工作边赚外快，帮别人做网站，做APP，维护系统之类的。当外快的钱比上班的的钱还多之后，很多同事就辞职，全职创业了。</p>
</li>
<li><p>而软件测试就没有这样的机会，至少我没听说几个软件测试创业成功的。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="10-传统的软件公司和互联网公司的区别"><a href="#10-传统的软件公司和互联网公司的区别" class="headerlink" title="10 传统的软件公司和互联网公司的区别"></a>10 传统的软件公司和互联网公司的区别</h2><ul>
<li><p>互联网公司需要大量的测试人员，那么什么样的公司才是互联网公司呢？</p>
<ol>
<li>传统软件公司的产品和服务依赖于特定的终端和相应的操作系统，而互联网公司产品和服务则依赖于浏览器和网络。</li>
<li>传统软件公司是卖软件给用户用，互联网公司是自己运营。</li>
<li>传统软件公司需求都是从真正用软件的用户那里间接得来的，需求经过收集，传递，分析，实现，测试，上线。整个过程很长。互联网公司一般都是自己开发自己用，有什么问题立刻改。</li>
<li>从用户角度看， 传统软件产品都是在本地，需要自己安装。而互联网公司的产品只需要通过互联网来访问。比如通过浏览器或者APP来使用。</li>
<li>传统软件公司上线周期长，可能要几个月才上线一个产品。 而互联网公司上线周期短，可能一个星期就上线一次，或者2次。所以测试会比较忙。</li>
<li>传统的软件公司有，苹果，小米，微软。</li>
</ol>
</li>
<li><p>互联网企业有， 谷歌，facebook,阿里，腾讯.还有比如说，网络游戏，直播。电子商务。</p>
</li>
<li><p>互联网企业众多，需要大量的测试人员。大部分的测试人员都是进入了互联网企业.</p>
</li>
</ul>
<h2 id="11-测试分两种"><a href="#11-测试分两种" class="headerlink" title="11 测试分两种"></a>11 测试分两种</h2><ul>
<li><p><img src="/assets/1/wpsC673.tmp-20211222145920-91n8oyg.png"><img src="/assets/1/wpsC674.tmp-20211222145920-rscndg4.jpg"></p>
</li>
<li><p>软件测试分为手动测试和自动化测试。手动测试工程师只要求像普通用户那样去使用软件，发现了问题，在Bug管理系统中，开一个Bug就可以了</p>
</li>
<li><p>而自动化测试工程师，是需要懂代码，了解Java或者Python， 会使用JMeter和Postman做接口测试，会使用Selenium做UI自动化测试。自动化测试是发展方向。三年以上的测试工程师都应该朝这个方向发展</p>
</li>
</ul>
<h2 id="12-B-x2F-S和C-x2F-S架构的区别"><a href="#12-B-x2F-S和C-x2F-S架构的区别" class="headerlink" title="12 B&#x2F;S和C&#x2F;S架构的区别"></a>12 B&#x2F;S和C&#x2F;S架构的区别</h2><ul>
<li><p>Browser&#x2F;Server架构（浏览器&#x2F;服务器架构），主要是指的是Web应用程序，比如淘宝网，以及各种网站。如下图</p>
</li>
<li><p>C&#x2F;S架构  是Client&#x2F;Server(客户端&#x2F;服务器)架构，主要是传统的桌面机的应用程序。如下图</p>
</li>
<li><p><img src="/assets/1/wpsC675.tmp-20211222145920-yxbq22w.jpg"></p>
</li>
<li><p>目前大概90%的系统都是采用B&#x2F;S架构，是未来的趋势。传统的C&#x2F;S架构的软件越来越少，C&#x2F;S的软件慢慢被淘汰。B&#x2F;S架构的优点是客户不需要安装软件，直接使用浏览器就可以访问了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>01_测试基础</category>
      </categories>
      <tags>
        <tag>测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>03_多维度分析</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/01_%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/03_%E5%A4%9A%E7%BB%B4%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>2020年</p>
<p><img src="/assets/1/image-20211120103613-yl1kx4c.png" alt="image.png"></p>
<h2 id="1-从业人员分布情况"><a href="#1-从业人员分布情况" class="headerlink" title="1. 从业人员分布情况"></a>1. 从业人员分布情况</h2><p><strong>1. 性别分布</strong></p>
<p><img src="/assets/1/image-20211207164743-c3tffd4.png" alt="image.png"><br>随着社会大环境鼓励生育二胎，相信女性回归家庭的比例有所攀升，2020 年测试岗位男性比例再次回到超过 70%。<br>很多测试同学可能感觉联系实际情况，做测试的女生明明很多，为何调查结果是男生占比高呢？</p>
<p>其实很好理解，关注 TesterHome 的同学以测试开发人员为主，尤其是效能和工具平台建设，以及智能、大数据、物联网等方向的测试人员，男生比例高些，也符合感性的感觉。</p>
<p>欢迎大家来参加 2021 年即将在上海举办的中国互联网测试开发大会 MTSC2021 上海站现场感受。</p>
<h2 id="2-年龄分布"><a href="#2-年龄分布" class="headerlink" title="2. 年龄分布"></a>2. 年龄分布</h2><p><img src="/assets/1/image-20211207164749-0jqcixc.png" alt="image.png"><br>从调查结果来看，35+ 测试人员占与去年持平，各年龄段的分布连续三年也较稳定。最近几年大家讨论最多的关于年龄的话题就是 “35 周岁中年危机” 了，职场上 35 岁 + 的人都去哪了呢？<br>测试开发岗位只是万千行业岗位中的一个，若年龄到了一个阶段，经验没有继续增长，学习能力却降低，而薪水不能降低吧？</p>
<ul>
<li>用人成本考量上，公司一般会偏向年轻人</li>
<li>团队梯队建设上，会考虑新老搭档</li>
</ul>
<h2 id="3-所在地分布"><a href="#3-所在地分布" class="headerlink" title="3.所在地分布"></a>3.所在地分布</h2><p><img src="/assets/1/image-20211207164753-6qbj4yn.png" alt="image.png"></p>
<ul>
<li>与前两年一致，互联网测试从业人员主要依然是来自一二线城市，但可以看出二线城市的比例逐年增加，单从这个结果上可以有 2 个猜测：</li>
<li>更多来自二线城市的测试人员</li>
<li>测试人员从一线搬至二线城市定居了，可推测二线城市对测试人员需求增加</li>
</ul>
<h2 id="4-工作年限分布"><a href="#4-工作年限分布" class="headerlink" title="4. 工作年限分布"></a>4. 工作年限分布</h2><p><img src="/assets/1/image-20211207164759-nhnwdcl.png" alt="image.png"></p>
<ul>
<li>这个调查和年龄分布可对比看，年龄 30 周岁 + 的总占比与去年持平，但工作时间超过 10 年以上的人数占比却稳步提升。</li>
<li>工作 6-10 年的人数占比也显著增加，二者加起来就是工作 5 年以上人数占比 37.4%。</li>
</ul>
<h2 id="5-学历分布"><a href="#5-学历分布" class="headerlink" title="5. 学历分布"></a>5. 学历分布</h2><p><img src="/assets/1/image-20211207164806-sqad1w0.png" alt="image.png"></p>
<ul>
<li>本科一如既往占七成，硕士占比近十分之一，博士继去年零突破后继续增加了。</li>
<li>测试开发人员属于技术类人员，对学历有要求，相信与其他相关技术从业人员也一致。</li>
</ul>
<h2 id="6-进入测试行业的途径"><a href="#6-进入测试行业的途径" class="headerlink" title="6.进入测试行业的途径"></a>6.进入测试行业的途径</h2><p><img src="/assets/1/image-20211207164811-ivob3vp.png" alt="image.png"></p>
<ul>
<li>毕业即入行，依然是常规途径，比例超过一半。由此可见，各大公司持续将校园招聘作为主要招聘渠道。</li>
<li>通过培训机构入行的连续三年增长，今年超过 15%，一定程度上反映了当下测试培训的火爆。</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>01_测试基础</category>
      </categories>
      <tags>
        <tag>测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>04_薪资分析</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/01_%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/04_%E8%96%AA%E8%B5%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、2021年软件测试的平均工资怎样？"><a href="#一、2021年软件测试的平均工资怎样？" class="headerlink" title="一、2021年软件测试的平均工资怎样？"></a>一、2021年软件测试的平均工资怎样？</h2><p>测试薪资，每个地方不太一样（后面会列上国内主要城市薪资），我们以北京为例，先来给大家看一下2020年的测试薪资，如下图所示：</p>
<p><img src="/assets/1/image-20211207164957-j4c2r0a.png" alt="image.png"></p>
<p> <strong>2021年又比2020年增加了3000多元。</strong> 最近这些年，测试薪资是一路往上涨的。</p>
<p>北京作为一线大城市，薪资肯定高，但很多小伙伴们未必是在北京工作，而是在自己的省会城市或其他一线城市，那他们的薪资如何呢？请继续往下看。</p>
<h2 id="二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？"><a href="#二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？" class="headerlink" title="二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？"></a>二、2021年哪些城市的薪资会更高一些？推荐哪些城市就业？</h2><p>看过了北京的薪资，再来看看其他城市的薪资。</p>
<p><img src="/assets/1/image-20211207165002-crnepas.png" alt="image.png"></p>
<h2 id="三、与编程开发相比，软件测试的薪资如何呢？"><a href="#三、与编程开发相比，软件测试的薪资如何呢？" class="headerlink" title="三、与编程开发相比，软件测试的薪资如何呢？"></a>三、与编程开发相比，软件测试的薪资如何呢？</h2><p>相信这个是很多由于到底是学编程还是测试的同学非常关注的。</p>
<p> <strong>给大家揭露一个非常有趣的现象：</strong> 以10年工龄为界，10年之内，同等工龄的开发岗位平均薪资要超过测试；<strong>但10年之后，软件测试的平均薪资却要反超编程开发。</strong></p>
<p>是不是这样呢？请狠狠点击下方链接查看直接证据：</p>
<p><a href="https://www.zhihu.com/question/33405392/answer/1649870187"><img src="/assets/1/image-20211207165006-ua3sb2o.png" alt="image.png"></a></p>
<h2 id="四、近10年来软件测试工资的波动状况，预测未来趋势"><a href="#四、近10年来软件测试工资的波动状况，预测未来趋势" class="headerlink" title="四、近10年来软件测试工资的波动状况，预测未来趋势"></a><strong>四、近10年来软件测试工资的波动状况，预测未来趋势</strong></h2><p>未来测试的薪资会怎样呢？老方法，回顾过去，才能展望未来，我们来看下近10年来测试平均薪资。为了能让趋势客观，仅选用北京测试薪资。</p>
<p><img src="/assets/1/image-20211207165010-h9cwmyo.png" alt="image.png"></p>
<p>刚刚我们看到了<strong>北京薪资2020年是15430，那么2019年是多少呢？请往下看14480元</strong></p>
<p><img src="/assets/1/image-20211207165015-lg94kmv.png" alt="image.png"></p>
<p>2018年，2017年，2015年，2014年……分别是多少呢？</p>
<p><img src="/assets/1/image-20211207165019-yvqzw61.png" alt="image.png"></p>
<p>从以上的薪资趋势可以看到，测试薪资10年来，已经从4460元跃升到15430元，薪资一路上涨。尤其是在2015年和2017年，涨薪幅度达到40%和34%。</p>
<p>为什么薪资能一路上涨，因为这10年来，互联网竞争越来越趋同质化， <strong>未来的互联网产品不仅是运营取胜，更是质量取胜，而测试人员就是保证质量的守门员，</strong> 这也是为何 <strong>2020是疫情之年，测试薪资仍比2019年上涨了1000元，2021年又比2020年增加了3000多元的根本原因。</strong> 所以未来测试薪资，不出意外， <strong>也将继续一路上扬</strong> 。</p>
<h2 id="五、测试各个岗位的薪资是怎样的？"><a href="#五、测试各个岗位的薪资是怎样的？" class="headerlink" title="五、测试各个岗位的薪资是怎样的？"></a>五、测试各个岗位的薪资是怎样的？</h2><p>测试按技术分，分支较多，有功能测试、接口测试、Ui自动化测试、性能测试、安全测试、测试开发….  各个岗位的薪资肯定是不一样的，带大家来看下</p>
<h3 id="1-功能测试（也叫手工测试）"><a href="#1-功能测试（也叫手工测试）" class="headerlink" title="1.功能测试（也叫手工测试）"></a><strong>1.功能测试（也叫手工测试）</strong></h3><p><img src="/assets/1/image-20211207165023-u0xwhox.png" alt="image.png"><br>2020年功能测试薪资</p>
<p><img src="/assets/1/image-20211207165027-3bpqrh8.png" alt="image.png"><br>2021年功能测试薪资，较2020上涨了2.6K</p>
<p>功能测试是其他测试工作的基础，是培养测试用例设计能力和建立测试思维的关键阶段。但是如果只是每天机械的进行“点点点”，想拿高薪是不太现实的。但是如果用例设计的非常牛，能够验证出系统中的绝大部分bug（尤其是关键的bug）；或者对某一行业的业务非常熟练也是可以拿到高薪的。</p>
<p>根据市场的实际情况来看，拿高薪的软件测试工程师一般都是具备良好的手工测试技能。<strong>所以手工测试虽然薪资是最低的，但是却是最核心的，千万不能忽视。</strong></p>
<h3 id="2-自动化测试"><a href="#2-自动化测试" class="headerlink" title="2 自动化测试"></a><strong>2 自动化测试</strong></h3><p><img src="/assets/1/image-20211207165031-gyq50kn.png" alt="image.png"><br>2020年自动化测试薪资截图</p>
<p><img src="/assets/1/image-20211207165035-dtga3sw.png" alt="image.png"><br>2021年自动化测试薪资，较2020增加2.5K</p>
<p>自动化测试主要包括接口自动化测试和UI自动化测试。</p>
<p><strong>为什么做接口自动化测试能拿高薪呢？</strong><br>因为现在的软件，都是前后端分离的，需要通过接口实现前后端数据的传递。所以接口自动化测试非常重要，大部分的公司都会做接口自动化测试的。</p>
<p><strong>为什么会UI自动化测试能拿高薪呢？</strong></p>
<p>通过手工方式实现项目回归测试既费时又费力，如果是已经写好的自动化测试脚本直接运行就可以了，可以实现真正的无人值守。<strong>UI自动化测试目前做的比较多的是Web自动化测试和APP自动化测试。</strong></p>
<p>所以做UI自动化测试一般都要具备一定的编程能力，而绝大部分测试人员是没有编程能力的，能拉开与别人之间的距离。</p>
<p>UI自动化测试比较适合功能比较稳定、回归测试比较频繁的项目，能很好的提高测试效率、节省手工验证的成本。</p>
<p><strong>3 性能测试</strong></p>
<p><img src="/assets/1/image-20211207165039-o2lhkgg.png" alt="image.png"><br>2020年性能测试薪资截图</p>
<p><img src="/assets/1/image-20211207165043-h5hcwvm.png" alt="image.png"><br>2021年性能测试薪资截图，较2020年上涨1.1K</p>
<p><strong>为什么说性能测试很有必要：</strong><br>人们对软件响应的速度也有很高的要求；但与之相对立的是用户访问量越大、数据量越多，软件产品的响应速度就会下降。所以每一个用户量较大的系统都面临着很大的挑战。作为一个测试人员，在产品交付客户上线之前就需要进行充分的性能测试，能够保证软件产品能够承受住实际用户访问的需求。</p>
<p><strong>为什么说做好性能测试不容易？</strong></p>
<p>要做好性能测试，除了最基本的会使用性能测试工具之外，还要对系统的架构、服务之间的调用非常清楚。性能测试的基本技能是性能测试脚本的编写，核心和难点是性能的瓶颈分析和性能调优。如果能把性能测试做好了，想拿高薪真的很容易！</p>
<p><strong>性能测试常用的工具有JMeter和Loadrunner。</strong></p>
<p><strong>4 安全测试</strong></p>
<p><img src="/assets/1/image-20211207165048-fwu6vzc.png" alt="image.png"><br>2020年安全测试薪资截图</p>
<p><img src="/assets/1/image-20211207165052-tyraktd.png" alt="image.png"><br>2021年薪资截图，较 2020年上涨2.2K</p>
<p>安全测试是测试中的一个专项测试，一般都是有专门的安全测试人员进行测试，专业技能要求比较高，但是 <strong>薪资待遇更是非常可观。</strong> 常见的安全测试有暴力破解、<a href="https://www.zhihu.com/search?q=%E8%B6%8A%E6%9D%83%E6%BC%8F%E6%B4%9E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1581863304%7D">越权漏洞</a>、命令注入、SQL注入、XSS、CSRF等等。</p>
<p><strong>5 测试开发</strong></p>
<p><img src="/assets/1/image-20211207165056-nyggkjx.png" alt="image.png"><br>2020年测试开发薪资截图</p>
<p><img src="/assets/1/image-20211207165100-b9slwms.png" alt="image.png"><br>2021年测试开发薪资截图，教上年增加2.5K</p>
<p>市场有大量测试开发岗位 打开BOSS直聘、智联招聘、拉勾等招聘平台，我们可以看到有很多测试开发的岗位。</p>
<p><img src="/assets/1/image-20211207165104-h3ogzke.png" alt="image.png"></p>
<p><strong>为什么说测试开发能拿高薪呢？</strong></p>
<p>测试开发岗位对软件测试工程师有更高的技能要求，不仅要有测试的技能，还要有开发的技能。永远都要相信当今社会不缺少高薪的岗位，只是缺少能拿高薪的人才。</p>
<p><strong>测试开发的主要工作是什么？</strong></p>
<p>目前测试开发的工作主要包括测试工具的开发、测试平台的开发、测试框架的搭建等。这些工作都能够服务于普通的测试人员，提高测试的效率，给公司创造价值。</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>01_测试基础</category>
      </categories>
      <tags>
        <tag>测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>05_测试素质</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/01_%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/05_%E6%B5%8B%E8%AF%95%E7%B4%A0%E8%B4%A8/</url>
    <content><![CDATA[<ol>
<li>对于软件 测试人员来说需要具备的素质，我觉得首先最重要的是要有一定的理论知识和 测试技能，这是测试工作的基础。那么我们 测试人员还应该具备哪些素质才能在工作当中被不断的认可呢？</li>
<li>一名优秀的测试人员应该具有的素质包括：</li>
</ol>
<h3 id="一、-踏实细心和积极主动"><a href="#一、-踏实细心和积极主动" class="headerlink" title="一、 踏实细心和积极主动"></a><strong>一、 踏实细心和积极主动</strong></h3><ol>
<li>我觉得作为一名测试人员首先要踏实细心。细心：这个不用多解释了吧。粗枝大叶的人是没法做好 软件测试的。 软件测试，特别是当前国内主流的手动黑盒 功能测试。基本上软件测试的工作就是一项重复劳动，需要有一定的耐心来保证不在枯燥的重复劳动中放过那些细小的 缺陷。测试人员每天都要面对着枯燥的程序，从事着大量的重复工作，还要尽量发现产品中的 bug。如果不踏实，你就坐不住，总想干别的，就无法净下心来想用户有可能怎么用， 需求对产品是怎么要求的，现在产品中是怎么做的，哪里可能存在问题。不细心，就特别容易一些产品中微笑的错误，而恰恰就是这些错误是最影响产品形象的问题。</li>
<li>至于积极主动就不多说了。这是每个人都应该具有</li>
</ol>
<h3 id="二、-好奇心，怀疑一切"><a href="#二、-好奇心，怀疑一切" class="headerlink" title="二、 好奇心，怀疑一切"></a><strong>二、 好奇心，怀疑一切</strong></h3><ol>
<li>测试人员，对于手上的项目，如果单单只是去运行它，这样是没法发现问题的。我们测试人员进行测试的主要目的就是发现软件存在缺陷，而不是证明它没有缺陷。如果不抱着怀疑一切的态度就不是一名合格的测试人员。经过你手测试的产品面对的是直接用户。你不认真负责，不抱着怀疑一切的态度。总想着这个功能本版没动应该没什么问题，认为一般人不会去这样操作它，这个功能没什么用户用不用认真测了。这样发出的产品，我是不敢让用户用。因为用户用起产品来是千奇百怪，有些用户的水平和对产品的理解比咱们还要深。所以一定要抱着怀疑一切的态度，从多个方面考虑，认为产品每个功能都可能有问题，多问一个「为什么」，「如果这样，行不行？」，认真地测试产品的每一个测试点。</li>
</ol>
<h3 id="三、-与他人良好交流的能力"><a href="#三、-与他人良好交流的能力" class="headerlink" title="三、 与他人良好交流的能力"></a><strong>三、 与他人良好交流的能力</strong></h3><ol>
<li><p>众所周知，测试的过程是一个发现问题并且跟踪解决问题的一个过程，在这个过程中，要意识到测试、 开发、需求是一个团队，一个整体。离了谁，产品的质量都无法保证。沟通能力作为一项特别重要的软技能，在工作中起着举足轻重的作用。作为一名测试人员，我们在提交问题的时候，要做到条理清晰，必要时配上图片以便别人理解，自己提交的问题只有自己能看懂这可不行。我们还需要和项目经理交流了解最新的客户需求，要和 开发人员沟通以便解决缺陷。之前看过一段幽默的开发人员和测试人员的对话：</p>
<ol>
<li><p>测试日常：</p>
<ol>
<li>开发：这不是软件的问题，我看了测试代码，这个地方有点问题，不该是这样测。</li>
<li>测试：真的吗？我看看…真的啊，稍等我提交一下…谢谢你帮我们找到这个bug。</li>
<li>开发：没事，不用谢…（感觉有什么不对）</li>
</ol>
</li>
<li><p>无论是和项目经理还是开发员人交流的时候，态度很重要，这里我说的态度不是低声下气，底气不足的跟她们交流，特别是和开发人员交流时，可能会因为一个bug，两人争执不下发生冲突，这时候我们测试人员要做到分析问题所在，同时也要听听开发人员的想法，心平气和进行交流，最后实在是两人都拿不定注意，可以请示上级。</p>
</li>
</ol>
</li>
</ol>
<h3 id="四、-持续不断的自我提高和总结能力"><a href="#四、-持续不断的自我提高和总结能力" class="headerlink" title="四、  持续不断的自我提高和总结能力"></a><strong>四、  持续不断的自我提高和总结能力</strong></h3><ol>
<li><p>我觉得无论是哪个行业，都不能停滞不前，自我提高是必须的，这样才不会被淘汰，那么作为一名优秀的测试人员如何提高自己的测试能力呢？</p>
<ol>
<li><strong>第一，首先提高自己的测试理论基础。</strong>所有的测试基础概念其实都是通用的：静态测试，动态测试， 测试用例，等等以及一些测试相关技术：等价类划分，边界值，相信这些方法所有的人每天都在用，但是未必所有的人都能说明白。所以为自己每天所做的测试行动找点理论基础，即有效率有与实践相结合，这也是职业发展的重要一步。</li>
<li><strong>第二，要对测试的整体流程有完整的概念。</strong>这个是目前很多初级测试人员所欠缺的。目前大多数人只知道自己测试的是什么东西，但是不知道自己执行的测试处于什么阶段，下一个阶段是什么，也许整个项目做完不知道；这对于一个产品来说是一个不负责任的行为，所以也就需要测试人员有端到端的测试意识和对测试流程的概念的认可，要有测试整体流程管理的概念。</li>
<li><strong>第三，在进行测试工作中要弄明白为什么要这么做，为什么要执行这样的案例，为什么要执行相关的测试工作。</strong>多问几个为什么。有一个问题要先讲清楚，就是有很多人还没有注意到这个问题，领导让怎么做就怎么做，也许真的做的很熟练了，但是一年后去问他为什么要这么做，相信他也说不出太多，反倒觉得就应该这么测。这样带来直接的弊端就是对自己的职业之路不负责任。</li>
<li>另外，我觉得作为一名合格的测试人员，一定要注意进行总结。通过总结可以对自己的工作进行一个回顾分析，看看那些做得不错，下次还继续这么做。那些工作还有改进的余地。对自己能力的提高是一个很好的帮助。</li>
</ol>
</li>
</ol>
<h3 id="五、-强烈的责任感"><a href="#五、-强烈的责任感" class="headerlink" title="五、  强烈的责任感"></a><strong>五、  强烈的责任感</strong></h3><ol>
<li>对于你测试的产品付责任，许多测试人员在早上来到办公室，完成自己的任务，然后晚上下班回家。当软件测试人员完成自己的任务，然后下班收拾东西回家，这种常规的工作方式听起来很正常吧？是的，不得不说，目前我们都是这样的一个状态。要完成一个高质量的产品，我们就要对它负责，那么怎么负责呢？</li>
<li>测试人员要对所测试的对象质量负责，要能保证测试的覆盖到每一需求点，同时要能保证功能都可以正确实现等或者达到了测试通过的标准。</li>
<li>对于测试人员漏测，毕竟人不是完美的，难免会出现错误，但是不能以漏测来做为质量考核。可以对其进行分类分析，究竟是哪个环节出现的问题，提出来进行改进。比如说需求描述不完整，导致理解错误；隐含性需求未考虑到；易用性方面考虑不周；实际环境与测试环境有差异；自身经验不足等多方面。</li>
<li>测试这项工作，是证明产品做了正确的事情，能满足用户的需求，用各种 测试方法来找出问题，是对质量的一种度量。好的质量是要靠高素质人员和好的过程来保证的。</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>01_测试基础</category>
      </categories>
      <tags>
        <tag>测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>06_学习规则</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/01_%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/06_%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="1-学习规则："><a href="#1-学习规则：" class="headerlink" title="1. 学习规则："></a>1. 学习规则：</h2><pre><code>1. 上课时间：大小周

    1. 打卡

        1. 要求每天打卡四次：

            1. 早上9：00（后期会有调整）、中午11：30与14：00、下午18：00
    2. 教学规则

        1. 上课期间手机等电子产品一律放入手机篮（手机调至静音）
        2. 晚上10点准时休息
        3. 学习期间不准酗酒
        4. 无重大事件不准请假
    3. 日报

        1. 每日必填
    4. 教学时间

        1. 分为大小周教学
    5. 教室、宿舍环境保证清洁卫生
    6. 教室、宿舍禁止抽烟
</code></pre>
<h2 id="2-时间安排-——–-gt-45天-不含休息日"><a href="#2-时间安排-——–-gt-45天-不含休息日" class="headerlink" title="2. 时间安排                ——–&gt;  45天(不含休息日)"></a>2. 时间安排                ——–&gt;  45天(不含休息日)</h2><pre><code>1. 第一章 基础              -----------&gt; 14工作天
2. 第二章 操作              -----------&gt; 6工作天
3. 第三章 接口测试        -----------&gt; 5工作日
4. 第四章 性能测试        -----------&gt; 3工作天
5. 第五章 APP测试        -----------&gt; 2工作天
6. 第六章 自动化测试    -----------&gt; 6工作天
7. 第七章 安全测试       -----------&gt; 1工作天
8. 第八章 项目             -----------&gt; 5工作天
9. 简历编写                 -----------&gt; 1工作天
10. 模拟面试题分析       -----------&gt; 2工作天
11. 面试题分析             -----------&gt; 30工作日(不在学习时间范围内)
</code></pre>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>01_测试基础</category>
      </categories>
      <tags>
        <tag>测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬取抖音app</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/03_APP%E8%87%AA%E5%8A%A8%E5%8C%96/01_appium/02_2/</url>
    <content><![CDATA[<ol>
<li>准备<br> 安装夜神模拟器<br> 安装Xposed<a href="assets/3/android.xposed.installer.apk">xposed.installer</a><br> <a href="https://blog.csdn.net/weixin_48140105/article/details/118359568">因Xposed服务不能访问，本地方法：</a><br> 安装包：<a href="assets/3/xposed-v89-sdk22-x86.zip">xposed-v89-sdk22-x86</a><br> <a href="assets/3/JustTrustMe.apk">JustTrustMe</a><br> 安装mitmproxy： pip install mitmproxy<br> 查看mitmproxy是否安装的命令：mitmdimp –version<br> 安装 mongdb数据库<br> <a href="https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-5.0.9.zip">官网下载地址（zip）</a><br> <a href="https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-5.0.9-signed.msi">官网下载地址（msi）</a></li>
</ol>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>03_APP自动化</category>
        <category>01_appium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>4位验证码识别</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/python%E6%8F%92%E4%BB%B6/4%E4%BD%8D%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<pre><code>#!/usr/bin/evn python
# -*- coding: utf-8 -*-
# @Time          ： 2022/05/30 21:21
# @Author        ： YuLong
# @site          ： 
# @file          ： server.py
# @explanation   ： ddddocr 验证码验证模型
# @software      : PyCharm Community Edition


import os
import ddddocr
from time import sleep
from PIL import Image
from selenium import webdriver
from selenium.webdriver.common.by import By


class GetVerificationCode:
    def __init__(self):
        self.res = None
        # 德尚商城登录页面
        url = &#39;https://dsshop.csdeshang.com/home/Login/login.html&#39;
        self.driver = webdriver.Chrome()
        self.driver.maximize_window()  # 将浏览器最大化
        self.driver.get(url)

    # 获取验证码信息


    def getVerification(self):
        # 获取当前文件的位置、并获取保存截屏的位置
        current_location = os.path.dirname(__file__)
        screenshot_path = os.path.join(current_location, &quot;&quot;, &quot;VerificationCode&quot;)
        # 截取当前网页并放到自定义目录下，并命名为printscreen，该截图中有我们需要的验证码
        sleep(1)
        self.driver.save_screenshot(screenshot_path + &#39;/&#39; + &#39;printscreen.png&#39;)
        sleep(1)
        # 定位验证码
        imgelement = self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;codeimage&quot;]&#39;)
        # 获取验证码x,y轴坐标
        location = imgelement.location
        # 获取验证码的长宽
        size = imgelement.size
        # 写成我们需要截取的位置坐标
        rangle = (int(location[&#39;x&#39;] +257),
                  int(location[&#39;y&#39;]+125 ),
                  int(location[&#39;x&#39;] + size[&#39;width&#39;]+ 300 ),
                  int(location[&#39;y&#39;] + size[&#39;height&#39;]+140 ))
        # 打开截图
        i = Image.open(screenshot_path + &#39;/&#39; + &#39;printscreen.png&#39;)
        # 使用Image的crop函数，从截图中再次截取我们需要的区域
        fimg = i.crop(rangle)
        fimg = fimg.convert(&#39;RGB&#39;)
        # 保存我们截下来的验证码图片，并读取验证码内容
        fimg.save(screenshot_path + &#39;/&#39; + &#39;code.png&#39;)
        ocr = ddddocr.DdddOcr()
        with open(screenshot_path + &#39;/&#39; + &#39;code.png&#39;, &#39;rb&#39;) as f:
            img_bytes = f.read()
        self.res = ocr.classification(img_bytes)
        print(&#39;识别出的验证码为：&#39; + self.res)

        # 判断验证码错误时的提示信息是否存在


    def isElementPresent(self, by, value):
        try:
            element = self.driver.find_element(by=by, value=value)
        except NoSuchElementException:
            pass
            # 发生了NoSuchElementException异常，说明页面中未找到该元素，返回False
            return False
        else:
            # 没有发生异常，表示在页面中找到了该元素，返回True
            return True

    # 登录


    def login(self):
        self.getVerification()
        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;member_name&quot;]&#39;).send_keys(&#39;用户名&#39;)
        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;member_password&quot;]&#39;).send_keys(&#39;密码&#39;)
        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;captcha_normal&quot;]&#39;).send_keys(self.res)
        sleep(1)
        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;login_normal_form&quot;]/div[5]/input[2]&#39;).click()
        sleep(2)
        isFlag = True


        while isFlag:
            try:
                isPresent = self.isElementPresent(By.XPATH, &#39;//*[@id=&quot;captcha_normal-error&quot;]&#39;)
                if isPresent is True:
                    codeText = self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;captcha_normal-error&quot;]&#39;).text
                    if codeText == &quot;验证码不正确&quot;:
                        self.getVerification()
                        sleep(2)
                        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;captcha_normal&#39;).clear()
                        sleep(1)
                        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;captcha_normal&#39;).send_keys(self.res)
                        sleep(1)
                        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;login_normal_form&quot;]/div[5]/input[2]&#39;).click()
                        sleep(2)
                    tips = self.driver.find_element(By.XPATH,&#39;//*[@id=&quot;captcha_normal-error&quot;]&#39;).text
                    if tips == &quot;验证码不能为空&quot;:
                        self.getVerification()
                        sleep(2)
                        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;captcha_normal&quot;]&#39;).click()
                        sleep(1)
                        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;captcha_normal&quot;]&#39;).send_keys(self.res)
                        sleep(1)
                        self.driver.find_element(By.XPATH, &#39;//*[@id=&quot;login_normal_form&quot;]/div[5]/input[2]&#39;).click()
                        sleep(2)
                    continue
                else:
                    print(&quot;验证码正确，登录成功！&quot;)
            except NoSuchElementException:
                pass
            else:
                isFlag = False

            sleep(5)
            self.driver.quit()

if __name__ == &#39;__main__&#39;:
    GetVerificationCode().login()

&#39;&#39;&#39;
ERROR: pip&#39;s dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.
paddlepaddle 2.2.2 requires numpy&lt;=1.19.3,&gt;=1.13; python_version &gt;= &quot;3.5&quot; and platform_system == &quot;Windows&quot;, but you have numpy 1.21.6 which is incompatible.
错误：pip 的依赖解析器当前不考虑所有已安装的包。此行为是以下依赖冲突的根源。 paddlepaddle 2.2.2 需要 numpy&lt;=1.19.3,&gt;=1.13; python_version &gt;= &quot;3.5&quot; 和 platform_system == &quot;Windows&quot;，但是你有不兼容的 numpy 1.21.6。

ERROR: pip&#39;s dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.
onnxruntime 1.11.1 requires numpy&gt;=1.21.6, but you have numpy 1.19.3 which is incompatible.
错误：pip 的依赖解析器当前不考虑所有已安装的包。此行为是以下依赖冲突的根源。 onnxruntime 1.11.1 需要 numpy&gt;=1.21.6，但你有 numpy 1.19.3，这是不兼容的。
&#39;&#39;&#39;
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>python插件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pytesseract安装使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/python%E6%8F%92%E4%BB%B6/pytesseract%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li>安装配置和测试<br> pytesseract是google的tesseract的一个python版本的接口库，想要真正使用，首先需要安装tesseract</li>
</ol>
<p>1.1 tesseract安装<br>下载安装tesseract，去这个网址下载：<a href="https://digi.bib.uni-mannheim.de/tesseract/%E3%80%82%EF%BC%88%E6%88%96%E8%80%85%E5%9C%A8github%E7%9A%84wiki%E9%A1%B5%E9%9D%A2%E4%B8%8A%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%EF%BC%89%EF%BC%8C%E6%A0%B9%E6%8D%AETesseract">https://digi.bib.uni-mannheim.de/tesseract/。（或者在github的wiki页面上也可以找到这个页面进行下载），根据Tesseract</a> document可知，Tesseract4.0及以上配备了LSTM网络，之前的低版本是没有的，所以按照自己需求去找相应的版本。<br>双击安装，记得勾选中文包（这个下载比较慢）</p>
<p><img src="/assets/2/image-20220530203405-z3znqfw.png" alt="image.png"></p>
<p>配置系统环境变量，只要配置到tesseract.exe所在的文件夹那一级就行</p>
<p><img src="/assets/2/image-20220530203414-zej2ozj.png" alt="image.png"></p>
<p>测试是否安装成功，在命令行输入tesseract –help查看是否会返回一些提示信息。</p>
<p><img src="/assets/2/image-20220530203421-i5eoze7.png" alt="image.png"></p>
<p>或者可以直接测试一张含有文字的图片，看看效果，tesseract image.png result</p>
<pre><code>tesseract 9450.jpg result
Tesseract Open Source OCR Engine v5.0.0.20190623 with Leptonica
Warning: Invalid resolution 0 dpi. Using 70 instead. Estimating resolution as 319

#     然后会在当前命令路径下看到一个result.txt，其中存放在识别结果
</code></pre>
<p>1.2 pytessract安装<br>上面那个搞好了，这个就很好搞，直接			</p>
<pre><code>pip install pytesseract
 #     或者通过conda安装
conda  install -c conda-forge pytesseract
</code></pre>
<ol start="2">
<li>简单使用和参数说明</li>
</ol>
<p>2.1 无法调用<br>如果报错：</p>
<pre><code>XXXX
FileNotFoundError: [WinError 2] 系统找不到指定的文件。
XXXX
pytesseract.pytesseract.TesseractNotFoundError: tesseract is not installed or it&#39;s not in your path
</code></pre>
<p>有两种解决方案，</p>
<p>一种是在pytessercat.py脚本中更改tesseract_cmd路径为tesseract安装路径，要具体到tesseract.exe文件，但是不用写.exe这个后缀</p>
<p><img src="/assets/2/image-20220530203835-c39zwl4.png" alt="image.png"></p>
<p>另一种就是每次在代码中加入以下代码，指明tesseract_cmd命令的位置，方便pytesseract调用：</p>
<pre><code>tesseract_cmd = r&#39;C:\Program Files (x86)\Tesseract-OCR\tesseract&#39;
pytesseract.pytesseract.tesseract_cmd =tesseract_cmd
</code></pre>
<p>2.2 基本用法<br>以下代码粘贴自jupyter notebook文件，</p>
<pre><code>from PIL import Image
import pytesseract
import matplotlib.pyplot as plt&lt;br /&gt;%matplotlib inline

path=&quot;9450.jpg&quot;

&quot;&quot;&quot;
指明tesseract命令位置
&quot;&quot;&quot;
tesseract_cmd = r&#39;C:\Program Files (x86)\Tesseract-OCR\tesseract&#39;
pytesseract.pytesseract.tesseract_cmd =tesseract_cmd

&quot;&quot;&quot;
 基础的图片转换为文字
&quot;&quot;&quot;

# 显示

image=Image.open(path)
plt.figure(figsize=(2,2))
plt.axis(&#39;off&#39;)
plt.imshow(image)

print(pytesseract.image_to_string(image))

&quot;&quot;&quot;
当前支持的语言 osd On Screen Display 屏幕显示字符
&quot;&quot;&quot;
print(pytesseract.get_languages(config=&#39;&#39;))

&quot;&quot;&quot;
尝试修改语言参数
&quot;&quot;&quot;
print(pytesseract.image_to_string(image, lang=&#39;osd&#39;))
&quot;&quot;&quot;
🐱👓识别超时就停止
&quot;&quot;&quot;
try:
    print(pytesseract.image_to_string(image, timeout=2)) # Timeout after 2 seconds
    print(pytesseract.image_to_string(image, timeout=0.5)) # Timeout after half a second
except RuntimeError as timeout_error:
    # Tesseract processing is terminated
    pass

&quot;&quot;&quot;
将识别结果导出成文字可选的pdf
这个达成的效果，就是会把图片转成pdf，同时其中的文字会是可编辑/可选的
&quot;&quot;&quot;
pdf = pytesseract.image_to_pdf_or_hocr(Image.open(&quot;1.png&quot;), extension=&#39;pdf&#39;)
with open(&#39;test.pdf&#39;, &#39;w+b&#39;) as f:
    f.write(pdf) # pdf type is bytes by default

&quot;&quot;&quot;
修改参数
&quot;&quot;&quot;
configdigit=&#39;--psm 6 --oem 1&#39;
print(pytesseract.image_to_string(img_cv,config=configdigit))
configdigit=&#39;--psm 6 --oem 3  -c tessedit_char_whitelist=0123456789&#39;
print(pytesseract.image_to_string(img_cv,config=configdigit))

&quot;&quot;&quot;
关于其中的psm参数和oem参数，可以查看帮助文档
&quot;&quot;&quot;
! tesseract --help-extra

Page segmentation modes:
0    Orientation and script detection (OSD) only.
1    Automatic page segmentation with OSD.
2    Automatic page segmentation, but no OSD, or OCR. (not implemented)
3    Fully automatic page segmentation, but no OSD. (Default)
4    Assume a single column of text of variable sizes.
5    Assume a single uniform block of vertically aligned text.
6    Assume a single uniform block of text.
7    Treat the image as a single text line.
8    Treat the image as a single word.
9    Treat the image as a single word in a circle.
10    Treat the image as a single character.
11    Sparse text. Find as much text as possible in no particular order.
12    Sparse text with OSD.
13    Raw line. Treat the image as a single text line,
    bypassing hacks that are Tesseract-specific.

OCR Engine modes:
0    Legacy engine only.
1    Neural nets LSTM engine only.
2    Legacy + LSTM engines.
3    Default, based on what is available.
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>python插件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy_gerapy爬虫管理框架</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/scrapy%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05_scrapy_gerapy%E7%88%AC%E8%99%AB%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="1-gerapy介绍"><a href="#1-gerapy介绍" class="headerlink" title="1. gerapy介绍"></a>1. gerapy介绍</h2><p>gerapy 是一款分布式爬虫管理框架，支持Python3，基于scrapy、scrapyd<br>scrapyd-client、scrapy-redis、scrapyd-api、scrapy-splash、jinjia2、django、vue.js开发、gerapy可以帮助我们：<br>    1. 更方便的控制爬虫运行<br>    2. 更直观的查看爬虫状态<br>    3. 更实时的查看爬去结果<br>    4. 更简单的实现项目部署<br>    5. 更统一地实现主机管理</p>
<h2 id="2-gerapy的安装"><a href="#2-gerapy的安装" class="headerlink" title="2. gerapy的安装"></a>2. gerapy的安装</h2><pre><code>1. 执行如下命令，等待安装完毕
    pip install gerapy
2. 验证gerapy是否安装成功
    在终端中执行gerapy 会出现如下信息
    ![wer](2232)
3. gerapy 配置启动
    1. 新建一个项目
        gerapy init
        执行完该命令之后在当前目录下生成一个gerapy文件夹，进入该文件夹，会找到一个名为projects 的文件
    2. 对数据库进行初始化（在gerapy目录中操作），执行如下命令
        gerapy migrate
        ![image.png](assets/2/image-20220527144809-zun804x.png)
        对数据库初始化之后会生成一个SQLite数据库，数据库保存主机配置和部署版本等
        ![image.png](assets/2/image-20220527144834-crdotse.png)
    3. 启动gerapy服务
        此时启动gerapy服务的这台机器的8000端口上开启了gerapy服务，在浏览器中输入http://localhost:8000就能进入gerapy管理界面，在管理界面就可以进行主机管理和界面管理
        ![image.png](assets/2/image-20220527145151-fkkxt6b.png)
    4. 通过gerapy配置管理scrapy项目
    5. 配置project
        1. 我们可以将scrapy项目直接放到/gerapy/projects下
        2. 可以在gerapy后台看到有个项目
        ![image.png](assets/2/image-20220527145500-k99cqu4.png)
        3. 点击部署点击部署按钮进行打包和部署，在右下角我么可以输入打包时的描述信息，类似于git的commit信息，
        ![image.png](assets/2/image-20220527145743-ls1oklb.png)
        然后点击打包按钮，即可发现gerapy会提示打包成功，同时在右侧显示打包的结果和打包名称
        ![image.png](assets/2/image-20220527145820-tdw8if1.png)
        4. 选择一个站点，点击右侧部署，将该项目部署到该站点上
        ![image.png](assets/2/image-20220527150104-my849n7.png)
        5. 成功部署之后会显示描述和部署时间
        ![image.png](assets/2/image-20220527150307-9u2rn2l.png)
        6. 来到client界面，找到部署该项目的节点，点击调度
        ![image.png](assets/2/image-20220527150412-68g8gf6.png)
        7. 在该节点中的项目列表中找到项目，点击右侧run运行项目
        ![image.png](assets/2/image-20220527150528-q4ueh1u.png)
    6. 补充
        1.gerapy 与scrad有什么联系
            我们仅仅使用scrapyd 是可以调用scrapy进行爬虫，只是需要使用命令进行开启爬虫 curl http://127.0.0.1:6800/schedule.json -d project=工程名 -d spider=爬虫名 使用gerapy就是将使用命令进行开启爬虫变成“小手一点”，我们在gerapy中配置scrad后，不需要使用命令行，可以通过图形化界面直接开启爬虫
</code></pre>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>01_爬虫技术</category>
        <category>scrapy框架</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy_scrapyd部署</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/scrapy%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/04_scrapy_scrapyd%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="1-scrapyd的介绍"><a href="#1-scrapyd的介绍" class="headerlink" title="1. scrapyd的介绍"></a>1. scrapyd的介绍</h3><p>scrapyd是一个用于部署和运行scrapy爬虫的程序，它允许你通过json api 来部署爬虫项目和控制爬虫运行，scrapyd 是一个守护进程，监听爬虫的运行和请求，然后启动进程来执行他们</p>
<blockquote>
<p>所谓json api本质就是post请求的webapi</p>
</blockquote>
<h3 id="2-scrapyd的安装"><a href="#2-scrapyd的安装" class="headerlink" title="2. scrapyd的安装"></a>2. scrapyd的安装</h3><p>scrapyd 服务 ： pip install scrapyd<br>scrapyd 客户端： pip install scrapyd-client</p>
<h3 id="3-启动scrapyd服务"><a href="#3-启动scrapyd服务" class="headerlink" title="3. 启动scrapyd服务"></a>3. 启动scrapyd服务</h3><ol>
<li>在scrapy项目路径下 启动scrapyd 的命令： sudo scrapyd 或scrapyd</li>
<li>启动之后可以在本地打开运行的scrapyd，浏览器中访问本地6800端口可以查看scrapyd 的监控界面</li>
<li><img src="/111" alt="为配图，待截图"></li>
</ol>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>01_爬虫技术</category>
        <category>scrapy框架</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>03_scrapy_splash框架问题分析</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/scrapy%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03_scrapy_splash%E6%A1%86%E6%9E%B6%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="启动splash服务"><a href="#启动splash服务" class="headerlink" title="启动splash服务"></a>启动splash服务</h2><h2 id="1-sittings-py-文件配置："><a href="#1-sittings-py-文件配置：" class="headerlink" title="1. sittings.py 文件配置："></a>1. sittings.py 文件配置：</h2><h5 id="1-修改settings-py，配置SPLASH-URL。在这里我们的Splash是在本地运行的，所以可以直接配置本地的地址："><a href="#1-修改settings-py，配置SPLASH-URL。在这里我们的Splash是在本地运行的，所以可以直接配置本地的地址：" class="headerlink" title="1. 修改settings.py，配置SPLASH_URL。在这里我们的Splash是在本地运行的，所以可以直接配置本地的地址："></a>1. 修改settings.py，配置SPLASH_URL。在这里我们的Splash是在本地运行的，所以可以直接配置本地的地址：</h5><pre><code>SPLASH_URL = &#39;http://localhost:8050&#39;
</code></pre>
<h5 id="如果Splash是在远程服务器运行的，那此处就应该配置为远程的地址。例如运行在IP为120-27-34-25的服务器上，则此处应该配置为："><a href="#如果Splash是在远程服务器运行的，那此处就应该配置为远程的地址。例如运行在IP为120-27-34-25的服务器上，则此处应该配置为：" class="headerlink" title="如果Splash是在远程服务器运行的，那此处就应该配置为远程的地址。例如运行在IP为120.27.34.25的服务器上，则此处应该配置为："></a>如果Splash是在远程服务器运行的，那此处就应该配置为远程的地址。例如运行在IP为120.27.34.25的服务器上，则此处应该配置为：</h5><pre><code>SPLASH_URL = &#39;http://120.27.34.25:8050&#39;
</code></pre>
<h5 id="2-还需要配置几个Middleware，代码如下所示："><a href="#2-还需要配置几个Middleware，代码如下所示：" class="headerlink" title="2. 还需要配置几个Middleware，代码如下所示："></a>2. 还需要配置几个Middleware，代码如下所示：</h5><pre><code>DOWNLOADER_MIDDLEWARES = &#123;
   &#39;scrapy_splash.SplashCookiesMiddleware&#39;: 723,
   &#39;scrapy_splash.SplashMiddleware&#39;: 725,
   &#39;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#39;: 810,
&#125;
SPIDER_MIDDLEWARES = &#123;
   &#39;scrapy_splash.SplashDeduplicateArgsMiddleware&#39;: 100,
&#125;
</code></pre>
<p>这里配置了三个Downloader Middleware和一个Spider Middleware，这是Scrapy-Splash的核心部分。我们不再需要像对接Selenium那样实现一个Downloader Middleware，Scrapy-Splash库都为我们准备好了，直接配置即可。</p>
<h5 id="3-还需要配置一个去重的类DUPEFILTER-CLASS，代码如下所示："><a href="#3-还需要配置一个去重的类DUPEFILTER-CLASS，代码如下所示：" class="headerlink" title="3. 还需要配置一个去重的类DUPEFILTER_CLASS，代码如下所示："></a>3. 还需要配置一个去重的类DUPEFILTER_CLASS，代码如下所示：</h5><pre><code>DUPEFILTER_CLASS = &#39;scrapy_splash.SplashAwareDupeFilter&#39;
1
</code></pre>
<h5 id="4-最后配置一个Cache存储HTTPCACHE-STORAGE，代码如下所示："><a href="#4-最后配置一个Cache存储HTTPCACHE-STORAGE，代码如下所示：" class="headerlink" title="4. 最后配置一个Cache存储HTTPCACHE_STORAGE，代码如下所示："></a>4. 最后配置一个Cache存储HTTPCACHE_STORAGE，代码如下所示：</h5><pre><code>HTTPCACHE_STORAGE = &#39;scrapy_splash.SplashAwareFSCacheStorage&#39;
</code></pre>
<h2 id="2-使用过程中遇到的问题分析"><a href="#2-使用过程中遇到的问题分析" class="headerlink" title="2. 使用过程中遇到的问题分析"></a>2. 使用过程中遇到的问题分析</h2><h3 id="1-错误演示-如图"><a href="#1-错误演示-如图" class="headerlink" title="1. 错误演示  如图"></a>1. 错误演示  如图</h3><p>spider文件编写代码错误</p>
<pre><code>    def start_requests(self):
         yield SplashRequest(
             url=self.start_urls[0],       # 这是一个错误的演示， 必须使用for循环取值，不能使用下标获取值，使用下标的话 会报 404的错误，找不到原因
             callback=self.parse,
             args=&#123;&quot;wait&quot;:10&#125;, # 最大超时时间，单位：s
             endpoint=&quot;reader.html&quot;
         )
</code></pre>
<p><img src="/assets/2/image-20220526211507-asoegu2.png" alt="image.png"></p>
<h4 id="正确演示："><a href="#正确演示：" class="headerlink" title="正确演示："></a>正确演示：</h4><pre><code>    def start_requests(self):
         for start_url in self.start_urls:
             yield SplashRequest(start_url,
                                 callback=self.parse,
                                 args=&#123;&#39;wait&#39;: 10&#125;,  # 最大超时时间，单位：秒
                                 endpoint=&#39;render.html&#39;)  # 使用splash服务的固定参数
</code></pre>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>01_爬虫技术</category>
        <category>scrapy框架</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python第-scrapy框架_概念和流程</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/scrapy%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01_scrapy_%E6%A6%82%E5%BF%B5%E5%92%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="scrapy-的概念和流程"><a href="#scrapy-的概念和流程" class="headerlink" title="scrapy 的概念和流程"></a>scrapy 的概念和流程</h1><h2 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h2><h3 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h3><ol>
<li>了解scrapy的概念</li>
<li>了解dcrapy框架的作用</li>
<li>掌握scrapy框架的运行流程</li>
<li>掌握scrapy中的每个模块的作用</li>
</ol>
<h3 id="1-scrapy的概念"><a href="#1-scrapy的概念" class="headerlink" title="1.scrapy的概念"></a>1.scrapy的概念</h3><h4 id="scrapy是一个python编写的开源网络爬虫框架，他是一个被设计-用于爬取网络数据、提取结构性数据的框架"><a href="#scrapy是一个python编写的开源网络爬虫框架，他是一个被设计-用于爬取网络数据、提取结构性数据的框架" class="headerlink" title="scrapy是一个python编写的开源网络爬虫框架，他是一个被设计 用于爬取网络数据、提取结构性数据的框架"></a>scrapy是一个python编写的开源网络爬虫框架，他是一个被设计 用于爬取网络数据、提取结构性数据的框架</h4><pre><code> scrapy使用了twisted异步网络框架，可以加快我们的下载速度
</code></pre>
<p>scrapy文档：<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/">https://scrapy-chs.readthedocs.io/zh_CN&#x2F;0.24&#x2F;</a></p>
<h3 id="2-scrapy框架的作用"><a href="#2-scrapy框架的作用" class="headerlink" title="2.scrapy框架的作用"></a>2.scrapy框架的作用</h3><h4 id="少量的代码，就能够快速的抓取"><a href="#少量的代码，就能够快速的抓取" class="headerlink" title="少量的代码，就能够快速的抓取"></a>少量的代码，就能够快速的抓取</h4><h3 id="3-scrapy的工作流程"><a href="#3-scrapy的工作流程" class="headerlink" title="3.scrapy的工作流程"></a>3.scrapy的工作流程</h3><h4 id="3-1-回顾之前的爬虫流程"><a href="#3-1-回顾之前的爬虫流程" class="headerlink" title="3.1 回顾之前的爬虫流程"></a>3.1 回顾之前的爬虫流程</h4><p> <img src="/assets/2/image-20220523141200-qq1ar39.png" alt="image.png"></p>
<h4 id="3-2-上面流程可以修改为"><a href="#3-2-上面流程可以修改为" class="headerlink" title="3.2 上面流程可以修改为"></a>3.2 上面流程可以修改为</h4><p> <img src="/assets/2/image-20220523142540-r3yhln7.png" alt="image.png"></p>
<h4 id="3-3-scrapy-的流程"><a href="#3-3-scrapy-的流程" class="headerlink" title="3.3 scrapy 的流程"></a>3.3 scrapy 的流程</h4><p><img src="/assets/2/scrapy1.jpg" alt="image.png"><br><img src="/assets/2/image-20220523142912-6lkduyf.png" alt="image.png"><br>其流程可以描述如下：<br>    1. 爬虫中起始的url构造成request对象–&gt;爬虫中间件–&gt;迎请–&gt;调度器<br>    2.  调度器把request–&gt;迎请–&gt;下载中间件–&gt;下载器<br>    3.  下载器发送请求，获取response 响应–&gt;下载中间件–&gt;引擎–&gt;爬虫<br>    4.  爬虫提取url地址，组装成request对象–&gt;爬虫中间件–&gt;引擎–&gt;调度器，重复步骤2<br>    5.  爬虫提取数据–&gt;引擎–&gt;管道处理和保存数据<br>注意：<br>    * 图中中文是为了方便理解后加上去的<br>    * 图中绿色线条的表示数据的传递<br>    * 注意中间件的位置，决定其作用<br>    * 注意其中引擎的位置，所有的模块之间相互独立，只和引擎进行交互</p>
<h4 id="3-4-scrapy的三个内组织对象"><a href="#3-4-scrapy的三个内组织对象" class="headerlink" title="3.4 scrapy的三个内组织对象"></a>3.4 scrapy的三个内组织对象</h4><pre><code>* request请求对象：由url method post_data headers 等构成
* response响应对象：由url body status headers等构成
* item数据对象：本质是个字典
</code></pre>
<h4 id="3-5-scrapy中的每个模块的具体作用"><a href="#3-5-scrapy中的每个模块的具体作用" class="headerlink" title="3.5 scrapy中的每个模块的具体作用"></a>3.5 scrapy中的每个模块的具体作用</h4><p>![image.png](assets&#x2F;2&#x2F;  image-20220523144758-47dlg2q.png)<br>注意：<br>    * 爬虫中间件和下载中间件知识运行逻辑的位置不同，作用是重复的：如替换UA等</p>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>01_爬虫技术</category>
        <category>scrapy框架</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python第-scrapy框架_入门使用</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/scrapy%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02_scrapy_%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h2><pre><code>1. 掌握scrapy的安装
2. 应用创建scrapy的项目
3. 应用创建scrapy爬虫
4. 应用运行scrapy爬虫
5. 应用scrapy定位以及提取数据或属性值得方法
6. 掌握response响应对象的常用属性
</code></pre>
<h2 id="1-安装scrapy"><a href="#1-安装scrapy" class="headerlink" title="1. 安装scrapy"></a>1. 安装scrapy</h2><h4 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h4><blockquote>
<p>sudo apt-get install scrapy</p>
</blockquote>
<h4 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h4><blockquote>
<p>pip&#x2F;pip3 install  scrapy</p>
</blockquote>
<h2 id="2-scrapy-项目开发流程"><a href="#2-scrapy-项目开发流程" class="headerlink" title="2. scrapy 项目开发流程"></a>2. scrapy 项目开发流程</h2><pre><code>1.创建项目：
    scrapy startoject mySpider
2.生成一个爬虫
    scrapy genspider itcast itcast.cn
3.提取数据
    根据网站结果在spider中实现数据采集相关内容
4.保存数据
    使用pipeline进行数据后续处理和保存
</code></pre>
<h2 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3. 创建项目"></a>3. 创建项目</h2><blockquote>
<p>通过命令将scrapy项目的文件生成出来，后续步骤都是在项目文件中进行相关操作，下面抓取传智师资库来学习scrapy的入门使用：<a href="http://www.itcast.cn/channel/teacher.shtml">http://www.itcast.cn/channel/teacher.shtml</a><br>创建scrapy项目的命令：<br>scrapy startpoject &lt;项目名称&gt;<br>示例：<br>scrapy startproject myspider<br>生成的目录和文件结构如图：<br><img src="/assets/image-20220523151330-kj8lufa.png" alt="image.png"></p>
</blockquote>
<h2 id="4-创建爬虫"><a href="#4-创建爬虫" class="headerlink" title="4. 创建爬虫"></a>4. 创建爬虫</h2><h3 id="通过命令创建出爬虫文件，爬虫文件为主要的代码作业文件通常一个网站的爬虫动作都会在爬虫文件中进行编写"><a href="#通过命令创建出爬虫文件，爬虫文件为主要的代码作业文件通常一个网站的爬虫动作都会在爬虫文件中进行编写" class="headerlink" title="通过命令创建出爬虫文件，爬虫文件为主要的代码作业文件通常一个网站的爬虫动作都会在爬虫文件中进行编写"></a>通过命令创建出爬虫文件，爬虫文件为主要的代码作业文件通常一个网站的爬虫动作都会在爬虫文件中进行编写</h3><h4 id="命令：-1"><a href="#命令：-1" class="headerlink" title="命令："></a>命令：</h4><pre><code>在项目路径下执行：
    &gt; scrapy genspider &lt;爬虫名字&gt;&lt;允许爬取的域名&gt;
</code></pre>
<h4 id="爬虫名字：作为爬虫运行时的参数"><a href="#爬虫名字：作为爬虫运行时的参数" class="headerlink" title="爬虫名字：作为爬虫运行时的参数"></a>爬虫名字：作为爬虫运行时的参数</h4><h4 id="允许爬取的域名：为对于爬虫设置的爬取范围，设置之后用于过滤要爬取的url，如果爬取的url与允许的域不同则被过滤掉"><a href="#允许爬取的域名：为对于爬虫设置的爬取范围，设置之后用于过滤要爬取的url，如果爬取的url与允许的域不同则被过滤掉" class="headerlink" title="允许爬取的域名：为对于爬虫设置的爬取范围，设置之后用于过滤要爬取的url，如果爬取的url与允许的域不同则被过滤掉"></a>允许爬取的域名：为对于爬虫设置的爬取范围，设置之后用于过滤要爬取的url，如果爬取的url与允许的域不同则被过滤掉</h4><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote>
<p>cd myspider<br>scrapy genspider itcast  itcast.cn</p>
</blockquote>
<p>生成的目录和文件结果如下：<br><img src="/assets/2/image-20220523153511-rqee69q.png" alt="image.png"></p>
<h3 id="5-完善爬虫"><a href="#5-完善爬虫" class="headerlink" title="5. 完善爬虫"></a>5. 完善爬虫</h3><blockquote>
<p>“””<br>filename:itcast.py<br>“””<br>import scrapy</p>
</blockquote>
<blockquote>
<p>class ItcastSpider(scrapy.Spider):</p>
<h1 id="爬虫名称"><a href="#爬虫名称" class="headerlink" title="爬虫名称"></a>爬虫名称</h1><p>   name &#x3D; ‘itcast’</p>
<h1 id="允许爬取的范围"><a href="#允许爬取的范围" class="headerlink" title="允许爬取的范围"></a>允许爬取的范围</h1><p>   allowed_domains &#x3D; [‘itcast.cn’]</p>
<h1 id="开始爬取的url地址"><a href="#开始爬取的url地址" class="headerlink" title="开始爬取的url地址"></a>开始爬取的url地址</h1><h1 id="start-urls-x3D-‘http-itcast-cn-39"><a href="#start-urls-x3D-‘http-itcast-cn-39" class="headerlink" title="start_urls &#x3D; [‘http://itcast.cn/&#39;]"></a>start_urls &#x3D; [‘<a href="http://itcast.cn/&#39;]">http://itcast.cn/&#39;]</a></h1><h1 id="修改开始爬取的地址"><a href="#修改开始爬取的地址" class="headerlink" title="修改开始爬取的地址"></a>修改开始爬取的地址</h1><p>   start_urls &#x3D; [‘<a href="http://www.itcast.cn/channel/teacher.shtml#ajavaee&#39;]">http://www.itcast.cn/channel/teacher.shtml#ajavaee&#39;]</a></p>
</blockquote>
<blockquote>
<h1 id="数据提取的方法，接受下载中间件传过来的response"><a href="#数据提取的方法，接受下载中间件传过来的response" class="headerlink" title="数据提取的方法，接受下载中间件传过来的response"></a>数据提取的方法，接受下载中间件传过来的response</h1><p>   def parse(self, response):<br>       #  获取所有教师节点<br>       node_list &#x3D; response.xpath(‘&#x2F;&#x2F;div[@class &#x3D; “li_txt”]’)<br>       # 遍历所有教师节点<br>       for  node   in   node_list:<br>           temp &#x3D; {}<br>           # xpath 方法返回的是选择器对象列表，<br>           # extract()用于从选择器兑现中提取数据<br>           #extract_first()  就不需要前面的索引[0],可能返回空列表可以处理，给None，列表只有一个值时使用<br>           temp[“name”] &#x3D; node.xpath(‘.&#x2F;h3&#x2F;text()’)[0].extract()<br>           temp[“title”] &#x3D; node.xpath(‘.&#x2F;h4&#x2F;text()’)[0].extract()<br>           temp[“desc”] &#x3D; node.xpath(‘.&#x2F;p&#x2F;text()’)[0].extract()<br>           # xpath 结果为只有一个值得列表可以使用extract_first()<br>           # xpath 结果如果有多个值时使用extract()<br>           yield  temp</p>
</blockquote>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><pre><code>* scrapy.Spider爬虫类中必须有名为parse的解析
* 如果网站结果层次比较负载，也可以自定义其他解析函数
* 在解析函数中提取的url地址如果要发送请求，则必须属于allowed_domains范围内，但是start_urls中的url地址不受这个限制，我们会在后续课程中学习如何在解析函数中构造发送请求
* 启动爬虫的时候注意启动的位置，是在项目路径下启动
* parse()函数中使用yield返回数据，注意：解析函数中的yield能够传递对象只能是：Baseltem，Request，dict，None
</code></pre>
<h4 id="5-2-定位元素以及提取数据、属性值的方法"><a href="#5-2-定位元素以及提取数据、属性值的方法" class="headerlink" title="5.2 定位元素以及提取数据、属性值的方法"></a>5.2 定位元素以及提取数据、属性值的方法</h4><blockquote>
<p>解析并获取scrapy爬虫中的数据，利用xpath规则字符串进行定位和提取<br>    1. response.xpath方法的返回结果是一个类似list的类型，其中包含的是selector对象，操作和列表一样<br>    2. 额外方法extract():返回一个包含字符串的列表<br>    3. 额外方法extract_first():返回列表中的第一个字符串，列表为空返回None</p>
</blockquote>
<h4 id="5-3-response响应对象的常见属性"><a href="#5-3-response响应对象的常见属性" class="headerlink" title="5.3 response响应对象的常见属性"></a>5.3 response响应对象的常见属性</h4><pre><code>* response.url：当前响应的url地址
* response.request.url：当前响应对应的请求的url地址
* response.headers：响应头
* response.requests.headers:当前响应的请求头
* response.body ：响应体，也就是html代码，byte类型
</code></pre>
<h3 id="7-运行scrapy"><a href="#7-运行scrapy" class="headerlink" title="7. 运行scrapy"></a>7. 运行scrapy</h3><h4 id="命令：在项目目录下执行scrapy-crawl-lt-爬虫名字-gt"><a href="#命令：在项目目录下执行scrapy-crawl-lt-爬虫名字-gt" class="headerlink" title="命令：在项目目录下执行scrapy crawl&lt;爬虫名字&gt;"></a>命令：在项目目录下执行scrapy crawl&lt;爬虫名字&gt;</h4><blockquote>
<p>scrapy crawl itcast</p>
</blockquote>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>01_爬虫技术</category>
        <category>scrapy框架</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebook安装（Windows）</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/03_python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/02_python%E6%8F%92%E4%BB%B6_jupyter/</url>
    <content><![CDATA[<p>Jupyter Notebook安装（Windows）</p>
<ol>
<li><p>下载Jupyter Notebook<br> （1）打开cmd（如果没有把Python安装目录添加到Path，就需要切换到Python安装目录的Scripts目录下，不过大多数的Python安装教程都会有这一步）；</p>
<p> <img src="/assets/2/image-20220521020425-aftpk03.png" alt="image.png"></p>
</li>
</ol>
<p>（2）输入pip install jupyter；</p>
<ol start="2">
<li><p>启动Juypter Notebook<br> （1）命令行窗口输入jupyter notebook；</p>
<p> <img src="/assets/2/image-20220521020437-ydugrs8.png" alt="image.png"></p>
</li>
</ol>
<p>同时，默认浏览器会打开Jupyter Notebook窗口，说明Jupyter Notebook安装成功。</p>
<p><img src="/assets/2/image-20220521020447-b4gi4oq.png" alt="image.png"></p>
<ol start="3">
<li><p>配置Jupyter Notebook<br> （1）命令行窗口输入jupyter notebook –generate-config，会发现C:\Users\用户名\ .jupyter下多出了一个配置文件jupyter_notebook_config.py；</p>
<p> <img src="/assets/2/image-20220521020459-2dhd2aa.png" alt="image.png"></p>
</li>
</ol>
<p>（2）打开这个配置文件，找到下面这句#c.NotebookApp.notebook_dir &#x3D; ‘’。</p>
<p><img src="/assets/2/image-20220521020506-0fcek2s.png" alt="image.png"></p>
<p>可以把它修改成c.NotebookApp.notebook_dir &#x3D; ‘D:\jupyter-notebook’，当然具体的目录由自己创建的文件夹决定（需要自己创建）。</p>
<p><img src="/assets/2/image-20220521020519-vll8ozo.png" alt="image.png"></p>
<p>配置文件修改完成后，以后在jupyter notebook中写的代码都会保存在该目录下。现在重新启动jupyter notebook，就进入了新的工作目录；</p>
<p><img src="/assets/2/image-20220521020528-wexy3m4.png" alt="image.png"></p>
<ol start="4">
<li>添加代码自动补全功能（可选）<br> （1）打开cmd，输入pip install jupyter_contrib_nbextensions，等待安装成功；</li>
</ol>
<p>（2）安装完之后需要配置nbextension（配置前要确保已关闭jupyter notebook），在cmd中输入jupyter contrib nbextension install –user –skip-running-check，等待配置成功；</p>
<p>（3）在前两步成功的情况下，启动jupyter notebook，会发现在选项栏中多出了Nbextension的选项，点开该选项，并勾选Hinterland，即可添加代码自动补全功能。</p>
<p><img src="/assets/2/image-20220521020535-pwhm2y0.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>03_python数据分析</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据分析入门实例-pandas_matplotlib</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/03_python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/01_pandas_matplotlib/</url>
    <content><![CDATA[<pre><code># 1. 读取csv文件道程序中，用一个合适的变量存储它
# 2. 清洗，处理
# 3. 可视化，画图
# 安装 第三方库   jupyter
# series  一维数据,dataframe  二维数据（csv）
# 打开jupyter服务
import pandas as pd
df = pd.read_csv(&quot;文件名.csv&quot;)  #  读取所有的数据
type(df)
# pandas.core.frame.DateFrame
df
# 表格文件
df.info()    # 文件属性

df.columns   # 获取所有的列名
# 删除无用列
del(df[&quot;需要删除的列名&quot;]) # 删除原数据   df.列名(列名不能包含空格)
dfhead()

# df.drop(删除一行或者一列) df.drop_duplicates(删除重复数据)  df.dropna(删除空白数据) 
# df.drop([&quot;列名1&quot;,&quot;列名2&quot;]，axis = 1,inplace = True)# 一列表的形式删除列    inplace 是否在原数据上执行

df.columns   # 获取所有的列名
df.columns = [要修改的列名]   # 修改列名

df.place #  假设此列为出版地
# 先分组，然后数每组有多少数据
count_df = df.groupby([&quot;place&quot;,&quot;date&quot;])    # 分组
place_count = count_df[&quot;Identifier&quot;].count()  # 统计
place_sorted = place_count.sort_values(ascending = False)    # False  降序   True  升序

# 数据可视化，画图
# 画什么图？？
# 趋势，规律  画线图
# 分布占比图  饼图
@matplotlib inline
import matplotlib.pyplot  as  plt

labels = place_sorted.index[:6]   #  取前六位
values = place_sorted.values[:6]  #  取前六位

plt.pie(calues,labels = labels,autopct=&quot;%.1f%%&quot;)
plt.axis(&quot;equal&quot;)




</code></pre>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>03_python数据分析</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python_tkinter_图形界面编程</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/02_python_tkinter/01_tkinter/</url>
    <content><![CDATA[<h2 id="系统登录"><a href="#系统登录" class="headerlink" title="系统登录"></a>系统登录</h2><pre><code># 安装  pip install tkinter
from tkinter import *
from tkinter import messagebox


window = TK()
window.title(&quot;灵犀教育管理系统&quot;)
window.geometry(&quot;300x300+400+400&quot;)

name_label = Lable(window,text = &quot;用户名&quot;)
pwd_label = Lable(window,text = &quot;密码&quot;)
name_entry=Entry(window)
pwd_entry = Entry(window,show = &quot;*&quot;)

uesrs = &#123;
    &quot;admin&quot;:&quot;123&quot;
&#125;

def login()
    # 获取用户名密码
    name=name_entry.get()
    pwd = pwd_entry.get()
    if name ==&quot;&quot;:
        messagebox.showerror(title= &quot;错误提示&quot;，message = &quot;用户名不能为空&quot;)
    elif pwd ==&quot;&quot;:
        messagebox.showerror(title= &quot;错误提示&quot;，message = &quot;密码不能为空&quot;)
    else:
        # 判断用户名是否存在，以及密码是否正确
        if useer.get(name) == pwd:
            messagebos.showinfo(title= &quot;提示&quot;，message = &quot;登陆成功&quot;)
        else:
            messagebox.showerror(title= &quot;错误提示&quot;，message = &quot;登陆失败&quot;)
            

login_btn = Button(window,text = &quot;登录&quot;，width = 8, command =login )

#name_label.pack()  #  pack 居中顺序排列
#pwd_label.pack()
#name_entry.pack()
#pwd_entry.pack()
#login_btn.pack()

# place(x,y)  #  详细位置布局

# grid 表格形式
name_label.grid(row = 0,column = 0,padx = 30,pady = 20)
name_entry.grid(row = 0,column = 1)
pwd_label.grid(row = 1,column = 0)
pwd_entry.grid(row = 1,column = 1)
login_btn.grid(row = 2,colimn = 1,pady = 20,stick = E)

window.mainloop()








</code></pre>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>02_python_tkinter</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python第三方库-scrapy爬虫框架</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/scrapy%E6%A1%86%E6%9E%B6/01_python_scrapy%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/">官方文档</a></h1><h2 id="爬虫原理"><a href="#爬虫原理" class="headerlink" title="爬虫原理"></a>爬虫原理</h2><h3 id="基础库的使用，"><a href="#基础库的使用，" class="headerlink" title="基础库的使用，"></a>基础库的使用，</h3><h3 id="进阶，"><a href="#进阶，" class="headerlink" title="进阶，"></a>进阶，</h3><h3 id="反爬虫，"><a href="#反爬虫，" class="headerlink" title="反爬虫，"></a>反爬虫，</h3><h3 id="单线程爬虫，"><a href="#单线程爬虫，" class="headerlink" title="单线程爬虫，"></a>单线程爬虫，</h3><h3 id="多线程爬虫，"><a href="#多线程爬虫，" class="headerlink" title="多线程爬虫，"></a>多线程爬虫，</h3><h3 id="scrapy（异步并发），"><a href="#scrapy（异步并发），" class="headerlink" title="scrapy（异步并发），"></a>scrapy（异步并发），</h3><h3 id="分布式爬虫"><a href="#分布式爬虫" class="headerlink" title="分布式爬虫"></a>分布式爬虫</h3><h2 id="框架："><a href="#框架：" class="headerlink" title="框架："></a>框架：</h2><h3 id="抓取，解析，保存"><a href="#抓取，解析，保存" class="headerlink" title="抓取，解析，保存"></a>抓取，解析，保存</h3><h3 id="域名，ip地址"><a href="#域名，ip地址" class="headerlink" title="域名，ip地址"></a>域名，ip地址</h3><h4 id="1-scrapy-异步并发-安装第三方库：pip-install-scrapy"><a href="#1-scrapy-异步并发-安装第三方库：pip-install-scrapy" class="headerlink" title="1. scrapy__异步并发 安装第三方库：pip install scrapy"></a>1. scrapy__异步并发 安装第三方库：pip install scrapy</h4><p>cmd 进入空白文件 通过scrapy 创建框架<br>    命令： </p>
<blockquote>
<p>scrapy startproject demo0520_scrapy（文件名,项目的名字）  回车<br><img src="/assets/2/20220520_1.jpg"><br>cd  demo0520_scrapy<br><img src="/assets/2/20220520_2.jpg"><br><img src="/assets/2/20220520_3.jpg"><br>scrapy genspider  movies（爬虫的类型，爬虫的名字） donban.com（域名）  # 需要加两个参数<br><img src="/assets/2/20220520_4.jpg"></p>
</blockquote>
<ol start="2">
<li>打开pycharm<br> 打开项目：  项目位置</li>
</ol>
<p><img src="/assets/2/scrapy1.jpg"></p>
<ol start="3">
<li>运行爬虫<br> 进入项目文件—&gt;&gt;&gt; cmd 或者pycharm 控制台<br> 输入 scrapy  crawl movies（爬虫的名字）</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>01_爬虫技术</category>
        <category>scrapy框架</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用编码_整理</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/02_python%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<pre><code># 去掉web页面自动化提醒标识- 自动化标识
from selenium.webdriver.chrome.options import Option
option = Options()
option.add_experimental_option(&#39;excludeSwitches&#39;,[&#39;enable-automation&#39;])
option.add_argument(&#39;--disable-blink-features-AutomationControlled&#39;)
driver = webdriver.Chrome(options=option)
</code></pre>
<pre><code># 关掉密码弹窗
from selenium.webdriver.chrome.options import Option
prefs = &#123;&#125;
prefs[&#39;credentials_enable_service&#39;] = False
prefs[&#39;profile.password_manger_enabled&#39;] = False
option.add_experimental_option(&#39;prefs&#39;,prefs)
</code></pre>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>01_爬虫技术</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>测试高阶</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<ul>
<li>爬虫技术接单平台<ul>
<li><a href="https://www.jfh.com/serviceProvider.html">解放号</a></li>
<li><a href="https://www.yuanjisong.com/job">猿急送</a></li>
<li><a href="https://www.proginn.com/?loginbox=show">程序员客栈</a></li>
<li><a href="https://codemart.com/">码市</a></li>
<li><a href="http://rrkf.com/">人人开发</a></li>
<li><a href="https://task.zbj.com/">猪八戒</a></li>
<li><a href="https://task.epwk.com/task/">一品威客</a></li>
<li><a href="https://zb.oschina.net/projects/list.html">开源众包</a></li>
<li><a href="https://www.taskcity.com/">智城外包网</a></li>
<li><a href="https://shixian.com/cases">实现网</a></li>
<li><a href="https://eleduck.com/categories/6/tags/0-18">电鸭社区</a></li>
<li><a href="https://remoteok.com/">Remoteok</a></li>
<li><a href="https://www.toptal.com/">Toptal</a></li>
<li><a href="https://angel.co/">AngelList</a></li>
<li><a href="https://www.yingxuan.io/">英选</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>03_测试高阶</category>
        <category>01_爬虫技术</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python+requests+pytest接口自动化</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/02_API%E8%87%AA%E5%8A%A8%E5%8C%96/api%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6/03_python+requests+pytest%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[<p>1、发送get请求</p>
<blockquote>
<p>#导包<br>import requests<br>#定义一个urlurl &#x3D; “<a href="http://xxxxxxx&quot;/">http://xxxxxxx&quot;</a><br>#传递参数payload&#x3D;”{&quot;head&quot;:{&quot;accessToken&quot;:&quot;&quot;,&quot;lastnotice&quot;:0,&quot;msgid&quot;:&quot;&quot;},&quot;body&quot;:{&quot;user_name&quot;:&quot;super_admin&quot;,&quot;password&quot;:&quot;b50c34503a97e7d0d44c38f72d2e91ad&quot;,&quot;role_type&quot;:1}}”<br>headers &#x3D; {‘Content-Type’: ‘text&#x2F;plain’,<br>‘Cookie’: ‘akpsysessionid&#x3D;bafc0ad457d5a99f3a4e53a1d4b32519’<br>}#发送get请求r &#x3D; requests.get( url&#x3D;url,headers&#x3D;headers, data&#x3D;payload)#打印结果print(r.text)<br>#解码print(r.encoding)<br>print(r.text.encode(‘utf-8’).decode(‘unicode_escape’))#先把返回的结果转换成utf-8，再去解码成中文的编码</p>
</blockquote>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p>2、发送post请求</p>
<blockquote>
<p>#导包<br>import requests<br>#定义一个urlurl &#x3D; “<a href="http://xxxxxxx&quot;/">http://xxxxxxx&quot;</a><br>#传递参数payload&#x3D;”{&quot;head&quot;:{&quot;accessToken&quot;:&quot;&quot;,&quot;lastnotice&quot;:0,&quot;msgid&quot;:&quot;&quot;},&quot;body&quot;:{&quot;user_name&quot;:&quot;super_admin&quot;,&quot;password&quot;:&quot;b50c34503a97e7d0d44c38f72d2e91ad&quot;,&quot;role_type&quot;:1}}”<br>headers &#x3D; {‘Content-Type’: ‘text&#x2F;plain’,<br>‘Cookie’: ‘akpsysessionid&#x3D;bafc0ad457d5a99f3a4e53a1d4b32519’<br>}#发送post请求r &#x3D; requests.post( url&#x3D;url,headers&#x3D;headers, data&#x3D;payload)#打印结果print(r.text)</p>
</blockquote>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><p>3、发送https请求</p>
<blockquote>
<p>import requests<br>url&#x3D;’<a href="https://www.ctrip.com/&#39;">https://www.ctrip.com/&#39;</a><br>#第一种解决方案，发送请求的时候忽略证书，证书的参数verify用的比较多r&#x3D;requests.post(url&#x3D;url,verify&#x3D;False)#verify参数默认为True，值为False，表示忽略证书#第二张解决方案，verify里面添加证书的路径r&#x3D;requests.post(url&#x3D;url,verify&#x3D;’证书的路径’)#verify参数默认为True，值为False，表示忽略证书<br>print(r.text)</p>
</blockquote>
<p>4、文件上传</p>
<blockquote>
<p>import requests<br>file &#x3D; {‘filename’:open(‘文件名称’,’rb’)<br>}response &#x3D; requests.post(“网址”,file)<br>print(response.text)</p>
</blockquote>
<p>5、文件下载</p>
<blockquote>
<p>#小文件下载<br>import requests<br>r &#x3D; requests.get(“<a href="https://img.sitven.cn/Tencent_blog_detail.jpg&quot;">https://img.sitven.cn/Tencent_blog_detail.jpg&quot;</a>)<br>with open(r”D:\a.jpg”, “wb”) as f:<br>f.write(r.content)#大文件下载import requests<br>def test_downloads(url, file):s &#x3D; requests.sessionr &#x3D; s.get(url, stream&#x3D;True, verify&#x3D;False)<br>with open(file, “wb”) as f:<br>for chunk in r.iter_content(chunk_size&#x3D;512):<br>f.write(chunk)if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>url &#x3D; “<a href="https://www.url.com/test/export&quot;">https://www.url.com/test/export&quot;</a><br>file &#x3D; “D:\a.xlsx”<br>test_downloads(url&#x3D;url, file&#x3D;file)#转载至：<a href="https://blog.csdn.net/weixin_43507959/article/details/107326912">https://blog.csdn.net/weixin_43507959/article/details/107326912</a></p>
</blockquote>
<p>6、timeout超时</p>
<blockquote>
<p>#导包<br>import requests<br>#循环10次<br>for i in range(0,10):<br>try:url&#x3D;”<a href="http://xxxxxxxxxxxxxxxx&quot;/">http://xxxxxxxxxxxxxxxx&quot;</a><br>data&#x3D;{“head”:{“lastnotice”:0,”msgid”:””,”accessToken”:”89a08bff-15d7-4d7a-9967-0b5f4fb699ce”},<br>“body”:{“clinicid”:”978f661e-1782-43bd-8675-b0ff1138ab7c”,”deptid”:”09b8515b-b01b-4771-9356-aed6b5aa01bf”,”doctorid”:”65ac0251-10ff-473a-af8a-20e8969176f7”,”registtype”:0,”card_num”:””,”bcc334”:””,”patientopt”:1,”bkc368”:”1”,”patient”:{“cardid”:””,”medicalcardid”:””,”label”:””,”sourcetype”:1,”nationid”:”01”,”maritalstatus”:0,”address”:””,”company”:””,”jobname”:””,”email”:””,”remark”:””,”bcc334”:””,”name”:”11”,”gender”:1,”phone”:””,”birthdate”:”2020-03-23”,”patienttype”:1,”szsbcardid”:””}}<br>}#发送post请求，超时时间0.03s<br>r&#x3D;requests.post(url&#x3D;url,json&#x3D;data,timeout&#x3D;0.03)<br>print(r.text)<br>print(r.cookies)<br>except:print(‘error’)<br>#可参考：<a href="https://blog.csdn.net/weixin_44350337/article/details/99655387">https://blog.csdn.net/weixin_44350337/article/details/99655387</a></p>
</blockquote>
<p>7、鉴权<br>7.1 auth参数鉴权</p>
<blockquote>
<p>import requests<br>url &#x3D; ‘<a href="http://192.168.1.1&/#39;">http://192.168.1.1&#39;</a><br>headers &#x3D; {} # 有的不带头也能请求到 不带头可以忽略这行 和headers&#x3D;headers,这两处r &#x3D; requests.get(url, auth&#x3D;(‘admin’, ‘123456’), headers&#x3D;headers, timeout&#x3D;10)<br>print(r.text)</p>
</blockquote>
<p>7.2 session操作</p>
<blockquote>
<p>#实例化session<br>session &#x3D; requests.session<br>#使用session发起请求<br>response &#x3D; session.post(url,headers&#x3D;req_header,data&#x3D;form_data)</p>
</blockquote>
<p>7.3 token操作</p>
<blockquote>
<p>import requests<br>url&#x3D;”<a href="http://xxxxxxxxxxxxxxx&quot;/">http://xxxxxxxxxxxxxxx&quot;</a><br>json&#x3D;{“head”:{“accessToken”:””,”lastnotice”:0,”msgid”:””},<br>“body”:{“username”:”15623720880”,”password”:”48028d2558577c526a017883211b4066”,”forceLogin”:0}<br>}r&#x3D;requests.post(url&#x3D;url,json&#x3D;json)print(r.text)<br>print(r.cookies)<br>#登录成功后返回token，带入下一个接口for i in range(0,1):<br>try:url&#x3D;”xxxxxxxxxxxxxxxxxx”<br>data&#x3D;{“head”:{“lastnotice”:0,”msgid”:””,”accessToken”:”89a08bff-15d7-4d7a-9967-0b5f4fb699ce”},<br>“body”:{“clinicid”:”978f661e-1782-43bd-8675-b0ff1138ab7c”,”deptid”:”09b8515b-b01b-4771-9356-aed6b5aa01bf”,”doctorid”:”65ac0251-10ff-473a-af8a-20e8969176f7”,”registtype”:0,”card_num”:””,”bcc334”:””,”patientopt”:1,”bkc368”:”1”,”patient”:{“cardid”:””,”medicalcardid”:””,”label”:””,”sourcetype”:1,”nationid”:”01”,”maritalstatus”:0,”address”:””,”company”:””,”jobname”:””,”email”:””,”remark”:””,”bcc334”:””,”name”:”11”,”gender”:1,”phone”:””,”birthdate”:”2020-03-23”,”patienttype”:1,”szsbcardid”:””}}<br>}r&#x3D;requests.post(url&#x3D;url,json&#x3D;data,timeout&#x3D;0.09)<br>print(r.text)<br>print(r.cookies)<br>except:print(‘error’)</p>
</blockquote>
<p>7.4 sign签名</p>
<blockquote>
<p>appid：wxd930ea5d5a258f4f</p>
<p>mch_id：10000100</p>
<p>device_info：1000</p>
<p>body：test</p>
<p>nonce_str：ibuaiVcKdpRxkhJA</p>
<p>import hashlib<br>#需要加密的字符串<br>stringA&#x3D;”appid&#x3D;wxd930ea5d5a258f4f&amp;body&#x3D;test&amp;device_info&#x3D;1000&amp;mch_id&#x3D;10000100&amp;nonce_str&#x3D;ibuaiVcKdpRxkhJA”;<br>#构建一个对象为md<br>md&#x3D;hashlib.md5<br>#对stringA字符串进行编码<br>md.update(stringA.encode)<br>#生成后的加密值<br>AES&#x3D;md.hexdigest<br>#把加密的结果，小写转大写 upper函数<br>AES&#x3D;AES.upper<br>print(AES)<br>参考微信支付：<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3#">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3#</a></p>
</blockquote>
<h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><p>8、自动化模块划分<br>config 配置文件（python package）#directory和python package大同小异</p>
<p>common 公共的方法（python package）</p>
<p>testdata 测试数据（python package）</p>
<p>test_case测试用例（python package）</p>
<p>report 报告（directory）</p>
<p>run_case 测试执行（python package）</p>
<p>log 日志</p>
<p><img src="/assets/2/image-20220516205752-38m0prz.png" alt="image.png"></p>
<p>8.1 config配置文件</p>
<blockquote>
<p>def server_ip:<br>‘’’<br>ait_ip&#x3D;’’开发环境的服务器ip<br>sit_ip&#x3D;’’测试环境的服务器ip<br>:return: 返回不同服务器的地址<br>‘’’<br>server_add&#x3D;{‘dev_ip’ : ‘<a href="http://his.xxxxxxxxxxx.com&/#39;">http://his.xxxxxxxxxxx.com&#39;</a>,<br>‘sit_ip’ : ‘<a href="http://his.xxxxxxxxxxxx.comm&/#39;">http://his.xxxxxxxxxxxx.comm&#39;</a><br>}return server_add[‘dev_ip’]<br>————————————————————————————def sql_conf:<br>‘’’<br>host数据库ip<br>user数据库用户名<br>password数据库密码<br>database:连接数据库名<br>port数据库端口<br>chrset数据库字符集 中文utf-8<br>:return:<br>‘’’<br>host&#x3D;’localhost’<br>user&#x3D;’root’<br>password&#x3D;’123456’<br>database&#x3D;’mysql’<br>port&#x3D;3306<br>charset&#x3D;’utf8’ #这用utf8，utf-8会报错<br>return host,user,password,database,port,charset</p>
</blockquote>
<p>8.2 common 公共的方法</p>
<blockquote>
<p>封装一个读取Excel表格数据的函数</p>
<p>对Excel表格数据的读取需要用到一个库——xlrd库import xlrd</p>
<p>def get_excel_value(i):’’’<br>读取表中一行的数据<br>:return:返回2，3行数据<br>‘’’<br>filename &#x3D; r”..&#x2F;testdata&#x2F;jiekou.xls” #文件要用相对路径<br>book &#x3D; xlrd.open_workbook(filename) # 打开一个工作薄，不需要手动进行关闭# sheet &#x3D; book.sheet_by_name(“Sheet1”) 根据工作表的名字，获取一个工作表对象<br>sheet &#x3D; book.sheet_by_index(0) # 获取一个工作表，以index的方式，这里是获取第1个工作表<br>return sheet.cell_value(i,1),sheet.cell_value(i,2)</p>
<p>print(sheet.nrows) #打印所有行</p>
<p>print(sheet.ncols) #打印所有列</p>
<p>print(sheet.row_values(0)) #打印第一行</p>
<p>print(sheet.col_values(0)) #打印第一列</p>
<p>print(sheet.cell_value(0,1)) #打印第一行，第二列</p>
<p>for i in range(1, sheet.nrows):</p>
<p>print(sheet.cell_value(i,1),sheet.cell_value(i,2))# 打印单元格[所有数据]的值</p>
<p>str&#x3D;’(sheet.cell_value(i,1),sheet.cell_value(i,2)))’</p>
<p>print(str)</p>
<p>for i in range(1, sheet.nrows):</p>
<h1 id="for-j-in-range-0-sheet-ncols"><a href="#for-j-in-range-0-sheet-ncols" class="headerlink" title="for j in range(0, sheet.ncols):"></a>for j in range(0, sheet.ncols):</h1><p>print(sheet.cell_value(i,j)) # 打印单元格[i,j]的值</p>
<p>———————————————————————————————import pymysql<br>from config.sql_conf import *<br>def get_sql(sql):’’’<br>:param sql:运行查询的sql语句<br>:return:数据库查询结果<br>‘’’<br>#建立一个连接对象host, user, password, database, port, charset&#x3D;sql_confdb&#x3D;pymysql.connect(host&#x3D;host,user&#x3D;user,password&#x3D;password,database&#x3D;database,port&#x3D;port,charset&#x3D;charset)#建立一个游标cursor&#x3D;db.cursor#执行sql语句cursor.execute(sql)#把sql运行的数据保存在data变量里面data&#x3D;cursor.fetchall #获取查询出的所有的值cursor.close #关闭游标<br>db.close #关闭数据库连接<br>return data</p>
<p>print(get_sql(“SELECT help_topic_id FROM help_topic WHERE Name&#x3D;’MOD’”)) #执行sql语句</p>
<p>print(type(get_sql(“SELECT help_topic_id FROM help_topic WHERE Name&#x3D;’MOD’”)))</p>
</blockquote>
<p>8.3 estdata 测试数据</p>
<p>主要存放xls，txt，csv测试数据</p>
<p><img src="/assets/2/image-20220516210004-huegsxl.png" alt="image.png"></p>
<p>8.4 test_case测试用例</p>
<blockquote>
<p>from common.get_mysql import get_sql<br>from config.cof import server_ip<br>from common.get_excel import *from config.sql_conf import *<br>import requests# user_id&#x3D;get_sql(“SELECT help_topic_id FROM help_topic WHERE Name&#x3D;’MOD’”)#提取数据库数据</p>
<p>print(user_id)#打印结果</p>
<p>assert get_sql(“SELECT help_topic_id FROM help_topic WHERE Name&#x3D;’MOD’”)#断言数据库的数据是否存在</p>
<p>def test_aokao_login:url&#x3D;server_ip+’&#x2F;service&#x2F;user&#x2F;login’<br>username,password&#x3D;get_excel_value(1) #读取文件第二行数据<br>json&#x3D;{“head”:{“accessToken”:””,”lastnotice”:0,”msgid”:””},<br>“body”:{“username”:username,”password”:password,”forceLogin”:0}<br>}# usernamepassword&#x3D;get_excel_value(4)[0] #读取文件第二行数据</p>
<p>print(type(usernamepassword))</p>
<p>#把str类型转为字典格式 eval 函数# json&#x3D;eval(usernamepassword)r&#x3D;requests.post(url&#x3D;url,json&#x3D;json)print(r.text)</p>
<p>assert r.status_code&#x3D;&#x3D;200 #断言状态码是否等于200<br>assert ‘“accessToken”:”89a08bff-15d7-4d7a-9967-0b5f4fb699ce”,’ in r.text #断言返回信息是否包含accesstoken<br>def test_aokao_registadd:url &#x3D; server_ip+’&#x2F;service&#x2F;registration&#x2F;registadd’<br>data &#x3D; {“head”: {“lastnotice”: 0, “msgid”: “”, “accessToken”: “89a08bff-15d7-4d7a-9967-0b5f4fb699ce”},<br>“body”: {“clinicid”: “978f661e-1782-43bd-8675-b0ff1138ab7c”, “deptid”: “09b8515b-b01b-4771-9356-aed6b5aa01bf”,<br>“doctorid”: “65ac0251-10ff-473a-af8a-20e8969176f7”, “registtype”: 0, “card_num”: “”, “bcc334”: “”,<br>“patientopt”: 1, “bkc368”: “1”,<br>“patient”: {“cardid”: “”, “medicalcardid”: “”, “label”: “”, “sourcetype”: 1, “nationid”: “01”,<br>“maritalstatus”: 0, “address”: “”, “company”: “”, “jobname”: “”, “email”: “”,<br>“remark”: “”, “bcc334”: “”, “name”: “11”, “gender”: 1, “phone”: “”,<br>“birthdate”: “2020-03-23”, “patienttype”: 1, “szsbcardid”: “”}}<br>}r &#x3D; requests.post(url&#x3D;url, json&#x3D;data, timeout&#x3D;0.09)<br>print(r.text)<br>print(r.cookies)<br>assert r.status_code &#x3D;&#x3D; 200 # 断言状态码是否等于200</p>
</blockquote>
<p>8.5 report 报告</p>
<p>主要存放html，xml报告</p>
<p><img src="/assets/2/image-20220516210059-45ve97t.png" alt="image.png"></p>
<p>8.6 run_case 测试执行</p>
<blockquote>
<p>import pytest<br>‘’’<br>测试文件以test_开头，（以—_test结尾也可以）<br>测试类以Test开头，并且不能带有init 方法<br>测试函数以test_开头<br>断言使用基本的assert即可<br>‘’’<br>#如何去运行测试用例，_test开头的函数就可以，判断用例运行是否成功，assert断言if <strong>name</strong>&#x3D;&#x3D;”<strong>main</strong>“:<br>#单个文件运行，运行添加，对应的文件路径，路径要用相对路径# pytest.main([‘..&#x2F;test_case&#x2F;&#x2F;test_case_01.py’])<br>#多个文件运行，运行添加多个对应的文件路径，列表的形式，去添加多个文件的路径# pytest.main([‘..&#x2F;test_case&#x2F;test_fore.py’,’..&#x2F;test_case&#x2F;Dynamic correlation_token.py’])<br>#运行整个目录，添加目录的路径pytest.main([‘..&#x2F;test_case&#x2F;‘,’–html&#x3D;..&#x2F;report&#x2F;report.html’,’–junitxml&#x3D;..&#x2F;report&#x2F;report.xml’])<br>‘’’<br>pytest生成报告：<br>1、生成html报告<br>‘–html&#x3D;..&#x2F;report&#x2F;report.html’<br>2、生成xml报告<br>‘–junitxml&#x3D;..&#x2F;report&#x2F;report.xml’<br>‘’’</p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>02_API自动化</category>
        <category>api自动化框架</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>测试面试题精选【拼多多二面】</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/09_%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89%E3%80%90%E6%8B%BC%E5%A4%9A%E5%A4%9A%E4%BA%8C%E9%9D%A2%E3%80%91/</url>
    <content><![CDATA[<p>面试一般分为技术面和hr面，形式的话很少有群面，少部分企业可能会有一个交叉面，不过总的来说，技术面基本就是考察你的专业技术水平的，hr面的话主要是看这个人的综合素质以及家庭情况符不符合公司要求，一般来讲，技术的话只要通过了技术面hr面基本上是没有问题（也有少数企业hr面会刷很多人）</p>
<p><img src="/assets/2/image-20220516203639-zpdniqr.png" alt="image.png"></p>
<p>我们主要来说技术面，技术面的话主要是考察专业技术知识和水平，下面是我们整理好的自动化测试岗的面试题。</p>
<p>1.如何把自动化测试在公司中实施并推广起来的？<br>1.项目组调研选择自动化工具并开会演示demo案例，我们主要是演示selenium和robotframework两种。</p>
<p>2.搭建自动化测试框架，在项目中逐步开展自动化。</p>
<p>3.把该项目的自动化流程、框架固化成文档</p>
<p>4.推广到公司的其它项目组应用</p>
<p>2.请描述一下自动化测试流程？<br>1.编写自动化测试计划</p>
<p>2.设计自动化测试用例</p>
<p>3.编写自动化测试框架和脚本</p>
<p>4.调试并维护脚本</p>
<p>5.无人值守测试</p>
<p>6.后期脚本维护（添加用例、开发更新版本）</p>
<p>3.自动化测试用例如何编写？以下答案二选一即可：<br>1.用例是自动化测试工程师自己设计的，一般刚开始已基本业务流程为主（登录–完成一个业务–退出）</p>
<p>2.从系统测试用例中进行筛选或由业务工程师提供</p>
<p>4.上一个项目中自动化测试的执行策略？<br>上一个项目中是定时执行的，设置的执行时间是晚上12点，执行完毕后会自动发送邮件通知</p>
<p>5.自动化测试发现BUG多吗？<br>不多，因为之前项目组是把已经测试通过的基本功能再进行自动化脚本编写和在后续版本执行自动化测试，它主要是保证已经测试通过的功能在新版本更新后没有问题。</p>
<p>6.你觉得自动化测试的价值在哪里？你们公司为什么要做自动化测试？<br>引用自动化测试之后，能代替大量繁琐的回归测试工作，把业务测试人员解放出来，既而让业务测试人员把精力集中在复杂的业务功能模块上，自动化测试一般是对稳定下来的功能进行自动化，保证不会因为产品的更新导致之前稳定下来的功能出现BUG</p>
<p>7.自动化测试有误报过bug吗？产生误报怎么办？<br>有误报过，有时候自动化测试报告中显示发现了bug,实际去通过手工测试去确认又不存在该bug。</p>
<p>误报原因一般是：</p>
<p>1.元素定位不稳定，需要尽量提高脚本的稳定性；</p>
<p>2.开发更新了页面但是测试没有及时更新维护!</p>
<p>8.自动化测试过程中，你遇到了哪些问题，是如何解决的？<br>1.频繁地变更页面，经常要修改页面对象类里面的代码</p>
<p>2.自动化测试偶尔出现过误报</p>
<p>3.自动化测试结果出现覆盖的情况：Jenkins根据时间建立文件夹</p>
<p>4.自动化测试代码维护比较麻烦</p>
<p>5.自动化测试进行数据库对比数据</p>
<p>9.在上一家公司做自动化测试用的什么框架？<br>可以说出以下自己擅长的一种：</p>
<p>1.python+selenium+unittest+htmltestrunner</p>
<p>2.python+selenium+pytest+allure</p>
<p>robotframework+Selenium3<br>10.在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？<br>主要是冒烟测试和回归测试。回归测试主要写一些功能稳定的场景，通过自动化手段去实现，节约测试时间。因为自动化测试用例也是在不断的更新和迭代，没有刻意去统计，大概在30%-40%左右！</p>
<p>11.在执行脚本过程，如何实现当前元素高亮显示？<br>这个其实就是利用javaScript去修改当前元素的边框样式来到达高亮显示的效果，</p>
<p>12.如果一个元素无法定位，你一般会考虑哪些方面的原因？<br>1.页面加载元素过慢，加等待时间</p>
<p>2.页面有frame框架页，需要先跳转入frame框架再定位</p>
<p>3.可能该元素是动态元素，定位方式要优化，可以使用部分元素定位或通过父节点或兄弟节点定位。</p>
<p>4.可能识别了元素，但是不能操作，比如元素不可用，不可写等。需要使用js先把前置的操作完成，</p>
<p>13.元素定位方法你熟悉的有哪些？（八大元素定位方式）<br>id ，name， class， tag， link_text， Partial link text， css， xpath</p>
<p>14.遇到frame框架页面怎么处理？<br>先用driver.switch_to.frame()跳转进去frame，</p>
<p>然后再操作页面元素，</p>
<p>操作完后使用driver.swith_to.default_content()跳转出来</p>
<p>15.遇到alert弹出窗如何处理？<br>使用driver.switch_to.alert方法先跳转到alert弹出窗口</p>
<p>然后再通过accept点击确定按钮，通过dismiss点击取消难，通过text()获得弹出窗口的文本。</p>
<p>16.如何处理多窗口？<br>这个多窗口之间跳转处理，我们在项目中也经常遇到。就是，当你点击一个链接，这个链接会在一个新的tab打开，然后你接下来要在新tab打开的页面查找元素，</p>
<p>1.我们在点击链接前使用driver.current_window_handle获得当前窗口句柄。</p>
<p>2.再点击链接。点击后通过driver.window_handles获得所有窗口的句柄，</p>
<p>3.然后再循环找到新窗口的句柄，然后再通过driver.switch_to.window()方法跳转到新的窗口。</p>
<p>17.怎么验证元素是enable&#x2F;disabled&#x2F;checked状态？<br>定位元素后：分别通过isEnabled()，isSelected()，isDisplayed()三个方法进行判断。</p>
<p>18.如何处理下拉菜单？<br>在Selenium中有一个叫Select的类，这个类支持对下拉菜单进行操作。使用方法如下：</p>
<p>1.定位元素</p>
<p>2.把定位的元素转化成Select对象。</p>
<p>sel &#x3D; Select(定位的元素对象)</p>
<p>3.通过下标或者值或者文本选中下拉框。</p>
<p>sel.select_by_index(index);<br>sel.select_by_value(value);<br>sel.select_by_visible_text(text);</p>
<p>19.在日历这种web 表单你是如何处理的?<br>首先要分析当前网页试用日历插件的前端代码，看看能不能通过元素定位，点击日期实现，如果不能，可能需要借助javascript。还有些日历控件一个文本输入框，可以直接sendKeys()方法来实现传入一个时间的数据。</p>
<p>20.举例一下说明一下你遇到过那些异常<br>常见的selenium异常有这些：</p>
<p>NoSuchElementException：没有该元素异常<br>TimeoutException ：超时异常</p>
<p>ElementNotVisibleException ：元素不可见异常<br>NoSuchAttributeException ：没有这样属性异常<br>NoSuchFrameException ：没有该frame异常</p>
<p>21.关闭浏览器中quit和close的区别<br>简单来说，两个都可以实现退出浏览器session功能，close是关闭你当前聚焦的tab页面，而quit是关闭全部浏览器tab页面，并退出浏览器session。知道这两个区别，我们就知道quit一般用在结束测试之前的操作，close用在执行用例过程中关闭某一个页面的操作。</p>
<p>22.在Selenium中如何实现截图，如何实现用例执行失败才截图<br>在Selenium中提供了一个get_screenshot_as_file()的方法来截图的，一般结合try&#x2F;except捕获异常时使用，进行错误截图。</p>
<p>23.如何实现文件上传？<br>定位元素后，直接使用send_keys()方法设置就行，参数为需要上传的文件的路径。</p>
<p>24.自动化中有哪三类等待？他们有什么特点？<br>1.线程等待（强制等待）如time.sleep(2)：线程强制休眠2秒钟，2秒过后，再执行后续的代码。建议少用。</p>
<p>2.imlicitlyWait（隐式等待）会在指定的时间范围内不断的查找元素，直到找到元素或超时，特点是必须等待整个页面加载完成。</p>
<p>3.WebDriverWait（显式等待）通常是我们自定义的一个函数代码，这段代码用来等待某个元素加载完成，再继续执行后续的代码</p>
<p>25.你写的测试脚本能在不同浏览器上运行吗<br>当然可以，我写的用例可以在在IE，火狐和谷歌这三种浏览器上运行。实现的思路是封装一个方法，分别传入一个浏览器的字符串，如果传入IE就使用IE，如果传入FireFox就使用FireFox，如果传入Chrome就使用Chrome浏览器，并且使用什么浏览器可以在总的ini配置文件中进行配置。需要注意的是每个浏览器使用的驱动不一样。</p>
<p>26.什么是PO模式，为什么要使用它<br>PO是Page Object 模式的简称，它是一种设计思想，意思是，把一个页面，当做一个对象，页面的元素和元素之间操作方法就是页面对象的属性和行为，PO模式一般使用三层架构，分别为：基础封装层BasePage，PO页面对象层，TestCase测试用例层。</p>
<p>27.你会封装自动化测试框架吗？<br>这个问得最多，甚至有很多公司直接卸载招聘要求中</p>
<p>当然可以，自动化框架主要的核心框架就是分层+PO模式：分别为：基础封装层BasePage，PO页面对象层，TestCase测试用例层。然后再加上日志处理模块，ini配置文件读取模块，unittest+ddt数据驱动模块，jenkins持续集成模式组成。</p>
<p>28.你们测试团队如何提升自己的测试技能？<br>更多是靠技术讨论和学习交流，除了我们公司内部群之外，我们还会有相关的技术交流群，可以和跟很多同行一起学习，完善自己的技能树。IT行业技术更新迭代本来就很快，所以更需要保持学习的心态。</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>从未听过的10个软件测试面试问题</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/07_%E4%BB%8E%E6%9C%AA%E5%90%AC%E8%BF%87%E7%9A%8410%E4%B8%AA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%20-%20%E5%89%AF%E6%9C%AC%20(2)/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础题目大全</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/08_Python%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><img src="/assets/2/image-20220516203117-m9jj2bk.png" alt="image.png"></p>
<p>1、为什么学习Python？<br>人生苦短？人间不值得？想想自己的初心吧！</p>
<p>2、通过什么途径学习的Python？<br>官网、网上视频、学习网站、论坛、大牛的辅导</p>
<p>3、Python和Java、PHP、C、C#、C++等其他语言的对比？<br>（1）、python代码，简介，明确，优雅，简单易懂<br>（2）、开发效率高<br>（3）、可扩展性强</p>
<p>4、简述解释型和编译型编程语言？<br>解释型：在执行程序时，计算机才一条一条的将代码解释成机器语言给计算机来执行<br>编译型：是把源程序的每一条语句都编译成机器语言，并保存成二进制文件，这样计算机运行该程序时可以直接以机器语言来运行此程序，运行速度很快。</p>
<p>5、Python解释器种类以及特点？<br>Cpython，IPython，Jpython，pypy，Ironpython</p>
<p>Python是一门解释器语言，代码想运行，必须通过解释器执行，Python存在多种解释器，分别基于不同语言开发，每个解释器有不同的特点，但都能正常运行Python代码，以下是常用的五种Python解释器：</p>
<p>CPython：当 从Python官方网站下载并安装好Python2.7后，就直接获得了一个官方版本的解</p>
<blockquote>
<p>释器：Cpython，这个解释器是用C语言开发的，所以叫 CPython，在命名行下运行python，<br>就是启动CPython解释器，CPython是使用最广的Python解释器。</p>
</blockquote>
<p>IPython：IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方</p>
<blockquote>
<p>式上有所增强，但是执行Python代码的功能和CPython是完全一样的，好比很多国产浏览器<br>虽然外观不同，但内核其实是调用了IE。</p>
</blockquote>
<p>PyPy：PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，</p>
<blockquote>
<p>对Python代进行动态编译，所以可以显著提高<br>Python代码的执行速度。</p>
</blockquote>
<p>Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。<br>IronPython：IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，</p>
<blockquote>
<p>可以直接把Python代码编译成.Net的字节码。</p>
</blockquote>
<p>在Python的解释器中，使用广泛的是CPython，对于Python的编译，除了可以采用以上解释器<br>进行编译外，技术高超的开发者还可以按照自己的需求自行编写Python解释器来执行Python代码，十分的方便！</p>
<p>6、位和字节的关系？<br>一个字节&#x3D;8位</p>
<p>7、b、B、KB、MB、GB 的关系？<br>1B(字节) &#x3D; 8b(位)<br>1KB &#x3D; 1024B<br>1MB &#x3D; 1024KB<br>1GB &#x3D; 1024MB</p>
<p>8、请至少列举5个 PEP8 规范<br>（1）、缩进：每一级4个缩进。连续跨行应该使用圆括号或大括号或者使用悬挂缩进。<br>（2）、代码长度约束</p>
<p>一行列数：PEP8 规定最大为79列，如果拼接url很容易超限<br>一个函数：不可以超过30行；直观来讲就是完整显示一个函数一个屏幕就够了，不需要上下拖动<br>一个类：不要超过200行代码，不要超过10个方法<br>一个模块：不要超过500行<br>（3）、import</p>
<p>不要在一句import中引用多个库<br>（4）、命名规范<br>（5）、注释</p>
<p>总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！</p>
<p>9、通过代码实现如下转换：<br>答案： 二进制转换成十进制：v &#x3D; “0b1111011”</p>
<blockquote>
<p> print(int(‘0b1111011’,2))<br>十进制转换成二进制：v &#x3D; 18<br>print(bin(18))<br>八进制转换成十进制：v &#x3D; “011”<br>print(int(‘011’,8))<br>十进制转换成八进制：v &#x3D; 30<br>print(oct(30))<br>十六进制转换成十进制：v &#x3D; “0x12”<br>print(int(‘0x12’,16))<br>十进制转换成十六进制：v &#x3D; 87<br>print(hex(87))</p>
</blockquote>
<p>10、请编写一个函数实现将IP地址转换成一个整数。<br>如 10.3.9.12 转换规则为：</p>
<blockquote>
<p>10            00001010<br>3            00000011<br>9            00001001<br>12            00001100</p>
</blockquote>
<p>再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 &#x3D; ？</p>
<p>答案：</p>
<p>def func(x):<br>lis &#x3D; x.strip().split(’.’)<br>li &#x3D; [bin(int(i)) for i in lis]<br>li2 &#x3D; [i.replace(‘0b’,(10-len(i))*‘0’) for i in li]<br>return int(’’.join(li2),2)<br>ret &#x3D; func(‘10.3.9.12’)<br>print(ret)</p>
<p>11、python递归的最大层数？<br>一般计算机默认的最大递归深度在1000左右，python最大递归深度一般在4000左右，跟计算<br>机的性能有关系，这个数不是一个定数，可通过一下方式测试</p>
<p>import sys<br>print(sys.getrecursionlimit())<br>print(sys.setrecursionlimit(10000))</p>
<p>12、求结果：<br>v1 &#x3D; 1 or 3 ————–&gt;1<br>v2 &#x3D; 1 and 3————–&gt;3<br>v3 &#x3D; 0 and 2 and 1——–&gt;0<br>v4 &#x3D; 0 and 2 or 1———&gt;1<br>v5 &#x3D; 0 and 2 or 1 or 4—-&gt;1<br>v6 &#x3D; 0 or Flase and 1—–&gt;False</p>
<p>13、ascii、unicode、utf-8、gbk 区别？<br>ASCII码：使用一个字节编码，所以它的范围基本是只有英文字母、数字和一些特殊符号 ，只有256个字符。<br>Unicode：能够表示全世界所有的字节<br>GBK：是只用来编码汉字的，GBK全称《汉字内码扩展规范》，使用双字节编码。<br>UTF-8：是一种针对Unicode的可变长度字符编码，又称万国码。</p>
<p>14、字节码和机器码的区别？<br>机器码：是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂<br>字节码：是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。</p>
<p>15、三元运算规则以及应用场景？<br>规则：为真时的结果 if 判定条件 else 为假时的结果<br>应用场景：在赋值变量的时候，可以直接加判断，然后赋值</p>
<p>16、列举 Python2和Python3的区别？<br>1、默认编码：2–&gt;ascii，3–&gt;utf-8</p>
<p>2、print的区别：python2中print是一个语句，不论想输出什么，直接放到print关键字后面即可。python3里，print()是一个函数，</p>
<p>像其他函数一样，print()需要你将要输出的东西作为参数传给它。</p>
<p>3、input的区别：</p>
<p>python2有两个全局函数，用在命令行请求用户输入。第一个叫input()，它等待用户输入一个python表达式(然后返回结果)。<br>第二个叫做raw_input(),用户输入什么他就返回什么。python3 通过input替代了他们。</p>
<p>4、字符串：python2中有两种字符串类型：Unicode字符串和非Unicode字符串。Python3中只有一种类型：Unicode字符串。</p>
<p>5、xrange()</p>
<p>python２里，有两种方法获得一定范围内的数字：range(),返回一个列表，还有xrange(),返回一个迭代器。<br>python3　里，range()返回迭代器，xrange()不再存在。</p>
<p>17、用一行代码实现数值交换：<br>a &#x3D; 1<br>b &#x3D; 2<br>答案：a &#x3D; 1</p>
<p>b &#x3D; 2<br>a,b &#x3D; b,a</p>
<p>18、Python3和Python2中 int 和 long的区别？<br>python2有非浮点数准备的int和long类型。int类型最大<br>值不能超过sys.maxint，而且这个最大值是平台相关的。<br>可以通过在数字的末尾附上一个Ｌ来定义长整型，显然，它比int类型表示的数字范围更大。在python3里，<br>只有一种整数类型int,大多数情况下，和python２中的长整型类似。<br>学习过程中会遇到很多问题，你可以到我们的 python学习 -q-u-n-784758214 ，基础，进阶。好友都会在里面交流，分享一些学习的方法和需要注意的小细节，每天也会准时讲一些项目实战案例。</p>
<p>19、xrange和range的区别？<br>python２里，有两种方法获得一定范围内的数字：range(),返回一个列表，还有xrange(),返回一个迭代器。<br>python3　里，range()返回迭代器，xrange()不再存在。</p>
<p>20、文件操作时：xreadlines和readlines的区别？<br>readlines返回一个list，xreadlines方法返回一个生成器</p>
<p>21、列举布尔值为False的常见值？<br>0, [] , () , {} , ‘’ , False , None</p>
<p>22、字符串、列表、元组、字典每个常用的5个方法？<br>字符串：repleace,strip,split,reverse,upper,lower,join…<br>列表：append,pop,insert,remove,sort,count,index…<br>元组：index,count,len(),dir()<br>字典：get,keys,values,pop,popitems,clear,update,items…</p>
<p>23、lambda表达式格式以及应用场景？<br>表达式格式：lambda后面跟一个或多个参数，紧跟一个冒号，以后是一个表达式。冒号前是参数，冒号后是返回值。例如：lambda x : 2x<br>应用场景：经常与一些内置函数相结合使用，比如说map(),filter(),sorted(),reduce()等</p>
<p>24、pass的作用？<br>1、空语句 do nothing<br>2、保证格式完整<br>3、保证语义完整</p>
<p>25、arg和*kwarg作用？<br>万能参数，解决了函数参数不固定的问题<br>*arg：会把位置参数转化为tuple<br>**kwarg：会把关键字参数转化为dict</p>
<p>26、is和&#x3D;&#x3D;的区别？<br>is:判断内存地址是否相等<br>&#x3D;&#x3D;：判断数值是否相等</p>
<p>27、简述Python的深浅拷贝以及应用场景？<br>copy()：浅copy，浅拷贝指仅仅拷贝数据集合的第一层数据<br>deepcopy():深copy,深拷贝指拷贝数据集合的所有层</p>
<p>28、Python垃圾回收机制？<br>python采用的是引用计数机制为主，标记-清除和分代收集(隔代回收、分代回收)两种机制为辅的策略<br>计数机制</p>
<p>Python的GC模块主要运用了引用计数来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”<br>解决容器对象可能产生的循环引用的问题。通过分代回收以空间换取时间进一步提高垃圾回收的效率。<br>标记-清除：</p>
<p>标记-清除的出现打破了循环引用，也就是它只关注那些可能会产生循环引用的对象<br>缺点：该机制所带来的额外操作和需要回收的内存块成正比。<br>隔代回收</p>
<p>原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，<br>垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，<br>就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，<br>如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。</p>
<p>29、python的可变类型和不可变类型？<br>不可变类型（数字、字符串、元组、不可变集合）<br>可变类型（列表、字典、可变集合）</p>
<p>30、求结果：<br>v &#x3D; dict.fromkeys([‘k1’,‘k2’],[])<br>v[‘k1’].append(666)<br>print(v)<br>v[‘k1’] &#x3D; 777<br>print(v)</p>
<p>答案：{‘k1’:[666],‘k2’:[666]}<br>{‘k1’:777,‘k2’:[666]}<br>解析：formkeys()默认参数为可变数据类型时有坑</p>
<p>如果对python自动化测试、web自动化、接口自动化、移动端自动化、面试经验交流等等感兴趣的测试人，可以关注微信公众号：【伤心的辣条】，获取软件测试工程师大厂面试资料！</p>
<p>31、求结果：<br>def num():<br>return [lambda x: i*x for i in range(4)]<br>print([m(2) for m in num()])</p>
<p>答案：[6, 6, 6, 6]<br>解析： 问题的本质在与python中的属性查找规则，LEGB（local，enclousing，global，bulitin），<br>在上面的例子中，i就是在闭包作用域（enclousing），而Python的闭包是 迟绑定 ，<br>这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的<br>所以：[lambda x: i*x for i in range(4)]打印出来是含有四个内存地址的列表，每个内存地址中的i<br>在在本内存中都没有被定义，而是通过闭包作用域中的i值，当for循环执行结束后，i的值等于3，所以<br>再执行[m(2) for m in num()]时，每个内存地址中的i值等于3，当x等于2时，打印出来的结果都是6，<br>从而得到结果[6, 6, 6, 6]。</p>
<p>32、列举常见的内置函数？<br>map,filter,zip,len,bin,oct,hex,int,float,bool,sum,min,max,str,list,tuple,dict,range,next,hash,help,id…</p>
<p>33、filter、map、reduce的作用？<br>filter(function，iterable)过滤函数<br>map(function，iterable)循环函数<br>reduce(function, iterable)累积函数</p>
<p>34、一行代码实现9*9乘法表。<br>lis &#x3D; [’%s%s&#x3D;%s’%(i,j,ij) for i in range(1,10) for j in range(i,10)]</p>
<p>35、如何安装第三方模块？以及用过哪些第三方模块？<br>pip3 imstall 模块名<br>django，Matplotlib，Tornado，PyGame</p>
<p>36、至少列举8个常用模块都有那些？<br>os,sys,time,random,re,hashlib,logging,json,pickle…</p>
<p>37、re的match和search区别？<br>match:从字符串的开头位置匹配，必须以此为开头<br>search:从开头开始查，找到符合的就返回结果</p>
<p>38、什么是正则的贪婪匹配？<br>正则表达式一般趋向于最大长度匹配</p>
<p>39、求结果：<br>a. [ i % 2 for i in range(10) ] &#x3D;&gt;[0,1,0,1,0,1,0,1,0,1]<br>b. ( i % 2 for i in range(10) )&#x3D;&gt;返回一个生成器的内存地址</p>
<p>40、求结果：<br>a. 1 or 2 &#x3D;&#x3D;&#x3D;&gt;1<br>b. 1 and 2 &gt;2<br>c. 1 &lt; (22)&gt;false<br>d. 1 &lt; 2 &#x3D;&#x3D; 2&gt;ture</p>
<p>41、def func(a,b&#x3D;[]) 这种写法有什么坑？<br>def func(a,b&#x3D;[]):</p>
<p>b.append(a)<br>print(b)<br>函数的第二个默认参数是一个list，当第一次执行的时候实例化了一个list，<br>第二次执行还是用第一次执行的时候实例化的地址存储，以后每次实例化都是<br>学习过程中会遇到很多问题，你可以到我们的 python学习 -q-u-n-784758214 ，基础，进阶。好友都会在里面交流，分享一些学习的方法和需要注意的小细节，每天也会准时讲一些项目实战案例。</p>
<p>42、如何实现 “1,2,3” 变成 [‘1’,‘2’,‘3’] ?<br>a &#x3D; “1,2,3”<br>li &#x3D; a.split(’,’)</p>
<p>43、如何实现[‘1’,’2’,’3’]变成[1,2,3] ?<br>li &#x3D; [‘1’,‘2’,‘3’]<br>lis &#x3D; list(map(lambda x:int(x) li))</p>
<p>44、比较： a &#x3D; [1,2,3] 和 b &#x3D; [(1),(2),(3) ] 以及 b &#x3D; [(1,),(2,),(3,) ] 的区别？<br>a &#x3D; [1,2,3]正常的列表<br>b &#x3D; [(1),(2),(3)] 虽然列表的每个元素加上了括号，但是当括号内只有一个元素并且没有逗号时，其数据类型是元素本身的数据类型<br>b &#x3D; [(1,),(2,),(3,)]列表中的元素类型都是元组类型</p>
<p>45、如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?<br>li &#x3D; [x*x for x in range(1,11)]</p>
<p>46、一行代码实现删除列表中重复的值 ?<br>li &#x3D; [1, 1, 1, 23, 3, 4, 4]<br>new_li &#x3D; list(set(li))<br>new_li.sort(key&#x3D;li.index)</p>
<p>47、如何在函数中设置一个全局变量 ?<br>使用python的内置语法 globals 全局变量</p>
<p>48、logging模块的作用？以及应用场景？<br>logging模块的作用：<br>1、程序调试<br>2、了解软件程序运行情况，是否正常<br>3、软件程序运行故障分析与问题定位<br>应用场景：网站的运维工作，程序实时监控</p>
<p>49、请用代码简答实现stack 。<br>def Stack(object):</p>
<p>def init(self):<br>self.stack &#x3D; []</p>
<p>def push(self,value):</p>
<p>进栈</p>
<p>self.stack.append(value)</p>
<p>def pop(self):</p>
<p>出栈</p>
<p>if self.stack:<br>self.stack.pop()<br>else:<br>raise LookupError(‘stack is empty!’)</p>
<p>def is_empty(self):</p>
<p>查看stack是否为空</p>
<p>reture bool(self.stack)</p>
<p>def top(self):</p>
<p>取出stack中最新的值</p>
<p>return self.stack[-1]</p>
<p>50、常用字符串格式化哪几种？<br>1、%s %d<br>2、format格式化输出<br>3、print(f’内容{变量名}’)</p>
<p>51、简述 生成器、迭代器、可迭代对象 以及应用场景？<br>生成器：在 Python 中，一边循环一边计算的机制，称为 生成器（generator），</p>
<p>通过next()取值，两种表现形式1、将列表生成式的[]改为()2、含有yield关键字的函数<br>应用场景：优化代码，节省内存<br>1<br>2<br>迭代器：是访问集合元素的一种方式。迭代器同时实现了__iter__和__next__方法<br>可迭代对象：只要实现了__iter__方法的对象就是可迭代对象</p>
<p>52、用Python实现一个二分查找的函数。<br>lis &#x3D; [0, 1, 3, 4, 5, 6, 7, 9, 10, 11,12,16,17]</p>
<p>def two_find(x, lis, start&#x3D;0, end&#x3D;None):</p>
<p>if end &#x3D;&#x3D; None:end &#x3D; len(lis) - 1<br>num &#x3D; (end - start) &#x2F;&#x2F; 2 + start<br>if end &gt; start:<br>if lis[num] &gt; x:<br>return two_find(x, lis, start&#x3D;start, end&#x3D;num)<br>elif lis[num] &lt; x:<br>return two_find(x, lis, start&#x3D;num + 1, end&#x3D;end)<br>elif lis[num] &#x3D;&#x3D; x:<br>return num<br>elif lis[end] &#x3D;&#x3D; x:return end<br>else:return None<br>print(two_find(17, lis))</p>
<p>53、谈谈你对闭包的理解？<br>在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。<br>一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。<br>但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。</p>
<p>54、os和sys模块的作用？<br>os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;<br>sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。</p>
<p>55、如何生成一个随机数？<br>import random<br>def rdm(n):</p>
<p>lis &#x3D; []<br>for i in range(n):<br>n &#x3D; random.randint(1,9)<br>lis.append(str(n))<br>s &#x3D; ‘’.join(lis)<br>return int(s)</p>
<p>56、如何使用python删除一个文件？<br>import os<br>os.remove(r’path’)</p>
<p>57、谈谈你对面向对象的理解？<br>面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，<br>不存在的也可以创造出来。对象是特征和技能的结合，其中特征和技能分别对应对象的数据属性和方法属性。<br>优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。<br>缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，<br>面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。<br>应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。</p>
<p>58、Python面向对象中的继承有什么特点？<br>1：在继承中基类的构造(init()方法)不会被自动调用，它需要在其派生类的构造中亲自专门调用。<br>2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。</p>
<p>区别于在类中调用普通函数时并不需要带上self参数<br>3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。</p>
<p>(先在本类中查找调用的方法，找不到才去基类中找)。</p>
<p>59、面向对象深度优先和广度优先是什么？<br>Python的类可以继承多个类，那么其寻找类方法的方式有两种：</p>
<p>当类是经典类时(主要在python2版本中的没有主动继承object的类)，多继承情况下，会按照深度优先方式查找<br>当类是新式类时(python3版本中的所有类和python2中主动继承object的类)，多继承情况下，会按照广度优先方式查找<br>简单点说就是：经典类是纵向查找，新式类是横向查找</p>
<p>60、面向对象中super的作用？<br>1、super在面向对象继承类中代指父类，书写方法super(类名,self).属性或者方法或super().属性或者方法<br>2、super方法可以增加类之间调用的灵活性，当父类名发生变化时不必修改<br>3、super方法在类的多继承时可以简化代码，避免代码冗余<br>4、super机制里可以保证公共父类仅被执行一次，执行的顺序遵循MRO，广度优先查询方法</p>
<p>如果对python自动化测试、web自动化、接口自动化、移动端自动化、面试经验交流等等感兴趣的测试人，可以关注微信公众号：【伤心的辣条】，获取软件测试工程师大厂面试资料！</p>
<p>61、是否使用过functools中的函数？其作用是什么？<br>functools用于高阶函数：指那些作用于函数或者返回其他函数的函数。通常情况下，只要是<br>可以被当做函数调用的对象就是这个模块的目标。</p>
<p>62、列举面向对象中带双下划线的特殊方法，如：new、init<br>new：构造方法，创建一个对象，实例化时第一个被执行，返回一个创建好的对象及__init__(self)的self，</p>
<p>只有继承了object的类才会有这个方法<br>init：初始化方法，__init__在__new__的基础上完成一些其它初始化的动作，__init__没有返回值</p>
<p>63、如何判断是函数还是方法？<br>函数和方法都封装了一些独立的功能，如果在类中定义的函数那就是方法(对象或者类名点方法名调用)，</p>
<p>否则就是函数(函数名()直接调用)</p>
<p>64、静态方法和类方法区别？<br>静态方法：是既不是用类中的属性又不使用对象中的属性，由类或者对象调用的方法，依赖python装饰器@staticmethod来实现<br>类方法：只使用类中的静态变量，一般都是由类调用，依赖python装饰器@classmethod来实现</p>
<p>65、列举面向对象中的特殊成员以及应用场景？<br>call：对象的构造方法，对象加上()，可以触发这个类的__call__方法。<br>len：内置函数的len函数是依赖类中的__len__方法<br>eq：判断值是否相等的时候依赖__eq__方法<br>hash:判断hash值是否相等的时候依赖__hash__方法(拓展：set的去重机制其实就是根据__hash__和__eq__方法实现的)<br>str：和str() print() %s 都是息息相关的，返回值一定是字符串类型<br>repr：和 repr() %r都是息息相关的，在没有__str__方法时，repr__可以完全取代__str。<br>del 析构方法，对应着一个对象的删除之前执行的内容</p>
<p>66、1、2、3、4、5 能组成多少个互不相同且无重复的三位数<br>count &#x3D; 0<br>for i in range(1,6):</p>
<p>for j in range(1,6):<br>for k in range(1,6):<br>if (i !&#x3D; j) and (i !&#x3D; k) and (j !&#x3D; k):<br>count +&#x3D; 1<br>if count % 6:<br>print(f’{i}{j}{k}’, end&#x3D;’|’)<br>else:<br>print(f’{i}{j}{k}’)<br>print(count)</p>
<p>67、什么是反射？以及应用场景？<br>定义：通过用字符串数据类型的变量名来访问这个变量的值，在python面向对象中的反射,通过字符串的形式操作对象相关的属性或方法.<br>应用场景：用于处理通过用户输入，文件读取，或者网络传输所得到的字符串形式的指令来完成对应的操作</p>
<p>68、metaclass作用？以及应用场景？<br>metaclass，直译为元类，简单的解释就是：当我们定义了类以后，就可以根据这个类创建出实例，<br>所以：先定义类，然后创建实例。但是如果我们想创建出类呢？那就必须根据metaclass创建出类，<br>所以：先定义metaclass，然后创建类。换句话说，你可以把类看成是metaclass创建出来的“实例”</p>
<p>69、用尽量多的方法实现单例模式。<br>1、基于__new__()方法</p>
<p>class Person:<br>def new(cls, *args, **kwargs):<br>if not hasattr(cls,cls._instance):</p>
<h1 id="cls-instance-x3D-object-new-cls"><a href="#cls-instance-x3D-object-new-cls" class="headerlink" title="cls._instance &#x3D; object.new(cls)"></a>cls._instance &#x3D; object.new(cls)</h1><p>cls._instance &#x3D; super().new(cls)<br>return cls._instance<br>2、基于模块导入方式，现在一个py文件中写好一个类，实例化一个对象。以后用这个类直接导入这个模块就是单例模式。<br>3、基于装饰器方法实现</p>
<p>def singleton(cls, *args, **kwargs):<br>instance_dic &#x3D; {}</p>
<blockquote>
<p>def inner(*args, **kwargs):<br>if cls not in instance_dic:<br>instance_dic[‘cls’] &#x3D; cls(*args, **kwargs)<br>return instance_dic[‘cls’]</p>
<p>return inner</p>
</blockquote>
<p>@singleton<br>class Person:<br>pass</p>
<p>70、装饰器的写法以及应用场景。<br>装饰器的写法：</p>
<p>def wrapper(func):<br>def inner(*args,**kwargs):<br>‘被装饰之前的操作’<br>ret &#x3D; func(*args,**kwargs)<br>‘被装饰之后的操作’<br>return ret<br>return inner<br>装饰器的应用场景：</p>
<p>比如注册登录、插入日志，性能测试，事务处理，缓存等等场景</p>
<p>71、异常处理写法以及如何主动跑出异常（应用场景）<br>异常处理的常规写法：</p>
<blockquote>
<p>try:<br>执行的主体函数<br>except Exception as e:<br>print(str(e))</p>
</blockquote>
<p>主动抛出异常：<br>raise TypeError(‘出现了不可思议的异常’)#TypeError可以是任意的错误类型</p>
<p>72、什么是面向对象的mro<br>MRO(Method Resolution Order 方法解析顺序)是面向对象中用于查询类的多继承的继承顺序的方法，<br>它是基于算法来实现的，不同的算法实现的MRO的顺序不同</p>
<p>73、isinstance作用以及应用场景？<br>isinstance作用是来判断一个对象是否是一个已知的类型</p>
<p>74、写代码并实现：<br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>Example:</p>
<blockquote>
<p>  Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,<br>Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,<br>return [0, 1]</p>
</blockquote>
<p>代码实现</p>
<p>def func(li,target):</p>
<p>try:<br>for i in range(0,len(li)):<br>num &#x3D; target-li[i]<br>if num in li:<br>return [i,li.index(num)]<br>except:print(‘li类型为数组类型，内的元素需是整型，target也为整型，请检查’)<br>else:return None</p>
<p>75、json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？<br>1、可以处理的数据类型是 string、int、list、tuple、dict、bool、null<br>2、定制支持datetime类型<br>————————–官方文档的memo———————————————–</p>
<blockquote>
<blockquote>
<blockquote>
<p>import json<br>class ComplexEncoder(json.JSONEncoder):<br>…     def default(self, obj):<br>…         if isinstance(obj, complex):<br>…             return [obj.real, obj.imag]<br>…         return json.JSONEncoder.default(self, obj)<br>…<br>dumps(2 + 1j, cls&#x3D;ComplexEncoder)<br>‘[2.0, 1.0]’<br>ComplexEncoder().encode(2 + 1j)<br>‘[2.0, 1.0]’<br>list(ComplexEncoder().iterencode(2 + 1j))<br>[‘[‘, ‘2.0’, ‘, ‘, ‘1.0’, ‘]’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>import json<br>import datetime<br>ret &#x3D; datetime.datetime.now()<br>class CJsonEncoder(json.JSONEncoder):<br>def default(self, obj):<br>if isinstance(obj, datetime.date):<br>return obj.strftime(’%Y-%m-%d %H:%M:%S’)<br>else:<br>return json.JSONEncoder.default(self, obj)</p>
<p>print(json.dumps(ret,cls&#x3D;CJsonEncoder))</p>
<p>76、json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？<br>在序列化是将json.dumps中的默认参数ensure_ascii改为False就可以保留中文了<br>json.dumps(obj,ensure_ascii&#x3D;False)<br>学习过程中会遇到很多问题，你可以到我们的 python学习 -q-u-n-784758214 ，基础，进阶。好友都会在里面交流，分享一些学习的方法和需要注意的小细节，每天也会准时讲一些项目实战案例。</p>
<p>77、什么是断言？应用场景？<br>assert 条件,‘自定义错误提示(可有可无)’ 例：assert 1 &#x3D;&#x3D; 0,‘这是一个低级的错误’<br>合约式设计是断言的经典应用，在一个正确的程序里，所有的前置条件和后置条件都将得到处理。</p>
<p>78、使用代码实现查看列举目录下的所有文件。<br>方法一：递归处理</p>
<p>import os<br>url &#x3D; r’C:\Users\Mr.Wang\PycharmProjects\untitled\前段学习’</p>
<p>def check_file(url,li &#x3D; []):<br>if os.path.isdir(url):<br>file_list &#x3D; os.listdir(url)<br>for ret in file_list:<br>base_url &#x3D; os.path.join(url,ret)<br>if os.path.isfile(base_url):<br>li.append(ret)<br>else: check_file(base_url)<br>return li<br>else:return os.path.basename(url)<br>方法二：堆栈的思想处理</p>
<p>import os<br>url &#x3D; r’C:\Users\Mr.Wang\PycharmProjects\untitled\python基础’</p>
<p>lis &#x3D; [url]<br>while lis:<br>url &#x3D; lis.pop()<br>ret_list &#x3D; os.listdir(url)<br>for name in ret_list:<br>abs_path &#x3D; os.path.join(url,name)<br>if os.path.isdir(abs_path):<br>lis.append(abs_path)<br>else:print(name)</p>
<p>79、简述 yield和yield from关键字。<br>yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器当你调用这个函数的时候，<br>函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象，当你使用for进行迭代的时候，<br>函数中的代码才会执行</p>
<p>yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，<br>这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。<br>有了这个结构，协程可以通过以前不可能的方式委托职责。</p>
<p>如果对python自动化测试、web自动化、接口自动化、移动端自动化、面试经验交流等等感兴趣的测试人，可以关注微信公众号：【伤心的辣条】，获取软件测试工程师大厂面试资料！</p>
<p>80、代码实现六位随机验证码<br>import random<br>s &#x3D; ‘’<br>for i in range(6):<br>num &#x3D; random.randint(0,9)<br>alpha1 &#x3D; chr(random.randint(65,90))<br>alpha2 &#x3D; chr(random.randint(97,122))<br>ret &#x3D; random.choice([num,alpha1,alpha2])<br>s +&#x3D; str(ret)<br>print(s)</p>
<p>81、代码实现随机发红包功能<br>import random<br>def red_packge(money,num):<br>li &#x3D; random.sample(range(1,money100),num-1)<br>li.extend([0,money100])<br>li.sort()<br>return [(li[index+1]-li[index])&#x2F;100 for index in range(num)]</p>
<p>ret &#x3D; red_packge(100,10)<br>print(ret)</p>
<p>————————–生成器版——————————————-<br>import random<br>def red_packge(money,num):<br>li &#x3D; random.sample(range(1,money100),num-1)<br>li.extend([0,money100])<br>li.sort()<br>for index in range(num):<br>yield (li[index+1]-li[index])&#x2F;100</p>
<p>ret &#x3D; red_packge(100,10)<br>print(ret)</p>
<p>82、请尽可能列举python列表的成员方法，并给出列表操作的答案：<br>（1） a&#x3D;[1, 2, 3, 4, 5], a[::2]&#x3D;？ a[-2:]&#x3D;？<br>a[::2]&#x3D;[1,3,5],<br>a[-2:] &#x3D; [4,5]</p>
<p>（2）一行代码实现对列表a中的偶数位置的元素进行加3后求和？<br>sum([i+3 for i in a[::2]])</p>
<p>（3）将列表a的元素顺序打乱，再对a进行排序得到列表b，然后把a和b按元素顺序构造一个字典d。<br>import random<br>random.shuffle(a)<br>b&#x3D;a.sort()<br>d&#x3D;{}<br>for i in range(len(a)):d[a[i]] &#x3D; b[i]</p>
<p>83、Python自省<br>自省就是面向对象的语言所写的程序在运行时，就能知道对象的类型。也就是程序运行时能够获得对象的类型。比如type()，dir()，getattr()，hasattr()，isinstance()。</p>
<p>84、Python是如何进行内存管理的？<br>从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制</p>
<p>一、对象的引用计数机制<br>Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。<br>引用计数增加的情况：<br>1，一个对象分配一个新名称<br>2，将其放入一个容器中（如列表、元组或字典）<br>引用计数减少的情况：<br>1，使用del语句对对象别名显示的销毁<br>2，引用超出作用域或被重新赋值<br>sys.getrefcount( )函数可以获得对象的当前引用计数<br>多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。</p>
<p>二、垃圾回收<br>1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。<br>2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。</p>
<p>三、内存池机制<br>Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。<br>1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。<br>2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。<br>3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。</p>
<p>85、介绍一下except的用法和作用？<br>try…except…except…else…<br>– 执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。<br>– try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行<br>– 如果存在finally语句，最后总是会执行。</p>
<p>86、如何用Python来进行查询和替换一个文本字符串？<br>可以使用re模块中的sub()函数或者subn()函数来进行查询和替换，比replace的功能更强大！！！<br>格式：sub(replacement, string[,count&#x3D;0])（replacement是被替换成的文本，string是需要被替换的文本，count是一个可选参数，指最大被替换的数量）</p>
<p>import re<br>p&#x3D;re.compile(“blue|white|red”)<br>print(p.sub(‘colour’,‘blue socks and red shoes’))<br>print(p.sub(‘colour’,‘blue socks and red shoes’,count&#x3D;1))<br>subn()方法执行的效果跟sub()一样，不过它会返回一个二维数组，包括替换后的新的字符串和总共替换的数量</p>
<p>87、有没有一个工具可以帮助查找python的bug和进行静态的代码分析？<br>PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告<br>Pylint是另外一个工具可以进行codingstandard检查<br>————————————————<br>版权声明：本文为CSDN博主「测试萌萌」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_50829653/article/details/116309089">https://blog.csdn.net/weixin_50829653/article/details/116309089</a></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>从未听过的10个软件测试面试问题</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/07_%E4%BB%8E%E6%9C%AA%E5%90%AC%E8%BF%87%E7%9A%8410%E4%B8%AA%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>聘请优秀人才对于建立可靠的软件测试程序至关重要。相对于招聘人数而言，高质量的应征者寥寥无几，因此招聘过程正在加速发展，并且比以往任何时候都更具竞争力。</p>
<p><img src="/assets/2/image-20220516202937-o976q5g.png" alt="image.png"></p>
<p>毫无疑问：进行软件测试面试问题对于评估候选人是否合适至关重要。尽管技术技能对于成功担任该职位至关重要，但非技术性问题(如沟通，文化，职业发展等)通常会导致招聘失败。</p>
<p>我们将软件测试面试问题集中在面试中经常忽略的软技能上。将这些与一系列严苛的技术面试问题配对，您将确保对候选人进行全方位评估!</p>
<p>1.您认为您经常使用哪种应用程序具有最佳&#x2F;最差的质量?什么让你有那个想法?<br>为什么这是一个好问题：测试他们的创造力，让您对他们所认为的“ 质量 ” 有所了解。</p>
<p>在响应中寻找什么：越详细越好。您需要一个可以轻松传达他们在应用程序中看到的内容并进行精妙观察的测试人员。另外，请确保其质量定义与您在测试中的应用中所寻找的内容保持一致。</p>
<p>2.在您过去的角色中，您创建并执行的最有价值的测试是什么?您如何衡量该价值?<br>为什么这是个好问题： 确定他们在测试中的价值以及促使他们做得更好的因素。</p>
<p>在响应中寻找的内容： 不断改进的愿望，以及创建精确，强大的测试以显示新缺陷而不是仅仅关注已生成测试数量的历史。</p>
<p>3.告诉我您过去与队友发生的冲突。为什么会出现?如何解决的?如果您可以再做一次，您会以相同的方式还是以不同的方式处理它?<br>为什么这是一个好问题：确定候选人可能存在的人际关系问题。</p>
<p>在响应中要寻找的内容：不断发生冲突的候选人可能会一直与避免冲突的人一样麻烦。确保候选人是平衡的，并从过去的冲突中学到了如何应对未来的冲突。</p>
<p>4.您做了什么准备今天的采访?<br>为什么这是一个好问题： 演示候选人的主要学习方式。</p>
<p>响应中要查找的内容：确保已做好充分的准备，但最重要的是，请注意他们如何学习该信息。您希望这种学习风格与最成功的测试人员(特定于您的组织)相匹配。</p>
<p>5.成为测试员对您意味着什么?您如何向家人和朋友解释您的角色?<br>为什么这是一个好问题：表明他们对工作感到自豪，并希望长期继续在野外工作。</p>
<p>在响应中查找的内容：应对响应中的任何不一致与职位空缺中规定的工作职责进行对比。测试人员的一个共同特征是希望过渡到应用程序开发，并确保他们对过渡的任何需求都符合您的计划。</p>
<p>6.五年后，您如何看待自己?要达到更高的水平，您需要实现什么?<br>为什么这是一个好问题：突出他们的职业野心。</p>
<p>应对措施中寻找的内容：一定 程度的职业发展有望留住任何员工，因此不要将升任管理层或担任领导职务的愿望作为危险信号。但是，您要确保他们对自己的优缺点和达到下一个水平所需要的发展有公正而准确的看法。</p>
<p>7.您错过&#x2F;迟迟未采用的一种改变测试的趋势是什么?我们需要关注的下一个测试趋势是什么?<br>为什么这是一个好问题：从以往的学习中表现出自我意识和成长。</p>
<p>寻找回应：寻找 适应不断变化的市场条件的意识，并更新其策略以与其他伟大公司的行为相匹配。</p>
<p>8.您会对刚开始测试的人提供什么建议?为什么您会建议呢?<br>为什么这是一个好问题：显示他们在培养其他候选人时转变为领导或管理角色的能力。</p>
<p>应对中要寻找的是： 自我意识以及向同事和过去的角色学习。</p>
<p>9.您工作过的最好&#x2F;最差的公司是哪家?为什么做得这么好&#x2F;可怕?<br>为什么这是一个好问题：说明比较符合他们个人喜好的公司文化。</p>
<p>寻找响应的内容：公司环境与他们所服务的优秀公司之间的紧密结合。在讨论应聘者工作最糟糕的公司时，请确保他们的论点是扎实的，并且不是眼前的实际问题。</p>
<p>10.您喜欢在工作以外做些什么?<br>为什么这是一个好问题：建议他们对工作与生活之间的平衡期望。</p>
<p>在响应中查找的内容：正确了解其下班后的时间表。期望不一致会导致挫败感和快速倦怠。</p>
<p>我们希望这些软件测试面试问题能派上用场，因为您继续聘请比较好的测试人员来建立您的团队。请在下面发表评论，让我们知道您最喜欢的问题，以及我们可能忘记的面试问题!<br><br /></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>测试人员总结软件测试常见问题(笔试、面试)</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/06_%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E6%80%BB%E7%BB%93%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1、什么是软件测试？其目的是什么？你怎么看待软件测试？<br>是为了发现错误而执行程序的过程。在软件投入运行前，对软件需求分析、设计规格说明和编码的最终复审，是软件质量保证的关键步骤。</p>
<p>目的是暴露程序中的错误。发现测试对象与预期的差异。具体地不同测试阶段对应不同测试目的。</p>
<p>软件测试工作者要站在用户的额角度思考问题，从用户的实际使用环境、习惯着手验证被测对象应用表现。与软件开发的创造性思维不同，软测活动的思维模式则是破坏性的通过构建正常、异常输入去考验被测对象的健壮性。测试工作是一项极其重要的质量保证活动。因为测试部门是软件发布质量把控的出口，又可能是用户意见反馈的入口。</p>
<p>2、软件测试的生命周期？各阶段对应的工作？<br>测试周期是指从测试项目计划建立到BUG提交的整个测试过程，包括软件项目测试计划，测试需求分析，测试用例设计，测试用例执行，BUG提交五个阶段。软件测试周期与软件生命周期并行，存在于软件生命周期的各个阶段。</p>
<p>需求分析阶段：测试人员了解需求、对需求进行分解、分析，得出测试需求。</p>
<p>测试计划阶段：根据需求编写测试计划&#x2F;测试方案。确定测试范围，测试通过的标准，测试的时间、人力、物力、资源、风险等。输出测试计划文档</p>
<p>测试设计、测试开发阶段：测试人员搭建测试用例框架，根据需求和设计编写一部分测试用例。输出测试方案文档。</p>
<p>测试执行阶段：测试执行阶段是软件测试人员最为重要的工作阶段，根据测试用例和计划执行测试。</p>
<p>测试评估阶段（BUG提交）：在执行的过程中记录、管理缺陷，测试完成后编写测试报告，进行测试评估。</p>
<p>3、测试计划和测试方案的内容和区别？<br>测试计划确定测试范围，测试通过的标准，测试的时间、人力、物力、资源、风险等；</p>
<p>测试方案确定测试的方法、类型；确定用例设计的方法，缺陷管理流程；缺陷严重程度的划分、用例格式等。</p>
<p>测试计划一般由测试经理、测试主管或项目测试负责人制定，属于管理文档，解决的是做什么的问题。测试方案由测试工程师设计，属于技术文档，解决的是怎么做的问题。</p>
<p>4、需求评审的内容？参与人员？测试人员为什么要参与需求评审？<br>内容：同步产品对于需求的详细设计,收集大家对于需求的各种反馈。</p>
<p>参与人员：产品、设计、研发、运营，测试等其他岗位的人</p>
<p>当面同步需求，对于需求的合理性、全面性的反馈。</p>
<p>5、测试用例的设计方法有哪几种，分别对应什么典型业务功能？<br>等价类划分</p>
<p>等价类即是某个测试对象的输入域的集合。是一种常用的黑盒测试方法。它将全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件，从而用少量代表性的测试数据取得较好的测试结果。等价类可分为有效等价类和无效等价类。</p>
<p>在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类。</p>
<p>在输入条件规定了输入值的集合或者规定了”必须如何”的条件的情况下,可确立一个有效等价类和一个无效等价类；</p>
<p>在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类</p>
<p>在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类</p>
<p>在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</p>
<p>实例：三角形等价类划分</p>
<p>业务：邮件注册功能。</p>
<p>测试用例实际就是各个等价类的排列组合。</p>
<p>边界值分析</p>
<p>边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。</p>
<p>大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。</p>
<p>构造测试数据是要考虑3个点的选择：上点，即边界值点；内点，即与范围内的点；离点，离上点最近的点，当域是开区间时离点在域内，闭区间时离点在域外。</p>
<p>边界值设计法为每一个有效等价类多增了2个上点的用例。为每一个无效等价类选择的是离点的用例。</p>
<p>应用场景与等价类相同</p>
<p>判定表驱动分析</p>
<p>在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表很适合于处理这类问题。</p>
<p>判定表通常由四个部分组成。</p>
<p>1)条件桩（ConditionStub）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。</p>
<p>2)动作桩（ActionStub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。</p>
<p>3)条件项（ConditionEntry）：列出针对它左列条件的取值。在所有可能情况下的真假值。</p>
<p>4)动作项（ActionEntry）：列出在条件项的各种取值情况下应该采取的动作。</p>
<p>因果图法</p>
<p>等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视。</p>
<p>针对需求规格，将原因及影响对应关系分为两组：输入与输出，输入与输入。每种又分别对应四类</p>
<p>输入与输出：关系主要有恒等、与、或、非。</p>
<p>恒等：输入a，一定产生对应的e。没有a的输入，就不会产生e的输出。</p>
<p>与（^）：只有同时有a和b的输入，才能产生对应的e。</p>
<p>或（v）：输入a或者b，就可以产生对应的e</p>
<p>非（~）：只有不输入a，才能产生对应的e</p>
<p>输入与输入：异、或、唯一、要求。</p>
<p>异：即互斥，所有输入条件只能成立一个，可以一个都不成立。</p>
<p>或：所有输入条件至少成立一个，可以多个条件共存</p>
<p>唯一：所有输入条件中只能且必须成立一个。</p>
<p>要求：如果输入条件a发生了，那么b也会发生。</p>
<p>采用因果图法设计测试用例的步骤：</p>
<p>1)分析软件规格说明描述中,那些是原因(即输入条件或输入条件的等价类),那些是结果(即输出条件),并给每个原因和结果赋予一个标识符。</p>
<p>2)分析软件规格说明描述中的语义，找出原因与结果之间,原因与原因之间对应的关系，根据这些关系,画出因果图。</p>
<p>3)由于语法或环境限制,有些原因与原因之间,原因与结果之间的组合情况不可能出现，为表明这些特殊情况,在因果图上用一些记号表明约束或限制条件。</p>
<p>4)把因果图转换为判定表。</p>
<p>5)把判定表的每一列拿出来作为依据,设计测试用例。</p>
<p>场景设计</p>
<p>用事件触发来控制流程的，对于涉及业务流程的软件系统，使用场景设计法设计是比较恰当的，比状态迁移类多了些异常的东西。</p>
<p>基本流：输入经过每一个正确的流程运转最终达到的额预期结果。</p>
<p>备选流：表示输入经过每一个流程运转时可能产生异常情况，但经过纠正后仍能达到预期的结果。</p>
<p>异常流：表示输入经过每一个流程运转时，产生的异常终止的现象。</p>
<p>错误推测法</p>
<p>基于经验和直觉推测程序中所有可能存在的各种错误,列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。从而有针对性的设计测试用例的方法。</p>
<p>6、缺陷的级别及管理流程？<br>缺陷等级一般划分为四个等级，致命、严重、一般、提示。</p>
<p>致命（Uregent）：主流程无法跑通，系统无法运行，崩溃或业务中断，应用模块无法启动或异常退出，主要功能模块无法使用。如：1.内存泄漏；2.严重的数值计算错误；3.系统容易崩溃；4.功能设计与需求严重不符；5.系统无法登陆；6.循环报错，无法正常退出。</p>
<p>严重（veryhigh）：影响系统功能或操作，主要功能存在严重缺陷，但不会影响到系统稳定性。如：1.功能未实现；2.功能存在报错；3.数值轻微的计算错误</p>
<p>一般（Medium）：界面、性能缺陷。如：1.边界条件下错误；2.容错性不好；3.大数据下容易无响应；4.大数据操作时，没有提供进度条</p>
<p>提示（Low）：易用性及建议性问题。如：1.界面颜色搭配不好；2.文字排列不整齐；3.出现错别字，但是不影响功能；4.界面格式不规范。</p>
<p>缺陷管理流程说明：</p>
<p>1、测试人员填写bug并（Assign）给测试负责人，状态为New；</p>
<p>2、测试负责人（review）缺陷。主要检查报告规范，以及确认bug。若是有效的bug，状态变化为open，并分配给开发人员；若bug无效则指派（Assign）回给测试人员，bug状态依旧为new</p>
<p>3、开发人员根据缺陷描述确认是否时缺陷，若是则进行修复，修改完成并进行单元测试后，将bug的状态变为fixed，在comment中说明修改方法，并指派给缺陷发现人。若不是缺陷或者延期修改的，将bug状态变化为Rejected，同时也在comment中注明原因。</p>
<p>4、测试人员每天查看自己提交的bug的状态变化，应该成为每个测试人员的例行行为；</p>
<p>5、当bug的状态变为fixed时，测试人员打开该bug，开始对该bug进行回归测试；如果该bug回归测试通过，则状态变为closed。否则bug的状态变为reopen（必须说明reopen、closed状态变化原因或者操作过程）；</p>
<p>6、若对（Reject）的缺陷进行再次确认后测试人员认为是缺陷，则需（Reopen）缺陷至开发人员出，并comment原因。</p>
<p>7、如果回归测试通过，可是修改的同时又引入新的bug，则重新提交bug，状态为new。如果需要的时候注明相关联的bug号；</p>
<p>8、只有当所有的bug状态为closed，才可发布版本。</p>
<p>注：每当bug状态改变后，必须给出相应的注释和说明，以便查看bug生命周期的变化情况。</p>
<p>7、测试准入和通过的标准？<br>准入标准：</p>
<p>开发人员编码结束，并已完成单元测试</p>
<p>需求说明书规定的功能或开发人员提交的功能说明书的功能均已实现</p>
<p>冒烟测试通过，界面上的功能均实现，符合设计文档规定的功能。</p>
<p>开发人员向测试部提交《测试申请》</p>
<p>通过标准：</p>
<p>达到100%需求覆盖</p>
<p>所有1、2级用例被执行，3级用例执行率达到95%，4级用例执行率达到80%</p>
<p>1级、2级缺陷100%修复，3级95%修复，4级60-80%修复</p>
<p>具体缺陷问题需要和用户沟通确认。<br><br /></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>初级测试总结题</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/05_%E5%88%9D%E7%BA%A7%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93%E9%A2%98/</url>
    <content><![CDATA[<p>1）软件的概念？</p>
<p>软件是计算机系统中与硬件相互依存的一部分，包括程序、数据以及与其相关文档的完整集合。</p>
<p>2）软件测试的概念？</p>
<p>使用人工或自动手段来运行或测试某个系统的过程, 其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别</p>
<p>3）测试人员和开发人员区别?</p>
<p>①人员不同</p>
<p>测试：开发人员和测试人员 开发：只有开发人员</p>
<p>②所处阶段不同</p>
<p>测试：贯穿整个软件开发生命周期</p>
<p>调试：在软件开发编码阶段以及测试过程中对BUG进行调试</p>
<p>③对bug处理结果不同</p>
<p>测试：只找出错误，不解决</p>
<p>调试：找出错误并解决</p>
<p>4）什么是需求？</p>
<p>①用户解决问题或达到目标所需的条件或权能，</p>
<p>②系统或系统部件要满足合同、标准、规范或其它正式规定文档所需具有的条件或权能</p>
<p>5）测试生命周期模型？</p>
<p>V模型、W模型、瀑布模型、 螺旋模型、敏捷H模型</p>
<p>软件测试流程<br>1、需求分析，需求评审</p>
<p>2、制定测试计划、计划评审</p>
<p>3、编写测试用例、用例评审</p>
<p>4、测试实施阶段、执行测试用例</p>
<p>按照设计好的用例、准备好的数据和制定的测试策略，实施进行具体的测试过程</p>
<p>5、测试评估阶段</p>
<p>测试总结、缺陷分析、过程评估</p>
<p>7）V模型？</p>
<p><img src="/assets/2/image-20220516202439-w9aeb86.png" alt="image.png"></p>
<p>8）W模型？</p>
<p><img src="/assets/2/image-20220516202447-igrkosc.png" alt="image.png"></p>
<p>9）瀑布模型？</p>
<p><img src="/assets/2/image-20220516202453-gxyog3j.png" alt="image.png"></p>
<p>10）需求评审内容？</p>
<p>①对需求的描述是否易于理解？</p>
<p>②受否存在有二义性的需求？</p>
<p>③是否定义了术语表，对特定含义的术语给予了定义？</p>
<p>④最终产品的每个特征是用唯一的术语描述的吗？</p>
<p>⑤需求是中的条件和结果是不是合理，有没有遗漏一些异常因果关系？</p>
<p>⑥需求中有没有包含不确定行描述，如：大约、可能、等</p>
<p>⑦每个规格是不是都有明确说明？</p>
<p>⑧环境搭建是否可能或有困难？</p>
<p>11）需求分类？</p>
<p>①业务需求 ②用户需求 ③系统需求</p>
<p>第二部分</p>
<p>12）什么是测试用例？</p>
<p>为实施测试而向被测试系统提供的输入数据、操作或各种环境设置以及期望结果的一个特定的集合。也就是解决要测什么、怎么测和如何衡量的问题</p>
<p>13）什么是测试计划?</p>
<p>软件测试计划就是在软件测试工作正式实施之前明确测试的对象，并且通过对资源、时间、风险、测试范围和预算等方面的综合分析和规划，保证有效的实施软件测试。</p>
<p>14）用例优先级？</p>
<p>② 高：最常执行以保证功能性是稳定的，目标的行为和能力可以正常的工作，和重要的错误和边界被测试的测试用例的集合。</p>
<p>③ 中：这是使给出的功能区域或功能变得更详细，检查功能的多数方面包括边界，错误和配置测试的测试用例。 ④ 低：这是通常最少被执行的测试用例。但这并不意味着这些测试都不重要，只是说他们在项目的生命期间里不是常常被运行，例如GUI，错误信息，可用性</p>
<p>15）用例内容？</p>
<p>主要分为三大部分：基本信息、用例主体、执行记录</p>
<p>基本信息：项目名称、功能模块名、用例设计人、测试执行人、功能特性、测试目的、预置条件、参考信息</p>
<p>用例主体：用例编号、测试对象、检查点、预置条件、用例说明、优先级、预期结果</p>
<p>执行记录：测试结果、缺陷编号、备注</p>
<p>16）用例执行结果？</p>
<p>通过，不通过，未运行，无法运行</p>
<p>17）测试计划内容？</p>
<p>①测试目的 ②测试背景 ③文件受众 ④术语和定义⑤测试参考文档</p>
<p>⑥测试提交文档 ⑦测试范围 ⑧测试策略⑨测试资源⑩测试进度里程碑</p>
<p>⑪系统错误、优先级⑫测试阶段进入退出标准和通过标准</p>
<p>18）测试阶段？</p>
<p>①单元测试（组件测试）</p>
<p>②集成测试 ：自顶向下集成测试 、 自底向上集成测试</p>
<p>③系统测试</p>
<p>④验收测试</p>
<p>19）黑盒测试方法？（写出15种以上）</p>
<p>动态测试</p>
<p>故障转移和恢复测试</p>
<p>配置测试</p>
<p>容量测试</p>
<p>UI测试</p>
<p>数据和数据库完整性测试</p>
<p>易用性测试</p>
<p>功能测试</p>
<p>性能测试</p>
<p>自动化测试</p>
<p>健壮性测试</p>
<p>稳定性测试</p>
<p>场景测试</p>
<p>逻辑测试</p>
<p>随机测试</p>
<p>集成测试</p>
<p>系统测试</p>
<p>验收测试</p>
<p>冒烟测试</p>
<p>兼容性测试</p>
<p>逆向思维测试</p>
<p>本地化测试</p>
<p>接口测试</p>
<p>回归测试</p>
<p>Cookie测试</p>
<p>Alpha测试</p>
<p>Beta测试</p>
<p>安全性和访问控制测试</p>
<p>20）白盒和黑盒区别？</p>
<p>白盒测试：是通过程序的源代码进行测试而不使用用户界面。</p>
<p>黑盒测试：是通过使用整个软件或某种软件功能来严格地测试</p>
<p>①测试特点不同</p>
<p>黑盒测试：测试功能</p>
<p>白盒测试：测试程序接口与结构</p>
<p>②测试依据不同</p>
<p>黑盒测试：需求规格说明书</p>
<p>白盒测试：软件程序</p>
<p>③侧重点不同</p>
<p>黑盒测试：关注功能逻辑实现</p>
<p>白盒测试：关注内部代码结构</p>
<p>21）测试类型？</p>
<p>黑盒</p>
<p>白盒</p>
<p>灰盒</p>
<p>22）回归测试？</p>
<p>更新新版本以后确保老版本的功能依然可以使用</p>
<p>23）alpha测试—内部测试（未公开）</p>
<p>beta测试—用户公测</p>
<p>24）冒烟测试？</p>
<p>确保软件满足系统测试的要求</p>
<p>25）系统测试标准？</p>
<p>不存在致命或严重级别的BUG</p>
<p>不存在优先级为P1的BUG</p>
<p>遗留问题不能大于总BUG数的8%</p>
<p>遗留问题不能明显影响用户使用</p>
<p>26）集成模块？</p>
<p>驱动模块、存根模块</p>
<p>27）验收测试内容？</p>
<p>合同验收测试、法规性验收测试、alpha测试、beta测试、确保实际效果与需求一致</p>
<p>28）确认测试？</p>
<p>缺陷修复后再对其进行测试，确保真正被修复</p>
<p>29）设计用例原则？</p>
<p>100%的覆盖需求</p>
<ol>
<li>编写测试用例的方法</li>
</ol>
<p>等价类</p>
<p>边界值</p>
<p>因果图</p>
<p>场景法</p>
<p>正交法</p>
<p>（有经验的老司机还可采用错误推断法）</p>
<ol>
<li>BUG的优先级</li>
</ol>
<p>P1应立即修复的问题</p>
<p>P2在产品发布之前必须修复的问题</p>
<p>P3如果时间允许应该修复的问题</p>
<p>P4可以在发布版本中存在的问题</p>
<p>P5可改可不改，无伤大雅</p>
<p>32）BUG严重程度</p>
<p>致命</p>
<p>严重</p>
<p>一半</p>
<p>轻微</p>
<p>建议</p>
<p>33）常用的BUG管理工具</p>
<p>禅道、JIRA、Bugfree、QC</p>
<p>34）符合下边5个规则的才能叫做软件缺陷：</p>
<p>①软件未达到产品说明书标明的功能</p>
<p>②软件出现了产品说明书指明不会出现的错误</p>
<p>③软件功能超出产品说明书指明范围</p>
<p>④软件未达到产品说明书虽未指出但应达到的目标</p>
<p>⑤软件测试员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好</p>
<p>35）缺陷产生的原因</p>
<p>程序设计错误、文档不完善、需求不断变化、软件的复杂性、沟通交流不够 、工期短，任务大、软硬件支持不完善</p>
<p>36）判断发现的问题是否是缺陷的方法</p>
<p>①通过参考文档来确认缺陷</p>
<p>②通过了解软件产品的行业背景（或参考同类典型软件）来发现缺陷</p>
<p>③通过沟通来确认和识别缺陷</p>
<p>37）缺陷报告原则</p>
<p>①Correct（准确）：每个组成部分的描述准确，不会引起误解； ②Clear（清晰）：每个组成部分的描述清晰，易于理解； ③Concise（简洁）：只包含必不可少的信息，不包括任何多余的内容； ④Complete（完整）：包含复现该缺陷的完整步骤和其他本质信息； ⑤Consistent（一致）：按照一致的格式书写全部缺陷报告。</p>
<p>38）缺陷报告的用途是什么？</p>
<p>①记录缺陷</p>
<p>②缺陷分类</p>
<p>③缺陷跟踪</p>
<p>39）缺陷报告的生命周期（处理流程）</p>
<p>激活、待确认、已解决、待确认、重新激活、已关闭</p>
<p>40）缺陷报告内容</p>
<p>三部分：基本信息、缺陷主体、跟踪记录</p>
<p>①基本信息：编号、版本号、软件名称、编译号、测试人员、日期、指定处理人、硬件平台、操作系统、严重程度、优先级</p>
<p>②缺陷主体：缺陷概述、预置条件、详细描述、预期结果、实际结果</p>
<p>③跟踪记录：处理报告、处理日期、修改记录、返测人、返测版本、返测日期、返测记录</p>
<p>OSI网络7层协议<br>物理层<br>数据链路层<br>网络层<br>传输层<br>会话层<br>表示层<br>应用层<br>APP的兼容性测试包含哪些？<br>浏览器<br>系统<br>分辨率<br>网络<br>————————————————<br>版权声明：本文为CSDN博主「测试萌萌」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_50829653/article/details/117089674">https://blog.csdn.net/weixin_50829653/article/details/117089674</a></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>面试Python自动化测试岗</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/04_%E9%9D%A2%E8%AF%95Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B2%97/</url>
    <content><![CDATA[<p>一共参加了 5 个公司的面试。第一家公司，通过了 2 轮技术面试，但是薪资不够理想。第二个公司，被面试的测试专家虐的不要不要的 ，挂了，但也知道了自己很多不足之处。后面三个公司的面试都顺利拿到了 Offer。凭印象对面试题进行简单总结回顾，以代码方面的问题为主，经验不足，回答水平也有限，希望能给你们带来些帮助。</p>
<p>P.S. 本人目前用的语言主要是 Python 和 JavaScript，面试的这 5 家公司都是用 Python 做自动化测试，所以以下代码问题基本上都是关于 Python 的。</p>
<p>Python 自动化测试面试题目汇总<br>1、super 是干嘛用的？在 Python2 和 Python3 使用，有什么区别？为什么要使用 super？请举例说明。</p>
<p>答：</p>
<p>super 用于继承父类的方法、属性。<br>super 是新式类中才有的，所以 Python2 中使用时，要在类名的参数中写 Object。Python3<br>默认是新式类，不用写，直接可用。<br>使用 super 可以提高代码的复用性、可维护性。修改代码时，只需修改一处。<br>代码举例：<br>class baseClass:<br> def test1(self, num):<br> print(num)</p>
<p>class sonClass(baseClass):<br> def test2(self):<br> super().test1(num)</p>
<p>son &#x3D; sonClass()<br>son.test1(11)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>2、阅读以下代码，推导最后结果：</p>
<p>def add(n, i):<br> return n+i</p>
<p>def test():<br> for i in range(4):<br> yield i</p>
<p>g &#x3D; test()</p>
<p>for n in [1, 10, 5]:<br>    g &#x3D; (add(n, i) for i in g)</p>
<p>print(list(g)) # 结果是 [15, 16, 17, 18]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>答： 所有的结果都是生成器表达式，不调用它，不从里面取值，就不干活。附上我的推导过程：</p>
<p>n &#x3D; 1<br>g &#x3D; (add(n,i) for i in test())</p>
<h1 id="print-list-g-1-2-3-4"><a href="#print-list-g-1-2-3-4" class="headerlink" title="print(list(g))    # [1, 2, 3, 4]"></a>print(list(g))    # [1, 2, 3, 4]</h1><p>n &#x3D; 10<br>g &#x3D; (add(n,i) for i in (add(n,i) for i in test()))</p>
<h1 id="print-list-g-20-21-22-23"><a href="#print-list-g-20-21-22-23" class="headerlink" title="print(list(g))    # [20, 21, 22, 23]"></a>print(list(g))    # [20, 21, 22, 23]</h1><p>n &#x3D; 5<br>g &#x3D; (add(n,i) for i in (add(n,i) for i in (add(n,i) for i in test())))<br>g &#x3D; (add(n,i) for i in (add(n,i) for i in (5,6,7,8)))<br>g &#x3D; (add(n,i) for i in (10,11,12,13))</p>
<p>g &#x3D; (15,16,17,18)<br>print(list(g)) # [15, 16, 17, 18]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>3、快速编写前端 HTML、JavaScript、Vue 代码。</p>
<p>答：</p>
<p>HTML、JavaScript 代码:<br><!DOCTYPE html></p>
<html lang="en">
<head>
 <meta charset="utf-8">
</head>
<body>
 <h1 id="title">xxx公司</h1>
 <p>xxx公司是一家......</p>

 <div id="mybox">
 <h1></h1>
 <input type="button" value="按我" v-on:click="add()">
 </div>
 <script type="text/javascript" src="public/bundle.js"></script>
</body>
</html>
<script>
 var title =  document.getElementById("title");
    title.onclick = function() {
        alert('我爱xxx公司，祝我面试成功');
 }
</script>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
Vue 代码编写：

<p>import Vue from “vue”;<br>new Vue({<br>    el : “#mybox”,<br>    data : {<br>        a : 100<br> },<br>    methods : {<br>        add : function(){<br>        this.a ++;<br>      }<br>   }<br>});<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>4、L &#x3D; [1, 2, 3, 11, 2, 5, 3, 2, 5, 3]，用一行代码得出 [11, 1, 2, 3, 5]</p>
<p>答： list(set(L))</p>
<p>5、L &#x3D; [1, 2, 3, 4, 5]，L[10:]的结果是？</p>
<p>答： 空列表(当时有点紧张，一直在“空列表”和“索引超出范围”两个答案之间徘徊）。</p>
<p>6、L &#x3D; [1, 2, 3, 5, 6]，如何得出 ‘12356’？</p>
<p>答： 注意，个人觉得这个题有坑，列表的元素不是字符串，所以不能 ‘’.join(L)。以下是过程：</p>
<p>s &#x3D; ‘’<br>for i in L:<br>    s &#x3D; s + str(i)<br>print(s) # 12356<br>print(type(s)) # &lt;class ‘str’&gt;<br>1<br>2<br>3<br>4<br>5<br>7、列表和字典有什么区别？</p>
<p>答： 一般都是问列表和元组有什么不同。 （1）获取元素的方式不同。列表通过索引值获取，字典通过键获取。 （2）数据结构和算法不同。字典是 hash 算法，搜索的速度特别快。 （3）占用的内存不同。</p>
<p>8、如何结束一个进程？</p>
<p>答：（1）调用 terminate 方法。 （2）使用 subProcess 模块的 Popen 方法。使用简单，具体用法，这里不展开。</p>
<p>9、进程、线程有什么区别？什么情况下用进程？什么情况下用线程？</p>
<p>答：</p>
<p>（1）区别：</p>
<p>① 地址空间和其它资源（如打开文件）：进程之间相互独立，同一进程的各线程之间共享。某进程内的线程在其它进程不可见。</p>
<p>② 通信：进程间通信 IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p>
<p>③ 调度和切换：线程上下文切换比进程上下文切换要快得多。</p>
<p>④ 在多线程操作系统中，进程不是一个可执行的实体。</p>
<p>（2）使用场景：同时操作一个对象的时候，比如操作的是一个全局变量，我用线程，因为全局变量是所有线程共享的。</p>
<p>10、什么是ORM？为什么要用ORM？不用ORM会带来什么影响？</p>
<p>答：</p>
<p>ORM 框架可以将类和数据表进行对应，只需要通过类和对象就可以对数据表进行操作。</p>
<p>通过类和对象操作对应的数据表，类的静态属性名和数据表的字段名一一对应，不需要写 SQL 语句。</p>
<p>ORM 另外一个作用，是根据设计的类生成数据库中的表。</p>
<p>11、写一段代码，ping 一个 ip 地址，并返回成功、失败的信息。</p>
<p>答： 使用 subProcess 模块的 Popen 方法(使用简单，具体用法，这里不展开)。</p>
<p>12、说说接口测试的流程，介绍一下request有哪些内容。</p>
<p>答：（1）流程：获取接口文档，依据文档设计接口参数，获取响应，解析响应，校验结果，判断测试是否通过。 （2）request 内容：</p>
<p>封装了各种请求类型，get、post 等；</p>
<p>以关键字参数的方式，封装了各种请求参数，params、data、headers、token 等；</p>
<p>封装了响应内容，status_code、json()、cookies、url 等；</p>
<p>session 会话对象，可以跨请求。</p>
<p>13、UI 自动化，如何做集群？</p>
<p>答： Selenium Grid。</p>
<p>14、移动端 UI 自动化，经常会自动安装 2 个程序，你知道那两个程序是什么东西不？</p>
<p>答： 守护精灵，和 Python 并发编程中的 daemon 原理一样，父进程&#x2F;父线程的代码执行完毕，它就终止，要写在 start 方法前面。另外，要找到配置文件，注释掉两行代码。</p>
<p>15、说5个以上 Linux 命令。</p>
<p>答：一口气，劈里啪啦说了 10 多个 。</p>
<p>16、介绍一下你在这个项目中是如何使用 Jenkins 的。</p>
<p>答：用的不深入，说了基本操作，比如定时构建执行代码。</p>
<p>17、说说你对敏捷模式的认识。</p>
<p>答：小步快跑，拥抱变化。测试中，可以通过行为驱动测试，有个框架 lettuce 可以用。</p>
<p>18、了解过 Docker 不？</p>
<p>答： 了解，没用过。然后说了下对 Docker 大概的认识、优势。</p>
<p>19、说一下你对软件测试的深刻心得。</p>
<p>答： 此处省略 n 个字。 【请各位看官拍砖】</p>
<p>20、做过性能测试没？没做过，说出功能测试的流程。</p>
<p>答： 此处省略 n 个字。 【请各位看官拍砖】</p>
<p>21、Bug 定位、分析、类型。</p>
<p>答： 此处省略 n 个字。 【请各位看官拍砖】</p>
<p>22、测试策略、测试方案的区别。</p>
<p>答： 此处省略 n 个字。 【请各位看官拍砖】</p>
<p>Python 学习回顾和曾经立下的 Flag</p>
<p>另外，说说我的 Python 学习经历。我买的第一本 Python 书，是《跟老齐学 python 轻松入门》，看了几十页，之后又买了第二本《Python 基础教程》，同样看了几十页就又没看下去了。我个人喜欢刨根究底，入门书感觉满足不了我深入学习 Python 的需求。</p>
<p>后来翻遍了图书馆的图书，决定买马克路特兹的《Python 学习手册》，全书有 1000 多页，非常详细，拿到书的那天，就下决心，并在微信朋友圈发誓：不搞定这本书 1000 多页的书，就不找女朋友！</p>
<p>面试总结<br>在自动化测试、测试开发岗面试中，编程知识、Linux 都是必问的。测试开发人员的知识面既要有一定的广度，同时还要有扎实的编码基础。</p>
<p>路漫漫其修远兮，我还有很长的路要走。</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官最常问的面试题及答案-100题</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/03_%E9%9D%A2%E8%AF%95%E5%AE%98%E6%9C%80%E5%B8%B8%E9%97%AE%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%20-100%E9%A2%98/</url>
    <content><![CDATA[<p>1 软件的含义 程序、数据及相关文档的完整集合。</p>
<p>2 测试与调试的区别是什么？</p>
<p>测试是由测试人员来进行，主要目标是发现、报告和跟踪缺陷。 调试是由开发人员进行，主要目标是定位缺陷位置，分析缺陷原因，修复缺陷。</p>
<p>3 IEEE 是什么意思？</p>
<p>国际电气电子工程师协会</p>
<p>4 GB 是什么意思？</p>
<p>国家标准</p>
<p>5 软件测试的含义 简单讲，软件测试是发现缺陷的过程；</p>
<p>IEEE 中的定义是，软件测试是使用人工或自动手 段来运行或测定某个系统的过程，目的在于检验它是否满足规定的需求或弄清预期结果与实 际结果之间的差别。</p>
<p>6 软件测试的目的</p>
<p>（1）验证软件是否满足各类文档说明书等规定的软件质量要求</p>
<p>（2）找出软件缺陷</p>
<p>（3）为软件产品的质量测量和评价提供依据</p>
<p>（4）帮助开发改进开发流程</p>
<p>7 什么是功能、性能、兼容性 功能代表一个软件能做什么；</p>
<p>性能反映软件运行的速度或效率、占用资源的多少等指标； 兼容性表示一个软件与其所在运行环境的依赖程度，包括与硬件、操作平台、其他软件的依 赖。</p>
<p>8 测试分为哪几个阶段？每个阶段的测试目的是什么？</p>
<p>测试分为单元测试、集成测试、系统测试、验收测试四个阶段。前三个阶段的目的是尽 可能多的发现缺陷，而验收测试是要验证软件满足了用户需求，帮助用户建立系统可以正常 使用的信心，发现缺陷不是此阶段的目标。</p>
<p>9 解释 QA 及其职责 QA 的含义是软件质量保证（人员）。</p>
<p>主要职责是制定和加强促进软件开发并防止软件缺陷的标准和方法，并监督标准和过程 被正确的遵循。</p>
<p>10 测试工程师与软件质量保证的区别 测试工程师的主要任务是在最短的时间内发现尽可能多的缺陷，并确保这些缺陷得以修 复。软件质量保证的主要职责是制定和加强促进软件开发并防止软件缺陷的标准和方法，并 监督标准和过程被正确的遵循。</p>
<p>11 测试应该由什么人来进行？<br>测试应该由独立的第三方来进行，第三方表示测试人员不参与程序的开发。</p>
<p>12 pareto 法则、帕累托法则、28 原则、82 原则 一般情况下 80%的缺陷聚集在 20%的关键核心业务模块中，这个原则至少告诉我们在做 测试时，应该重点分析和测试 20%的核心业务，具体说要做好需求分析。</p>
<p>13 杀虫剂怪事 杀虫剂怪事用于描述软件测试越多，其对测试的免疫力越强的现象。这个现象告诉我们， 测试时，应尝试新方法、不同的测试程序，对程序进行测试，以找出更多软件缺陷。</p>
<p>14 木桶原理 木桶原理在软件方面的主要含义是全面质量管理，另外还告诉我们测试时要关注团队中 较弱的人。</p>
<p>15 Good-enough 原则 Good-enough 原则告诉我们做测试的时候既不要做过多测试，也不做不充分的测试。至 于多少测试合适，需要我们不断积累经验，在项目中可以指定最低测试通过标准和测试内容， 然后具体问题具体分析。</p>
<p>16 群集效应 群集效应的含义是发现的缺陷越多，证明软件存在的缺陷越多。群集效应指导我们在找 到软件缺陷的地方要继续找找。</p>
<p>17 什么是确认测试？回归测试？</p>
<p>确认测试也称再测试：缺陷修复以后，验证缺陷是否真正修复 回归测试：缺陷修复以后，确保对程序的修改没有给软件其他未改变部分带来新的缺陷。</p>
<p>18 测试人员应该具备哪些素质？</p>
<p>要有责任心，要有破坏的态度，对事不对人，三心二意（细心、信心、耐心、缺陷预防 意识、沟通意识），具有一定的开发技能，善于思考。</p>
<p>19 如果测试提交的缺陷开发人员不认可，该怎么办？</p>
<p>首先分析或与开发沟通开发不认可的原因。 如果拒绝原因是提交的不是缺陷，而且自己分析后，的确不是缺陷，则应该注意以后再 做测试时要做好复现，认真研读需求，提高自己找缺陷的能力。 如果拒绝原因是提交的不是缺陷 但自己分析时认为缺陷应该是存在的，则再次研读需 求并做好复现，拿出确实是缺陷的证据，然后与开发沟通。 如果拒绝原因是认可缺陷，但不予修复，如果自己觉得必须修复，则拿出充分理由和证 据和不修复的不利影响和影响范围，再与开发沟通。 注意沟通技巧，合理的论述，向开发说明自己的判断的理由，注意客观、严谨，不掺杂 个人情绪。 把问题交给测试经理，等待测试经理做出最终决定，如果仍然存在争议，可以通过公司 政策所提供的渠道，向上级反映，并由上级做出决定。</p>
<p>20 如何解决开发和测试的矛盾？<br>（1）以沟通和合作的方式开展工作</p>
<p>（2）提高开发技能</p>
<p>（3）换位思考</p>
<p>（4）进行有效沟通</p>
<p>21 测试团队中都有哪些角色？各负责什么任务？各有多少人？</p>
<p>测试负责人：制定测试计划，监督安排任务，进行测试总结，1 测试工程师：进行测试需求分析、设计用例、搭建环境、执行用例、提交并跟踪缺陷 ， 3 技术支持：负责环境维护，1 配置管理员：维护版本架构，维护版本库，文档配置，1 质量保证人员：负责软件质量方面的工作，1</p>
<p>22 什么是软件开发生命周期？</p>
<p>从软件最初构思到公开发行的过程。瀑布模型的过程是计划、需求、设计、编码、测试、 运行、维护循环。瀑布模型有严格的开发步骤，每个阶段是按顺序进行的，每个阶段都必须编写完整的文 档，每个阶段完成后必须经过审查才能进入下一步。 瀑布模型不能迭代、不能反复；测试在编码之后，测试太晚；测试的只是程序。</p>
<p>23 软件开发有什么模型？</p>
<p>软件测试主要有哪些模型？ 软件开发模型：大爆炸模型、边写边改模型、瀑布模型、螺旋模型、敏捷开发模型 软件测试模型：V 模型、W 模型、H 模型、X 模型、前置测试模型、敏捷测试模型</p>
<p>24 简述 V 模型。</p>
<p>V 模型的过程：用户需求→需求分析→概要设计→详细设计→编码→单元测试→集成测 试→系统测试→验收测试。</p>
<p>优点：</p>
<p>（1）V 的左端表示传统的瀑布开发模型，V 的右端明确地将测试分为不同的级别或阶 段，测试过程更为具体；</p>
<p>（2）测试各个阶段和开发的各个阶段相对应；</p>
<p>（3）V 模型的测试策略包括低层测试和高层测试，低层测试是为了源代码的正确性， 高层测试是为了整个系统满足用户的需求。</p>
<p>缺点：<br>（1）测试的对象就是程序本身。忽视了测试活动对需求分析，系统设计等活动的验证 和确认的功能，直到后期的验收测试才被发现。</p>
<p>（2）测试是开发之后的一个阶段。实际应用中容易导致需求阶段的错误一直到最后系 统测试阶段才被发现。</p>
<p>25 简述 W 模型。</p>
<p>W 模型的过程：左边 V 是需求分析→概要设计→详细设计→编码实现→模块集成→系 统构建→系统安装；右边 V 是需求测试→概要设计测试→详细设计测试→单元测试→集成 测试→系统测试→验收测试。</p>
<p>优点：</p>
<p>（1）W 模型体现了尽早和不断测试的原则，既强调测试方案设计，也强调测试执行。</p>
<p>（2）左侧 V 是开发，右侧 V 是与开发并行的测试，相对于 V 模型，W 模型增加了软件 各开发阶段中应同步进行的验证和确认活动，W 明确表示出了测试与开发的并行关系。测 试与开发是同步进行的，有利于尽早地全面的发现问题。</p>
<p>（3）测试伴随整个软件开发周期，且测试的对象不仅仅是程序，需求、设计等同样要 测试。</p>
<p>缺点：</p>
<p>在 W 模型中，需求、设计、编码等活动被视为串行的，测试和开发活动也保持着一种 线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段工作。这样就无法支持迭代 的开发模型，不利于当前软件开发复杂多变的情况。</p>
<p>26 简述 H 模型。</p>
<p>H 模型将测试活动完全独立出来，形成一个完全独立的流程，将测试准备活动和测试执 行活动清晰地体现出来。H 模型的测试流程是只要测试准备工作完成，达到测试就绪点，测 试就可以执行了。</p>
<p>优点：</p>
<p>（1）软件测试不仅仅指测试的执行，还包括很多其他的活动。</p>
<p>（2）软件测试是一个独立的流程，贯穿产品整个生命周期，与其他流程并发地进行。 当某个测试时间点就绪时，软件测试即从测试准备阶段进入测试执行阶段。</p>
<p>（3）H 模型反映出软件测试要尽早准备，尽早执行。</p>
<p>（4）软件测试可以进行迭代、反复进行。</p>
<p>27 敏捷开发 敏捷开发的核心思想是：以人为本，适应变化。 具体讲：</p>
<p>（1）认为个体和交互重于过程和工具，强调通过过程和工具理解个人和交流的作用；</p>
<p>（2）认为可用软件重于完备文档，强调通过全面的文档理解运行的软件；</p>
<p>（3）认为客户协作重于合同谈判，强调通过合同和谈判得到客户的协作；</p>
<p>（4）认为响应变化重于遵循计划，强调在计划的执行中做出对变更的响应。</p>
<p>特点：</p>
<p>（1）敏捷开发提倡迭代式和增量式的开发模式，并强调测试在其中的重要作用。</p>
<p>（2）敏捷开发是以用户为中心、以客户需求为导向的开发过程，在此过程中随时做好 “迎接变化”的准备，客户是敏捷的关键环节。</p>
<p>（3）敏捷开发没有单一固定的开发方法或过程，敏捷开发有三个共同点：依赖客户的 参与、测试驱动以及紧凑的迭代开发周期。</p>
<p>28 敏捷测试</p>
<p>（1）敏捷测试是协同测试的一种形式，程序员结对编程，程序员分饰测试员角色，敏 捷测试是连续测试。</p>
<p>（2） 敏捷测试侧重单元测试和验收测试。单元测试的过程是先设计单元测试用例，然 后进行编码，之后执行测试。</p>
<p>（3）敏捷测试强调客户参与，单元测试通过之后代码集成到代码库中，再由客户进行 验收测试，验收测试的结论反馈给开发人员，缺陷得以迅速修复。</p>
<p>29 软件质量要求有哪些？</p>
<p>功能要求和非功能要求。</p>
<p>30 软件非功能要求有哪些？</p>
<p>性能要求（负载测试、压力测试、容量测试、可靠性测试）、界面测试、兼容性测试、 易用性测试、文档测试、可用性测试、安装测试、安全测试、灾难恢复测试等。</p>
<p>31 简述测试的基本过程</p>
<p>（1）测试人员进行测试需求分析。</p>
<p>（2）测试负责人编写测试计划。</p>
<p>（3）测试人员根据测试需求分析设计和编写测试用例。</p>
<p>（4）测试人员搭建测试环境、创建测试数据、执行测试用例、提交缺陷报告并进行跟 踪、记录测试事件。</p>
<p>（5）进行测试评估和总结。 每一分步工作完成后都进行评审。</p>
<p>32 拿到一个软件后，应该怎样开始工作？</p>
<p>编写需求分析并评审→编写测试计划并评审→设计测试用例并评审→搭建测试环境、执 行测试用例、提交缺陷报告→进行评估和总结</p>
<p>33 怎么做测试？</p>
<p>编写需求分析并评审→编写测试计划并评审→设计测试用例并评审→搭建测试环境、执 行测试用例、提交缺陷报告→进行评估和总结</p>
<p>34 简介测试流程 编写需求分析并评审→编写测试计划并评审→设计测试用例并评审→搭建测试环境、执 行测试用例、提交缺陷报告→进行评估和总结。</p>
<p>35 怎么进行测试需求分析？</p>
<p>（1）收集各类文档，仔细阅读文档，提出问题，分析问题或沟通解决，整理需求信息。</p>
<p>（2）编写测试需求分析说明书：功能分解，编写检查点和测试点。</p>
<p>（3）需求评审。</p>
<p>36 拿到项目后，需要分析或咨询软件哪些方面的问题？</p>
<p>软件主要的功能、流程、开发环境（开发语言&lt;含数据类型&gt;、数据库、中间件）、运行 环境（硬件、软件、网络、软件架构）、用户群、测试范围、测试优先级。</p>
<p>37 什么时候提交发现的缺陷？</p>
<p>测试执行发现缺陷时立即提交缺陷。</p>
<p>38 什么是入口准则、出口准则？</p>
<p>入口准则是进行一项测试工作前需要准备好的前提条件。 出口准则是一项测试工作可以结束的前提条件。</p>
<p>39 需求评审都有哪些人参与？</p>
<p>项目经理、开发经理、测试经理、测试人员、开发人员、市场经理、客户等。</p>
<p>40 怎么做需求评审或者说需求评审需要评审哪些方面？</p>
<p>编写或设计需求评审检查单，比如可以检查有无错别字、病句，标点符号使用是否正确， 格式是否一致，是否还有多余需求，是否有错误需求，是否有遗漏需求等。</p>
<p>41 测试资源需求有哪些方面？</p>
<p>人力资源、硬件资源、软件资源。</p>
<p>42 什么是测试策略？什么是测试范围？</p>
<p>测试策略主要指如何进行某种测试（如功能测试、性能测试、兼容性测试、可用性测试、 易用性测试等），用于说明测试方法以及如何使用测试方法。测试范围有时候等价于测试策 略，有时候可以表示要进行测试的某个软件部位。</p>
<p>43 什么是 BVT？冒烟测试？版本验证测试？怎么测？</p>
<p>也称冒烟测试、版本验证测试、小版本验证测试、版本构建测试。冒烟测试用例是一组 想先运行以确定这个给出的小版本是否可以测试的测试用例。冒烟测试主要测试软件的基本 功能，以判断整个软件值不值得进行大规模测试。通常由一个人进行 1-2 小时的测试，一般 不测试次要功能和各种错误。</p>
<p>44 测试计划的内容和目的是什么？</p>
<p>包含了产品概述、测试区域&#x2F;测试策略&#x2F;测试范围&#x2F;测试目标（测试项、被测特征）、测试 配置&#x2F;测试资源、测试周期、进度安排（测试任务、人员安排）、测试方法&#x2F;途径、测试交流、 风险分析等内容。目的是指导测试过程，规定测试活动的范围、方法、资源和进度；明确正 在测试的项目、要测试的特性、要执行的测试任务、每个任务的责任人以及与计划相关的风 险。</p>
<p>45 怎么判断是不是软件缺陷？</p>
<p>（1）软件未达到产品说明书标明的功能；</p>
<p>（2）软件出现了产品说明书指明不会出现的错误；</p>
<p>（3）软件功能超出产品说明书指明范围；</p>
<p>（4）软件未达到产品说明书虽未指出但应达到的目标；</p>
<p>（5）软件测试员具体问题具体分析，认为软件难以理解、不易使用、运行速度缓慢， 或者最终用户认为不好。</p>
<p>46 缺陷的产生主要有哪些原因？最主要的原因是什么？</p>
<p>需求频繁变更、沟通不良、不了解客户的需求、实现新功能或很酷的功能、追求新技术、 项目期限的压力、需求分析或设计投入的时间和精力不够、产品的复杂度、开发人员疲劳、 压力过大或受到干扰、缺乏足够的知识、技能和经验、缺乏动力等。 最主要的原因：需求方面的原因</p>
<p>47 当你发现一个缺陷时，应该怎么确认的确是一个缺陷？</p>
<p>根据缺陷的判断原则来甄别发现的问题是不是一个缺陷，发现缺陷后，应该做好分离和 再现（3 次），然后才能提交。</p>
<p>48 在正式提交一个缺陷前，你应该做些什么？</p>
<p>分离缺陷、再现缺陷（3 次），然后才能提交。</p>
<p>49 怎么处理无法再现的缺陷？ 首先，应当对这样的缺陷进行详细的记录，并尽快提交给开发人员。 其次，对于寻找难以再现的缺陷要合理地安排时间，对一时难以再现的缺陷可以暂时搁 置，以保证项目的正常进度。 最后，在测试过程中对未再现缺陷予以关注。</p>
<p>50 什么是重复缺陷？怎么避免重复缺陷？</p>
<p>提交了一个缺陷库中存在或者开发人员已经知道的缺陷。</p>
<p>1、如果缺陷是跟同事提交的重复，任务分工解决，也可以在提交之前查询下库缺陷是 否存在。</p>
<p>2、如果缺陷是与自己提交的缺陷重复，则需要提高发现缺陷的能力，通过提高开发能 力来理解两个缺陷本质上是一个缺陷。</p>
<p>51 什么是无效缺陷？怎么避免无效缺陷？</p>
<p>提交的缺陷不是真正的缺陷。 充分了解需求、提高自己识别缺陷的能力、提高缺陷写作能力 52 缺陷报告的写作准则是什么？ Correct（准确）：每个组成部分的描述准确，不会引起误解； Clear（清晰）：每个组成部分的描述清晰，易于理解； Concise（简洁）：只包含必不可少的信息，不包括任何多余的内容； Complete（完整）：包含复现该缺陷的完整步骤和其他本质信息； Consistent（一致）：按照一致的格式书写全部缺陷报告。</p>
<p>53 缺陷报告的内容有哪些？</p>
<p>缺陷标题（或者说缺陷摘要、缺陷概述、缺陷基本信息） 预处理 复现步骤 预期结果 实际结果 严重程度 优先级 测试环境 测试版本 测试执行人 注释</p>
<p>54 缺陷报告的组织结构是什么？</p>
<p>缺陷标题（或者说缺陷摘要、缺陷概述、缺陷基本信息） 预处理 复现步骤 预期结果 实际结果 严重程度 优先级 测试环境 测试版本 测试执行人 注释</p>
<p>55 缺陷报告的写作需要注意什么问题？</p>
<p>不要使用我、你、他等字眼，不要使用情绪化的语言和强调符号、不要使用“似乎”、 看上去可能等不确定性内容、不要使用认为比较幽默的内容、不要使用不确定的测试问题(不 确定是否是缺陷)、不要人身攻击。</p>
<p>56 简述缺陷报告的处理流程 软件测试人员提交缺陷报告；</p>
<p>测试负责人审核后将缺陷报告分配给相关的开发人员修改； 缺陷被修改后由测试人员根据缺陷报告中的修改记录进行返测 返测通过的缺陷报告由负责人关闭； 返测未通过的缺陷报告直接返回开发人员重新修改，然后再由测试人员返测，直到测试 和开发达成一致处理意见。</p>
<p>57 简述缺陷的生命周期 软件测试人员提交缺陷报告；</p>
<p>测试负责人审核后将缺陷报告分配给相关的开发人员修改； 缺陷被修改后由测试人员根据缺陷报告中的修改记录进行返测 返测通过的缺陷报告由负责人关闭； 返测未通过的缺陷报告直接返回开发人员重新修改，然后再由测试人员返测，直到测试 和开发达成一致处理意见。</p>
<p>58 简述重复缺陷的处理流程</p>
<p>提交缺陷→分配缺陷→是重复缺陷→置为无效缺陷。</p>
<p>59 缺陷按照严重程度可以分为哪些类型？</p>
<p>致命缺陷、严重缺陷、一般缺陷、较小错误、意见建议等</p>
<p>60 缺陷按照优先级可以分为哪些类型？ 缺陷必须立即解决； 缺陷需要正常排队等待修复或列入软件发布清单； 缺陷可以在方便时被纠正； 下一个版本修复； 不修复。</p>
<p>61 缺陷的状态有哪些？</p>
<p>新建&#x2F;已提交 打开已拒绝 已解决&#x2F;已修复 已验证 已关闭</p>
<p>62 测试有哪些级别？</p>
<p>单元测试、集成测试、系统测试、验收测试</p>
<p>63 测试有哪些阶段？</p>
<p>单元测试、集成测试、系统测试、验收测试</p>
<p>64 什么是单元测试？</p>
<p>单元测试谁来做？ 针对一个软件单元的测试。开发人员或懂开发的测试人员</p>
<p>65 什么是桩模块、驱动模块？</p>
<p>桩模块：被被测模块调用的模块。 驱动模块：调用被测模块的模块。</p>
<p>66 什么时候可以进行组件测试？</p>
<p>完成编译的测试对象，测试环境，开发工具，测试对象的规范说明书。</p>
<p>67 单元测试使用技术？测试重点是什么？测试条件是什么？</p>
<p>单元测试的技术：黑盒白盒技术，但是白盒居多，黑盒居少，一般先做黑盒再做白盒。 单元测试重点：功能性测试，健壮性（逆向测试：无效值），性能。 单元测试前提条件：完成编译的测试对象，测试环境，开发工具，测试对象的规范说明 书。</p>
<p>68 什么是集成测试？</p>
<p>组件间的接口与交互的测试。</p>
<p>69 集成测试的测试重点是什么？测试条件是什么？使用什么技术？</p>
<p>接口和系统内不同部分的相互作用（交互）。 测试条件是完成集成的被测系统，测试台，有关组件间交互的文档。 测试技术包括白盒技术、黑盒技术，白盒居多，黑盒居少，对比单元测试，白盒下降， 一般先做黑盒再做白盒。</p>
<p>70 集成测试有哪些策略？</p>
<p>自顶向下集成 自底向上集成</p>
<p>71 什么是系统测试？</p>
<p>对整个系统能不能满足用户需求的测试。</p>
<p>72 系统测试的目的是什么？</p>
<p>检查软件是否满足需求。</p>
<p>73 系统测试能够发现哪些缺陷？会遗留哪些缺陷？ 发现：非功能性缺陷、涉及整个系统的问题。 遗漏：对用户的需求的错误理解、没有实现或者没有完全实现用户的隐性需求。</p>
<p>74 什么是验收测试？ 一般由用户&#x2F;客户进行的确认是否可以接受一个系统的验证性测试。验收测试根据用户 需求，业务流程进行的正式测试以确保系统符合所有验收的准则。</p>
<p>75 验收测试有哪些人进行？ 客户或用户，测试人员可以介入。</p>
<p>76 验收测试的目标是什么？</p>
<p>对系统或子系统建立信心、对系统非功能性的特性赢得信任。</p>
<p>77 什么是 alpha、beta 测试？有何区别？</p>
<p>Alpha 测试：潜在的客户&#x2F;用户在开发场地进行的测试。 Beta 测试：由潜在客户&#x2F;用户在自己的环境下测试软件系统。</p>
<p>78 什么是维护测试？ 软件正常使用后，对软件的变更、更新进行测试</p>
<p>79 什么是性能测试？负载测试？压力测试？有什么区别？</p>
<p>性能表现处理速度、响应时间、CPU 使用、内存使用、硬盘使用等。 负载测试：通过不断增加负载来测试一个系统的性能。 压力测试：通过增加负载超过系统正常工作能力来考察系统能否在异常情况下正常工作</p>
<p>80 什么是功能测试？</p>
<p>测试一个软件能做什么，是不是做了应该做的工作，没做不该做的工作。</p>
<p>81 什么是结构测试？</p>
<p>白盒测试也称结构测试、逻辑驱动测试、基于程序本身的测试，是对程序结构进行的测 试。</p>
<p>82 什么是与变更相关的测试？</p>
<p>有哪些具体类型？ 与变更相关的测试是对修改过的程序进行的测试。 确认测试（再测试）和回归测试。</p>
<p>83 什么是静态测试？动态测试？如何区分二者？</p>
<p>静态测试：不执行程序的测试。针对文档和不需执行的代码。动态测试需要执行程序，方法一般采用黑盒测试方法和白盒测试方法。</p>
<p>84 圈复杂度怎么计算？</p>
<p>不重叠的闭合环数+1</p>
<p>85 什么是黑盒测试？白盒测试？</p>
<p>黑盒测试也称功能测试，基于规格说明书的测试，关注输入数据到程序中，输出结果是 否正确，侧重于测试软件能做什么 白盒测试也称结构测试、逻辑驱动测试，是对程序内部逻辑结构进行的测试</p>
<p>86 白盒测试有哪些方法？具体解释每种方法？</p>
<p>白盒测试主要使用逻辑覆盖测试方法，包括语句覆盖、判定覆盖、条件覆盖、判定-条 件覆盖、条件组合覆盖、路径覆盖等。 语句覆盖：程序中的每个可执行语句至少被执行一次。能发现语句错误，但不能发现逻 辑错误。判定覆盖：也称分支覆盖，程序中的每个判定的取真分支和取假分支至少执行一次。能 发现逻辑错误，但不能发现组合判断中的条件错误。 条件覆盖：程序每个判定中每个条件的可能取值至少满足一次。能发现条件错误，但不 能发现逻辑错误。 判定-条件覆盖：每个条件中的所有可能取值至少执行一次，同时，每个判定的可能结 果至少执行一次。 条件组合覆盖：每个判定中的所有的条件取值组合至少执行一次。 路径覆盖：用例覆盖程序中的所有可能的执行路径。如果路径数很多，会变得不切实际。</p>
<p>87 什么是配置测试？</p>
<p>不同配置环境下进行测试。</p>
<p>88 什么是文档测试？</p>
<p>不仅包括测试文档校对，还有文档和软件不一致</p>
<p>89 什么是国际化测试？本地化测试？</p>
<p>国际性的软件 翻译成本国语言的，测试是否符合本国的语言习惯，是否符合本国法律，是否符合本国 的国情。</p>
<p>90 测试用例的内容是什么？</p>
<p>用例编号，测试概述或用例标题、测试步骤，预期结果，输入数据，优先级，前置条件 等</p>
<p>91 测试用例有哪些元素？</p>
<p>用例编号，测试概述或用例标题、测试步骤，预期结果，输入数据，优先级，前置条件 等 或者说测试目标 Why、测试对象 What、测试环境要求 Where、测试前提 When，输入 数据</p>
<p>92 什么是 UI、GUI？UI 测试什么意思？</p>
<p>界面图形界面 界面测试</p>
<p>93 测试用例的优先级如何？</p>
<p>冒烟测试 高中低</p>
<p>94 解释测试目标、测试环境、测试对象、前置条件、测试策略、测 试范围的含义？</p>
<p>测试目标：功能测试、性能测试、界面测试、易用性测试、兼容性测试、安全性测试 测试策略：某类别测试的过程、方法以及方法如何应用，测试的注意事项等 测试环境：硬件环境、软件环境、网络环境 前置条件：进行某些测试工作需要做好的准备条件 测试范围：软件需要测试的某个部位</p>
<p>95 用例评审一般使用什么方式？</p>
<p>哪些人参与评审？ 检查单。一般由测试人员进行</p>
<p>96 测试计划由谁编写？测试需求说明书由谁编写？测试用例谁编 写？测试总结谁编写？</p>
<p>测试负责人。测试人员（测试需求分析人员）。测试人员（测试设计工程师）。测试负责 人</p>
<p>97 软件投入运行后还需要测试吗？需要哪些测试？</p>
<p>需要测试。维护测试（含升级测试）、数据迁移测试、备份恢复测试、灾难恢复测试等</p>
<p>98 SP2 什么意思？</p>
<p>第 2 个版本的服务包或补丁包</p>
<p>99 给你一个网站，你如何测试？</p>
<p>首先，查找需求说明、网站设计等相关文档，分析测试需求。 制定测试计划，确定测试范围和测试策略，一般包括以下几个部分：功能性测试、界 面测试、性能测试、数据库测试、安全性测试、兼容性测试。</p>
<p>设计测试用例：</p>
<p> 功能性测试可以包括，但不限于以下几个方面：</p>
<p> 链接测试。链接是否正确跳转，是否存在空页面和无效页面，是否有不正确 的出错信息返回。</p>
<p> 提交功能的测试。</p>
<p> 多媒体元素是否可以正确加载和显示。</p>
<p> 多语言支持是否能够正确显示选择的语言等。  界面测试可以包括但不限于一下几个方面：</p>
<p> 页面是否风格统一，美观</p>
<p> 页面布局是否合理，重点内容和热点内容是否突出</p>
<p> 控件是否正常使用</p>
<p> 对于必须但未安装的控件，是否提供自动下载并安装的功能</p>
<p> 文字检查</p>
<p> 性能测试一般从以下两个方面考虑：</p>
<p> 压力测试、负载测试</p>
<p> 数据库测试要具体决定是否需要开展。</p>
<p> 数据库一般需要考虑连结性，对数据的存取操作，数据内容的验证等方面。</p>
<p> 安全性测试：</p>
<p> 基本的登录功能的检查</p>
<p> 是否存在溢出错误，导致系统崩溃或者权限泄露</p>
<p> 相关开发语言的常见安全性问题检查，例如 SQL 注入等</p>
<p> 兼容性测试，根据需求说明的内容，确定支持的平台组合：</p>
<p> 浏览器的兼容性；</p>
<p> 操作系统的兼容性；</p>
<p> 软件平台的兼容性；</p>
<p> 数据库的兼容性</p>
<p> 开展测试，并记录缺陷。</p>
<p> 合理的安排调整测试进度，提前获取测试所需的资源，建立管理体系（例如，需 求变更、风险、配置、测试文档、缺陷报告、人力资源等内容）。</p>
<p> 定期评审，对测试进行评估和总结，调整测试的内容。</p>
<p>100 一台客户端有三百个客户与三百个客户端有三百个客户对服务 器施压，有什么区别?</p>
<p> 300 个用户在一个客户端上</p>
<p> 会占用客户机更多的资源，而影响测试的结果。线程之间可能发生干扰，而产生 一些异常。</p>
<p> 需要更大的带宽。</p>
<p> IP 地址的问题，可能需要使用 IP 欺骗来绕过服务器对于单一 IP 地址最大连接 数的限制。</p>
<p> 不必考虑分布式管理的问题。</p>
<p> 用户分布在不同的客户端上</p>
<p> 需要考虑使用控制器来整体调配不同客户机上的用户。</p>
<p> 需要给予相应的权限配置和防火墙设置。</p>
<p>最后：<br>一线互联网 软件测试 的高级进阶路线思维图</p>
<p>看完这篇内容后，相信以下两件事，也会对你的个人提升有所帮助：</p>
<p>1、 点赞，让更多人能看到这篇文章，同时你的认可也会鼓励我创作更多优质内容。</p>
<p>2、 让自己变得更强：想一想，如果你想在测试这个行业一直做下去，你的经验和测试技术是远远不够的，你需要进阶，你需要丰富你的技术栈！还等什么！<br><br /></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试面试题含答案:WEB+网络|接口测试|性能测试|自动化测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%AB%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<p>一、WEB+网络<br>http代码表，常考题目<br>404：找不到资源</p>
<p>500：服务器内部错误，无法完成请求。</p>
<p>501：服务器不支持请求的功能，无法完成请求。</p>
<p>502：充当网关或代理的服务器，从远端服务器接收到了一个无效的请求。</p>
<p>301：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI，今后任何新的请求都应使用新的URI代替。</p>
<p>302：临时移动。与301类似。但资源只是临时被移动，客户端应继续使用原有URI。</p>
<p>200：成功。</p>
<p>TCP&#x2F;IP四层网络模型<br>链路层、网络层、传输层、应用层。</p>
<p>TCP&#x2F;UDP区别？<br>TCP：可靠传输协议，需要三次握手连接，有确认重传机制，特点是可靠、准确、有拥塞控制，缺点就是比较慢，传输量比较小，适用于升级、下载；一句话：TCP是可靠的传输。</p>
<p>UDP：不可靠传输协议，面向非连接的协议，优点是传输量大、速度快，缺点是已丢失、没有拥塞控制，适用于直播、视频等。一句话：UDP是不可靠的传输。</p>
<p>html css js运行的先后顺序是什么？<br>界面加载的时候先加载html在加载css最后加载js</p>
<p>session和cookie的区别是什么</p>
<p>session存放在服务器端用来校验客户端的身份</p>
<p>cookie存放在客户端，每次从客户端往服务器发请求时，将cookie带到服务器端，用来校验客户端的身份</p>
<p>二、接口测试</p>
<ol>
<li>怎么用JMeter测试接口？<br> 如果使用JMeter进行接口测试：</li>
</ol>
<p>测试前了解需求，根据接口规格说明书梳理业务；</p>
<p>接下来设计用例，分析接口的入参和出参，分清楚有哪些有效输入和无效输入，设计用例(原则：用最少的用例覆盖所有有效输入，针对每一个无效的输入设计一个测试用例，如果有错误码没有覆盖到，还要对每个未覆盖的错误码分别设计一个用例)；</p>
<p>准备测试数据，比如：测试所需的账号、密码、key 等信息；</p>
<p>打开JMeter，创建一个线程组，根据接口类型，填写好对应的接口地址和请求方式等；</p>
<p>参数化配置，添加配置元件CSV Data Set Config，定义变量，并准备CSV格式的数据，变量的引用用${变量名}的格式；</p>
<p>添加断言来判断测试结果的正确性，用得最多的是响应断言；</p>
<p>添加监听器，比如查看结果树，对测试结果进行监听；</p>
<p>运行测试用例；</p>
<p>查看监听器结果，来判断用例的执行是成功还是失败，针对失败的用例，分析其失败原因；</p>
<p>针对测试中发现的问题，给开发提单，直到问题最终解决。</p>
<p>最后输出测试报告。</p>
<ol start="2">
<li>怎么用Postman测试接口？<br> 如果使用Postman测试接口：</li>
</ol>
<p>其中1,2,3点相同，工具使用方面则比JMeter跟简单，工具的主要的步骤是添加对应的请求、填写主机URL及入参、添加测试套、运行测试套、分析结果出报告。</p>
<ol start="3">
<li>在JMeter上如何把上一个请求的结果作为下一个请求的参数？<br> 使用正则表达式提取器提取上一个请求的响应中的信息，保存一个引用名称比如abc，在下一个请求的参数中，用${abc}的格式来引用提取的结果。</li>
</ol>
<p>常用的正则表达式格式：(.+?)，其中.表示匹配任意字符串，+表示只匹配一次，？表示匹配到就停下来。</p>
<p>三、 性能测试<br>一般是我们功能测试完成最后两三天时间测试性能。</p>
<p>1、先是分析需求计算出并发数，TPS，响应时间和 CPU，内存，硬盘和网络IO这些指标。</p>
<p>2、制定测试方案，主要包括环境，计划和具体测试那些场景（如可靠性，并发，负载，压力测试等）</p>
<p>3、根据场景用Badboy录制脚本，导出为JMeter工具支持的脚本。</p>
<p>4、用JMeter工具打开脚本，进行脚本调试，加一些断言，监听器，参数化等。</p>
<p>5、接下来执行性能测试，然后主要收集监听器和收集服务器CPU，内存，硬盘和网络IO等分析是否满足需求，如果满足就输出性能测试报告。</p>
<p>6、如果指标不能满足，反馈给开发进行调优。调优后继续测试，一直到满足需求后最终输出测试报告。</p>
<p>四、自动化测试</p>
<ol>
<li>Python怎么定义一个函数？<br> 你可以定义一个由自己想要功能的函数，以下是简单的规则：</li>
</ol>
<p>函数代码块以def关键词开头，后接函数标识符名称和圆括号()。</p>
<p>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</p>
<p>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</p>
<p>函数内容以冒号起始，并且缩进</p>
<p>return[表达式]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回None</p>
<p>2 Python切片<br>list1&#x3D;[sa,fe,faw,ve,eta,t]</p>
<p>list1[2:5]</p>
<p>list1[2:]</p>
<p>list1[:]</p>
<p>list1[20:]</p>
<p>得到的是[ ]</p>
<ol start="3">
<li>Python上用过什么库&#x2F;模块？<br> webdriver：定位和操作元素</li>
</ol>
<p>time：设置等待时间</p>
<p>ActionChains：动作链，完成鼠标的相关操作</p>
<p>Keys：键盘的相关操作</p>
<p>WebDriverWait：设置显式等待</p>
<p>Expect_Conditions：针对单个元素，设置显式等待的场景</p>
<p>PIL：截图</p>
<p>Select：下拉选择框的操作</p>
<p>unittest python：自带的单元测试框架</p>
<p>HTMLTestRunner：运行脚本，生成报告</p>
<p>ddt：实现数据驱动测试，行为和数据分离</p>
<ol start="4">
<li>你做过自动化测试吗？<br> 我在上一份工作中，公司去年下半年也开始规划做Web 自动化，采用Python作为开发语言，通过Selenium WebDriver定位和操作页面元素，自动化框架用的是unittest。我主要负责写测试脚本。</li>
</ol>
<p>假设一个测试团队有5个人：1资深(测试经理)+2~3个中级(自动化+手动)+1 个初级(手动)</p>
<ol start="5">
<li>使用什么工具进行的自动化测试<br> 使用的工具是Selenium（Web自动化工具）</li>
<li>用的什么编程语言<br> 用的Python</li>
<li>Selenium 用的是哪个版本的的？Python用的是哪个版本的？<br> 用的是selenium 3.11.0和Python2.7.10</li>
<li>Selenium的工作原理？<br> 1）对html元素定位</li>
</ol>
<p>2）模拟对第一步定位到的元素进行点击、输入、选择等操作一句话：定位元素，操作元素。</p>
<ol start="9">
<li>元素定位方法有哪些？<br> 要点：8种定位方法</li>
</ol>
<p>根据元素的属性值定位，比如 id、name、class、标签名、链接文字和部分链接文字；</p>
<p>根据CSS选择器定位；</p>
<p>根据 XPath 定位；</p>
<ol start="10">
<li>子页面里的元素怎么定位？<br> 先切换到框架里，然后再定位，用switch_to_frame函数根据子页面id或name，切换到子页面；定位完了如果要再定位主页面的元素，要用switch_to_default_content 函数先返回主页面。</li>
<li>怎么定位alert弹窗？或者这样问：怎么处理JS原生窗口？<br> 要点：主要涉及点击弹窗确认按钮、强行关闭弹窗、获取弹窗中的文字等操作。</li>
</ol>
<p>点击弹窗的确定按钮，用如下函数：<br>driver.switch_to_alert().accept()</p>
<p>强行关闭，点击右上角的叉叉，用如下函数：<br>driver.switch_to_alert().dismiss()</p>
<p>获取弹窗里的文字，用如下函数：<br>driver.switch_to_alert().text</p>
<ol start="12">
<li>怎么运行自动化用例并生成测试报告？<br> 以unittest为例，我通常的做法是把用例加载到测试套中，做成一个脚本，在命令窗口下运行脚本，报告的生成用第三方模块HTML TestRunner来生成。</li>
<li>怎么定位&#x2F;操作图片中的验证码？<br> 用tesseract OCR引擎处理图片中的验证码，步骤：</li>
</ol>
<p>（1）对整个屏幕截屏，保存成png格式的图片；</p>
<p>（2）在截取的图片中定位验证码图片的位置坐标；</p>
<p>（3）根据坐标对验证码截图；</p>
<p>（4）在图片中提取验证码，输入到输入框。</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Api接口自动化测试框架一</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/02_API%E8%87%AA%E5%8A%A8%E5%8C%96/api%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6/02_Python_Api%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%B8%80/</url>
    <content><![CDATA[<p>公司内部的一个接口自动化使用框架（非使用工具）</p>
<p>　　<a href="javascript:;"><strong>工作</strong></a>原理: <a href="javascript:;"></a><strong><a href="javascript:;"><strong>测试</strong></a>用例</strong>在excel上编辑，使用第三方库xlrd，读取表格sheet和内容，sheetName对应模块名，Jenkins集成服务发现服务moduleName查找对应表单，运用第三方库requests请求接口，根据结果和期望值进行断言，根据输出报告判断<a href="javascript:;"><strong>接口测试</strong></a>是否通过。</p>
<p>　**　1. 数据准备**</p>
<p>　　数据插入（容易实现的测试场景下所需外部数据)</p>
<p>　　准备<a href="javascript:;"><strong>sql</strong></a> （接口需要重复使用，参数一定得是变量)</p>
<p>　**　2.集成部署(运维相关了解即可)**</p>
<p>　　平滑升级验证脚本加入自动化</p>
<p>　**　3.自动化框架实现**</p>
<p>　　●调用mysql</p>
<p>　　●excel遍历测试用例</p>
<p>　　●requests实现接口调用</p>
<p>　　●根据接口返回的code值和Excel对比</p>
<p>　　●报告反馈</p>
<p>　　●暴露服务</p>
<p>　　<strong>写一个简单登录的接口<a href="javascript:;"><strong>自动化测试</strong></a></strong></p>
<p>　　代码的分层如下图：</p>
<p><a href="http://www.51testing.com/batch.download.php?aid=73948"><img src="/assets/2/image-20220516200437-vaxneq1.png" alt="image.png"></a></p>
<p>　　coding.png</p>
<p>　　<strong>一、写一个封装的获取excel表格的模块</strong></p>
<p><a href="http://www.51testing.com/batch.download.php?aid=73949"><img src="/assets/2/image-20220516200443-b6aqkhe.png" alt="image.png"></a></p>
<p>　　excel.png</p>
<p>　　代码实现如下：</p>
<table>
<thead>
<tr>
<th># !&#x2F;usr&#x2F;bin&#x2F;python# -<em>- coding: UTF-8 -</em>-# 基础包：excel的封装import xlrdworkbook &#x3D; Nonedef open_excel(path):”””打开excel”””global workbookif (workbook &#x3D;&#x3D; None):workbook &#x3D; xlrd.open_workbook(path, on_demand&#x3D;True)def get_sheet(sheetName):”””获取页名”””global workbookreturn workbook.sheet_by_name(sheetName)def get_rows(sheet):”””获取行号”””return sheet.nrowsdef get_content(sheet, row, col):”””获取表格中内容”””return sheet.cell(row, col).valuedef release(path):”””释放excel减少内存”””global workbookworkbook.release_resources()del workbook</th>
</tr>
</thead>
</table>
<p>　　代码封装后当成模块引用，这还是最开始呢。</p>
<p>　　<strong>二、引用log模块获取日志</strong></p>
<p>　　准备工作：</p>
<p>　　需要一个日志的捕获，包括框架和源码抛出的expection。</p>
<p>　　代码如下：</p>
<table>
<thead>
<tr>
<th>#!&#x2F;usr&#x2F;bin&#x2F;python# -<em>- coding: UTF-8 -</em>-# 基础包：日志服务import loggingimport timedef getLogger():global tezLogPathtry:tezLogPathexcept NameError:tezLogPath &#x3D; “&#x2F;data&#x2F;log&#x2F;apiTest&#x2F;“FORMAT &#x3D; ‘%(asctime)s - %(name)s - %(levelname)s - %(message)s’# file &#x3D; tezLogPath + time.strftime(“%Y-%m-%d”, time.localtime()) + “.log”# logging.basicConfig(filename&#x3D;file, level&#x3D;logging.INFO, format&#x3D;FORMAT)# 开发阶段为了方便调试，可不输出到文件logging.basicConfig(level&#x3D;logging.INFO, format&#x3D;FORMAT)return logging</th>
</tr>
</thead>
</table>
<p>　　<strong>三、引用requests模块接口测试</strong></p>
<p>　　准备工作：</p>
<p>　　需要的请求类型和执行测试的方法。</p>
<p>　　代码如下：</p>
<table>
<thead>
<tr>
<th>#!&#x2F;usr&#x2F;bin&#x2F;python##-<em>- coding: UTF-8 -</em>-# 基础包：接口测试的封装import requestsimport tezLog as loglogging &#x3D; log.getLogger()def api_test(method, url, data ,headers):”””定义一个请求接口的方法和需要的参数:Args:method  - 企业名称 strurl - 用户昵称 strdata - 参数 strheaders - 请求头信息 dict非RESTful API请求另外的请求类型实际用不到。也不安全。”””try:if method &#x3D;&#x3D; “post”:results &#x3D; requests.post(url, data, headers&#x3D;headers)if method &#x3D;&#x3D; “get”:results &#x3D; requests.get(url, data, headers&#x3D;headers)# if method &#x3D;&#x3D; “put”:#     results &#x3D; requests.put(url, data, headers&#x3D;headers)# if method &#x3D;&#x3D; “delete”:#     results &#x3D; requests.delete(url, headers&#x3D;headers)# if method &#x3D;&#x3D; “patch”:#     results &#x3D;&#x3D; requests.patch(url, data, headers&#x3D;headers)# if method &#x3D;&#x3D; “options”:#     results &#x3D;&#x3D; requests.options(url, headers&#x3D;headers)response &#x3D; results.json()code &#x3D; response.get(“code”)return codeexcept Exception, e:logging.error(“service is error”, e)</th>
</tr>
</thead>
</table>
<p>　**　四、关于common模块**</p>
<p>　　主要调用二次封装的代码，结合业务做一个通用代码。如下：</p>
<table>
<thead>
<tr>
<th>#!&#x2F;usr&#x2F;bin&#x2F;python# -<em>- coding: UTF-8 -</em>-# 业务包：通用函数import core.tezMysql as mysqlimport core.tezLog as logimport glimport core.tezExcel as excelimport core.tezRequest as requestfrom prettytable import PrettyTablefilename &#x3D; gl.FILE_NAMElogging &#x3D; log.get_logger()def prepare_data(host, user, password, db, sql):”””数据准备，添加测试数据”””mysql.connect(host, user, password, db)res &#x3D; mysql.execute(sql)mysql.close()logging.info(“Run sql: the row number affected is %s”, res)return resdef get_excel_sheet(path, module):”””依据模块名获取sheet”””excel.open_excel(path)return excel.get_sheet(module)def replace_holder(value):”””遍历字典替换占位符”””for holder in gl.PLACE_HOLDER:value &#x3D; value.replace(holder, gl.PLACE_HOLDER[holder])return valuedef get_prepare_sql(sheet):”””获取预执行SQL”””return replace_holder(excel.get_content(sheet, gl.SQL_ROW,     gl.SQL_COL))def run_test(sheet, url):”””再执行测试用例”””rows &#x3D; excel.get_rows(sheet)fail &#x3D; 0for i in range(2, rows):testNumber &#x3D; str(int(excel.get_content(sheet, i, gl.CASE_NUMBER)))testData &#x3D; excel.get_content(sheet, i, gl.CASE_DATA)testName &#x3D; excel.get_content(sheet, i, gl.CASE_NAME)testUrl &#x3D; excel.get_content(sheet, i, gl.CASE_URL)testUrl &#x3D; url + testUrltestMethod &#x3D; excel.get_content(sheet, i, gl.CASE_METHOD)testHeaders &#x3D; str(excel.get_content(sheet, i, gl.CASE_HEADERS))testHeaders &#x3D; eval(replace_holder(testHeaders))testCode &#x3D; excel.get_content(sheet, i, gl.CASE_CODE)actualCode &#x3D; request.api_test(testMethod, testUrl, testData, testHeaders)expectCode &#x3D; str(int(testCode))failResults &#x3D; PrettyTable([“Number”, “Method”, “Url”, “Data”, “ActualCode”, “ExpectCode”])failResults.align[“Number”] &#x3D; “l”failResults.padding_width &#x3D; 1failResults.add_row([testNumber, testMethod, testUrl, testData, actualCode, expectCode])if actualCode !&#x3D; expectCode:logging.info(“FailCase %s”, testName)print “FailureInfo”print failResultsfail +&#x3D; 1else:logging.info(“Number %s”, testNumber)logging.info(“TrueCase %s”, testName)if fail &gt; 0:return Falsereturn True</th>
</tr>
</thead>
</table>
<p>　**　五、关于参数中gl模块**</p>
<p>　　准备工作：</p>
<p>　　所有的参数和常量我们会整理到这个文件中，因为设计业务和服务密码、<a href="javascript:;"><strong>数据库</strong></a>密码这里展示一部分。</p>
<p>　　代码如下：</p>
<table>
<thead>
<tr>
<th>#!&#x2F;usr&#x2F;bin&#x2F;python# -<em>- coding: UTF-8 -</em>-# 脚本功能：全部变量import timeimport uuidCASE_NUMBER &#x3D; 0  # 用例编号CASE_NAME &#x3D; 1    # 用例名称CASE_DATA &#x3D; 2    # 用例参数CASE_URL &#x3D; 3     # 用例接口地址CASE_METHOD &#x3D; 4  # 用例请求类型CASE_CODE &#x3D; 5    # 用例codeCASE_HEADERS &#x3D; 6 # 用例headersSQL_ROW &#x3D; 0      # 预执行SQL的行号SQL_COL &#x3D; 1      # 预执行SQL的列号</th>
</tr>
</thead>
</table>
<p>　　<strong>六、写一个run文件：只是用来执行的，业务和代码剥离。</strong></p>
<p>　　代码如下：</p>
<table>
<thead>
<tr>
<th>#!&#x2F;usr&#x2F;bin&#x2F;python# -<em>- coding: UTF-8 -</em>-# 验证包：接口测试脚本import sysimport core.tezLog as logimport function.common as commonlogging &#x3D; log.getLogger()”””1.外部输入参数”””path &#x3D; sys.path[0]      # 当前路径module &#x3D; sys.argv[1]    # 服务模块名url &#x3D; sys.argv[2]       # 服务地址host &#x3D; sys.argv[3]      # 数据库地址user &#x3D; sys.argv[4]      # 数据库用户名password &#x3D; sys.argv[5]  # 数据库密码db &#x3D; sys.argv[6]        # 数据库名称”””2.根据module获取Sheet”””logging.info(“————– Execute TestCases —————“)sheet &#x3D; common.get_excel_sheet(path + “&#x2F;“ + common.filename,  module)”””3.数据准备”””logging.info(“————– Prepare data through MysqlDB ————–”)sql &#x3D; common.get_prepare_sql(sheet)common.prepare_data(host&#x3D;host, user&#x3D;user, password&#x3D;password, db&#x3D;db, sql&#x3D;sql)”””4.执行测试用例”””res &#x3D; common.run(sheet, url)logging.info(“————– Get the result ———— %s”, res)”””这里的res是我们平滑升级的时候需要返回结果为TRUE才会继续下面走。”””</th>
</tr>
</thead>
</table>
<p>　**　七、查看测试报告（部署到jenkins会通过控制台查看）**</p>
<p><img src="/assets/2/image-20220516200449-cdlnofc.png" alt="image.png"></p>
<p>　　报告.png</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>02_API自动化</category>
        <category>api自动化框架</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>API自动化-http</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/02_API%E8%87%AA%E5%8A%A8%E5%8C%96/api%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6/01_http/</url>
    <content><![CDATA[<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><h2 id="Web及网络基础"><a href="#Web及网络基础" class="headerlink" title="Web及网络基础"></a>Web及网络基础</h2><h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><h4 id="URI：统一资源标识符"><a href="#URI：统一资源标识符" class="headerlink" title="URI：统一资源标识符"></a>URI：统一资源标识符</h4><h5 id="URI是由某个协议方案表示的资源（这里的资源为任意类型的的文件）的定位标识符"><a href="#URI是由某个协议方案表示的资源（这里的资源为任意类型的的文件）的定位标识符" class="headerlink" title="URI是由某个协议方案表示的资源（这里的资源为任意类型的的文件）的定位标识符"></a>URI是由某个协议方案表示的资源（这里的资源为任意类型的的文件）的定位标识符</h5><h5 id="常见协议方案：http、ftp（文件传输）、mailto、file等"><a href="#常见协议方案：http、ftp（文件传输）、mailto、file等" class="headerlink" title="常见协议方案：http、ftp（文件传输）、mailto、file等"></a>常见协议方案：http、ftp（文件传输）、mailto、file等</h5><h4 id="URL格式"><a href="#URL格式" class="headerlink" title="URL格式"></a>URL格式</h4><h6 id="协议方案名"><a href="#协议方案名" class="headerlink" title="协议方案名"></a>协议方案名</h6><p>####### 使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不 区分字母大小写，最后附一个冒号（:）。 </p>
<h6 id="登录信息（认证）"><a href="#登录信息（认证）" class="headerlink" title="登录信息（认证）"></a>登录信息（认证）</h6><p>####### 分支主指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份 认证）。此项是可选项。<br>题</p>
<h6 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h6><p>####### 使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址 名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。</p>
<h6 id="服务器端口号"><a href="#服务器端口号" class="headerlink" title="服务器端口号"></a>服务器端口号</h6><p>####### 指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动 使用默认端口号</p>
<h6 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h6><p>####### 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参 数。此项可选</p>
<h6 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h6><p>####### 使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个 位置），为可选 项。</p>
<h4 id="URI：用字符串标识某一个互联网资源"><a href="#URI：用字符串标识某一个互联网资源" class="headerlink" title="URI：用字符串标识某一个互联网资源"></a>URI：用字符串标识某一个互联网资源</h4><p>URL：表示资源的地点（互联网所处的位置）<br>URL是URI的子集</p>
<h3 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><h4 id="通常使用的网络是在TCP-x2F-IP协议族的基础上运行的，HTTP属于它内部的一个子集"><a href="#通常使用的网络是在TCP-x2F-IP协议族的基础上运行的，HTTP属于它内部的一个子集" class="headerlink" title="通常使用的网络是在TCP&#x2F;IP协议族的基础上运行的，HTTP属于它内部的一个子集"></a>通常使用的网络是在TCP&#x2F;IP协议族的基础上运行的，HTTP属于它内部的一个子集</h4><h4 id="TCP-x2F-IP协议族概述"><a href="#TCP-x2F-IP协议族概述" class="headerlink" title="TCP&#x2F;IP协议族概述"></a>TCP&#x2F;IP协议族概述</h4><h5 id="网络通讯中需要遵守各种的协议，协议集合的总称就为TCP-x2F-IP"><a href="#网络通讯中需要遵守各种的协议，协议集合的总称就为TCP-x2F-IP" class="headerlink" title="网络通讯中需要遵守各种的协议，协议集合的总称就为TCP&#x2F;IP"></a>网络通讯中需要遵守各种的协议，协议集合的总称就为TCP&#x2F;IP</h5><h4 id="TCP-x2F-IP分层管理"><a href="#TCP-x2F-IP分层管理" class="headerlink" title="TCP&#x2F;IP分层管理"></a>TCP&#x2F;IP分层管理</h4><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为封装。 </p>
<h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p>####### HTTP在这层。应用层决定了向用户提供应用服务时通信的活动。<br>TCP&#x2F;IP 协议族内预存了各类通用的应用服务。比如，FTP（文件传输协议）和 DNS（域名系统）服务就是其中两类。</p>
<h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6><p>####### 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。<br>在传输层有两个性质不同的协议：TCP（传输控制协议）和 UDP（用户数据报协议）。</p>
<h6 id="网络层（网络互连层）"><a href="#网络层（网络互连层）" class="headerlink" title="网络层（网络互连层）"></a>网络层（网络互连层）</h6><p>####### IP协议在这一层。 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。</p>
<h6 id="链路层（网络接口层）"><a href="#链路层（网络接口层）" class="headerlink" title="链路层（网络接口层）"></a>链路层（网络接口层）</h6><p>####### 用来处理连接网络的硬件部分。硬件上的范畴均在 链路层的作用范围之内。比如：光纤，网卡。</p>
<h3 id="IP、TCP、DNS协议详解"><a href="#IP、TCP、DNS协议详解" class="headerlink" title="IP、TCP、DNS协议详解"></a>IP、TCP、DNS协议详解</h3><h4 id="IP协议：负责传输，网络层。"><a href="#IP协议：负责传输，网络层。" class="headerlink" title="IP协议：负责传输，网络层。"></a>IP协议：负责传输，网络层。</h4><h5 id="IP-协议的作用是把各种数据包传送给对方。根据-IP-地址和-MAC-地址"><a href="#IP-协议的作用是把各种数据包传送给对方。根据-IP-地址和-MAC-地址" class="headerlink" title="IP 协议的作用是把各种数据包传送给对方。根据 IP 地址和 MAC 地址"></a>IP 协议的作用是把各种数据包传送给对方。根据 IP 地址和 MAC 地址</h5><p>IP间的通讯是依赖MAC地址的，在网络上，通信的双方一般要经过多个计算机和网络设备中转才能连接到对方。<br>中转:利用下一站中转设备的MAC地址来搜索下一个中转目标。通过ARP协议根据通讯方的IP地址可反查出对应的MAC地址。<br>因为要不断中转，所以经过的计算机和路由器其实都只是知道上一个和下一个中转设备，没有哪个计算机和网络设备可以知道整个传输细节。</p>
<h6 id="IP地址：IP-地址指明了节点被分配到的地址。IP地址是可变的。"><a href="#IP地址：IP-地址指明了节点被分配到的地址。IP地址是可变的。" class="headerlink" title="IP地址：IP 地址指明了节点被分配到的地址。IP地址是可变的。"></a>IP地址：IP 地址指明了节点被分配到的地址。IP地址是可变的。</h6><h6 id="MAC地址：MAC-地址是指网卡所属的固定地址。不会改变。"><a href="#MAC地址：MAC-地址是指网卡所属的固定地址。不会改变。" class="headerlink" title="MAC地址：MAC 地址是指网卡所属的固定地址。不会改变。"></a>MAC地址：MAC 地址是指网卡所属的固定地址。不会改变。</h6><h4 id="TCP协议：提供可靠的字节流服务，传输层"><a href="#TCP协议：提供可靠的字节流服务，传输层" class="headerlink" title="TCP协议：提供可靠的字节流服务，传输层"></a>TCP协议：提供可靠的字节流服务，传输层</h4><h5 id="字节流服务：是指，为了方便传输，将大-块数据-分割-成以报文段为单位的数据包进行管理"><a href="#字节流服务：是指，为了方便传输，将大-块数据-分割-成以报文段为单位的数据包进行管理" class="headerlink" title="字节流服务：是指，为了方便传输，将大 块数据 分割 成以报文段为单位的数据包进行管理"></a>字节流服务：是指，为了方便传输，将大 块数据 分割 成以报文段为单位的数据包进行管理</h5><h5 id="可靠的：为了确保数据真的传到目标，TCP协议采用了三次握手策略。"><a href="#可靠的：为了确保数据真的传到目标，TCP协议采用了三次握手策略。" class="headerlink" title="可靠的：为了确保数据真的传到目标，TCP协议采用了三次握手策略。"></a>可靠的：为了确保数据真的传到目标，TCP协议采用了三次握手策略。</h5><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><h4 id="DNS服务：DNS-协议提供通过域名-查找-IP-地址，或逆向从-IP-地址反查域名的服务。-应用层。"><a href="#DNS服务：DNS-协议提供通过域名-查找-IP-地址，或逆向从-IP-地址反查域名的服务。-应用层。" class="headerlink" title="DNS服务：DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务。  应用层。"></a>DNS服务：DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务。  应用层。</h4><h4 id="各种协议与http协议的关系"><a href="#各种协议与http协议的关系" class="headerlink" title="各种协议与http协议的关系"></a>各种协议与http协议的关系</h4><h5 id="分支主题"><a href="#分支主题" class="headerlink" title="分支主题"></a>分支主题</h5><h2 id="HTTP协议简述"><a href="#HTTP协议简述" class="headerlink" title="HTTP协议简述"></a>HTTP协议简述</h2><h3 id="HTTP协议用于客户端和服务器端之间的通讯，从一条线路来说，服务器端和客户端的角色是确定的"><a href="#HTTP协议用于客户端和服务器端之间的通讯，从一条线路来说，服务器端和客户端的角色是确定的" class="headerlink" title="HTTP协议用于客户端和服务器端之间的通讯，从一条线路来说，服务器端和客户端的角色是确定的"></a>HTTP协议用于客户端和服务器端之间的通讯，从一条线路来说，服务器端和客户端的角色是确定的</h3><h4 id="客户端：请求访问资源的一端"><a href="#客户端：请求访问资源的一端" class="headerlink" title="客户端：请求访问资源的一端"></a>客户端：请求访问资源的一端</h4><h4 id="服务器端：提供资源相应的一端"><a href="#服务器端：提供资源相应的一端" class="headerlink" title="服务器端：提供资源相应的一端"></a>服务器端：提供资源相应的一端</h4><h3 id="通过请求和响应的交换达成通讯"><a href="#通过请求和响应的交换达成通讯" class="headerlink" title="通过请求和响应的交换达成通讯"></a>通过请求和响应的交换达成通讯</h3><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><h6 id="请求行：一个"><a href="#请求行：一个" class="headerlink" title="请求行：一个"></a>请求行：一个</h6><p>####### 请求方式：HTTP协议中有7种请求方式，常见为get和post</p>
<p>其他请求方式：</p>
<p>最常用的是Get请求和post请求方式，还有一些其他的请求方式，可能服务器不会接受此方法。(了解即可)</p>
<blockquote>
<p>HEAD：只返回除了响应正文的部分，即响应头。部分服务器可能支持，也可能不支持。</p>
<p>OPTIONS:当前url所支持的方法</p>
<p>DELETE:向服务器发送一个删除资源的请求</p>
<p>PUT:向服务器发送一个提交文件的请求</p>
</blockquote>
<p>######## GET：用户如没有设置，默认情况下浏览器向服务器发送的都是get请求</p>
<p>######### 请求提交数据放在地址栏中拼接，</p>
<p>######### url的长度有限制，数据一般不超过1k，</p>
<p>######### 不太安全</p>
<p>######## POST</p>
<p>######### 请求提交数据是放在请求正文中。</p>
<p>######### 传输的	数据没有大小限制</p>
<p>######### 略微安全一些。</p>
<p>######## GET和POST的区别</p>
<p>Get请求和Post请求的区别：<br>get和post传输过程都是明文传输。<br>get<br>请求提交数据放在地址栏中拼接，<br>url的长度有限制，数据一般不超过1k，<br>不太安全<br>Post<br>请求提交数据是放在请求正文中。<br>传输的	数据没有大小限制<br>略微安全一些。</p>
<p>####### 请求资源名称</p>
<p>####### HTTP版本号</p>
<h6 id="请求头：若干"><a href="#请求头：若干" class="headerlink" title="请求头：若干"></a>请求头：若干</h6><p>####### 浏览器在和服务器商议通讯细节（可以理解为双方签订一个合同，然后又拟定了一份补充协议，就是对合同的进一步说明）</p>
<p>####### 常见请求头</p>
<p>######## Accept请求头：type&#x2F;sub-type     例如： text&#x2F;html  </p>
<p>######## Accept-Charset: 浏览器通过这个头告诉服务器，它支持哪种字符集</p>
<p>######## Accept-Encoding:浏览器能够进行解码的数据编码方式，比如gzip</p>
<p>######## Accept-Language: 浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 可以在浏览器中进行设置。</p>
<p>######## Host:初始URL中的主机和端口</p>
<p>######## Referer：指明从哪个页面跳转过来。从其他页面跳转过来的才有</p>
<p>######## Cookie：缓存，一般与服务器端发送的set-Cookie响应头成对出现。</p>
<p>######## Content-Type:内容类型</p>
<p>######## User-Agent:浏览器类型.</p>
<p>######## Connection:表示是否需要持久连接。HTTP 1.1默认进行持久连接“Keep -Alive”</p>
<p>######## Date：Date: Mon, 22 Aug 2011 01:55:39 GMT请求时间GMT</p>
<h6 id="空格行：一个"><a href="#空格行：一个" class="headerlink" title="空格行：一个"></a>空格行：一个</h6><h6 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h6><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><h6 id="格式：-HTTP版本号-状态码-原因叙述举例：HTTP-1-1-200-OK"><a href="#格式：-HTTP版本号-状态码-原因叙述举例：HTTP-1-1-200-OK" class="headerlink" title="格式： HTTP版本号　状态码　原因叙述	举例：HTTP 1.1 200 OK"></a>格式： HTTP版本号　状态码　原因叙述<CRLF>	举例：HTTP 1.1 200 OK</h6><h6 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h6><p>####### 200(正常)表示一切正常，返回的是正常请求结果 206 表示分段的请求OK</p>
<p>####### 301、302&#x2F;307(临时重定向)</p>
<p>####### 304(未修改，缓存 )表示客户机缓存的版本是最新的，客户机可以继续使用它，无需到服务器请求。</p>
<p>####### 404(找不到)服务器上不存在客户机所请求的资源。</p>
<p>####### 400 服务器不支持这种请求方式</p>
<p>####### 500(服务器内部错误)服务器端的程序发生错误</p>
<h5 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h5><h6 id="常见响应头"><a href="#常见响应头" class="headerlink" title="常见响应头"></a>常见响应头</h6><p>####### Location: <a href="http://www.cskaoyan.com/">http://www.cskaoyan.com/</a><br>指示新的资源的位置 ,与重定向状态码搭配使用302&#x2F;307搭配。</p>
<p>####### Content-Type: text&#x2F;html;  服务器发送的内容的MIME类型</p>
<p>####### Refresh: 1;url&#x3D;<a href="http://www.cskaoyan.com/">http://www.cskaoyan.com</a><br>指示客户端刷新频率。单位是秒,是间隔1s后，向url地址发送http请求。如果没有url，则表示每隔1s刷新当前页面。</p>
<p>####### Content-Disposition: attachment; filename&#x3D;aaa.zip指示客户端保存文件.</p>
<p>####### Set-Cookie: SS&#x3D;Q0&#x3D;5Lb_nQ; path&#x3D;&#x2F;search服务器端发送的Cookie,浏览器再次访问服务器时，会带上cookie请求头</p>
<p>####### Cache-Control: no-cache (1.1):网页的缓存，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。</p>
<h5 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h5><h5 id="消息实体"><a href="#消息实体" class="headerlink" title="消息实体"></a>消息实体</h5><h3 id="HTTP是无状态协议：HTTP协议自身不对请求和响应之间的通讯状态进行保存。"><a href="#HTTP是无状态协议：HTTP协议自身不对请求和响应之间的通讯状态进行保存。" class="headerlink" title="HTTP是无状态协议：HTTP协议自身不对请求和响应之间的通讯状态进行保存。"></a>HTTP是无状态协议：HTTP协议自身不对请求和响应之间的通讯状态进行保存。</h3><h4 id="产生新的请求的时候不会保存之前的请求和响应报文的信息"><a href="#产生新的请求的时候不会保存之前的请求和响应报文的信息" class="headerlink" title="产生新的请求的时候不会保存之前的请求和响应报文的信息"></a>产生新的请求的时候不会保存之前的请求和响应报文的信息</h4><h4 id="无状态的可以快速处理大量的事务，但是像用户登陆后跳转了页面这种状况不好管理，所以引入cookie"><a href="#无状态的可以快速处理大量的事务，但是像用户登陆后跳转了页面这种状况不好管理，所以引入cookie" class="headerlink" title="无状态的可以快速处理大量的事务，但是像用户登陆后跳转了页面这种状况不好管理，所以引入cookie"></a>无状态的可以快速处理大量的事务，但是像用户登陆后跳转了页面这种状况不好管理，所以引入cookie</h4><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><h4 id="HTTP1-1默认的就是持久化连接，TCP链接后，可以进行多次HTTP通讯。"><a href="#HTTP1-1默认的就是持久化连接，TCP链接后，可以进行多次HTTP通讯。" class="headerlink" title="HTTP1.1默认的就是持久化连接，TCP链接后，可以进行多次HTTP通讯。"></a>HTTP1.1默认的就是持久化连接，TCP链接后，可以进行多次HTTP通讯。</h4><h4 id="管线化：可以一次并行发送多个请求，不需要一个接一个等待上一个的响应"><a href="#管线化：可以一次并行发送多个请求，不需要一个接一个等待上一个的响应" class="headerlink" title="管线化：可以一次并行发送多个请求，不需要一个接一个等待上一个的响应"></a>管线化：可以一次并行发送多个请求，不需要一个接一个等待上一个的响应</h4><h3 id="Cookie进行状态管理"><a href="#Cookie进行状态管理" class="headerlink" title="Cookie进行状态管理"></a>Cookie进行状态管理</h3><h4 id="Cookie原理分析"><a href="#Cookie原理分析" class="headerlink" title="Cookie原理分析"></a>Cookie原理分析</h4><ol>
<li>客户第一次向浏览器发出请求，这时请求头不带cookie</li>
<li>服务端第一次响应的时候，使用构造函数新建一个cookie设定key和value Cookie cookie &#x3D;new Cookie(key,value)，通过reponse.add将cookie添加到相应头中。发送 cookie 在相应头中表现是set-cookie：key&#x3D;value</li>
<li>客服端第二次发出请求，请求头中含有cookie：key&#x3D;value。</li>
<li>服务端可以通过request.getCookies获取到请求头中的&#x3D;&#x3D;所有cookie&#x3D;&#x3D;</li>
</ol>
<h4 id="Cookie的细节"><a href="#Cookie的细节" class="headerlink" title="Cookie的细节"></a>Cookie的细节</h4><ol>
<li>一次可以发送多个cookie，多次创建cookie对象，多次调用addcookie方法</li>
<li>cookie默认情况下在浏览器关闭的时候就被销毁了，cookie是储存在浏览器内存中的</li>
<li>cookie 想要&#x3D;&#x3D;持久化储存&#x3D;&#x3D;（存到硬盘），调用setMaxAge（int seconds）<br>1.传入 整数 ：将cookie数据写到硬盘中 ，并指定cookie存活时间，时间到了后，cookie文件自动失效，&#x3D;&#x3D;以秒为单位&#x3D;&#x3D;<br>2.传入负数： 默认，关闭浏览器，cookie就不在了<br>3.传入 0 ：&#x3D;&#x3D;删除cookie信息&#x3D;&#x3D;（如果设置了path，删除的时候path要和设置的时候一样）</li>
<li>cookie在tomcat8之后可以存储中文，但是特殊字符还是不支持，例如 空格，建议使用URL编码存储</li>
<li>cookie共享问题：默认情况下服务器下的不同应用的cookie不能共享</li>
</ol>
<h2 id="分支主题-1"><a href="#分支主题-1" class="headerlink" title="分支主题"></a>分支主题</h2>]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>02_API自动化</category>
        <category>api自动化框架</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium-Pytest自动化测试框架实战</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/07_Selenium+Pytest%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>前言#<br>selenium自动化+ pytest测试框架</p>
<p>本章你需要</p>
<p>一定的python基础——至少明白类与对象，封装继承</p>
<p>一定的selenium基础——本篇不讲selenium，不会的可以自己去看<a href="https://selenium-python-zh.readthedocs.io/">selenium中文翻译网</a></p>
<p>测试框架简介#<br>    测试框架有什么优点呢：<br>        代码复用率高，如果不使用框架的话，代码会很冗余<br>        可以组装日志、报告、邮件等一些高级功能<br>        提高元素等数据的可维护性，元素发生变化时，只需要更新一下配置文件<br>        使用更灵活的PageObject设计模式<br>        测试框架的整体目录</p>
<table>
<thead>
<tr>
<th align="center">目录&#x2F;文件</th>
<th>说明</th>
<th>是否为python包</th>
</tr>
</thead>
<tbody><tr>
<td align="center">common</td>
<td>这个包中存放的是常见的通用的类，如读取配置文件</td>
<td>是</td>
</tr>
<tr>
<td align="center">config</td>
<td>配置文件目录</td>
<td>是</td>
</tr>
<tr>
<td align="center">logs</td>
<td>日志目录</td>
<td></td>
</tr>
<tr>
<td align="center">page</td>
<td>对selenium的方放进行深度的封装</td>
<td>是</td>
</tr>
<tr>
<td align="center">page_element</td>
<td>页面元素存放目录</td>
<td></td>
</tr>
<tr>
<td align="center">page_object</td>
<td>页面对象POM设计模式，本人对这个的理解来自于苦叶子的博客</td>
<td>是</td>
</tr>
<tr>
<td align="center">TestCase</td>
<td>所有的测试用例集</td>
<td>是</td>
</tr>
<tr>
<td align="center">utils</td>
<td>工具类</td>
<td>是</td>
</tr>
<tr>
<td align="center">script</td>
<td>脚本文件</td>
<td></td>
</tr>
<tr>
<td align="center">conftest.py</td>
<td>pytest胶水文件</td>
<td></td>
</tr>
<tr>
<td align="center">pytest.ini</td>
<td>pytest配置文件</td>
<td></td>
</tr>
<tr>
<td align="center">这样一个简单的框架结构就清晰了。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>知道了以上这些我们就开始吧！</p>
<p>我们在项目中先按照上面的框架指引，建好每一项目录。</p>
<p>注意：python包为是的，都需要添加一个__init__.py文件以标识此目录为一个python包。</p>
<p>首先管理时间#<br>首先呢，因为我们很多的模块会用到时间戳，或者日期等等字符串，所以我们先单独把时间封装成一个模块。</p>
<p>然后让其他模块来调用即可。在utils目录新建times.py模块</p>
<pre><code>#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import time
import datetime
from functools import wraps
 
 
def timestamp():
    &quot;&quot;&quot;时间戳&quot;&quot;&quot;
    return time.time()
 
 
def dt_strftime(fmt=&quot;%Y%m&quot;):
    &quot;&quot;&quot;
    datetime格式化时间
    :param fmt &quot;%Y%m%d %H%M%S
    &quot;&quot;&quot;
    return datetime.datetime.now().strftime(fmt)
 
 
def sleep(seconds=1.0):
    &quot;&quot;&quot;
    睡眠时间
    &quot;&quot;&quot;
    time.sleep(seconds)
 
 
def running_time(func):
    &quot;&quot;&quot;函数运行时间&quot;&quot;&quot;
 
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = timestamp()
        res = func(*args, **kwargs)
        print(&quot;校验元素done！用时%.3f秒！&quot; % (timestamp() - start))
        return res
 
    return wrapper
 
 
if __name__ == &#39;__main__&#39;:
    print(dt_strftime(&quot;%Y%m%d%H%M%S&quot;))
</code></pre>
<p>添加配置文件#<br>配置文件总是项目中必不可少的部分！</p>
<p>将固定不变的信息集中在固定的文件中</p>
<p>conf.py#</p>
<blockquote>
<p>项目中都应该有一个文件对整体的目录进行管理，我也在这个python项目中设置了此文件。</p>
</blockquote>
<p>在项目config目录创建conf.py文件，所有的目录配置信息写在这个文件里面。</p>
<pre><code>#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import os
from selenium.webdriver.common.by import By
from utils.times import dt_strftime
 
 
class ConfigManager(object):
    # 项目目录
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
 
    # 页面元素目录
    ELEMENT_PATH = os.path.join(BASE_DIR, &#39;page_element&#39;)
 
    # 报告文件
    REPORT_FILE = os.path.join(BASE_DIR, &#39;report.html&#39;)
 
    # 元素定位的类型
    LOCATE_MODE = &#123;
        &#39;css&#39;: By.CSS_SELECTOR,
        &#39;xpath&#39;: By.XPATH,
        &#39;name&#39;: By.NAME,
        &#39;id&#39;: By.ID,
        &#39;class&#39;: By.CLASS_NAME
    &#125;
 
    # 邮件信息
    EMAIL_INFO = &#123;
        &#39;username&#39;: &#39;1084502012@qq.com&#39;,  # 切换成你自己的地址
        &#39;password&#39;: &#39;QQ邮箱授权码&#39;,
        &#39;smtp_host&#39;: &#39;smtp.qq.com&#39;,
        &#39;smtp_port&#39;: 465
    &#125;
 
    # 收件人
    ADDRESSEE = [
        &#39;1084502012@qq.com&#39;,
    ]
 
    @property
    def log_file(self):
        &quot;&quot;&quot;日志目录&quot;&quot;&quot;
        log_dir = os.path.join(self.BASE_DIR, &#39;logs&#39;)
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
        return os.path.join(log_dir, &#39;&#123;&#125;.log&#39;.format(dt_strftime()))
 
    @property
    def ini_file(self):
        &quot;&quot;&quot;配置文件&quot;&quot;&quot;
        ini_file = os.path.join(self.BASE_DIR, &#39;config&#39;, &#39;config.ini&#39;)
        if not os.path.exists(ini_file):
            raise FileNotFoundError(&quot;配置文件%s不存在！&quot; % ini_file)
        return ini_file
 
 
cm = ConfigManager()
if __name__ == &#39;__main__&#39;:
    print(cm.BASE_DIR)
</code></pre>
<blockquote>
<p>注意：QQ邮箱授权码：<a href="https://jingyan.baidu.com/article/ac6a9a5eb439f36b653eacc0.html">点击查看生成教程</a></p>
</blockquote>
<blockquote>
<p>这个conf文件我模仿了Django的settings.py文件的设置风格，但是又有些许差异。</p>
</blockquote>
<p>在这个文件中我们可以设置自己的各个目录，也可以查看自己当前的目录。</p>
<p>遵循了约定：不变的常量名全部大写，函数名小写。看起来整体美观。</p>
<p>config.ini#<br>在项目config目录新建一个config.ini文件，里面暂时先放入我们的需要测试的URL</p>
<pre><code>[HOST]
HOST = https://www.baidu.com
</code></pre>
<p>读取配置文件#<br>配置文件创建好了，接下来我们需要读取这个配置文件以使用里面的信息。</p>
<p>我们在common目录中新建一个readconfig.py文件</p>
<pre><code>#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import configparser
from config.conf import cm
 
HOST = &#39;HOST&#39;
 
 
class ReadConfig(object):
    &quot;&quot;&quot;配置文件&quot;&quot;&quot;
 
    def __init__(self):
        self.config = configparser.RawConfigParser()  # 当有%的符号时请使用Raw读取
        self.config.read(cm.ini_file, encoding=&#39;utf-8&#39;)
 
    def _get(self, section, option):
        &quot;&quot;&quot;获取&quot;&quot;&quot;
        return self.config.get(section, option)
 
    def _set(self, section, option, value):
        &quot;&quot;&quot;更新&quot;&quot;&quot;
        self.config.set(section, option, value)
        with open(cm.ini_file, &#39;w&#39;) as f:
            self.config.write(f)
 
    @property
    def url(self):
        return self._get(HOST, HOST)
 
 
ini = ReadConfig()
 
if __name__ == &#39;__main__&#39;:
    print(ini.url)
</code></pre>
<p>可以看到我们用python内置的configparser模块对config.ini文件进行了读取。</p>
<p>对于url值的提取，我使用了高阶语法@property属性值，写法更简单。</p>
<p>记录操作日志#<br>日志，大家应该都很熟悉这个名词，就是记录代码中的动作。</p>
<p>在utils目录中新建logger.py文件。</p>
<p>这个文件就是我们用来在自动化测试过程中记录一些操作步骤的。</p>
<pre><code>#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import logging
from config.conf import cm
 
 
class Log:
    def __init__(self):
        self.logger = logging.getLogger()
        if not self.logger.handlers:
            self.logger.setLevel(logging.DEBUG)
 
            # 创建一个handle写入文件
            fh = logging.FileHandler(cm.log_file, encoding=&#39;utf-8&#39;)
            fh.setLevel(logging.INFO)
 
            # 创建一个handle输出到控制台
            ch = logging.StreamHandler()
            ch.setLevel(logging.INFO)
 
            # 定义输出的格式
            formatter = logging.Formatter(self.fmt)
            fh.setFormatter(formatter)
            ch.setFormatter(formatter)
 
            # 添加到handle
            self.logger.addHandler(fh)
            self.logger.addHandler(ch)
 
    @property
    def fmt(self):
        return &#39;%(levelname)s\t%(asctime)s\t[%(filename)s:%(lineno)d]\t%(message)s&#39;
 
 
log = Log().logger
 
if __name__ == &#39;__main__&#39;:
    log.info(&#39;hello world&#39;)
</code></pre>
<p>在终端中运行该文件，就看到命令行打印出了：</p>
<pre><code>INFO	2020-12-01 16:00:05,467	[logger.py:38]	hello world
</code></pre>
<p>然后在项目logs目录下生成了当月的日志文件。</p>
<p>简单理解POM模型#</p>
<blockquote>
<p>由于下面要讲元素相关的，所以首先理解一下POM模型</p>
</blockquote>
<p>Page Object模式具有以下几个优点。</p>
<blockquote>
<p>该观点来自 《Selenium自动化测试——基于Python语言》</p>
</blockquote>
<p>抽象出对象可以最大程度地降低开发人员修改页面代码对测试的影响， 所以， 你仅需要对页<br>面对象进行调整， 而对测试没有影响；<br>可以在多个测试用例中复用一部分测试代码；<br>测试代码变得更易读、 灵活、 可维护<br>Page Object模式图</p>
<p><img src="/assets/2/image-20220515233228-h1gn5ur.png"></p>
<p>basepage ——selenium的基类，对selenium的方法进行封装<br>pageelements——页面元素，把页面元素单独提取出来，放入一个文件中<br>searchpage ——页面对象类，把selenium方法和页面元素进行整合<br>testcase ——使用pytest对整合的searchpage进行测试用例编写<br>通过上图我们可以看出，通过POM模型思想，我们把：</p>
<p>selenium方法<br>页面元素<br>页面对象<br>测试用例<br>以上四种代码主体进行了拆分，虽然在用例很少的情况下做会增加代码，但是当用例多的时候意义很大，代码量会在用例增加的时候显著减少。我们维护代码变得更加直观明显，代码可读性也变得比工厂模式强很多，代码复用率也极大的得到了提高。</p>
<p>简单学习元素定位#<br>在日常的工作中，我见过很多在浏览器中直接在浏览器中右键Copy Xpath复制元素的同学。这样获得的元素表达式放在 webdriver 中去运行往往是不够稳定的，像前端的一些微小改动，都会引起元素无法定位的NoSuchElementException报错。</p>
<p>所以在实际工作和学习中我们应该加强自己的元素定位能力，尽可能的采用xpath和CSS selector 这种相对稳定的定位语法。由于CSS selector的语法生硬难懂，对新手很不友好，而且相比xpath缺少一些定位语法。所以我们选择xpath进行我们的元素定位语法。</p>
<p>xpath#</p>
<p>语法规则</p>
<blockquote>
<p><a href="https://www.runoob.com/xpath/xpath-intro.html">菜鸟教程</a>中对于 xpath 的介绍是一门在 XML 文档中查找信息的语言。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th>介绍</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td>&#x2F;</td>
<td>根节点</td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F;</td>
<td>当前节点的所有子节点</td>
<td>相对路径</td>
</tr>
<tr>
<td align="center">*</td>
<td>所有节点元素的</td>
<td></td>
</tr>
<tr>
<td align="center">@</td>
<td>属性名的前缀</td>
<td>@class   @id</td>
</tr>
<tr>
<td align="center">*[1]</td>
<td>[] 下标运算符</td>
<td></td>
</tr>
<tr>
<td align="center">[]</td>
<td>[ ]谓词表达式</td>
<td>&#x2F;&#x2F;input[@id&#x3D;’kw’]</td>
</tr>
<tr>
<td align="center">Following-sibling</td>
<td>当前节点之后的同级</td>
<td></td>
</tr>
<tr>
<td align="center">preceding-sibling</td>
<td>当前节点之前的同级</td>
<td></td>
</tr>
<tr>
<td align="center">parent</td>
<td>当前节点的父级节点</td>
<td></td>
</tr>
<tr>
<td align="center">定位工具</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>chropath<br>优点：这是一个Chrome浏览器的测试定位插件，类似于firepath，本人试用了一下整体感觉非常好。对小白的友好度很好。<br>缺点：安装这个插件需要FQ。<br>Katalon录制工具<br>录制出来的脚本里面也会有定位元素的信息<br>自己写——本人推荐这种<br>优点：本人推荐的方式，因为当熟练到一定程度的时候，写出来的会更直观简洁，并且在运行自动化测试中出现问题时，能快速定位。<br>缺点：需要一定xpath和CSS selector语法积累，不太容易上手。<br>管理页面元素#</p>
<blockquote>
<p>本教程选择的测试地址是百度首页，所以对应的元素也是百度首页的。</p>
</blockquote>
<p>项目框架设计中有一个目录page_element就是专门来存放定位元素的文件的。</p>
<p>通过对各种配置文件的对比，我在这里选择的是YAML文件格式。其易读，交互性好。</p>
<p>我们在page_element中新建一个search.yaml文件。</p>
<pre><code>搜索框: &quot;id==kw&quot;
候选: &quot;css==.bdsug-overflow&quot;
搜索候选: &quot;css==#form div li&quot;
搜索按钮: &quot;id==su&quot;
</code></pre>
<p>元素定位文件创建好了，下来我们需要读取这个文件。</p>
<p>在common目录中创建readelement.py文件。</p>
<pre><code>#!/usr/bin/env python3
# -*- coding:utf-8 -*-
import os
import yaml
from config.conf import cm
 
 
class Element(object):
    &quot;&quot;&quot;获取元素&quot;&quot;&quot;
 
    def __init__(self, name):
        self.file_name = &#39;%s.yaml&#39; % name
        self.element_path = os.path.join(cm.ELEMENT_PATH, self.file_name)
        if not os.path.exists(self.element_path):
            raise FileNotFoundError(&quot;%s 文件不存在！&quot; % self.element_path)
        with open(self.element_path, encoding=&#39;utf-8&#39;) as f:
            self.data = yaml.safe_load(f)
 
    def __getitem__(self, item):
        &quot;&quot;&quot;获取属性&quot;&quot;&quot;
        data = self.data.get(item)
        if data:
            name, value = data.split(&#39;==&#39;)
            return name, value
        raise ArithmeticError(&quot;&#123;&#125;中不存在关键字：&#123;&#125;&quot;.format(self.file_name, item))
 
 
if __name__ == &#39;__main__&#39;:
    search = Element(&#39;search&#39;)
    print(search[&#39;搜索框&#39;])
```	
    
通过特殊方法__getitem__实现调用任意属性，读取yaml中的值。

这样我们就实现了定位元素的存储和调用。

但是还有一个问题，我们怎么样才能确保我们写的每一项元素不出错，人为的错误是不可避免的，但是我们可以通过代码来运行对文件的审查。当前也不能所有问题都能发现。

所以我们编写一个文件，在script脚本文件目录中创建inspect.py文件，对所有的元素yaml文件进行审查。
</code></pre>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env python3</p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import os<br>import yaml<br>from config.conf import cm<br>from utils.times import running_time</p>
<p>@running_time<br>def inspect_element():<br>    “””检查所有的元素是否正确<br>    只能做一个简单的检查<br>    “””<br>    for files in os.listdir(cm.ELEMENT_PATH):<br>        _path &#x3D; os.path.join(cm.ELEMENT_PATH, files)<br>        with open(_path, encoding&#x3D;’utf-8’) as f:<br>            data &#x3D; yaml.safe_load(f)<br>        for k in data.values():<br>            try:<br>                pattern, value &#x3D; k.split(‘&#x3D;&#x3D;’)<br>            except ValueError:<br>                raise Exception(“元素表达式中没有<code>==</code>“)<br>            if pattern not in cm.LOCATE_MODE:<br>                raise Exception(‘%s中元素【%s】没有指定类型’ % (_path, k))<br>            elif pattern &#x3D;&#x3D; ‘xpath’:<br>                assert ‘&#x2F;&#x2F;‘ in value,<br>                    ‘%s中元素【%s】xpath类型与值不配’ % (_path, k)<br>            elif pattern &#x3D;&#x3D; ‘css’:<br>                assert ‘&#x2F;&#x2F;‘ not in value, <br>                    ‘%s中元素【%s]css类型与值不配’ % (_path, k)<br>            else:<br>                assert value, ‘%s中元素【%s】类型与值不匹配’ % (_path, k)</p>
<p>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    inspect_element()</p>
<pre><code>执行该文件：

校验元素done！用时0.002秒！
可以看到，很短的时间内，我们就对所填写的YAML文件进行了审查。

现在我们基本所需要的组件已经大致完成了。

接下来我们将进行最重要的一环，封装selenium。

封装Selenium基类#
在工厂模式种我们是这样写的：
</code></pre>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env python3</p>
<h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import time<br>from selenium import webdriver</p>
<p>driver &#x3D; webdriver.Chrome()<br>driver.get(‘<a href="https://www.baidu.com&/#39;">https://www.baidu.com&#39;</a>)<br>driver.find_element_by_xpath(“&#x2F;&#x2F;input[@id&#x3D;’kw’]”).send_keys(‘selenium’)<br>driver.find_element_by_xpath(“&#x2F;&#x2F;input[@id&#x3D;’su’]”).click()<br>time.sleep(5)<br>driver.quit()</p>
<pre><code>很直白，简单，又明了。

创建driver对象，打开百度网页，搜索selenium，点击搜索，然后停留5秒，查看结果，最后关闭浏览器。

那我们为什么要封装selenium的方法呢。首先我们上述这种较为原始的方法，基本不适用于平时做UI自动化测试的，因为在UI界面实际运行情况远远比较复杂，可能因为网络原因，或者控件原因，我们元素还没有显示出来，就进行点击或者输入。所以我们需要封装selenium方法，通过内置的显式等待或一定的条件语句，才能构建一个稳定的方法。而且把selenium方法封装起来，有利于平时的代码维护。

我们在page目录创建webpage.py文件。
</code></pre>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env python3</p>
<h1 id="coding-utf-8-2"><a href="#coding-utf-8-2" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>“””<br>selenium基类<br>本文件存放了selenium基类的封装方法<br>“””<br>from selenium.webdriver.support import expected_conditions as EC<br>from selenium.webdriver.support.ui import WebDriverWait<br>from selenium.common.exceptions import TimeoutException</p>
<p>from config.conf import cm<br>from utils.times import sleep<br>from utils.logger import log</p>
<p>class WebPage(object):<br>    “””selenium基类”””</p>
<pre><code>def __init__(self, driver):
    # self.driver = webdriver.Chrome()
    self.driver = driver
    self.timeout = 20
    self.wait = WebDriverWait(self.driver, self.timeout)

def get_url(self, url):
    &quot;&quot;&quot;打开网址并验证&quot;&quot;&quot;
    self.driver.maximize_window()
    self.driver.set_page_load_timeout(60)
    try:
        self.driver.get(url)
        self.driver.implicitly_wait(10)
        log.info(&quot;打开网页：%s&quot; % url)
    except TimeoutException:
        raise TimeoutException(&quot;打开%s超时请检查网络或网址服务器&quot; % url)

@staticmethod
def element_locator(func, locator):
    &quot;&quot;&quot;元素定位器&quot;&quot;&quot;
    name, value = locator
    return func(cm.LOCATE_MODE[name], value)

def find_element(self, locator):
    &quot;&quot;&quot;寻找单个元素&quot;&quot;&quot;
    return WebPage.element_locator(lambda *args: self.wait.until(
        EC.presence_of_element_located(args)), locator)

def find_elements(self, locator):
    &quot;&quot;&quot;查找多个相同的元素&quot;&quot;&quot;
    return WebPage.element_locator(lambda *args: self.wait.until(
        EC.presence_of_all_elements_located(args)), locator)

def elements_num(self, locator):
    &quot;&quot;&quot;获取相同元素的个数&quot;&quot;&quot;
    number = len(self.find_elements(locator))
    log.info(&quot;相同元素：&#123;&#125;&quot;.format((locator, number)))
    return number

def input_text(self, locator, txt):
    &quot;&quot;&quot;输入(输入前先清空)&quot;&quot;&quot;
    sleep(0.5)
    ele = self.find_element(locator)
    ele.clear()
    ele.send_keys(txt)
    log.info(&quot;输入文本：&#123;&#125;&quot;.format(txt))

def is_click(self, locator):
    &quot;&quot;&quot;点击&quot;&quot;&quot;
    self.find_element(locator).click()
    sleep()
    log.info(&quot;点击元素：&#123;&#125;&quot;.format(locator))

def element_text(self, locator):
    &quot;&quot;&quot;获取当前的text&quot;&quot;&quot;
    _text = self.find_element(locator).text
    log.info(&quot;获取文本：&#123;&#125;&quot;.format(_text))
    return _text

@property
def get_source(self):
    &quot;&quot;&quot;获取页面源代码&quot;&quot;&quot;
    return self.driver.page_source

def refresh(self):
    &quot;&quot;&quot;刷新页面F5&quot;&quot;&quot;
    self.driver.refresh()
    self.driver.implicitly_wait(30)
</code></pre>
<pre><code>在文件中我们对主要用了显式等待对selenium的click，send_keys等方法，做了二次封装。提高了运行的成功率。

好了我们完成了POM模型的一半左右的内容。接下来我们们进入页面对象。

创建页面对象#
在page_object目录下创建一个searchpage.py文件。
</code></pre>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env python3</p>
<h1 id="coding-utf-8-3"><a href="#coding-utf-8-3" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from page.webpage import WebPage, sleep<br>from common.readelement import Element</p>
<p>search &#x3D; Element(‘search’)</p>
<p>class SearchPage(WebPage):<br>    “””搜索类”””</p>
<pre><code>def input_search(self, content):
    &quot;&quot;&quot;输入搜索&quot;&quot;&quot;
    self.input_text(search[&#39;搜索框&#39;], txt=content)
    sleep()

@property
def imagine(self):
    &quot;&quot;&quot;搜索联想&quot;&quot;&quot;
    return [x.text for x in self.find_elements(search[&#39;候选&#39;])]

def click_search(self):
    &quot;&quot;&quot;点击搜索&quot;&quot;&quot;
    self.is_click(search[&#39;搜索按钮&#39;])
</code></pre>
<pre><code>在该文件中我们对，输入搜索关键词，点击搜索，搜索联想，进行了封装。

并配置了注释。

&gt;在平时中我们应该养成写注释的习惯，因为过一段时间后，没有注释，代码读起来很费劲。

好了我们的页面对象此时业已完成了。下面我们开始编写测试用例。在开始测试用了之前我们先熟悉一下pytest测试框架。

简单了解Pytest#
打开pytest框架的官网。[pytest: helps you write better programs — pytest documentation](http://www.pytest.org/en/latest/)
</code></pre>
<h1 id="content-of-test-sample-py"><a href="#content-of-test-sample-py" class="headerlink" title="content of test_sample.py"></a>content of test_sample.py</h1><p>def inc(x):<br>    return x + 1</p>
<p>def test_answer():<br>    assert inc(3) &#x3D;&#x3D; 5</p>
<pre><code>官方教程我认为写的并不适合入门阅读，而且没有汉化版。

推荐看一下[上海悠悠的pytest教程](https://www.cnblogs.com/yoyoketang/tag/pytest/)

pytest.ini#
pytest项目中的配置文件，可以对pytest执行过程中操作做全局控制。

在项目根目录新建pytest.ini文件。
</code></pre>
<p>[pytest]<br>addopts &#x3D; –html&#x3D;report.html –self-contained-html</p>
<pre><code>addopts 指定执行时的其他参数说明：
--html=report/report.html --self-contained-html 生成pytest-html带样式的报告
-s 输出我们用例中的调式信息
-q 安静的进行测试
-v 可以输出用例更加详细的执行信息，比如用例所在的文件及用例名称等
编写测试用例#
我们将使用pytest编写测试用例。

在TestCase目录中创建test_search.py文件。
</code></pre>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env python3</p>
<h1 id="coding-utf-8-4"><a href="#coding-utf-8-4" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import re<br>import pytest<br>from utils.logger import log<br>from common.readconfig import ini<br>from page_object.searchpage import SearchPage</p>
<p>class TestSearch:<br>    @pytest.fixture(scope&#x3D;’function’, autouse&#x3D;True)<br>    def open_baidu(self, drivers):<br>        “””打开百度”””<br>        search &#x3D; SearchPage(drivers)<br>        search.get_url(ini.url)</p>
<pre><code>def test_001(self, drivers):
    &quot;&quot;&quot;搜索&quot;&quot;&quot;
    search = SearchPage(drivers)
    search.input_search(&quot;selenium&quot;)
    search.click_search()
    result = re.search(r&#39;selenium&#39;, search.get_source)
    log.info(result)
    assert result

def test_002(self, drivers):
    &quot;&quot;&quot;测试搜索候选&quot;&quot;&quot;
    search = SearchPage(drivers)
    search.input_search(&quot;selenium&quot;)
    log.info(list(search.imagine))
    assert all([&quot;selenium&quot; in i for i in search.imagine])
</code></pre>
<p>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    pytest.main([‘TestCase&#x2F;test_search.py’])</p>
<pre><code>我们测试用了就编写好了。

pytest.fixture 这个实现了和unittest的setup，teardown一样的前置启动，后置清理的装饰器。

第一个测试用例：

我们实现了在百度selenium关键字，并点击搜索按钮，并在搜索结果中，用正则查找结果页源代码，返回数量大于10我们就认为通过。
第二个测试用例：

我们实现了，搜索selenium，然后断言搜索候选中的所有结果有没有selenium关键字。
最后我们的在下面写一个执行启动的语句。

这时候我们应该进入执行了，但是还有一个问题，我们还没有把driver传递。

conftest.py#
我们在项目根目录下新建一个conftest.py文件。
</code></pre>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env python3</p>
<h1 id="coding-utf-8-5"><a href="#coding-utf-8-5" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import pytest<br>from py.xml import html<br>from selenium import webdriver</p>
<p>driver &#x3D; None</p>
<p>@pytest.fixture(scope&#x3D;’session’, autouse&#x3D;True)<br>def drivers(request):<br>    global driver<br>    if driver is None:<br>        driver &#x3D; webdriver.Chrome()<br>        driver.maximize_window()</p>
<pre><code>def fn():
    driver.quit()

request.addfinalizer(fn)
return driver
</code></pre>
<p>@pytest.hookimpl(hookwrapper&#x3D;True)<br>def pytest_runtest_makereport(item):<br>    “””<br>    当测试失败的时候，自动截图，展示到html报告中<br>    :param item:<br>    “””<br>    pytest_html &#x3D; item.config.pluginmanager.getplugin(‘html’)<br>    outcome &#x3D; yield<br>    report &#x3D; outcome.get_result()<br>    report.description &#x3D; str(item.function.<strong>doc</strong>)<br>    extra &#x3D; getattr(report, ‘extra’, [])</p>
<pre><code>if report.when == &#39;call&#39; or report.when == &quot;setup&quot;:
    xfail = hasattr(report, &#39;wasxfail&#39;)
    if (report.skipped and xfail) or (report.failed and not xfail):
        file_name = report.nodeid.replace(&quot;::&quot;, &quot;_&quot;) + &quot;.png&quot;
        screen_img = _capture_screenshot()
        if file_name:
            html = &#39;&lt;div&gt;&lt;img src=&quot;data:image/png;base64,%s&quot; alt=&quot;screenshot&quot; style=&quot;width:1024px;height:768px;&quot; &#39; \
                   &#39;onclick=&quot;window.open(this.src)&quot; align=&quot;right&quot;/&gt;&lt;/div&gt;&#39; % screen_img
            extra.append(pytest_html.extras.html(html))
    report.extra = extra
</code></pre>
<p>def pytest_html_results_table_header(cells):<br>    cells.insert(1, html.th(‘用例名称’))<br>    cells.insert(2, html.th(‘Test_nodeid’))<br>    cells.pop(2)</p>
<p>def pytest_html_results_table_row(report, cells):<br>    cells.insert(1, html.td(report.description))<br>    cells.insert(2, html.td(report.nodeid))<br>    cells.pop(2)</p>
<p>def pytest_html_results_table_html(report, data):<br>    if report.passed:<br>        del data[:]<br>        data.append(html.div(‘通过的用例未捕获日志输出.’, class_&#x3D;’empty log’))</p>
<p>def _capture_screenshot():<br>    ‘’’<br>    截图保存为base64<br>    :return:<br>    ‘’’<br>    return driver.get_screenshot_as_base64()</p>
<pre><code>conftest.py测试框架pytest的胶水文件，里面用到了fixture的方法，封装并传递出了driver。

执行用例#
以上我们已经编写完成了整个框架和测试用例。

我们进入到当前项目的主目录执行命令：

&gt;pytest
命令行输出：
</code></pre>
<p>Test session starts (platform: win32, Python 3.7.7, pytest 5.3.2, pytest-sugar 0.9.2)<br>cachedir: .pytest_cache<br>metadata: {‘Python’: ‘3.7.7’, ‘Platform’: ‘Windows-10-10.0.18362-SP0’, ‘Packages’: {‘pytest’: ‘5.3.2’, ‘py’: ‘1.8.0’, ‘pluggy’: ‘0.13.1’}, ‘Plugins’: {‘forked’: ‘1.1.3’, ‘html’: ‘2.0.1’, ‘metadata’: ‘1.8.0’, ‘ordering’: ‘0.6’, ‘rerunfailures’: ‘8.0’, ‘sugar’: ‘0.9.2’, ‘xdist’: ‘1.31.0’}, ‘JAVA_HOME’: ‘D:\Program Files\Java\jdk1.8.0_131’}<br>rootdir: C:\Users\hoou\PycharmProjects\web-demotest, inifile: pytest.ini<br>plugins: forked-1.1.3, html-2.0.1, metadata-1.8.0, ordering-0.6, rerunfailures-8.0, sugar-0.9.2, xdist-1.31.0<br>collecting …<br>DevTools listening on ws:&#x2F;&#x2F;127.0.0.1:10351&#x2F;devtools&#x2F;browser&#x2F;78bef34d-b94c-4087-b724-34fb6b2ef6d1</p>
<p> TestCase\test_search.py::TestSearch.test_001 ✓                                                                                              50% █████     </p>
<p> TestCase\test_search.py::TestSearch.test_002 ✓                                                                                             100% ██████████<br>——————————- generated html file: file:&#x2F;&#x2F;C:\Users\hoou\PycharmProjects\web-demotest\report\report.html ——————————– </p>
<p>Results (12.90s):<br>       2 passed</p>
<pre><code>可以看到两条用例已经执行成功了。

项目的report目录中生成了一个report.html文件。

这就是生成的测试报告文件。

发送邮件#
当项目执行完成之后，需要发送到自己或者其他人邮箱里查看结果。

我们编写发送邮件的模块。

在utils目录中新建send_mail.py文件
</code></pre>
<p>#!&#x2F;usr&#x2F;bin&#x2F;env python3</p>
<h1 id="coding-utf-8-6"><a href="#coding-utf-8-6" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import zmail<br>from config.conf import cm</p>
<p>def send_report():<br>    “””发送报告”””<br>    with open(cm.REPORT_FILE, encoding&#x3D;’utf-8’) as f:<br>        content_html &#x3D; f.read()<br>    try:<br>        mail &#x3D; {<br>            ‘from’: ‘<a href="mailto:&#49;&#48;&#56;&#x34;&#53;&#48;&#x32;&#x30;&#49;&#x32;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;">&#49;&#48;&#56;&#x34;&#53;&#48;&#x32;&#x30;&#49;&#x32;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;</a>‘,<br>            ‘subject’: ‘最新的测试报告邮件’,<br>            ‘content_html’: content_html,<br>            ‘attachments’: [cm.REPORT_FILE, ]<br>        }<br>        server &#x3D; zmail.server(*cm.EMAIL_INFO.values())<br>        server.send_mail(cm.ADDRESSEE, mail)<br>        print(“测试邮件发送成功！”)<br>    except Exception as e:<br>        print(“Error: 无法发送邮件，{}！”, format(e))</p>
<p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    ‘’’请先在config&#x2F;conf.py文件设置QQ邮箱的账号和密码’’’<br>    send_report()</p>
<pre><code>执行该文件：
</code></pre>
<p>测试邮件发送成功！</p>
<p>&#96;&#96;&#96;<br>可以看到测试报告邮件已经发送成功了。打开邮箱。</p>
<p><img src="/assets/2/image-20220515234106-au2d6r6.png"></p>
<p><img src="/assets/2/image-20220515234151-jb81a6m.png"></p>
<p>成功收到了邮件。</p>
<p>这个demo项目就算是整体完工了；是不是很有心得，在发送邮件的那一刻很有成就感。</p>
<p>最后，想必你已经对pytest+selenium框架有了一个整体的认知了，在自动化测试的道路上又上了一层台阶。</p>
<p>allure测试报告的生成#<br>已经在另外一篇博客写了allure报告了，并且用的也是本篇的开源项目进行改造的，所以直接在这里放个链接^_^</p>
<p>开源地址#<br>为了方便学习交流，本次的示例项目：</p>
<p><a href="assets/3/web-demotest-master.zip">web-demotest</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>01_selenium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium-webdriver-元素的处理方法</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/05_Selenium-%E5%85%83%E7%B4%A0%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>selenium webdriver是业界公认ui⾃动化测试的标准,其封装的api可以对浏览器的任何地⽅进⾏操作<br>selenium2.0和selenium3.0的区别?<br>3.0任何浏览器的⼚商都⽀持selenium,他们只要给予驱动就可以了,2.0只⽀持⽕狐和⾕歌<br>webdriver⼯作原理?<br>　　通过webdriver创建⼀个浏览器服务,remote server(底层服务).启动脚本后会通过驱动打开浏览器,并绑定端⼝,不同浏览器端⼝不同<br>client端创建⼀个session来请求rmote server并发送restful请求,server解析后,完成代码的操作返回结果<br>如何定位html中的元素?<br>1.查看并分析html中所需定位的元素<br>2.找到对于当前页⾯来说唯⼀的属性<br>css selector与xpath区别?<br>　　其有着不同的定位⽅式,择优选择最佳的定位⽅式<br>xpath可以通过⾓标定位到⼀些css selector定位不到的元素<br>css selector基于html,能快速取到值,xpath底层要从xml转换成html对代码执⾏效率会受到影响,还依赖转化的准确度　　<br>xpath定位　　xpath是xml的路径语⾔<br>&#x2F;html&#x2F;body&#x2F;div&#x2F;div&#x2F;div&#x2F;ul&#x2F;li&#x2F;a[@href&#x3D;”&#x2F;xpath&#x2F;xpath_syntax.asp”]　　从祖先html开始查找定位元素,可以不⽤写⾓标　　注意<br>:⼀个&#x2F;表⽰其<br>⼦元素查找,&#x2F;&#x2F;表⽰模糊匹配查找<br>&#x2F;&#x2F;*　　获取页⾯所有元素<br>&#x2F;&#x2F;<em>[@id&#x3D;’xxxx’]@表⽰以id属性定位<br>&#x2F;&#x2F;input[@id&#x3D;’xxx’]input表⽰以input标签名进⾏定位<br>&#x2F;&#x2F;input[1]　　如果出现不唯⼀的请求可以通过⾓标的形式取,注意⾓标从1开始<br>&#x2F;&#x2F;input[1]&#x2F;input[1]　　层级定位⽅式,&#x2F;表⽰当前层级内<br>&#x2F;&#x2F;input[@id&#x3D;’xxx’ and @class&#x3D;’xxx’]#逻辑定位⽅法,通过多种属性确⽴唯⼀<br>xpath(定位⽅法尽量少⽤层级定位,如果修改了层级位置会导⼊所有定位都失效,以属性定位为主)<br>css selector定位　　html的css选择器标签定位<br>#i1　　表⽰查找id属性为i1的元素<br>.i1　　表⽰查找class属性为i1的属性<br>[name&#x3D;’xxx’]　　表⽰查找name属性定位<br>input[name&#x3D;’xxx’]　　可以通过标签名进⾏检索来缩⼩范围<br>input#name　　查找input标签中id为name的元素<br>input[name&#x3D;’xxx’][id&#x3D;’xxx’][class&#x3D;’xxx’]input标签下多属性确⽴唯⼀<br>input&gt;input[id&#x3D;’xxx’]&gt;表⽰递进⼀层<br>input[name^&#x3D;’xxx’]^⽀持前者模糊匹配<br>input[name$&#x3D;’xxx’]$⽀持后者模糊匹配<br>input[name</em>&#x3D;’xxx’]*表⽰包含,只要包含字段中的内容都可能会被匹配上<br>css selector不⽀持⾓标取值,所以我们要灵活运⽤xpath和css selector结合<br>由于css是html原始⽀持,还可以⽀持很多定位⽅法,以上⼀些我们在⽇常通常都可以⽤了,如进⼀步学习可以参考<br>selenium webdriver api-代码定位,基础操作<br>pip install selenium<br>from selenium import webdriver</p>
<h1 id="驱动程序-⽤chrome-当然还可以⽤firefox-ie驱动"><a href="#驱动程序-⽤chrome-当然还可以⽤firefox-ie驱动" class="headerlink" title="驱动程序,⽤chrome,当然还可以⽤firefox,ie驱动"></a>驱动程序,⽤chrome,当然还可以⽤firefox,ie驱动</h1><p>driver &#x3D; webdriver.Chrome()</p>
<h1 id="获取⽹址"><a href="#获取⽹址" class="headerlink" title="获取⽹址"></a>获取⽹址</h1><p>driver.get(“<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a>)</p>
<h1 id="设置页⾯宽长"><a href="#设置页⾯宽长" class="headerlink" title="设置页⾯宽长"></a>设置页⾯宽长</h1><p>driver.get_window_size()# 获取浏览器的⼤⼩<br>driver.set_window_size(400, 800)# 定义指定页⾯长宽<br>driver.maximize_window()#最⼤页⾯长宽</p>
<h1 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h1><p>driver.get_screenshot_as_file(‘xx.jpg’)# 在当前脚本的同⼀级⽬录⽣成浏览器截屏的图⽚⽂件(其他底层还有三个截图api)</p>
<h1 id="⼋种单数定位⽅式-都需要确⽴唯⼀"><a href="#⼋种单数定位⽅式-都需要确⽴唯⼀" class="headerlink" title="⼋种单数定位⽅式(都需要确⽴唯⼀)"></a>⼋种单数定位⽅式(都需要确⽴唯⼀)</h1><p>driver.find_element_by_name()#通过name属性定位<br>driver.find_element_by_id()#通过id属性定位<br>driver.find_element_by_class_name()#通过class属性定位<br>driver.find_element_by_link_text(“”)#⽂案定位<br>driver.find_element_by_partial_link_text()#包含⽂案定位<br>driver.find_element_by_css_selector()#css selector定位<br>driver.find_element_by_tag_name()#标签名定位,如果有多个,获取的是html页⾯中第⼀个<br>driver.find_element_by_xpath(“.&#x2F;&#x2F;*[@id&#x3D;’kw’]”).clear()#xpath定位</p>
<h1 id="⼋种复数定位⽅法"><a href="#⼋种复数定位⽅法" class="headerlink" title="⼋种复数定位⽅法"></a>⼋种复数定位⽅法</h1><p>(不常⽤,单数的element加s就是复数,所有复数形式都返回⼀个列表,列表顺序按html从上到下,如果元素下还有⼦元素,可以通过元素进⾏再次定位)</p>
<h1 id="其他两种定位"><a href="#其他两种定位" class="headerlink" title="其他两种定位"></a>其他两种定位</h1><p>driver.find_element(‘id’,’i1’)#单数形式,参数id表⽰通过id定位,i1表⽰元素值为i1进⾏定位<br>driver.find_elemnets(‘id’,’i1’)#复数形式,返回列表</p>
<h1 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h1><p>driver.find_element_by_xpath(“.&#x2F;&#x2F;[@id&#x3D;’kw’]”).send_keys(“selenium”)<br>driver.find_element_by_xpath(“.&#x2F;&#x2F;*[@id&#x3D;’kw’]”).submit()</p>
<h1 id="控制浏览器前进后退"><a href="#控制浏览器前进后退" class="headerlink" title="控制浏览器前进后退"></a>控制浏览器前进后退</h1><p>driver.back()<br>driver.forward()</p>
<h1 id="刷新页⾯"><a href="#刷新页⾯" class="headerlink" title="刷新页⾯"></a>刷新页⾯</h1><p>driver.refresh()</p>
<h1 id="浏览器关闭"><a href="#浏览器关闭" class="headerlink" title="浏览器关闭"></a>浏览器关闭</h1><p>driver.close() # 关闭⼀个页⾯也叫关闭⼀个tag,当页⾯只有⼀个tag的时候就直接关闭浏览器了<br>driver.quit()  # 退出驱动也就是关闭浏览器<br>等待,操作浏览器,悬浮<br>from selenium import webdriver<br>from selenium.webdriver.common.action_chains import ActionChains  # 引⼊actionchains类<br>from selenium.webdriver.common.keys import Keysfrom selenium.common.exceptions import NoSuchElementException<br>from time import ctime<br>from selenium.webdriver.support.select import Select<br>import time<br>browser &#x3D; webdriver.Chrome()  # 打开⽹页驱动<br>#等待　　⼀般等待分为三种,系统等待,隐⼠等待,显⽰等待</p>
<h1 id="隐式等待10s"><a href="#隐式等待10s" class="headerlink" title="隐式等待10s"></a>隐式等待10s</h1><p> “””<br> implicitly_wait():隐式等待<br>当使⽤了隐⼠等待执⾏测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常<br>换句话说，当查找元素或元素并没有⽴即出现的时候，隐式等待将等待⼀段时间再查找 DOM，默认的时间是0<br>⼀旦设置了隐式等待，则它存在整个 WebDriver 对象实例的声明周期中，隐式的等到会让⼀个正常响应的应⽤的测试变慢，<br>它将会在寻找每个元素的时候都进⾏等待，这样会增加整个测试执⾏的时间,所以在ui⾃动化实现⽐较鸡肋<br> “””<br>browser.implicitly_wait(10)</p>
<h1 id="显⽰等待↓"><a href="#显⽰等待↓" class="headerlink" title="显⽰等待↓"></a>显⽰等待↓</h1><p>‘’’<br>显⽰等待　　&#x3D;&#x3D;&gt;显⽰等待为selenium的核⼼,⽤好它能增加⾃动化的执⾏速度,提⾼效率<br>⾃设置了显⽰等待,在设置后到指定设置时间内,会按设置的步长等待,直到找到元素或超时<br>‘’’<br>browser.get(“<a href="https://www.baidu.com&quot;/">https://www.baidu.com&quot;</a>)  # 打开⽹址<br>print(“设置浏览器宽1200、⾼1400显⽰”)<br>browser.set_window_size(1200, 1400)<br>from selenium.webdriver.support.ui import WebDriverWait<br>from selenium.webdriver.support import expected_conditions as EC<br>from selenium.webdriver.common.by import By<br>element &#x3D; WebDriverWait(browser, 5, 0.5).until( EC.presence_of_element_located((By.ID, “kw”)) )<br>#browser, 5, 0.5分别表⽰对象,超时时间,步长<br>#By.ID,”kw”分别表⽰通过id属性,定位的值</p>
<h1 id="系统等待↓"><a href="#系统等待↓" class="headerlink" title="系统等待↓"></a>系统等待↓</h1><p>‘’<br>time.sleep(5)<br>　　系统等待⽤在测试调试阶段<br>‘’’<br>time.sleep(2)<br>title &#x3D; browser.title</p>
<h1 id="title：⽤于获得当前页⾯的标题。"><a href="#title：⽤于获得当前页⾯的标题。" class="headerlink" title="title：⽤于获得当前页⾯的标题。"></a>title：⽤于获得当前页⾯的标题。</h1><p>print(title)  # 打印当前页⾯的title<br>now_url &#x3D; browser.current_url # 打印当前页⾯URL</p>
<h1 id="current-url：⽤户获得当前页⾯的URL。"><a href="#current-url：⽤户获得当前页⾯的URL。" class="headerlink" title="current_url：⽤户获得当前页⾯的URL。"></a>current_url：⽤户获得当前页⾯的URL。</h1><p>print(now_url)<br>size &#x3D; browser.find_element_by_id(“kw”).size # 找到输⼊框的页⾯属性<br>print(size)<br>text &#x3D; browser.find_element_by_id(“kw”).text # 获取搜索条⽬的⽂本信息<br>print(text)<br>attribute &#x3D; browser.find_element_by_id(“kw”).get_attribute(‘type’)  # 返回元素属性值<br>print(attribute)<br>result &#x3D; browser.find_element_by_id(“kw”).is_displayed()  # 查看是否可见<br>print(result)<br>browser.find_element_by_id(“kw”).clear()  # 清除内容</p>
<h1 id="如果超出10s抛出异常"><a href="#如果超出10s抛出异常" class="headerlink" title="如果超出10s抛出异常"></a>如果超出10s抛出异常</h1><p>try:<br>print(ctime())<br>    search_test &#x3D; browser.find_element_by_id(“kw”).send_keys(“seleniuma”)  # 输⼊seleniuma<br>    time.sleep(2)<br>except NoSuchElementException as e:<br>print(e)<br>finally:<br>print(ctime())</p>
<h1 id="键盘按键"><a href="#键盘按键" class="headerlink" title="键盘按键"></a>键盘按键</h1><p>browser.find_element_by_id(“kw”).send_keys(Keys.BACK_SPACE)<br>browser.find_element_by_id(“su”).send_keys(Keys.ENTER)<br>time.sleep(2)<br>browser.refresh()  # 刷新<br>time.sleep(2)<br>browser.find_element_by_id(“kw”).clear()<br>search_test2 &#x3D; browser.find_element_by_id(“kw”).send_keys(“webdriver”)  # 输⼊webdriver<br>time.sleep(2)<br>browser.find_element_by_id(‘su’)  # 提交表单</p>
<h1 id="⿏标悬浮"><a href="#⿏标悬浮" class="headerlink" title="⿏标悬浮"></a>⿏标悬浮</h1><p>adove &#x3D; browser.find_element_by_class_name(“pf”)  # 找到adove<br>ActionChains(browser).move_to_element(adove).perform()  # ⽅法：定位到执⾏元素⿏标悬停操作<br>browser.find_element_by_class_name(“setpref”).click()  # 找到下拉条中元素进⾏点击操作,click:点击事件<br>time.sleep(2)</p>
<h1 id="悬停下拉框-显⽰条数"><a href="#悬停下拉框-显⽰条数" class="headerlink" title="悬停下拉框+显⽰条数"></a>悬停下拉框+显⽰条数</h1><h1 id="search03-x3D-browser-find-element-by-link-text-“设置”"><a href="#search03-x3D-browser-find-element-by-link-text-“设置”" class="headerlink" title="search03 &#x3D; browser.find_element_by_link_text(“设置”)"></a>search03 &#x3D; browser.find_element_by_link_text(“设置”)</h1><h1 id="ActionChains-browser-move-to-element-search03-perform"><a href="#ActionChains-browser-move-to-element-search03-perform" class="headerlink" title="ActionChains(browser).move_to_element(search03).perform()"></a>ActionChains(browser).move_to_element(search03).perform()</h1><h1 id="time-sleep-2"><a href="#time-sleep-2" class="headerlink" title="time.sleep(2)"></a>time.sleep(2)</h1><h1 id="搜索结果显⽰条数"><a href="#搜索结果显⽰条数" class="headerlink" title="搜索结果显⽰条数"></a>搜索结果显⽰条数</h1><p>sel &#x3D; browser.find_element_by_xpath(“&#x2F;&#x2F;select[@id&#x3D;’nr’]”)<br>Select(sel).select_by_value(‘50’)  # 显⽰50条<br>time.sleep(5)<br>browser.find_element_by_link_text(“保存设置”).click()<br>time.sleep(2)</p>
<h1 id="返回原来的样⼦"><a href="#返回原来的样⼦" class="headerlink" title="返回原来的样⼦"></a>返回原来的样⼦</h1><p>browser.switch_to.alert.accept()<br>time.sleep(2)<br>search03 &#x3D; browser.find_element_by_link_text(“设置”)<br>ActionChains(browser).move_to_element(search03).perform()<br>time.sleep(2)<br>av &#x3D; browser.find_element_by_link_text(“搜索设置”)<br>av.click()<br>time.sleep(2)<br>browser.find_element_by_id(“nr”).click()</p>
<p>time.sleep(2)</p>
<h1 id="搜索结果显⽰条数-1"><a href="#搜索结果显⽰条数-1" class="headerlink" title="搜索结果显⽰条数"></a>搜索结果显⽰条数</h1><p>sel &#x3D; browser.find_element_by_xpath(“&#x2F;&#x2F;select[@id&#x3D;’nr’]”)<br>Select(sel).select_by_value(‘10’)  # 显⽰10条</p>
<h1 id="……"><a href="#……" class="headerlink" title="……"></a>……</h1><p>time.sleep(2)<br>browser.find_element_by_link_text(“保存设置”).click()<br>time.sleep(2)<br>browser.close()<br>等待扩展<br>WebDriverWait参数<br>def__init__(self, driver, timeout, poll_frequency&#x3D;POLL_FREQUENCY, ignored_exceptions&#x3D;None):<br>pass<br>#driver:类的实例<br>#timeout:超时时间<br>poll_frequency&#x3D;POLL_FREQUENC:#调⽤until或until_not中的⽅法的间隔时间,默认值0.5秒<br>ignored_exceptions&#x3D;None:#忽略的异常，如果在调⽤until或until_not的过程中抛出这个元组中的异常，<br>则不中断代码，继续等待，如果抛出的是这个元组外的异常，则中断代码，抛出异常。默认只有NoSuchElementException<br>#以上是构造函数,下⾯介绍⽅法,总共两个until和until_not<br>defuntil_not(self, method, message&#x3D;’’):#当某元素消失或什么条件不成⽴则继续执⾏<br>pass<br>defuntil(self, method, message&#x3D;’’):#当某元素出现或什么条件成⽴则继续执⾏<br>pass<br>#method:在等待期间，每隔⼀段时间调⽤这个传⼊的⽅法，直到返回值不是False<br>#message: 如果超时，抛出TimeoutException，将message传⼊异常</p>
<p>等待操作<br>from selenium import webdriver<br>from selenium.webdriver.support.wait import WebDriverWait<br>from selenium.webdriver.common.by import By<br>from selenium.webdriver.support import expected_conditions as EC<br>driver &#x3D; webdriver.Chrome()<br>driver.get(‘<a href="http://www.baidu.com&/#39;">http://www.baidu.com&#39;</a>)<br>driver.maximize_window()</p>
<h1 id="判断某个元素进⼊dom树中-可以是不可见的元素-找到返回WebElement对象属性"><a href="#判断某个元素进⼊dom树中-可以是不可见的元素-找到返回WebElement对象属性" class="headerlink" title="判断某个元素进⼊dom树中,可以是不可见的元素,找到返回WebElement对象属性"></a>判断某个元素进⼊dom树中,可以是不可见的元素,找到返回WebElement对象属性</h1><p>WebDriverWait(driver, 10, 1).until(EC.presence_of_element_located((By.CSS_SELECTOR, ‘#kw’)))</p>
<h1 id="判断某组元素进⼊dom树中-可以是不可见的元素-找到返回WebElement对象列表"><a href="#判断某组元素进⼊dom树中-可以是不可见的元素-找到返回WebElement对象列表" class="headerlink" title="判断某组元素进⼊dom树中,可以是不可见的元素,找到返回WebElement对象列表"></a>判断某组元素进⼊dom树中,可以是不可见的元素,找到返回WebElement对象列表</h1><p>WebDriverWait(driver, 10, 1).until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, ‘#kw’)))</p>
<h1 id="判断title是否正确-返回布尔值"><a href="#判断title是否正确-返回布尔值" class="headerlink" title="判断title是否正确,返回布尔值"></a>判断title是否正确,返回布尔值</h1><p>WebDriverWait(driver, 10, 1).until(EC.title_is(u”百度⼀下，你就知道”))</p>
<h1 id="包含判断title是否正确-返回布尔值"><a href="#包含判断title是否正确-返回布尔值" class="headerlink" title="包含判断title是否正确,返回布尔值"></a>包含判断title是否正确,返回布尔值</h1><p>WebDriverWait(driver, 10, 1).until(EC.title_contains(‘百度’))</p>
<h1 id="判断某个元素是否被加到了dom树⾥，并不代表该元素⼀定可见，如果定位到就返回WebElement"><a href="#判断某个元素是否被加到了dom树⾥，并不代表该元素⼀定可见，如果定位到就返回WebElement" class="headerlink" title="判断某个元素是否被加到了dom树⾥，并不代表该元素⼀定可见，如果定位到就返回WebElement"></a>判断某个元素是否被加到了dom树⾥，并不代表该元素⼀定可见，如果定位到就返回WebElement</h1><p>WebDriverWait(driver, 10, 1).until(EC.presence_of_element_located((By.ID, ‘kw’)))</p>
<h1 id="判断是否⾄少有1个元素存在于dom树中，如果定位到就返回列表"><a href="#判断是否⾄少有1个元素存在于dom树中，如果定位到就返回列表" class="headerlink" title="判断是否⾄少有1个元素存在于dom树中，如果定位到就返回列表"></a>判断是否⾄少有1个元素存在于dom树中，如果定位到就返回列表</h1><p>WebDriverWait(driver, 10, 1).until(EC.visibility_of_all_elements_located((By.ID, ‘kw’)))</p>
<h1 id="判断某个元素是否可见"><a href="#判断某个元素是否可见" class="headerlink" title="判断某个元素是否可见"></a>判断某个元素是否可见</h1><p>WebDriverWait(driver, 10, 1).until(EC.visibility_of(driver.find_element(by&#x3D;By.ID, value&#x3D;’kw’)))</p>
<h1 id="判断某个元素是否别添加到dom⾥并可见-可见代表元素可显⽰且宽和⾼都⼤于0"><a href="#判断某个元素是否别添加到dom⾥并可见-可见代表元素可显⽰且宽和⾼都⼤于0" class="headerlink" title="判断某个元素是否别添加到dom⾥并可见,可见代表元素可显⽰且宽和⾼都⼤于0"></a>判断某个元素是否别添加到dom⾥并可见,可见代表元素可显⽰且宽和⾼都⼤于0</h1><p>WebDriverWait(driver, 10, 1).until(EC.visibility_of_element_located((By.ID, ‘kw’)))</p>
<h1 id="判断某个元素是否包含预期字符串-返回布尔值"><a href="#判断某个元素是否包含预期字符串-返回布尔值" class="headerlink" title="判断某个元素是否包含预期字符串,返回布尔值"></a>判断某个元素是否包含预期字符串,返回布尔值</h1><p>WebDriverWait(driver, 10, 1).until(EC.text_to_be_present_in_element((By.XPATH, “&#x2F;&#x2F;*[@id&#x3D;’u1’]&#x2F;a[8]”), u’设置’))</p>
<h1 id="判断指定元素的属性值中是否包含预期字符串-返回布尔值"><a href="#判断指定元素的属性值中是否包含预期字符串-返回布尔值" class="headerlink" title="判断指定元素的属性值中是否包含预期字符串,返回布尔值"></a>判断指定元素的属性值中是否包含预期字符串,返回布尔值</h1><p>WebDriverWait(driver, 10, 1).until(EC.text_to_be_present_in_element_value((By.CSS_SELECTOR, ‘#su’), ‘百度⼀下’))</p>
<h1 id="判断该frame是否可以switch进-如果可以返回True并且switch进去，否则返回False"><a href="#判断该frame是否可以switch进-如果可以返回True并且switch进去，否则返回False" class="headerlink" title="判断该frame是否可以switch进,如果可以返回True并且switch进去，否则返回False"></a>判断该frame是否可以switch进,如果可以返回True并且switch进去，否则返回False</h1><p>WebDriverWait(driver,10,1).until(EC.frame_to_be_available_and_switch_to_it())</p>
<h1 id="判断某个元素中是否可见并且是enable的，代表可点击"><a href="#判断某个元素中是否可见并且是enable的，代表可点击" class="headerlink" title="判断某个元素中是否可见并且是enable的，代表可点击"></a>判断某个元素中是否可见并且是enable的，代表可点击</h1><p>WebDriverWait(driver, 10, 1).until(EC.element_to_be_clickable((By.XPATH, “&#x2F;&#x2F;*[@id&#x3D;’u1’]&#x2F;a[8]”))).click()</p>
<h1 id="等待某个元素从dom树中移除WebDriverWait-driver-10-1-until-EC-staleness-of-driver-find-element-By-ID-’su’"><a href="#等待某个元素从dom树中移除WebDriverWait-driver-10-1-until-EC-staleness-of-driver-find-element-By-ID-’su’" class="headerlink" title="等待某个元素从dom树中移除WebDriverWait(driver,10,1).until(EC.staleness_of(driver.find_element(By.ID,’su’)))"></a>等待某个元素从dom树中移除WebDriverWait(driver,10,1).until(EC.staleness_of(driver.find_element(By.ID,’su’)))</h1><h1 id="判断某个元素是否被选中了-⼀般⽤在下拉列表"><a href="#判断某个元素是否被选中了-⼀般⽤在下拉列表" class="headerlink" title="判断某个元素是否被选中了,⼀般⽤在下拉列表"></a>判断某个元素是否被选中了,⼀般⽤在下拉列表</h1><p>WebDriverWait(driver, 10).until(EC.element_to_be_selected(driver.find_element(By.XPATH, “&#x2F;&#x2F;*[@id&#x3D;’nr’]&#x2F;option[1]”)))</p>
<h1 id="判断某个元素的选中状态是否符合预期"><a href="#判断某个元素的选中状态是否符合预期" class="headerlink" title="判断某个元素的选中状态是否符合预期"></a>判断某个元素的选中状态是否符合预期</h1><p>WebDriverWait(driver, 10).until(</p>
<p>EC.element_selection_state_to_be(driver.find_element(By.XPATH, “&#x2F;&#x2F;*[@id&#x3D;’nr’]&#x2F;option[1]”), True))</p>
<h1 id="判断某个元素的选中状态是否符合预期-1"><a href="#判断某个元素的选中状态是否符合预期-1" class="headerlink" title="判断某个元素的选中状态是否符合预期"></a>判断某个元素的选中状态是否符合预期</h1><p>WebDriverWait(driver, 10).until(EC.element_located_selection_state_to_be((By.XPATH, “&#x2F;&#x2F;*[@id&#x3D;’nr’]&#x2F;option[1]”), True))</p>
<h1 id="判断页⾯上是否存在alert-如果有就切换到alert并返回alert的内容"><a href="#判断页⾯上是否存在alert-如果有就切换到alert并返回alert的内容" class="headerlink" title="判断页⾯上是否存在alert,如果有就切换到alert并返回alert的内容"></a>判断页⾯上是否存在alert,如果有就切换到alert并返回alert的内容</h1><p>instance &#x3D; WebDriverWait(driver, 10).until(EC.alert_is_present())<br>⽂件上传,cookie,滚动条,js执⾏<br>from selenium import webdriver<br>import time<br>driver &#x3D; webdriver.Chrome()<br>driver.get(‘<a href="http://sahitest.com/demo/php/fileUpload.htm&#39;">http://sahitest.com/demo/php/fileUpload.htm&#39;</a>)<br>driver.find_element_by_name(“file”).send_keys(“C:\Users\admin\Desktop\test.txt”)#选择本地⽂件上传<br>driver.find_element_by_name(“submit”).click()<br>driver.quit()<br>driver &#x3D; webdriver.Chrome()<br>driver.set_window_size(1920,1080)<br>driver.get(“<a href="http://www.youdao.com&quot;/">http://www.youdao.com&quot;</a>)</p>
<h1 id="获得cookie信息"><a href="#获得cookie信息" class="headerlink" title="获得cookie信息"></a>获得cookie信息</h1><p>cookie &#x3D; driver.get_cookies()</p>
<h1 id="将获得cookie的信息打印"><a href="#将获得cookie的信息打印" class="headerlink" title="将获得cookie的信息打印"></a>将获得cookie的信息打印</h1><p>print(cookie)<br>print(“向cookie的name 和value中添加会话信息”)<br>driver.add_cookie({‘name’: ‘key-aaaaaaa’, ‘value’: ‘value-bbbbbb’})</p>
<h1 id="遍历cookies中的name-和value信息并打印，当然还有上⾯添加的信息"><a href="#遍历cookies中的name-和value信息并打印，当然还有上⾯添加的信息" class="headerlink" title="遍历cookies中的name 和value信息并打印，当然还有上⾯添加的信息"></a>遍历cookies中的name 和value信息并打印，当然还有上⾯添加的信息</h1><p>for cookie in driver.get_cookies():</p>
<p>print(“%s -&gt; %s” % (cookie[‘name’], cookie[‘value’]))<br>driver.get(“<a href="http://www.testclass.net/selenium_python/javascript/&quot;">http://www.testclass.net/selenium_python/javascript/&quot;</a>)<br>#滚动条操作<br>js &#x3D; “window.scrollTo(100,700);”#scrollTo(x,y)<br>#执⾏js代码<br>driver.execute_script(js)<br>time.sleep(3)<br>driver.quit()<br>警告框处理<br>from selenium import webdriver<br>from selenium.webdriver.common.action_chains import ActionChains<br>import time<br>browser &#x3D; webdriver.Firefox()<br>browser.implicitly_wait(10)<br>browser.get(“<a href="https://www.baidu.com&quot;/">https://www.baidu.com&quot;</a>)<br>time.sleep(2)<br>link &#x3D; browser.find_element_by_link_text(“设置”)<br>ActionChains(browser).move_to_element(link).perform()<br>browser.find_element_by_link_text(“搜索设置”).click()<br>time.sleep(2)<br>browser.find_element_by_link_text(“保存设置”).click()<br>time.sleep(2)<br>print (browser.switch_to_alert().text)      #先打印再接受警告框<br>ar &#x3D; browser.switch_to.alert.accept()        #点击确定警告框<br>dis &#x3D; browser.switch_to.alert.dismiss()#点击取消警告框<br>browser.quit()</p>
<p>多窗⼝切换<br>from selenium import webdriver<br>import time<br>driver &#x3D; webdriver.Chrome()<br>driver.implicitly_wait(10)<br>driver.get(“<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a>)</p>
<h1 id="获取当前对象的窗⼝句柄"><a href="#获取当前对象的窗⼝句柄" class="headerlink" title="获取当前对象的窗⼝句柄"></a>获取当前对象的窗⼝句柄</h1><p>sreach_windows &#x3D; driver.current_window_handle<br>driver.find_element_by_link_text(‘登录’).click()<br>driver.find_element_by_link_text(“⽴即注册”).click()</p>
<h1 id="获得当前所有打开的窗⼝的句柄-以列表形式返回"><a href="#获得当前所有打开的窗⼝的句柄-以列表形式返回" class="headerlink" title="获得当前所有打开的窗⼝的句柄,以列表形式返回"></a>获得当前所有打开的窗⼝的句柄,以列表形式返回</h1><p>all_handles &#x3D; driver.window_handles</p>
<h1 id="进⼊注册窗⼝"><a href="#进⼊注册窗⼝" class="headerlink" title="进⼊注册窗⼝"></a>进⼊注册窗⼝</h1><p>for handle in all_handles:<br>if handle !&#x3D; sreach_windows:#遍历如果不属于之前的那个页⾯就执⾏下⾯操作<br>        driver.switch_to.window(handle)#跳转到另⼀个页⾯<br>print(‘now register window!’)<br>        driver.find_element_by_name(“userName”).send_keys(‘这个是⽤户名’)</p>
<p>driver.find_element_by_id(‘TANGRAM__PSP_3__phone’).send_keys(‘123456’)<br>        time.sleep(2)</p>
<h1 id="以上过于复杂-可以参考以下两⾏"><a href="#以上过于复杂-可以参考以下两⾏" class="headerlink" title="以上过于复杂,可以参考以下两⾏"></a>以上过于复杂,可以参考以下两⾏</h1><p>last_handle &#x3D; driver.windows_handles[-1]# 表⽰拿到列表最后⼀个值,也就是最后⼀个页⾯的窗⼝句柄<br>driver.switch_to.window(last_handle)# 让浏览器跳到刚刚指定页⾯</p>
<h1 id="两个页⾯之间tab切换"><a href="#两个页⾯之间tab切换" class="headerlink" title="两个页⾯之间tab切换"></a>两个页⾯之间tab切换</h1><p>driver.switch_to.window(all_handles[0])<br>time.sleep(5)<br>driver.switch_to.window(all_handles[1])<br>time.sleep(5)<br>driver.switch_to.window(all_handles[0])<br>driver.quit()<br>判断checkbox勾选<br>off &#x3D; driver.find_element_by_id(‘xxx’)# 定位到checkbox勾选元素<br>print(on.is_selected())# 判断是否勾选,返回布尔值<br>iframe定位<br>driver.switch_to.frame(‘xxx’)# 切换进⼊到当前html下的frame层<br>driver.switch_to.parent_frame()# 返回上⼀层<br>driver.switch_to.default_content()# 直接返回最外层<br>拖拽指令<br>from selenium.webdriver.common.action_chains import ActionChains<br>s1 &#x3D; driver.find_element_by_id(‘xxx’)# s1为推拽起始元素<br>t1 &#x3D; driver.find_element_by_class_name(‘xxx’)# t1位推拽⽬标元素<br>ActionChains(driver).drag_and_drop(s1,t1).perform()</p>
<p>UI⾃动化框架(web)<br>我们为什么要做ui⾃动化测试?<br>　　项⽬基于稳定的前提,由于⽼功能在原先基础要增加新功能点,为了避免在旧业务上有过多资源来回归测试,可以⽤ui⾃动化来对其业务进<br>⾏回归测试,不适⽤与新业务<br>我们为什么要做ui⾃动化框架?<br>　　⽬前互联⽹公司ui⾃动化框架现状:<br>1.运⾏不稳定<br>2.维护⿇烦,源码修改后需要重新定位<br>3.⾃动化测试⽤例与页⾯数据脚本写在⼀起,排查时业务混乱<br>　　⾃动化框架解决思路:<br>1.显⽰等待框架封装<br>2.PO思想(page object) 每个页⾯为⼀个类class,每个功能为⼀个函数def,web端和app端都以这种思想为主<br>3.⾃动化测试⽤例与页⾯数据脚本分离<br>　　所以可以基于selenium webdriver原⽣代码,unittest单元测试api,报告,截图,⽇志和现状结合实现的框架能很好的帮助我们做好框架<br>框架中怎么为业务逻辑做断⾔?</p>
<p>1.判断元素消失,代表业务成功<br>2.判断另⼀个元素出现,且该元素⼀定是唯⼀的<br>有哪些框架值得我们使⽤?<br>　　我个⼈推荐⾍师⼤⼤的框架,pyse,poium,还有等都是优秀的改良版测试框架,内置增加了api⾜够我们使⽤了,当然还有⼀些很好⽤的其他<br>框架,欢迎推荐</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>01_selenium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试的16种测试类型</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%8416%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="软件测试主要从以下16种类型进行测试："><a href="#软件测试主要从以下16种类型进行测试：" class="headerlink" title="软件测试主要从以下16种类型进行测试："></a>软件测试主要从以下16种类型进行测试：</h2><h3 id="一：功能测试（10个方面）"><a href="#一：功能测试（10个方面）" class="headerlink" title="一：功能测试（10个方面）"></a>一：功能测试（10个方面）</h3><p>　　菜单、工具栏、快捷键、下拉框、按钮、单选按钮、复选按钮、切换、链接、触发键</p>
<h3 id="二：界面测试"><a href="#二：界面测试" class="headerlink" title="二：界面测试"></a>二：界面测试</h3><pre><code>登陆界面、总界面、输入界面（增、删、改、查）、处理界面、输出界面、报表界面、提示界面
</code></pre>
<h3 id="三：容错测试"><a href="#三：容错测试" class="headerlink" title="三：容错测试"></a>三：容错测试</h3><p>　　数据长度、数据类型、非法此操作</p>
<h3 id="四：接口测试"><a href="#四：接口测试" class="headerlink" title="四：接口测试"></a>四：接口测试</h3><p>　　接口测试也叫业务流程测试（包括功能模块之间、模块与模块之间、子系统之间）<br>　　内部接口：例如：导入、导出（通俗的讲是接口就是调用）<br>　　外部接口：</p>
<h3 id="五：性能测试（TPS吞吐量、响应速度、cpu占用率、内存占用率）"><a href="#五：性能测试（TPS吞吐量、响应速度、cpu占用率、内存占用率）" class="headerlink" title="五：性能测试（TPS吞吐量、响应速度、cpu占用率、内存占用率）"></a>五：性能测试（TPS吞吐量、响应速度、cpu占用率、内存占用率）</h3><p>　　平均吞吐量：单位时间内处理事务的个数<br>　　平均响应速度：做一个事务处理所用时间<br>　　例如：界面操作效率测试；报表输出及查询效率测试</p>
<h3 id="六：负载测试（压力测试、强度测试、容量测试）"><a href="#六：负载测试（压力测试、强度测试、容量测试）" class="headerlink" title="六：负载测试（压力测试、强度测试、容量测试）"></a>六：负载测试（压力测试、强度测试、容量测试）</h3><p>　　压力测试即就是大用户测试（针对B&#x2F;S而言）<br>　　容量测试即就是大数据量测试</p>
<h3 id="七：并发测试"><a href="#七：并发测试" class="headerlink" title="七：并发测试"></a>七：并发测试</h3><p>　　指多个用户在同一时间对同一条数据的删除或者修改等处理</p>
<h3 id="八：稳定性测试"><a href="#八：稳定性测试" class="headerlink" title="八：稳定性测试"></a>八：稳定性测试</h3><p>　　例如：1小时触发600条信息，那么8个、10个等发信息的条数测试</p>
<h3 id="九：恢复测试"><a href="#九：恢复测试" class="headerlink" title="九：恢复测试"></a>九：恢复测试</h3><p>　　突然断电（系统触发正常启动；数据包要在断电的地方继续进行处理）</p>
<h3 id="十：配置测试"><a href="#十：配置测试" class="headerlink" title="十：配置测试"></a>十：配置测试</h3><p>　　最低配置：<br>　　推荐配置：大多数用户所用的配置</p>
<h3 id="十一：安装测试"><a href="#十一：安装测试" class="headerlink" title="十一：安装测试"></a>十一：安装测试</h3><p>　　安装过程；卸载过程</p>
<h3 id="十二：文档测试"><a href="#十二：文档测试" class="headerlink" title="十二：文档测试"></a>十二：文档测试</h3><p>　　交给用户的文档。例如：系统帮助、用户使用手册、用户安装手册</p>
<h3 id="十三：可用性测试（纯粹靠经验）"><a href="#十三：可用性测试（纯粹靠经验）" class="headerlink" title="十三：可用性测试（纯粹靠经验）"></a>十三：可用性测试（纯粹靠经验）</h3><h3 id="十四：初始化测试"><a href="#十四：初始化测试" class="headerlink" title="十四：初始化测试"></a>十四：初始化测试</h3><p>　　是指系统刚刚安装完成后，在数据位空的情况下，如果被调用的模块为空，点击调用模块的时候，是否进行容错的测试。</p>
<h3 id="十五：数据完整性测试"><a href="#十五：数据完整性测试" class="headerlink" title="十五：数据完整性测试"></a>十五：数据完整性测试</h3><p>　　是指当主表的某一条件信息被删除后，和这一条相关的从表的信息都应该被删除。<br>　　如果某些数据的主键是由数据库本身而实现的，可以不用删除，如果有些主从表是由程序员写的代码而实现，则要进行数据完整性的测试。</p>
<h3 id="16种测试类型归类"><a href="#16种测试类型归类" class="headerlink" title="16种测试类型归类"></a>16种测试类型归类</h3><h4 id="1、此软件能做什么？"><a href="#1、此软件能做什么？" class="headerlink" title="1、此软件能做什么？"></a>1、此软件能做什么？</h4><p>　　针对数据进行”功能、接口、容错、界面、权限、初始化、数据完整性测试“</p>
<h4 id="2、软件做的怎么样？"><a href="#2、软件做的怎么样？" class="headerlink" title="2、软件做的怎么样？"></a>2、软件做的怎么样？</h4><p>　　性能、负载、恢复、稳定性、并发、系统安全</p>
<h4 id="3、软件在什么环境条件下做？"><a href="#3、软件在什么环境条件下做？" class="headerlink" title="3、软件在什么环境条件下做？"></a>3、软件在什么环境条件下做？</h4><p>　　配置、安装、文档、可用性</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>PlayWright教程(二)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/03_Playwright/03_PlayWright%E6%95%99%E7%A8%8B(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="页面基本操作"><a href="#页面基本操作" class="headerlink" title="页面基本操作"></a><strong>页面基本操作</strong></h2><p><a href="https://playwright.bootcss.com/docs/navigations" title="Navigations | Playwright 中文文档 | Playwright 中文网">Navigations | Playwright 中文文档 | Playwright 中文网</a></p>
<p>按照官网文档，调用 page.goto(url) 后页面加载过程：</p>
<ol>
<li>设定 url</li>
<li>通过网络加载解析页面</li>
<li>触发 page.on(“domcontentloaded”) 事件</li>
<li>执行页面的 js 脚本，加载静态资源</li>
<li>触发 page.on(“laod”) 事件</li>
<li>页面执行动态加载的脚本</li>
<li>当 500ms 都没有新的网络请求的时候，触发 networkidle 事件<br><code>page.goto(url)</code> 会跳转到一个新的链接。默认情况下 Playwright 会等待到 load 状态。如果我们不关心加载的 CSS 图片等信息，可以改为等待到 domcontentloaded 状态，如果页面是 ajax 加载，那么我们需要等待到 networkidle 状态。如果 networkidle 也不合适的话，可以采用 page.wait_for_selector 等待某个元素出现。不过对于 click 等操作会自动等待。<pre><code class="python">page.goto(url, referer=&quot;&quot;, timeout=30, wait_until=&quot;domcontentloaded|load|networkidle&quot;)
// Navigate and wait until network is idle
await page.goto(&#39;https://example.com&#39;, &#123; waitUntil: &#39;networkidle&#39; &#125;);
</code></pre>
</li>
</ol>
<p>Playwright 会自动等待元素处于可操作的稳定状态。当然也可以用 <code>page.wait_for_*</code> 函数来手工等待：</p>
<pre><code class="python">page.wait_for_event(&quot;event&quot;, event_predict, timeout)
page.wait_for_function(js_function)
page.wait_for_load_state(state=&quot;domcontentloaded|load|networkidle&quot;, timeout)
page.wait_for_selector(selector, timeout)
page.wait_for_timeout(timeout)  # 不推荐使用
</code></pre>
<p>对页面的操作方法主要有：</p>
<pre><code class="python"># selector 指的是 CSS 等表达式
page.click(selector)
page.fill(selector, value)  # 在 input 中填充值

# 例子
page.click(&quot;#search&quot;)
</code></pre>
<p>获取页面中的数据的主要方法有：</p>
<pre><code class="python">page.url  # url
page.title()  # title
page.content()  # 获取页面全文
page.inner_text(selector)  # element.inner_text()
page.inner_html(selector)
page.text_content(selector)
page.get_attribute(selector, attr)

# eval_on_selector 用于获取 DOM 中的值
page.eval_on_selector(selector, js_expression)
# 比如：
search_value = page.eval_on_selector(&quot;#search&quot;, &quot;el =&gt; el.value&quot;)

# evaluate 用于获取页面中 JS 中的数据，比如说可以读取 window 中的值
result = page.evaluate(&quot;([x, y]) =&gt; Promise.resolve(x * y)&quot;, [7, 8])
print(result) # prints &quot;56&quot;
</code></pre>
<h3 id="选择器表达式"><a href="#选择器表达式" class="headerlink" title="选择器表达式"></a><strong>选择器表达式</strong></h3><p>在上面的代码中，我们使用了 CSS 表达式（比如<code>#button</code>）来选取元素。实际上，Playwright 还支持 XPath 和自己定义的两种简单表达式，并且是自动识别的。</p>
<pre><code class="python"># 通过文本选择元素，这是 Playwright 自定义的一种表达式
page.click(&quot;text=login&quot;)

# 直接通过 id 选择
page.click(&quot;id=login&quot;)

# 通过 CSS 选择元素
page.click(&quot;#search&quot;)
# 除了常用的 CSS 表达式外，Playwright 还支持了几个新的伪类
# :has 表示包含某个元素的元素
page.click(&quot;article:has(div.prome)&quot;)
# :is 用来对自身做断言
page.click(&quot;button:is(:text(&#39;sign in&#39;), :text(&#39;log in&#39;))&quot;)
# :text 表示包含某个文本的元素
page.click(&quot;button:text(&#39;Sign in&#39;)&quot;)  # 包含
page.click(&quot;button:text-is(&#39;Sign is&#39;)&quot;)  # 严格匹配
page.click(&quot;button:text-matches(&#39;\w+&#39;)&quot;)  # 正则
# 还可以根据方位匹配
page.click(&quot;button:right-of(#search)&quot;)  # 右边
page.click(&quot;button:left-of(#search)&quot;)  # 左边
page.click(&quot;button:above(#search)&quot;)  # 上边
page.click(&quot;button:below(#search)&quot;)  # 下边
page.click(&quot;button:near(#search)&quot;)  # 50px 之内的元素

# 通过 XPath 选择
page.click(&quot;//button[@id=&#39;search&#39;])&quot;)
# 所有 // 或者 .. 开头的表达式都会默认为 XPath 表达式
</code></pre>
<p>对于 CSS 表达式，还可以添加前缀<code>css=</code>来显式指定，比如说 <code>css=.login</code> 就相当于 <code>.login</code>.</p>
<p>除了上面介绍的四种表达式以外，Playwright 还支持使用 <code>&gt;&gt;</code> 组合表达式，也就是混合使用四种表达式。</p>
<pre><code class="python">page.click(&#39;css=nav &gt;&gt; text=Login&#39;)
</code></pre>
<h2 id="复用-Cookies-等认证信息"><a href="#复用-Cookies-等认证信息" class="headerlink" title="复用 Cookies 等认证信息"></a><strong>复用 Cookies 等认证信息</strong></h2><p>在 Puppeteer 中，复用 Cookies 也是一个老大难问题了。这个是 Playwright 特别方便的一点，他可以直接导出 Cookies 和 LocalStorage, 然后在新的 Context 中使用。</p>
<pre><code class="python"># 保存状态
import json
storage = context.storage_state()
with open(&quot;state.json&quot;, &quot;w&quot;) as f:
    f.write(json.dumps(storage))

# 加载状态
with open(&quot;state.json&quot;) as f:
    storage_state = json.loads(f.read())
context = browser.new_context(storage_state=storage_state)
</code></pre>
<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a><strong>监听事件</strong></h2><p>通过 page.on(event, fn) 可以来注册对应事件的处理函数：</p>
<pre><code class="python">def log_request(intercepted_request):
    print(&quot;a request was made:&quot;, intercepted_request.url)
page.on(&quot;request&quot;, log_request)
# sometime later...
page.remove_listener(&quot;request&quot;, log_request)
</code></pre>
<p>其中比较重要的就是 request 和 response 两个事件</p>
<h3 id="拦截更改网络请求"><a href="#拦截更改网络请求" class="headerlink" title="拦截更改网络请求"></a><strong>拦截更改网络请求</strong></h3><p>可以通过 page.on(“request”) 和 page.on(“response”) 来监听请求和响应事件。</p>
<pre><code class="python">from playwright.sync_api import sync_playwright as playwright

def run(pw):
    browser = pw.webkit.launch()
    page = browser.new_page()
    # Subscribe to &quot;request&quot; and &quot;response&quot; events.
    page.on(&quot;request&quot;, lambda request: print(&quot;&gt;&gt;&quot;, request.method, request.url))
    page.on(&quot;response&quot;, lambda response: print(&quot;&lt;&lt;&quot;, response.status, response.url))
    page.goto(&quot;https://example.com&quot;)
    browser.close()

with playwright() as pw:
    run(pw)
</code></pre>
<p>其中 request 和 response 的属性和方法，可以查阅文档：<a href="https://link.zhihu.com/?target=https://playwright.dev/python/docs/api/class-request" title="https://playwright.dev/python/docs/api/class-request">https://playwright.dev/python/docs/api/class-request</a></p>
<p>通过 context.route, 还可以伪造修改拦截请求等。比如说，拦截所有的图片请求以减少带宽占用：</p>
<pre><code class="python">context = browser.new_context()
page = context.new_page()
# route 的参数默认是通配符，也可以传递编译好的正则表达式对象
context.route(&quot;**/*.&#123;png,jpg,jpeg&#125;&quot;, lambda route: route.abort())
context.route(re.compile(r&quot;(\.png$)|(\.jpg$)&quot;), lambda route: route.abort())
page.goto(&quot;https://example.com&quot;)
browser.close()
</code></pre>
<p>其中 route 对象的相关属性和方法，可以查阅文档：<a href="https://link.zhihu.com/?target=https://playwright.dev/python/docs/api/class-route" title="https://playwright.dev/python/docs/api/class-route">https://playwright.dev/python/docs/api/class-route</a></p>
<h3 id="灵活设置代理"><a href="#灵活设置代理" class="headerlink" title="灵活设置代理"></a><strong>灵活设置代理</strong></h3><p>Playwright 还可以很方便地设置代理。Puppeteer 在打开浏览器之后就无法在更改代理了，对于爬虫类应用非常不友好，而 Playwright 可以通过 Context 设置代理，这样就非常轻量，不用为了切换代理而重启浏览器。</p>
<pre><code class="python">context = browser.new_context(
    proxy=&#123;&quot;server&quot;: &quot;http://example.com:3128&quot;, &quot;bypass&quot;: &quot;.example.com&quot;, &quot;username&quot;: &quot;&quot;, &quot;password&quot;: &quot;&quot;&#125;
)
</code></pre>
<h2 id="杀手级功能：录制操作直接生成代码"><a href="#杀手级功能：录制操作直接生成代码" class="headerlink" title="杀手级功能：录制操作直接生成代码"></a><strong>杀手级功能：录制操作直接生成代码</strong></h2><p>Playwright 的命令行还内置了一个有趣的功能：可以通过录制你的点击操作，直接生成 Python 代码。</p>
<pre><code class="python">python -m playwright codegen http://example.com/
</code></pre>
<p>Playwright 还有很多命令行功能，比如生成截图等等，可以通过 <code>python -m playwright -h</code> 查看。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><p>除此之外，Playwright 还支持处理页面弹出的窗口，模拟键盘，模拟鼠标拖动（用于滑动验证码），下载文件等等各种功能，请查看官方文档吧，这里不赘述了。对于写爬虫来说，Playwright 的几个特性可以说是秒杀 Puppeteer&#x2F;Pyppeteer:</p>
<ol>
<li>官方同步版本的 API</li>
<li>方便导入导出 Cookies</li>
<li>轻量级设置和切换代理</li>
<li>支持丰富的选择表达式</li>
</ol>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>03_Playwright</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>PlayWright教程(一)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/03_Playwright/02_PlayWright%E6%95%99%E7%A8%8B(%E4%B8%80)/</url>
    <content><![CDATA[<p>PlayWright的核心概念包括：</p>
<ul>
<li><a href="https://playwright.dev/python/docs/core-concepts#browser" title="Browser">Browser</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#browser-contexts" title="Browser contexts">Browser contexts</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#pages-and-frames" title="Pages and frames">Pages and frames</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#selectors" title="Selectors">Selectors</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#auto-waiting" title="Auto-waiting">Auto-waiting</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#execution-contexts-playwright-and-browser" title="Execution contexts: Playwright and Browser">Execution contexts: Playwright and Browser</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#evaluation-argument" title="Evaluation Argument">Evaluation Argument</a><h1 id="1-Browser"><a href="#1-Browser" class="headerlink" title="1. Browser"></a>1. Browser</h1>一个Browser是一个Chromium, Firefox 或 <a href="https://so.csdn.net/so/search?q=WebKit&spm=1001.2101.3001.7020">WebKit</a>（plarywright支持的三种浏览器）的实例plarywright脚本通常以启动浏览器实例开始，以关闭浏览器结束。浏览器实例可以在headless（没有 GUI）或head模式下启动。Browser实例创建：<pre><code class="python">from playwright.sync_api import sync_playwright
with sync_playwright() as p:
  browser = p.chromium.launch(headless=False)
  browser.close()
</code></pre>
启动browser实例是比较耗费资源的，plarywright做的就是如何通过一个browser实例最大化多个BrowserContext的性能。<br>API:</li>
<li><a href="https://playwright.dev/python/docs/api/class-browser" title="Browser">Browser</a><h1 id="2-BrowserContext"><a href="#2-BrowserContext" class="headerlink" title="2.BrowserContext"></a>2.BrowserContext</h1>一个BrowserContex就像是一个独立的匿名模式会话（session），非常轻量，但是又完全隔离。<br>（译者注：每个browser实例可有多个BrowserContex，且完全隔离。比如可以在两个BrowserContext中登录两个不同的账号，也可以在两个 context 中使用不同的代理。 ）<br>context创建：<pre><code class="python">browser = playwright.chromium.launch()
context = browser.new_context()
</code></pre>
context还可用于模拟涉及移动设备、权限、区域设置和配色方案的多页面场景，如移动端context创建：<pre><code class="python">from playwright.sync_api import sync_playwright
with sync_playwright() as p:
  iphone_11 = p.devices[&#39;iPhone 11 Pro&#39;]
  browser = p.webkit.launch(headless=False)
  context = browser.new_context(
      **iphone_11,
      locale=&#39;de-DE&#39;,
      geolocation=&#123; &#39;longitude&#39;: 12.492507, &#39;latitude&#39;: 41.889938 &#125;,
      permissions=[&#39;geolocation&#39;]
  )
  browser.close()
</code></pre>
API:</li>
<li><a href="https://playwright.dev/python/docs/api/class-browsercontext" title="BrowserContext">BrowserContext</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-browser#browser-new-context" title="browser.new_context(**kwargs)">browser.new_context(**kwargs)</a></li>
</ul>
<h1 id="3-Page-和-Frame"><a href="#3-Page-和-Frame" class="headerlink" title="3. Page 和 Frame"></a>3. Page 和 <a href="https://so.csdn.net/so/search?q=Frame&spm=1001.2101.3001.7020">Frame</a></h1><p> 一个BrowserContext可以有多个page，每个page代表一个tab或者一个弹窗。page用于导航到URL并与page内的内容交互。<br>创建page:</p>
<pre><code class="python">page = context.new_page()
# Navigate explicitly, similar to entering a URL in the browser.
page.goto(&#39;http://example.com&#39;)
# Fill an input.
page.fill(&#39;#search&#39;, &#39;query&#39;)
# Navigate implicitly by clicking a link.
page.click(&#39;#submit&#39;)
# Expect a new url.
print(page.url)
# Page can navigate from the script - this will be picked up by Playwright.
# window.location.href = &#39;https://example.com&#39;
</code></pre>
<p> 一个page可以有多个frame对象，但只有一个主frame，所有page-level的操作(比如click），都是作用在主frame上的。page的其他frame会打上<code>iframe</code> HTML标签，这些frame可以在内部操作实现访问。</p>
<pre><code class="python"># 通过name属性获取frame
frame = page.frame(&#39;frame-login&#39;)

# 通过URL获取frame
frame = page.frame(url=r&#39;.*domain.*&#39;)

# 通过其他选择器(selector)获取frame
frame_element_handle = page.query_selector(&#39;.frame-class&#39;)
frame = frame_element_handle.content_frame()

# 与frame交互
frame.fill(&#39;#username-input&#39;, &#39;John&#39;)
</code></pre>
<p>在录制模式下，会自动识别是否是frame内的操作，不好定位frame时，那么可以使用录制模式来找。</p>
<p>API：</p>
<ul>
<li><a href="https://playwright.dev/python/docs/api/class-page" title="Page">Page</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-frame" title="Frame">Frame</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-page#page-frame" title="page.frame(**kwargs)">page.frame(**kwargs)</a></li>
</ul>
<h1 id="4-Selector"><a href="#4-Selector" class="headerlink" title="4. Selector"></a>4. <a href="https://so.csdn.net/so/search?q=Selector&spm=1001.2101.3001.7020">Selector</a></h1><p> playwright可以通过 CSS selector, XPath selector, HTML 属性（比如 <code>id</code>, <code>data-test-id）或者是文本内容</code>定位元素。</p>
<p>除了xpath selector外，所有selector默认都是指向shadow DOM，如果要指向常规DOM，可使用*:light。不过通常不需要。</p>
<pre><code class="python"># Using data-test-id= selector engine
page.click(&#39;data-test-id=foo&#39;)

# CSS and XPath selector engines are automatically detected
page.click(&#39;div&#39;)
page.click(&#39;//html/body/div&#39;)

# Find node by text substring
page.click(&#39;text=Hello w&#39;)

# Explicit CSS and XPath notation
page.click(&#39;css=div&#39;)
page.click(&#39;xpath=//html/body/div&#39;)

# Only search light DOM, outside WebComponent shadow DOM:
page.click(&#39;css:light=div&#39;)

# 不同的selector可组合使用，用 &gt;&gt;连接
# Click an element with text &#39;Sign Up&#39; inside of a #free-month-promo.
page.click(&#39;#free-month-promo &gt;&gt; text=Sign Up&#39;)

# Capture textContent of a section that contains an element with text &#39;Selectors&#39;.
section_text = page.eval_on_selector(&#39;*css=section &gt;&gt; text=Selectors&#39;, &#39;e =&gt; e.textContent&#39;)
</code></pre>
<p>详细：</p>
<p><a href="https://playwright.dev/python/docs/selectors/" title="Element selectors | Playwright Python">Element selectors | Playwright Python</a></p>
<h1 id="5-Auto-waiting"><a href="#5-Auto-waiting" class="headerlink" title="5.  Auto-waiting"></a>5.  Auto-waiting</h1><p>playwright在执行操作之前对元素执行一系列可操作性检查，以确保这些行动按预期运行。它会自动等待（auto-wait）所有相关检查通过，然后才执行请求的操作。如果所需的检查未在给定的范围内通过<code>timeout</code>，则操作将失败并显示<code>TimeoutError</code></p>
<p>如 <a href="https://playwright.dev/python/docs/api/class-page#page-click" title="page.click(selector, **kwargs)">page.click(selector, **kwargs)</a> 和 <a href="https://playwright.dev/python/docs/api/class-page#page-fill" title="page.fill(selector, value, **kwargs)">page.fill(selector, value, **kwargs)</a> 这样的操作会执行auto-wait ，等待元素变成可见（visible）和 可操作（ <a href="https://playwright.dev/python/docs/actionability" title="actionable">actionable</a>）。例如，click将会:</p>
<ul>
<li>等待selectorx选定元素出现在 DOM 中</li>
<li>待它变得可见（visible）：有非空的边界框且没有 <code>visibility:hidden</code></li>
<li>等待它停止移动：例如，等待 css 过渡（css transition）完成</li>
<li>将元素滚动到视图中</li>
<li>等待它在动作点接收点事件：例如，等待元素不被其他元素遮挡</li>
<li>如果在上述任何检查期间元素被分离，则重试</li>
</ul>
<pre><code class="python"># Playwright waits for #search element to be in the DOM
page.fill(&#39;#search&#39;, &#39;query&#39;)

# Playwright waits for element to stop animating
# and accept clicks.
page.click(&#39;#search&#39;)

#也可显示执行等待动作

# Wait for #search to appear in the DOM.
page.wait_for_selector(&#39;#search&#39;, state=&#39;attached&#39;)
# Wait for #promo to become visible, for example with `visibility:visible`.
page.wait_for_selector(&#39;#promo&#39;)

# Wait for #details to become hidden, for example with `display:none`.
page.wait_for_selector(&#39;#details&#39;, state=&#39;hidden&#39;)
# Wait for #promo to be removed from the DOM.
page.wait_for_selector(&#39;#promo&#39;, state=&#39;detached&#39;)
</code></pre>
<p> API:</p>
<ul>
<li><a href="https://playwright.dev/python/docs/api/class-page#page-click" title="page.click(selector, **kwargs)">page.click(selector, **kwargs)</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-page#page-fill" title="page.fill(selector, value, **kwargs)">page.fill(selector, value, **kwargs)</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-page#page-wait-for-selector" title="page.wait_for_selector(selector, **kwargs)">page.wait_for_selector(selector, **kwargs)</a></li>
</ul>
<h1 id="6-Execution-context"><a href="#6-Execution-context" class="headerlink" title="6. Execution context"></a>6. Execution context</h1><p>API <a href="https://playwright.dev/python/docs/api/class-page#page-evaluate" title="page.evaluate(expression, **kwargs)">page.evaluate(expression, **kwargs)</a> 可以用来运行web页面中的 JavaScript函数，并将结果返回到plarywright环境中。浏览器的<a href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">全局变量</a>，如 <code>window</code> 和 <code>document，</code> 可用于 <code>evaluate。</code></p>
<pre><code class="python">href = page.evaluate(&#39;() =&gt; document.location.href&#39;)

# if the result is a Promise or if the function is asynchronous evaluate will automatically wait until it&#39;s resolved

status = page.evaluate(&quot;&quot;&quot;async () =&gt; &#123;
  response = fetch(location.href)
  return response.status
&#125;&quot;&quot;&quot;)
</code></pre>
<h2 id="7-Evaluation-Argument"><a href="#7-Evaluation-Argument" class="headerlink" title="7. Evaluation Argument"></a>7. Evaluation Argument</h2><p>  <a href="https://playwright.dev/python/docs/api/class-page#page-evaluate" title="page.evaluate(expression, **kwargs)">page.evaluate(expression, **kwargs)</a> 方法接收单个可选参数。此参数可以是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description" title="Serializable">Serializable</a>值和<a href="https://playwright.dev/python/docs/api/class-jshandle" title="JSHandle">JSHandle</a>或<a href="https://playwright.dev/python/docs/api/class-elementhandle" title="ElementHandle">ElementHandle</a>实例的混合。句柄会自动转换为它们所代表的值</p>
<pre><code class="python">result = page.evaluate(&quot;([x, y]) =&gt; Promise.resolve(x * y)&quot;, [7, 8])
print(result) # prints &quot;56&quot;


print(page.evaluate(&quot;1 + 2&quot;)) # prints &quot;3&quot;
x = 10
print(page.evaluate(f&quot;1 + &#123;x&#125;&quot;)) # prints &quot;11&quot;


body_handle = page.query_selector(&quot;body&quot;)
html = page.evaluate(&quot;([body, suffix]) =&gt; body.innerHTML + suffix&quot;, [body_handle, &quot;hello&quot;])
body_handle.dispose()


# A primitive value.
page.evaluate(&#39;num =&gt; num&#39;, 42)

# An array.
page.evaluate(&#39;array =&gt; array.length&#39;, [1, 2, 3])

# An object.
page.evaluate(&#39;object =&gt; object.foo&#39;, &#123; &#39;foo&#39;: &#39;bar&#39; &#125;)

# A single handle.
button = page.query_selector(&#39;button&#39;)
page.evaluate(&#39;button =&gt; button.textContent&#39;, button)

# Alternative notation using elementHandle.evaluate.
button.evaluate(&#39;(button, from) =&gt; button.textContent.substring(from)&#39;, 5)

# Object with multiple handles.
button1 = page.query_selector(&#39;.button1&#39;)
button2 = page.query_selector(&#39;.button2&#39;)
page.evaluate(&quot;&quot;&quot;o =&gt; o.button1.textContent + o.button2.textContent&quot;&quot;&quot;,
    &#123; &#39;button1&#39;: button1, &#39;button2&#39;: button2 &#125;)

# Object destructuring works. Note that property names must match
# between the destructured object and the argument.
# Also note the required parenthesis.
page.evaluate(&quot;&quot;&quot;
    (&#123; button1, button2 &#125;) =&gt; button1.textContent + button2.textContent&quot;&quot;&quot;,
    &#123; &#39;button1&#39;: button1, &#39;button2&#39;: button2 &#125;)

# Array works as well. Arbitrary names can be used for destructuring.
# Note the required parenthesis.
page.evaluate(&quot;&quot;&quot;
    ([b1, b2]) =&gt; b1.textContent + b2.textContent&quot;&quot;&quot;,
    [button1, button2])

# Any non-cyclic mix of serializables and handles works.
page.evaluate(&quot;&quot;&quot;
    x =&gt; x.button1.textContent + x.list[0].textContent + String(x.foo)&quot;&quot;&quot;,
    &#123; &#39;button1&#39;: button1, &#39;list&#39;: [button2], &#39;foo&#39;: None &#125;)
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>03_Playwright</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Playwright</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/03_Playwright/01_Playwright/</url>
    <content><![CDATA[<p>Playwright是由微软公司2020年初发布的新一代自动化测试工具，相较于目前最常用的Selenium，本文就详细的介绍一下快速上手指南，对新手有一定的帮助，感兴趣的可以了解一下<br><a href="https://playwright.bootcss.com/docs/installation" title="Installation | Playwright 中文文档 | Playwright 中文网">Installation | Playwright 中文文档 | Playwright 中文网</a></p>
<h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ul>
<li><ol>
<li>为什么选择Playwright</li>
</ol>
<ul>
<li>1.1 Playwright的优势</li>
<li>1.2 已知局限性</li>
</ul>
</li>
<li><ol start="2">
<li>Playwright使用</li>
</ol>
</li>
<li>2.1 安装</li>
<li>2.2 自动录制</li>
<li>2.3 定制化编写</li>
<li>2.4 网络拦截（Mock接口），示例如下：</li>
<li>2.6 异步执行，示例如下：</li>
<li>2.7 Pytest结合，示例如下：</li>
<li>2.8 移动端操作，示例如下：</li>
<li><ol start="3">
<li>总结<br>Playwright是由微软公司2020年初发布的新一代自动化测试工具，相较于目前最常用的Selenium，它仅用一个API即可自动执行Chromium、Firefox、WebKit等主流浏览器自动化操作。作为针对 Python 语言纯自动化的工具，在回归测试中可更快的实现自动化。<h2 id="1-为什么选择Playwright"><a href="#1-为什么选择Playwright" class="headerlink" title="1. 为什么选择Playwright"></a>1. 为什么选择Playwright</h2><h3 id="1-1-Playwright的优势"><a href="#1-1-Playwright的优势" class="headerlink" title="1.1 Playwright的优势"></a>1.1 Playwright的优势</h3>（1） Selenium需要通过WebDriver操作浏览器；Playwright通过开发者工具与浏览器交互，安装简洁，不需要安装各种Driver。<br>（2） Playwright几乎支持所有语言，且不依赖于各种Driver，通过调用内置浏览器所以启动速度更快。<br>（3） Selenium基于HTTP协议（单向通讯），Playwright基于Websocket（双向通讯）可自动获取浏览器实际情况。<br>（4） Playwright为自动等待。</li>
</ol>
</li>
<li>等待元素出现（定位元素时，自动等待30s，等待时间可以自定义，单位毫秒）</li>
<li>等待事件发生<h3 id="1-2-已知局限性"><a href="#1-2-已知局限性" class="headerlink" title="1.2 已知局限性"></a>1.2 已知局限性</h3>（1） Playwright不支持旧版Microsoft Edge或IE11。支持新的Microsoft Edge（在Chromium上）；所以对浏览器版本有硬性要求的项目不适用。<br>（2） 需要SSL证书进行访问的网站可能无法录制，该过程需要单独定位编写。<br>（3） 移动端测试是通过桌面浏览器来模拟移动设备（相当于自带模拟器），无法控制真机。<h2 id="2-Playwright使用"><a href="#2-Playwright使用" class="headerlink" title="2. Playwright使用"></a>2. Playwright使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3>（1）安装Playwright依赖库（Playwright支持Async\Await语法，故需要Python3.7+）<table>
<thead>
<tr>
<th>1</th>
<th><code>pip install playwright</code></th>
</tr>
</thead>
</table>
</li>
</ul>
<p>（2）安装Chromium、Firefox、WebKit等浏览器的驱动文件（内置浏览器）</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>python ``-``m playwright install</code></th>
</tr>
</thead>
</table>
<h3 id="2-2-自动录制"><a href="#2-2-自动录制" class="headerlink" title="2.2 自动录制"></a>2.2 自动录制</h3><p>（1）命令行键入 –help 看到所有可后接选项</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>python ``-``m playwright codegen ``-``-``help</code></th>
</tr>
</thead>
</table>
<p>（2）从起始页为xingzheai.cn开始录制</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>python ``-``m playwright codegen https:``/``/``xingzheai.cn``/</code></th>
</tr>
</thead>
</table>
<p>（3）打开xingzheai.cn，用Chromium驱动，将结果保存为my.py的python文件</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>python ``-``m playwright codegen ``-``-``target python ``-``o ``&#39;my.py&#39;</code> <code>-``b chromium https:``/``/``xingzheai.cn``/</code></th>
</tr>
</thead>
</table>
<p> -target：规定生成脚本的语言，有JS和Python两种，默认为Python<br>-b：指定浏览器驱动<br>-o：将录制的脚本保存到一个文件</p>
<h3 id="2-3-定制化编写"><a href="#2-3-定制化编写" class="headerlink" title="2.3 定制化编写"></a>2.3 定制化编写</h3><p>（1）元素定位</p>
<ul>
<li>选择单个元素：querySelector(engine&#x3D;body)</li>
<li>选择多个元素：querySelectorAll(engine&#x3D;body)</li>
<li>选择单个元素，并且自动等待：waitForSelector(engine&#x3D;body)<br>By的8种定位方式，实际为4种</li>
<li>id、name、tag name、class name（java和pythona将该4种都归为CSS）</li>
<li>xpath、link text、partial link text、css selector<br>W3C标准规定的webDriver协议为5种定位方式</li>
<li>CSS、Link text、Partial link text、Tag name、XPath<br>Playwright将选择器汇总为3种</li>
<li>CSS、XPATH（支持逻辑表达式和函数）、TEXT<br>（2）选择器规则</li>
<li>CSS： ID选择器、类选择器、元素选择器、属性选择器、通配选择器、层次选择器。</li>
<li>XPath： XML路径语言，通过“路径标识符”，导航XML文档的，在类XML种（HTML）也可以使用。</li>
<li>Text： 结构化内容（html，xml，json）使用模糊匹配（忽略大小写，忽略前后空格，搜索子字符串）及精确匹配、非结构化内容使用正则匹配。<br>（3）元素常用操作</li>
<li>下拉选择框：selectOpion、value、labei、index</li>
<li>文件上传：setInputFiles、单个文件、多个文件、拖放上传</li>
<li>鼠标点击：click、dbclick</li>
<li>鼠标拖动：down、up</li>
<li>鼠标移动：move</li>
<li>触摸屏幕：tag</li>
<li>键盘按键：press</li>
<li>截屏、录屏：screenshot、recordVideo<h3 id="2-4-网络拦截（Mock接口），示例如下：2-5-同步执行，示例如下："><a href="#2-4-网络拦截（Mock接口），示例如下：2-5-同步执行，示例如下：" class="headerlink" title="2.4 网络拦截（Mock接口），示例如下：2.5 同步执行，示例如下："></a>2.4 网络拦截（Mock接口），示例如下：2.5 同步执行，示例如下：</h3><blockquote>
<p>page &#x3D; context.newPage()<br>def Whether_intercept() -&gt; bool:<br>return True  #进行拦截</p>
<h6 id="return-False-不进行拦截"><a href="#return-False-不进行拦截" class="headerlink" title="# return False #不进行拦截"></a># return False #不进行拦截</h6><p>def handler(route:Route):<br>print(route.request.url)<br>#正常访问<br># route.continue_()<br>#拒绝访问<br># route.abort(“网络拦截”)<br># 重定向到非目标地址<br>route.fulfill(<br>    status&#x3D;302,<br>    headers&#x3D;{<br>        ‘Location’ : “<a href="https://xingzheai.cn/&quot;">https://xingzheai.cn/&quot;</a><br>    }<br>)<br>page.route(Whether_intercept,handler)</p>
</blockquote>
</li>
</ul>
<h3 id="2-5-同步执行，示例如下："><a href="#2-5-同步执行，示例如下：" class="headerlink" title="2.5 同步执行，示例如下："></a>2.5 同步执行，示例如下：</h3><blockquote>
<p>#依次打开三个浏览器，前往行者官网，截图后退出。<br>from playwright import sync_playwright with sync_playwright() as p:<br>    for browser_type in [p.chromium, p.firefox, p.webkit]:<br>         # 指定为有头模式，Ture为无头模式<br>        browser &#x3D; browser_type.launch(headless&#x3D;False)<br>        page &#x3D; browser.newPage()<br>        page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>        # 等待页面加载完全后截图<br>        page.waitForSelector(“text&#x3D;智能内容审核”)<br>        page.screenshot(path&#x3D;f’example-{browser_type.name}.png’)<br>        browser.close()</p>
</blockquote>
<h3 id="2-6-异步执行，示例如下："><a href="#2-6-异步执行，示例如下：" class="headerlink" title="2.6 异步执行，示例如下："></a>2.6 异步执行，示例如下：</h3><blockquote>
<p>#同时进行三个浏览器操作<br>import asyncio<br>from playwright import async_playwright<br>async def main():<br> async with async_playwright() as p:<br>     for browser_type in [p.chromium, p.firefox, p.webkit]:<br>          browser &#x3D; await browser_type.launch()<br>         page &#x3D; await browser.newPage()<br>         await page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>          await page.waitForSelector(“text&#x3D;智能内容审核”)<br>          await page.screenshot(path&#x3D;f’example-{browser_type.name}.png’)<br>          await browser.close()<br>         asyncio.get_event_loop().run_until_complete(main())</p>
</blockquote>
<h3 id="2-7-Pytest结合，示例如下："><a href="#2-7-Pytest结合，示例如下：" class="headerlink" title="2.7 Pytest结合，示例如下："></a>2.7 Pytest结合，示例如下：</h3><p>安装：<code>pip install pytest-playwright</code></p>
<blockquote>
<p>def test_playwright(page):<br>    page.goto(“<a href="https://xingzheai.cn/&quot;">https://xingzheai.cn/&quot;</a>)<br>    with page.expect_popup() as popup_info:<br /> page.click(‘text&#x3D;”智能内容审核”‘)<br />    assert “智能内容审核” &#x3D;&#x3D; element.textContent()</p>
</blockquote>
<h3 id="2-8-移动端操作，示例如下："><a href="#2-8-移动端操作，示例如下：" class="headerlink" title="2.8 移动端操作，示例如下："></a>2.8 移动端操作，示例如下：</h3><p>目前支持模拟机型较少， 参照：仿真设备列表</p>
<blockquote>
<p>from time import sleep<br>from playwright import sync_playwright<br />with sync_playwright() as p:<br>    GalaxyS5 &#x3D; p.devices[‘Galaxy S5’]<br>    browser &#x3D; p.chromium.launch(headless&#x3D;False)<br>    context &#x3D; browser.newContext(**GalaxyS5)<br>    page &#x3D; context.newPage()<br>    page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>    page.click(‘text&#x3D;”智能内容审核”‘)<br>    # 截图<br>    # page.screenshot(path&#x3D;’colosseum-GalaxyS5.png’)<br>    sleep(10)<br>    browser.close()</p>
</blockquote>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Playwright作为新一代自动化测试工具，相较于Selenium不论是易用性，还是实用性都得到了全方位的提升。做到了简约而不简单，相信使用该工具可以帮助我们提升做自动化的工作效率。<br>到此这篇关于Playwright快速上手指南(入门教程)的文章就介绍到这了,更多相关Playwright入门内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>03_Playwright</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Puppeteer</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/02_Puppeteer/01_Puppeteer/</url>
    <content><![CDATA[<p>puppeteer<br>puppeteer是google公司出品对于运行无界面chrome 学名headless,当然也可以有界面运行，可以通过参数进行设置</p>
<p>安装好nodejs， 安装puppeteer就可以做自动化测试，这一点，google称得上是良心开发商了，api非常简单，网站非常<br>丰富<br>puppeteer github 网站在这里</p>
<pre><code>const puppeteer = require(&#39;puppeteer&#39;);

(async () =&gt; &#123;
  const browser = await puppeteer.launch(&#123;executablePath:&quot;C:/Users/Administrator/AppData/Local/Google/Chrome/Application/chrome.exe&quot;&#125;);
  const page = await browser.newPage();
  await page.goto(&#39;file://J:/webrtc/accelerator/test.html&#39;);
  await page.screenshot(&#123;path: &#39;j:/webrtc/accelerator/1.png&#39;&#125;);
  await browser.close();
&#125;)();
</code></pre>
<p>node demo.js<br>会在目录下生成一张png图片</p>
<p>自动化测试<br>写一段最简单的html</p>
<pre><code>&lt;html&gt;
&lt;body&gt;

&lt;div&gt;
早安
&lt;a href=&quot;https://www.baidu.com&quot;&gt;&lt;b&gt;百度&lt;/b&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>demo2.js</p>
<pre><code>const puppeteer = require(&#39;puppeteer&#39;);

(async () =&gt; &#123;
  const browser = await puppeteer.launch(&#123;
    headless: false
  &#125;);
  const page = await browser.newPage();

  await page.goto(&#39;file://J:/webrtc/accelerator/test.html&#39;);

  await page.click(&#39;a&#39;);
&#125;)();
</code></pre>
<p><img src="/assets/image-20220516194046-rj38snc.png" alt="image.png"></p>
<p>可以看出api 是可以任意查找想要的事件进行点击的。这次是简单的测试，后面会添加一些复杂的功能。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>02_Puppeteer</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium-webdriver常见报错问题</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/06_selenium-webdriver%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。"><a href="#一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。" class="headerlink" title="一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。"></a>一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。</h2><h4 id="selenium-common-exceptions-WebDriverException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-WebDriverException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.WebDriverException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.WebDriverException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：WebDriver基础的异常类

    解决思路：检查驱动版本与浏览器版本
</code></pre>
<h4 id="selenium-common-exceptions-TimeoutException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-TimeoutException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.TimeoutException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.TimeoutException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：在足够的时间内没有完成某项操作

    解决思路：适当的增加时长，等待界面元素的渲染
</code></pre>
<h4 id="selenium-common-exceptions-NoSuchElementException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoSuchElementException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoSuchElementException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoSuchElementException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：定位元素不被找到

    解决思路：检查是否写错了元素，更换定位元素
</code></pre>
<h4 id="selenium-common-exceptions-NoSuchAttributeException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoSuchAttributeException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoSuchAttributeException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoSuchAttributeException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：元素属性不能被找到

    解决思路：检查是否写错了元素属性
</code></pre>
<h4 id="selenium-common-exceptions-NoAlertPresentException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoAlertPresentException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoAlertPresentException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoAlertPresentException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：切换到alert弹窗，alert并没有弹出

    解决思路：增加等待时间
</code></pre>
<h4 id="selenium-common-exceptions-NoSuchFrameException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoSuchFrameException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoSuchFrameException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoSuchFrameException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：没有iframe窗口

    解决思路：检查是否存在此类窗口
</code></pre>
<h4 id="selenium-common-exceptions-InvalidElementStateException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-InvalidElementStateException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.InvalidElementStateException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.InvalidElementStateException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：元素无效

    解决思路：更改定位元素
</code></pre>
<h4 id="selenium-common-exceptions-ElementNotSelectableException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-ElementNotSelectableException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.ElementNotSelectableException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.ElementNotSelectableException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：元素不能被选中

    解决思路：检查是否是元素是否写错，检查属性
</code></pre>
<h4 id="selenium-common-exceptions-ElementNotVisibleException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-ElementNotVisibleException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.ElementNotVisibleException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.ElementNotVisibleException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：元素不可见，不能操作

    解决思路：检查元素是否带有display:none属性
</code></pre>
<h4 id="selenium-common-exceptions-InvalidSwitchToTargetException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-InvalidSwitchToTargetException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.InvalidSwitchToTargetException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.InvalidSwitchToTargetException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：切换窗口或框架不存在

    解决思路：检查页面元素，查看是否存在此类窗口或检查定位元素
</code></pre>
<h4 id="selenium-common-exceptions-NoSuchWindowException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoSuchWindowException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoSuchWindowException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoSuchWindowException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：目标窗口不存在

    解决思路：打印窗口信息，核对切换的窗口是否存在
</code></pre>
<h2 id="二、关于selenium中webdriver版本报错"><a href="#二、关于selenium中webdriver版本报错" class="headerlink" title="二、关于selenium中webdriver版本报错"></a>二、关于selenium中webdriver版本报错</h2><p>###报错信息<br>####selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 95 Current browser version is 100.0.4896.88 with binary path C:\Program Files\Google\Chrome\Application\chrome.exe<br>解决办法<br>查看Chrome版本<br>chrome:&#x2F;&#x2F;settings&#x2F;help<br><img src="/assets/2/image-20220515152357-6kac3mb.png" alt="image.png"></p>
<p>webdriver下载地址<br><a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></p>
<p>永久解决办法<br>关闭Chrome版本更新</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>01_selenium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium-webdriver基础操作二</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/04_selenium-webdriver%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BA%8C/</url>
    <content><![CDATA[<p>查找页面元素<br>前置条件：①Firefox浏览器 ②例子里的网页为<a href="https://www.baidu.com/">https://www.baidu.com</a></p>
<p>1.按id属性查找  一般作为查找元素的首选属性  注意特殊情况-动态id</p>
<pre><code>from selenium import webdriver  # 从selenium库导入网络驱动包
from time import sleep          # 从time库导入sleep
from selenium.webdriver.common.by import By  # 用于对象的定位
 
browser = webdriver.Firefox()         # 定义一个变量browser，代表浏览器的驱动
browser.get(&#39;https://www.baidu.com&#39;)  # 打开浏览器
browser.maximize_window()             # 窗口最大化
 
browser.find_element(By.ID, &#39;kw&#39;).send_keys(&#39;Selenium&#39;)  # 在百度输入栏内输入Selenium
browser.find_element(By.ID, &#39;su&#39;).click()                # 点击“百度一下”
sleep(2)
</code></pre>
<p>2 class定位 可能重复</p>
<pre><code>browser.find_element(By.CLASS_NAME, &#39;s_ipt&#39;).send_keys(&#39;Selenium&#39;)
browser.find_element(By.CLASS_NAME, &#39;s_btn&#39;).click()
sleep(3)
</code></pre>
<p>3 tag定位  极其容易重复</p>
<pre><code>browser.find_element(By.TAG_NAME, &#39;input&#39;).send_keys(&#39;Selenium&#39;)
# 报错：ElementNotInteractableException 元素不可输入异常
</code></pre>
<p>4 name定位 可能重复</p>
<pre><code>browser.find_element(By.NAME, &#39;wd&#39;).send_keys(&#39;Selenium&#39;)
browser.find_element(By.ID, &#39;su&#39;).click()
</code></pre>
<p>5 link精确定位</p>
<pre><code>browser.find_element(By.LINK_TEXT, &#39;新闻&#39;).click()
</code></pre>
<p>6 link模糊定位</p>
<pre><code>browser.find_element(By.PARTIAL_LINK_TEXT, &#39;闻&#39;).click()
</code></pre>
<p>7 CSS定位<br>7.1 id定位</p>
<pre><code>browser.find_element(By.CSS_SELECTOR, &#39;#kw&#39;).send_keys(&#39;Selenium&#39;)
</code></pre>
<p>7.2 tag定位</p>
<pre><code>browser.find_element(By.CSS_SELECTOR, &#39;input&#39;).send_keys(&#39;Selenium&#39;)
</code></pre>
<p>7.3 class定位</p>
<pre><code>browser.find_element(By.CSS_SELECTOR, &#39;.s_ipt&#39;).send_keys(&#39;Selenium&#39;)
</code></pre>
<p>7.4 其余属性定位   [属性名&#x3D;’属性值’]</p>
<pre><code>browser.find_element(By.CSS_SELECTOR, &#39;[name=&quot;wd&quot;]&#39;).send_keys(&#39;Selenium&#39;)
browser.find_element(By.CSS_SELECTOR, &#39;[maxlength=&quot;255&quot;]&#39;).send_keys(&#39;Selenium&#39;)
</code></pre>
<p>7.5 父子定位 即层级定位</p>
<pre><code>browser.find_element(By.CSS_SELECTOR, &#39;span&gt;input&#39;).send_keys(&#39;Selenium&#39;)
</code></pre>
<p>7.6 组合定位 特别不容易定位时才考虑</p>
<pre><code>browser.find_element(By.CSS_SELECTOR, &#39;span.quickdelete-wrap&gt;input[maxlength=&quot;255&quot;][name=&quot;wd&quot;]&#39;).send_keys(&#39;Selenium&#39;)
</code></pre>
<p>8 XPATH定位</p>
<pre><code>browser.find_element(By.XPATH, &#39;//*[@id=&quot;kw&quot;]&#39;).send_keys(&#39;Selenium&#39;)
</code></pre>
<p>在每一步骤间最好设定好sleep时间，可以解决响应延迟带来的问题</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>01_selenium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium-webdriver基础操作一</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/03_selenium-webdriver%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%80/</url>
    <content><![CDATA[<p>基于Firefox浏览器的基本操作<br>1.浏览器的导航操作</p>
<pre><code>from selenium import webdriver        #从selenium库中导入webdriver模块
firefox = webdriver.Firefox()         #定义一个firefox变量，用于代指浏览器
firefox.get(&quot;https://www.baidu.com&quot;)  #打开浏览器并进入百度网页
</code></pre>
<p>后退、前进、刷新操作对应的代码为：</p>
<pre><code>driver.back()    #后退
driver.forward() #前进
driver.refresh() #刷新
</code></pre>
<p>2.浏览器的窗口操作<br>—窗口的位置和大小在一定程度上会影响页面的显示和操作，Selenium提供了一些函数，用于调整浏览器窗口的位置和大小，以及关闭浏览器的窗口等操作。</p>
<p>窗口最大化、最小化以及关闭操作的代码如下：</p>
<pre><code>driver.minimize_window()  #最大化窗口
driver.minimize_window()  #最小化窗口
driver.close()            #关闭窗口
</code></pre>
<pre><code>也可以引入time模块，使用sleep函数在每个操作间休眠，具体示例代码如下：
</code></pre>
<pre><code>from selenium import webdriver        #从selenium库中导入webdriver模块
import time                           #引入time模块

firefox = webdriver.Firefox()         #定义一个firefox变量，用于代指浏览器

firefox.get(&quot;https://www.baidu.com&quot;)  #打开浏览器并进入百度网页
firefox.maximize_window()             #最大化窗口

time.sleep(3)                         #sleep函数，用于每个操作间休眠3秒
firefox.quit()                        #关闭浏览器
</code></pre>
<p>上述代码还可获知，关闭浏览器的代码是.quit()</p>
<p>3.获取浏览器信息<br>最常用的的获取：</p>
<pre><code>driver.title         #获取浏览器窗口的当前标题
drive.current_url    #获取浏览器窗口的当前网址
driver.get_window_position()    #获取位置对象
driver.get_window_size()        #获取大小对象
driver.get_window_rect()        #获取位置以及大小对象
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>01_selenium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium-webdriver基础操作</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/02_selenium-webdriver%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>这是<strong>Selenium</strong>里面最总要的东西。 <strong>Selenium Webdriver</strong> （也就是 <strong>Selenium2，Selenium3</strong> ）和 <strong>Selenium RC</strong> （ <strong>Selenium 1</strong> ）一样提供了<strong>web</strong>自动化的各种语言调用接口库。相比 <strong>Selenium RC</strong> ，<strong>Selenium WebDriver</strong>的编程接口更加直观易懂，也更加简练。但是和<strong>Selenium RC</strong>不同的是，<strong>Selenium Webdriver</strong>是通过各种浏览器的驱动（ <strong>web driver</strong> ）来驱动浏览器的，而不是通过注入<strong>JavaScript</strong>的方式，下面是其原理的示意图：</p>
<p><img src="/assets/2/image-20220515145116-jknthhg.png" alt="image.png"></p>
<p>image.png</p>
<p>我们的代码运行起来是一个进程，里面调用<strong>Selenium WebDriver</strong>的库 和 各个浏览器的驱动进程 进行交互，传递<strong>Selenium</strong>命令 给它们，并且获取命令执行的结果，返回给我们的代码进行处理。</p>
<p><strong>Selenium WebDriver</strong>目前包括两个版本<strong>Selenium 2</strong>和 <strong>Selenium 3</strong> 。这两个版本从开发代码调用接口上来看，几乎没什么区别。区别在于库的实现和<strong>web driver</strong>的实现。<strong>Selenium2</strong>是<strong>Selenium</strong>组织帮各种浏览器写<strong>web driver</strong>的，而<strong>Selenium 3</strong>里面的<strong>web driver</strong>是由各个浏览器厂商（ <strong>Apple,Google,Microsoft,Mozilla</strong> ）自己提供的。所以<strong>Selenium 3</strong>的自动化效率更高，成功率也更高。</p>
<p><strong>Selenium WebDriver</strong> 支持浏览器众多：</p>
<ul>
<li><strong>Google Chrome</strong></li>
<li><strong>Microsoft Internet Explorer 7，8，9，10，11</strong>在 <strong>Windows Vista，Windows 7，Windows 8，Windows 8.1.</strong></li>
<li>Microsoft Edge</li>
<li>Firefox</li>
<li>Safari</li>
<li>Opera</li>
</ul>
<h4 id="3-1安装"><a href="#3-1安装" class="headerlink" title="3.1安装"></a>3.1安装</h4><p><strong>Selenium WebDriver</strong>提供了各种语言的编程接口，来进行<strong>Web</strong>自动化开发。我们以<strong>Python</strong>来讲解它的使用。首先我们要确保<strong>Python</strong>解释器已经安装好了。由于我们习惯在<strong>Windows</strong>操作系统上进行操作，建议大家安装<strong>Python</strong>官方的<strong>Python 3.6</strong></p>
<ul>
<li><p>安装编程接口库</p>
<p><strong>python</strong>安装好后，我们用<strong>Pip</strong>来安装<strong>Selenium Web Driver</strong>的<strong>python</strong>库，执行下面的命令即可。（执行该命令之前，要确保<strong>python</strong>的<strong>script</strong>目录在系统环境变量<strong>path</strong>里面已经包括了）。命令为：<strong>pip install selenium</strong></p>
</li>
</ul>
<p>安装完成后，运行python解释器，执行命令 <strong>import selenium</strong> ，如果没有异常，则表示安装成功了，如下所示</p>
<p><img src="/assets/2/image-20220515145129-y4ykbjr.png" alt="image.png"></p>
<p>image.png</p>
<ul>
<li><p>安装各浏览器的驱动</p>
<p>当然我们是通过各浏览器的驱动程序 来操作浏览器的，所以，还要有各浏览器的驱动程序。我们主要以谷歌的<strong>chrome</strong>浏览器为例来演示。</p>
</li>
</ul>
<p><strong>chrom</strong>浏览器的 <strong>web driver</strong> （ <strong>chromedriver.exe</strong> ），可以在下面网址访问：</p>
<p><a href="https://links.jianshu.com/go?to=http://npm.taobao.org/mirrors/chromedriver/">http://npm.taobao.org/mirrors/chromedriver/</a></p>
<p> <strong>firefox</strong> （火狐浏览器）的 <strong>web driver （geckodriver.exe）</strong> 在这里访问：</p>
<p><a href="https://links.jianshu.com/go?to=https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a></p>
<p>其他浏览器驱动可以见下面列表:</p>
<p> <strong>Edge:</strong> <a href="https://links.jianshu.com/go?to=https://developer.microsoft.com/en-us/micrsosft-edage/tools/webdriver">https://developer.microsoft.com/en-us/micrsosft-edage/tools/webdriver</a></p>
<p> <strong>Safari:</strong> <a href="https://links.jianshu.com/go?to=https://webkit.org/blog/6900/webdriver-support-in-safari-10/">https://webkit.org/blog/6900/webdriver-support-in-safari-10/</a></p>
<h4 id="3-2从一个例子开始"><a href="#3-2从一个例子开始" class="headerlink" title="3.2从一个例子开始"></a>3.2从一个例子开始</h4><pre><code>#从selenium里面导入webdriver
from selenium import webdriver

#指定chrom的驱动
#执行到这里的时候Selenium会到指定的路径将chrome driver程序运行起来
driver = webdriver.Chrome(&#39;E:\ChromDriver\chromedriver.exe&#39;)
#driver = webdriver.Firefox()#这里是火狐的浏览器运行方法

#get 方法 打开指定网址
driver.get(&#39;http://www.baidu.com&#39;)

#选择网页元素
element_keyword = driver.find_element_by_id(&#39;kw&#39;)

#输入字符
element_keyword.send_keys(&#39;宋曲&#39;)

#找到搜索按钮
element_search_button = driver.find_element_by_id(&#39;su&#39;)
</code></pre>
<p>下面是对搜索结果的验证：</p>
<pre><code>import time

#注意这里必须要等待时间，因为代码运行过快，代码运行完的时候页面还没加载出来就会找不到元素

time.sleep(2)

ret = driver.find_element_by_id(&#39;1&#39;)
print(ret.text)

if ret.text.startswith(&#39;宋曲&#39;):#是不是已宋曲开头
    print(&#39;测试通过&#39;)
else:
    print(&#39;不通过&#39;)
#最后，driver.quit()让浏览器和驱动进程一起退出，不然桌面会有好多窗口
driver.quit()
</code></pre>
<p>下面是对代码的详细分析：</p>
<pre><code>driver = webdriver.Chrome(&#39;E:\ChromDriver\chromedriver.exe&#39;)
</code></pre>
<p>执行到这里的时候<strong>Selenium</strong>会到指定的路径将<strong>chrom driver</strong>程序运行起来，<strong>chrome driver</strong>会将浏览器运行起来。成功后会返回一个<strong>WebDriver</strong>实例对象，通过它的方法，可以控制浏览器，我们可以把它想象成浏览器的遥控器一样。</p>
<p>浏览器运行起来后，通常第一件事情就是打开网址了。一般我们通过控制对象的<strong>get</strong>方法来控制浏览器打开指定网址</p>
<pre><code>driver.get(&#39;http://www.baidu.com&#39;)
</code></pre>
<p>这一行执行后，<strong>web</strong>浏览器将会访问<code>http://www.baidu.com</code>这个网址。<strong>Selenium</strong>的官方文档说，不同的<strong>WebDriver</strong>和浏览器行为可能会有所不同。有的浏览器不一定等<strong>web</strong>页面完全加载完成，就返回了。当然通常我们希望的是加载完毕，再返回，不然可能页面上有的元素还没有出现，后续的操作可能有问题。这样还需要加入一些其他的代码等待某个关键的页面元素出现再进行后续操作。个人测试的情况看，<strong>Selenium 3</strong>的<strong>Chrom WebDriver</strong>驱动相应的<strong>chrom</strong>浏览器是会等待页面完全加载完成才返回的。所以我们可以放心。</p>
<p>接下来我们要查找到那个搜索输入栏网页元素，这里是根据该网页元素的<strong>id</strong>来选择的。</p>
<pre><code>element_keyword = driver.find_element_by_id(&#39;kw&#39;)
</code></pre>
<p>网页元素的信息可以通过浏览器的<strong>debug</strong>功能来查看。怎么寻找网页元素，可以说是<strong>web</strong>自动化最重要的东西之一。下一节会讲到。</p>
<p><strong>driver</strong>找到该元素的话，就会返回一个该元素的<strong>WebElement</strong>对象。我们接着就可以对其进行操作了，这个例子里面的操作，就是在这个输入框里面输入字符。</p>
<pre><code>element_keyword.send_keys(&#39;宋曲&#39;)
</code></pre>
<p>后面就是在进行一次元素的选择和操作，找到搜索按钮，点击它。最后，执行下面的代码让浏览器和驱动进程一起退出</p>
<pre><code>driver.quit()
</code></pre>
<p>这里大家要注意代码里我们用了 <strong>time</strong> ，<strong>注意这里必须</strong>要等待时间，因为代码运行过快，代码运行完的时候页面还没加载出来就会找不到元素。后面我们会想到更好的解决方法。</p>
<h4 id="3-3-Web元素选择"><a href="#3-3-Web元素选择" class="headerlink" title="3.3 Web元素选择"></a>3.3 Web元素选择</h4><p>浏览器读入页面文档（html格式）后，通过内置的 <strong>layout engine</strong> （就是页面渲染引擎，也成为浏览器内核，比如 <strong>Webkit、Gecko</strong> ）将整个页面显示出我们看到的样子。我们人在看<strong>web</strong>页面的时候，是用眼睛视觉上<strong>web</strong>页面的元素，比如上面有个输入框。下面有个按钮。可是对浏览器这个程序来说，他会创建一个 <strong>HTML DOM（Document Object Model）</strong> 来理解和操作整个页面结构。这是一个树状的结构，下面是一张示意图：</p>
<p><strong>DOM</strong>是<strong>W3C</strong>指定的标准，<strong>DOM</strong>是由一个个的 <strong>node</strong> （节点）组成。而 <strong>element</strong> （元素）是最重要的一种 <strong>node</strong> ，他是<strong>html</strong>中一个<strong>tag</strong>里面的内容，比如</p>
<pre><code>&lt;a href=&quot;www.baidu.com&quot;&gt;My link&lt;/a&gt;
</code></pre>
<p>这个 <strong><a></strong> 就是一个 <strong>element</strong> ，我们中文称之为元素。<strong>HTML DOM</strong>就是一个用来给程序增删改查<strong>HTML</strong>元素的接口。</p>
<p>所以，我们在程序中选择元素，就是在网页的<strong>DOM</strong>结构里选择元素。就像上面说的，<strong>web</strong>元素的选择，是<strong>Selenium</strong>开发的重中之重。因为，我们首先必须要找到<strong>web</strong>元素，才能对其进行操作。<strong>web</strong>元素的选择，在<strong>Selenium</strong>可以通过<strong>WebDriver</strong>对象，也可以通过<strong>WebElement</strong>对象选择，它们都有成员 方法来进行选择。通过<strong>WebDriver</strong>对象选择，查找范围是 <strong>整个html文档</strong> 。而通过WebElement对象选择，查找范围是整个该对象的子元素，<strong>web</strong>元素的选择，有好几种方式。下面会一一讲述。</p>
<h4 id="3-3-1通过id选择属性"><a href="#3-3-1通过id选择属性" class="headerlink" title="3.3.1通过id选择属性"></a>3.3.1通过id选择属性</h4><p><strong>web</strong>元素可以有很多属性（ <strong>attribute</strong> ）</p>
<blockquote>
<p>&lt;input <strong>id&#x3D;”kw” name&#x3D;”wd” class&#x3D;”s_ipt” value&#x3D;”” maxlength&#x3D;”255” autocomplete&#x3D;”off”&gt;</strong></p>
</blockquote>
<p>上面元素的属性被用黑体显示了。这些属性中，id是非常特殊的一个，它是在<strong>DOM</strong>中唯一标志这个元素的。所以，如果<strong>web</strong>元素有<strong>id</strong>属性的话，是最好查找的，也是效率最高的，通过<strong>id</strong>就唯一的找到了它。</p>
<p>要找到该元素，可以用下面的方法</p>
<pre><code>element = driver.find_element_by_id(&quot;kw&quot;)
</code></pre>
<p>或者换一种写法，导入Selenium by这个类，效果是一样的，个人更喜欢上面的方法</p>
<pre><code>from selenium.webdriver.common.by import By
element = driver.find_element(by=By.ID, value=&quot;kw&quot;)
</code></pre>
<p>都是可以的，大家以后看到别人的代码这样写，不要感到吃惊</p>
<p> <strong>注</strong> ：<strong>id</strong>其实还有重复的，虽然我们讲<strong>id</strong>不应该重复</p>
<p>的，但是有的人可能写错了，如果有重复的假如说你要查个某个<strong>id</strong>通过<strong>Webdriver</strong>对象查找，他查找的是整个页面查找的是第一个符合条件的，他可能不是你想要的，你可以先通过先缩小查找范围，先查找他的父节点 <strong>id</strong> ，再通过父节点<strong>id</strong>再去<strong>find_element_by_id</strong>这样就限制他的范围了，这是一种常用的方法。</p>
<p>没有找到会抛出如下异常</p>
<pre><code>selenium.common.exceptions.NoSuchElementException
</code></pre>
<p>如果抛出异常，后面的程序就执行不到了，假如</p>
<p>你不希望由于某一个异常导致程序结束的话，我们可以加一个异常的捕获</p>
<pre><code>from selenium.common.exceptions import NoSuchElementException
try:
    ele = driver.find_element_by_id(&quot;food333&quot;)
except NoSuchElementException:
    print(&#39;NoSuchElementException&#39;)
</code></pre>
<h4 id="3-3-2获取元素-inner-Text"><a href="#3-3-2获取元素-inner-Text" class="headerlink" title="3.3.2获取元素 inner Text"></a>3.3.2获取元素 inner Text</h4><p><strong>innerText</strong> 是 <strong>DOM</strong>节点的属性，它代表了 <strong>node</strong> 节点（通常是元素）可以显示出来的文本内容。通俗点说，就是我们能在界面上看到的文本内容，比如按钮上的问题、输入框里面的内容、 <strong><p></strong> 元素的内容、链接的文本内容，等等。可想而知，这是我们经常需要获取的东西。<strong>Selenium</strong> 通过 <strong>Webdriver</strong> 的 <strong>text</strong>属性来获取其内容。下面的代码将当前页面上的 <strong>id</strong> 为 <strong>1</strong> 的元素的可见文本打印出来。代码实例如下</p>
<ul>
<li><p><strong>text</strong>属性 显示该元素在<strong>web</strong>页面显示出来的文本内容。</p>
<pre><code>ret = driver.find_element_by_id(&#39;1&#39;)
print(ret.text)
</code></pre>
</li>
<li><p>我们有的时候，希望获取的不是某个元素的页面展示部分，而是它的一个属性的值， 这时候，我们可以通过一个方法<strong>get_attribute</strong>方法，这个方法就是返回元素的某个属性的值。看下面示例：</p>
</li>
</ul>
<blockquote>
<p>&lt;a href&#x3D;”<a href="https://links.jianshu.com/go?to=http://www.baidu.com">http://www.baidu.com</a>“ id&#x3D;”baidulink&gt;转到百度</a></p>
</blockquote>
<p>下面的代码就是获取<strong>href</strong>属性的值，就获取到了链接</p>
<pre><code>ele = driver.find_element_by_id(&quot;baidulink&quot;)
print (ele.get_attribute(&#39;href&#39;))
</code></pre>
<ul>
<li><p>有的时候，我们需要完整的获取这个元素对应的<strong>html</strong>进行分析，比如</p>
<p>我们还是通过<strong>get_attribute</strong>方法，只需要参数指定为<strong>outerHTML</strong>就可以了。</p>
<pre><code>ele = driver.find_element_by_id(&quot;baidulink&quot;)
print (ele.get_attribute(&#39;outerHTML &#39;))
</code></pre>
</li>
</ul>
<p>上面代码输出的结果就是：</p>
<pre><code>&lt;a href=&quot;http://www.baidu.com&quot; id=&quot;baidulink&gt;转到百度&lt;/a&gt;
</code></pre>
<ul>
<li><p>如果我们只想获取 该元素的内部的<strong>html</strong>源代码，我们还是通过<strong>get_attribute</strong>方法， 只需要参数指定为<strong>innerHTML</strong>就可以了。</p>
<pre><code>ele = driver.find_element_by_id(&quot;baidulink&quot;)
print (ele.get_attribute(&#39;innerHTML&#39;))
</code></pre>
</li>
</ul>
<p>上面代码输出结果就是：</p>
<pre><code>转到百度
</code></pre>
<p>有如下一段<strong>html</strong></p>
<pre><code>div id=&quot;food&quot; style=&quot;margin-top:10px;color:red&quot;&gt;
    &lt;span calss=&quot;vegetable good&quot;&gt;黄瓜&lt;/span&gt;
    &lt;span calss=&quot;meat&quot;&gt;牛肉&lt;/span&gt;
    &lt;p calss=&quot;vegetable&quot;&gt;南瓜&lt;/p&gt;
    &lt;p calss=&quot;vegetable&quot;&gt;青菜&lt;/p&gt;
</code></pre>
<p>用attribute(‘innerHTML’)方法获取该元素的内部的html源代码效果如下:</p>
<pre><code>ele = driver.find_element_by_id(&quot;food&quot;)
print (ele.get_attribute(&#39;innerHTML&#39;))
</code></pre>
<p>上面代码输出结果就是：</p>
<pre><code>    &lt;span calss=&quot;vegetable good&quot;&gt;黄瓜&lt;/span&gt;
    &lt;span calss=&quot;meat&quot;&gt;黄瓜&lt;/span&gt;
    &lt;p calss=&quot;vegetable&quot;&gt;南瓜&lt;/p&gt;
    &lt;p calss=&quot;vegetable&quot;&gt;青菜&lt;/p&gt;
</code></pre>
<p>就是这个元素的内部的内容，不包括它本身的这段。</p>
<p>各位可能会疑惑我们获取这些东西干嘛？我们为什么要或整个<strong>html</strong>呢，因为有的时候我们开发自动化程序的时候，比如测试不通过，某个点不通过，这个时候想把比如说选择元素没选择到，或者元素的内容和预期的内容不一样，这个时候需要判断分析定位，这个时候把它放在自动化用例里面，就可以把他整个<strong>html</strong>信息弄回来，把它打印到日志里面，方便自动化用例执行完了用来分析和判断，用来定位问题的一种手段。</p>
<p>还有一种场景有时候你去选择一个元素的时候根据常规手段，无法去获取选择内容了比如看下面的例子。</p>
<pre><code>div id=&quot;food&quot; style=&quot;margin-top:10px;color:red&quot;&gt;
    &lt;span calss=&quot;vegetable good&quot;&gt;黄瓜&lt;/span&gt;
    &lt;span calss=&quot;meat&quot;&gt;牛肉&lt;/span&gt;
    &lt;p calss=&quot;vegetable&quot;&gt;南瓜&lt;/p&gt;
    &lt;p calss=&quot;vegetable&quot;&gt;青菜&lt;/p&gt;
</code></pre>
<p>假如我要获取牛肉他的<strong>class</strong>属性是否是 <strong>meat</strong> ，我们后面学到的选择元素方法是很简单获取到的，假如根据现在的知识点，只有父元素有<strong>id</strong>他本身没有<strong>id</strong>的，根据当前的知识点获取不到他，那怎么办呢？我们可以把有<strong>id</strong>的父元素整个<strong>HTML</strong>拿回来，通过 <strong>get_arrtibute(innerHTML)</strong> 方法拿回来，然后通过 <strong>split()</strong> 切割字符串的方法得到。</p>
<p>代码如下：</p>
<pre><code>#找到id为food的元素
ele = driver.find_element_by_id(&#39;food&#39;)
#通过get_attribute(&#39;innerHTML&#39;)方法拿到内部元素
foodText = ele.get_attribute(&#39;innerHTML&#39;)
#通过split()方法得到数据
ret1 = foodText.split(&#39;&lt;/span&gt;)[1]
ret2 = ret1.split(&#39;&quot;&#39;)[1]
</code></pre>
<p>通过这样一个方法，我们就得到了<strong>meat</strong>上面这种方法当然可以达到目的，但是比较丑陋代码多了一点让人费解，更重要的是不够健壮，比如属性值可以用单引号也可以用双引号，如果开发下次改代码改成了单引号，我们的代码就没用了。</p>
<p>我们怎么样让程序更健壮一点呢，不需要那么麻烦使用字符串分割，我们可以使用另外一种方法<strong>BeautifulSoup4</strong>这个库。</p>
<h4 id="3-3-3-BeautifulSoup4的介绍与安装"><a href="#3-3-3-BeautifulSoup4的介绍与安装" class="headerlink" title="3.3.3 BeautifulSoup4的介绍与安装"></a>3.3.3 BeautifulSoup4的介绍与安装</h4><p><strong>BS</strong>是可以从<strong>HTML</strong>或<strong>XMl</strong>文件中提取数据的库,他就是一个让你来<strong>HTML</strong>的工具，他可以把信息提取出来，不需要用字符串切割这种方法<strong>Selenium</strong>可以 用来远程获取数据。有的时候，感觉用<strong>Selenium</strong>获取某些元素数据不太方便</p>
<p>我们可以将它 和 <strong>Selenium</strong>两种技术融合使用达到我们的目的。</p>
<p><strong>beautifulSoup4</strong> 和** Selenium <strong>的关系：直接的讲他们 两者没有直接关系，</strong> beautifulSoup4** 是<strong>python</strong>程序直接对一个字符串进行分析的，这个字符串要符合<strong>HTML</strong>或<strong>XMl</strong>的格式，他是专门用来处理<strong>HTML</strong>或<strong>XMl</strong>格式的字符串的，他和<strong>selenium</strong>自动化没有直接的关系。他是<strong>python</strong>语言独有的</p>
<p><strong>beautifulSoup4</strong> 中文文档大家可以看一下：</p>
<p><a href="https://links.jianshu.com/go?to=https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</a></p>
<ul>
<li><p>安装编程接口库</p>
<p>我们用<strong>Pip</strong>来安装<strong>BeautifulSoup4</strong>这个库，执行下面的命令即可。（执行该命令之前，要确保<strong>python</strong>的<strong>script</strong>目录在系统环境变量<strong>path</strong>里面已经包括了）。命令为：<strong>pip install beautifulsoup4</strong></p>
</li>
</ul>
<p>安装好<strong>beautifulsoup</strong>之后强烈要求大家安装<strong>html5lib</strong> 这个库，如果大家要进行<strong>HTML</strong>分析的话，因为<strong>beautifulsoup4</strong>内置分析<strong>HTML</strong>他对<strong>HTML</strong>语法兼容性不够好，指定用<strong>html5lib</strong>来分析，<strong>html5lib</strong>库对<strong>HTML</strong>兼容性比较好，这个库对<strong>html</strong>的兼容性基本和浏览器差不多。</p>
<ul>
<li><p>安装<strong>html5lib</strong></p>
<p><strong>pip install html5lib</strong></p>
</li>
</ul>
<h4 id="3-3-4-BeautifulSoup4的使用"><a href="#3-3-4-BeautifulSoup4的使用" class="headerlink" title="3.3.4 BeautifulSoup4的使用"></a>3.3.4 BeautifulSoup4的使用</h4><p>现在我们根据一个例子来讲解如何使用 <strong>bs</strong> ，本地有一个<strong>html</strong>文档，注意他只是本地的一个磁盘文件和Selenium没有关系，如下</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;三兄弟的故事&lt;/title&gt;
    &lt;title&gt;三兄弟的故事23454554545&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p class=&quot;title tile2&quot; style=&quot;color:red&quot;&gt;&lt;b&gt;三兄弟的故事&lt;/b&gt;&lt;/p&gt;

    &lt;p class=&quot;story&quot;&gt;从前有三个兄弟，他们的名字是
    &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;张三&lt;/a&gt;,
    &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;李四&lt;/a&gt; 和
    &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;王二&lt;/a&gt;;
    他们都住在一口井里.&lt;/p&gt;

    &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;

    &lt;div id=&quot;d1&quot;&gt;
        &lt;a href=&quot;http://baidu.com/tillie&quot; class=&quot;sister&quot; &gt;百度&lt;/a&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>下面是使用<strong>BeautifulSoup</strong>库处理<strong>HTML</strong>字符串</p>
<pre><code>with open(&#39;bs1.html&#39;,encoding=&#39;utf8&#39;) as f:
    html_doc = f.read()

#从bs4这个库导入BeautifulSoup对象
from bs4 import BeautifulSoup

#指定用html5lib来解析文档
soup = BeautifulSoup(html_doc,&#39;html5lib&#39;)
</code></pre>
<p>下面我们从<strong>html</strong>文档获取我们想要获取的信息，比如说获取一个标签名为<strong>title</strong>的元素，怎么做呢？看示例</p>
<pre><code># 查找 标签名为title的第一个元素 ，
# 返回一个 &lt;class &#39;bs4.element.Tag&#39;&gt; 实例
print(soup.find(&#39;title&#39;))
</code></pre>
<p><strong>find</strong>就是找，这里我们找到的是标签名为<strong>title</strong>的元素.</p>
<pre><code>&lt;titile&gt;三兄弟的故事&lt;/title&gt;
</code></pre>
<p>大家看我上面<strong>HTML</strong>的截图，里面有两个元素标签名为 <strong>title</strong> ，他找的是第一个，这里代码运行会很快因为我们是本地运行，不需要和浏览器交互和<strong>Selenium</strong>没关系，假如我们想要获取<strong>title</strong>的内容进行分析的话该怎么办？</p>
<p>可以用<strong>string</strong>方法</p>
<pre><code>#.string就是获取内部的内容
print(soup.find(title).string)
#也可以这样写
print(soup.title.string)
</code></pre>
<p>也可以用<strong>get</strong></p>
<pre><code>print(soup.find(title).get_text())
#也可以这样写
print(soup.title.get_text())
</code></pre>
<p>输出结果为:</p>
<pre><code>三兄弟的故事
</code></pre>
<p>这两种方法是有区别的，建议大家使用get_text()方法，下面给大家举个例子，看下面的<strong>html</strong></p>
<pre><code>&lt;div id=&quot;dl&quot;&gt;
    &lt;a herf=&quot;http://baidu.com/tillie&quot; class=&quot;sister&quot;&gt;百度&lt;/a&gt;&gt;
&lt;div&gt;   
</code></pre>
<p>如果想要获取<strong>div</strong>元素里面的文本内容，百度并不是直接内容，是他子节点的内容，这个时候就用 <strong>get_text()</strong> 才能获取到“百度”，如果用**.string<strong>的话会打印出 <strong>“None”</strong> ，</strong>None<strong>就是没有因为</strong>string<strong>优先显示</strong>div**元素的直接文本，但是这里面的文本是他子元素的文本，所以建议大家优先使用 <strong>get_text()</strong> 。</p>
<p>目前我们只简单介绍了<strong>BeautifulSoup</strong>如果获取文本，这还没有什么神奇的，我们还可以进行更为复杂的分析，比如我们想获取其中某一个属性的值，我们要获取第一个<strong>a</strong>的<strong>class</strong>属性值</p>
<pre><code>&lt;body&gt;
    &lt;p class=&quot;title tile2&quot; style=&quot;color:red&quot;&gt;&lt;b&gt;三兄弟的故事&lt;/b&gt;&lt;/p&gt;

    &lt;p class=&quot;story&quot;&gt;从前有三个兄弟，他们的名字是
    &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;张三&lt;/a&gt;,
    &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;李四&lt;/a&gt; 和
    &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;王二&lt;/a&gt;;
    他们都住在一口井里.&lt;/p&gt;
</code></pre>
<p>那我们该怎么写呢？</p>
<pre><code>#第一种方法
print(soup.find(&#39;a&#39;)[&#39;class&#39;])
#第二种方法
print(soup.a[&#39;calss&#39;])
</code></pre>
<p>就获取到了第一个<strong>a</strong>的<strong>class</strong>属性的值，这样我们就可以获取属性的值了，讲到这里大家发现我们都是找第一个元素，如果我想找第三个第四个怎么办?<strong>find</strong>还有一个方法叫 <strong>find_all</strong> ，那我们要找到所有的a该怎么写呢？？</p>
<pre><code>print(soup.find_all(&#39;a&#39;))
</code></pre>
<p>这个时候打印出来的是一个列表，就全找到了</p>
<pre><code>[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;张三&lt;/a&gt;,
 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;李四&lt;/a&gt;, 
 &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;王二&lt;/a&gt;,
 &lt;a class=&quot;sister&quot; href=&quot;http://baidu.com/tillie&quot;&gt;百度&lt;/a&gt;, &lt;a class=&quot;sister&quot; herf=&quot;http://baidu.com/tillie&quot;&gt;百度&lt;/a&gt;]
</code></pre>
<p>我们想找第二个怎么办，直接用<strong>python</strong>的知识下标。</p>
<pre><code>print(soup.find_all(&#39;a&#39;))[1]
</code></pre>
<p>就找到李四了，这种方法有时候比较麻烦，有的时候网页很大很大，比如有上百个 <strong>a</strong> ，你要找第几个你也不知道，一个个数肯定不现实，那怎么办？还一种方法根本不需要<strong>find_all</strong>把所有的都找出来再通过下标去找，可以通过其他的属性还限定他，假如说我们要找第二个 <strong>a</strong> ，发现他有id这个时候我们可以通过id属性来找。</p>
<pre><code>print(soup.find(&#39;a&#39;，id=&#39;link2&#39;))
</code></pre>
<p>通过上面的代码就可以直接找到他，不一定要用<strong>id</strong>属性，任何属性都可以</p>
<p>这里就可以发现<strong>BeautifulSoup</strong>可以进行数据的提取，我们甚至可以用多个条件进行提取。</p>
<pre><code>print(soup.find(&#39;a&#39;，id=&#39;link2&#39;,herf=&#39;http://exaple.com/lacie&#39;))
</code></pre>
<p>大家还记得上面我们想获取牛肉的<strong>calss</strong>属性是否是 <strong>meat</strong> ，当时我们用<strong>python</strong>字符串切割的方法得到的，我们可以通过<strong>BeautifulSoup</strong>直接获取啦！</p>
<pre><code>ele = driver.find_element_by_id(&#39;food&#39;)
html= ele.get_Attribute(&#39;innerHTML)
print(html)
from bs4 import BeautifulSoup
soup = BeautifulSoup(html,&#39;html5lib&#39;)
target = soup.find_all(&#39;span&#39;)[1][&#39;class&#39;]#列表
print(taget)
</code></pre>
<p>这种写法更稳定可靠，写法有很多种下面再介绍一种写法,目的就是判断值是不是 <strong>meat</strong> ，我们直接根据<strong>class</strong>属性去找，如果我们根据<strong>class</strong>等于<strong>meat</strong>能找到说明也有。</p>
<pre><code>from bs4 import BeautifulSoup 
soup = BeautifulSoup(html,&#39;html5lib&#39;)
target = soup.find(&#39;span&#39;,&#123;&#39;class&#39;:&#39;meat&#39;&#125;)
if target：
  print(&#39;是meat&#39;)
print(taget)
</code></pre>
<p>注意这里不能直接这样写 <strong>find(‘span’,class&#x3D;’meat’)，</strong> 因为<strong>class</strong>是我们定义类的关键字</p>
<h4 id="3-3-5-查看元素的属性"><a href="#3-3-5-查看元素的属性" class="headerlink" title="3.3.5 查看元素的属性"></a>3.3.5 查看元素的属性</h4><p>上面讲了可以根据<strong>id</strong>来查找元素，可是，面对一个别人开发的网页，我们怎么知道元素的属性值呢？现在，基本上每款浏览器都会内置开发者工具（通常是在浏览器窗口下按<strong>F12</strong>按键打开），我们可以利用浏览器的开发者工具来查看。在<strong>chrom</strong>浏览器里，按 <strong>F12</strong> ，打开开发工具窗口，<strong>chrom</strong>界面如下所示：</p>
<p><img src="/assets/2/image-20220515145819-e706oly.png" alt="image.png"></p>
<p>image.png</p>
<p>其中右边红框里面的窗口就是开发者工具窗口。它的功能非常强大，<strong>web</strong>前端开发人员经常用来调试前端代码。我们这里先使用它来查看<strong>web</strong>元素的属性信息。工具栏的上边最左边的箭头，就是用来选择界面元素，并且查看其信息用的。我们点击这个箭头，再异动鼠标到左边的页面上，点击一下搜索输入框，结果右边的开发工具窗口内容如下：</p>
<p><img src="/assets/2/image-20220515145828-29kjp8a.png" alt="image.png"></p>
<p>image.png</p>
<p>大家请注意红圈里面的内容，这里就是该输入框的<strong>html</strong>代码内容，里面的属性有<strong>id，name，class</strong>等。这样我们就可以知道该元素的信息了。这是<strong>Chrom</strong>浏览器的用法。事实上，其他浏览器基本也大同小异。大家可以自己尝试一下</p>
<h4 id="3-3-6-通过name属性选择"><a href="#3-3-6-通过name属性选择" class="headerlink" title="3.3.6 通过name属性选择"></a>3.3.6 通过name属性选择</h4><p><strong>name</strong>也是<strong>html</strong>标准属性之一，假设要选择的元素具有该属性的话，也可以通过它来进行选择。假设<strong>html</strong>中有如下元素：</p>
<pre><code>&lt;input name=&quot;cheese&quot; type=&quot;text&quot;/&gt;
</code></pre>
<p>要找到该元素，可以用下面的方法:</p>
<pre><code>cheese = driver.find_element_by_name(&quot;cheese&quot;)
</code></pre>
<p>或者：</p>
<pre><code>from selenium.webdriver.common.by import By
cheese = driver.find_element(By.NAME, &quot;cheese&quot;)
</code></pre>
<p>要注意的是，和<strong>id</strong>不同，<strong>name</strong>不一定是唯一的（当然通常是唯一的）。</p>
<p>当指定选择的名字，在网页中有多个元素都具有时，返回的是第一个找到的元素。</p>
<p>如果我们要找出所有具有该名字的元素可以这样，代码如下：</p>
<pre><code>cheeses = driver.find_elements_by_name(&quot;cheese&quot;)
</code></pre>
<p>或者：</p>
<pre><code>from selenium.webdriver.common.by import By
cheeses = driver.find_elements(By.NAME,&quot;cheese&quot;)
</code></pre>
<p>这时，返回的是一个 <strong>python list</strong> ，里面包含了所有找到的<strong>WebElement</strong>对象,如果找不到，返回空列表，不抛出异常。</p>
<h4 id="3-3-7-通过class选择元素"><a href="#3-3-7-通过class选择元素" class="headerlink" title="3.3.7 通过class选择元素"></a>3.3.7 通过class选择元素</h4><p><strong>class</strong>也是html标准属性之一，假设要选择的元素具有该属性的话，也可以通过它来进行查找。但是通常具有相同<strong>class</strong> 属性值的元素很多，我们往往调用选择多个元素的方法，而不是选择一个元素。假设<strong>html</strong>中有如下片段：</p>
<pre><code>&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Cheddar&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Gouda&lt;/span&gt;&lt;/div&gt;
</code></pre>
<p>要找到该元素，可以用下面的方法:</p>
<pre><code>cheeses = driver.find_elements_by_class_name(&quot;cheese&quot;)
</code></pre>
<p>或者：</p>
<pre><code>from selenium.webdriver.common.by import By
cheeses = driver.find_elements(By.CLASS_NAME, &quot;cheese&quot;)
</code></pre>
<p>这时，返回的是一个python list，里面包含了所有找到的WebElement对象。</p>
<p>注意：通过elements这个返回的就不是一个webelement对象了，他是所有的符合条件的wedelement对象，既然是所有的返回的时候放在一个列表里面，所以他的返回值就是列表，这个时候我们就不能用这种写法了</p>
<pre><code>eles = find_elements_by_name(&#39;button&#39;)
print(eles.get_attribute(&#39;outerHTMl&#39;))
</code></pre>
<p>上面这种写法是不对的，因为eles是个列表，列表并没有get_attribute()方法，这个方法只有webelement对象才有的，只有列表里的每一个元素才有的，那我们该怎么写呢？</p>
<pre><code>eles = find_elements_by_name(&#39;button&#39;)
for ele in eles:
  print(ele.get_attribute(&#39;outerHTMl&#39;))
</code></pre>
<p>这样就可以了，通过for循环去遍历class同理</p>
<h4 id="3-3-8通过-tag-名称选择"><a href="#3-3-8通过-tag-名称选择" class="headerlink" title="3.3.8通过 tag 名称选择"></a>3.3.8通过 tag 名称选择</h4><p>有的时候，有的上述的定位方式都不能定位到，比如 一个元素没有 <strong>id</strong> ，没有 <strong>class</strong> 、 <strong>name</strong> 。 但是它的<strong>tag</strong>名却是唯一的。可以根据<strong>tag</strong>名定位</p>
<p>假设<strong>html</strong>中有如下片段:</p>
<pre><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>如果<strong>iframe</strong>这个tag在本html中是唯一的，可以根据<strong>iframe</strong>这个<strong>tag</strong>名来找到该元素:</p>
<pre><code>frame = driver.find_element_by_tag_name(&quot;iframe&quot;)
</code></pre>
<p>或者：</p>
<pre><code>from selenium.webdriver.common.by import By
frame = driver.find_element(By.TAG_NAME, &quot;iframe&quot;)
</code></pre>
<h4 id="3-3-9-通过链接文本选择"><a href="#3-3-9-通过链接文本选择" class="headerlink" title="3.3.9 通过链接文本选择"></a>3.3.9 通过链接文本选择</h4><p><strong>web</strong>自动化的时候，经常会自动化点击某个链接，对于链接，可以通过其链接文本的内容或者部分内容进行选择。假设html中有如下片段：</p>
<pre><code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;转到百度&lt;/a&gt;
</code></pre>
<p>可以这样选择:</p>
<pre><code>ele = driver.find_element_by_link_text(&quot;转到百度&quot;)
</code></pre>
<p>或者：</p>
<pre><code>from selenium.webdriver.common.by import By
ele = driver.find_element(By.LINK_TEXT, &quot;转到百度&quot;)
</code></pre>
<p>有的时候，链接的文本很长，我们甚至只需要通过部分文本去找到该链接元素只要这个链接文本是唯一的就行，可以这样选择。</p>
<pre><code>ele = driver.find_element_by_partial_link_text(&quot;百度&quot;)
</code></pre>
<p>或者：</p>
<pre><code>from selenium.webdriver.common.by import By
ele = driver.find_element(By.PARTIAL_LINK_TEXT, &quot;百度&quot;)
</code></pre>
<hr>
<h4 id="下面是小练习，自己练习玩的"><a href="#下面是小练习，自己练习玩的" class="headerlink" title="下面是小练习，自己练习玩的"></a>下面是小练习，自己练习玩的</h4><p><strong>Selenium 练习1</strong></p>
<p>1.访问天气查询网站（网址如下），查询江苏省天气</p>
<p><a href="https://links.jianshu.com/go?to=http://www.weather.com.cn/html/province/jiangsu.shtml">http://www.weather.com.cn/html/province/jiangsu.shtml</a></p>
<p>获取江苏所有城市的天气，并找出其中每天最低气温最低的城市，显示出来，比如</p>
<p>温度最低为12℃, 城市有连云港 盐城</p>
<p> <strong>方法1：</strong> 取回 整个 <strong>html</strong> 代码片段， 用<strong>python</strong>语言， 直接分析</p>
<pre><code>from selenium import webdriver
driver = webdriver.Chrome(r&quot;d:\tools\webdrivers\chromedriver.exe&quot;)
# ------------------------
driver.get(&#39;http://www.weather.com.cn/html/province/jiangsu.shtml&#39;)

ele = driver.find_element_by_id(&quot;forecastID&quot;)
print(ele.text)

citysWeather = ele.text.split(&#39;℃\n&#39;)

# 这样：citysWeather是每个城市的温度信息 list
#
# 每个元素像这样：
# 南京
# 12℃/27

#下面就是算法，算出温度最低城市，
# 有很多方法，大家看看这种

# 我们循环 去遍历这个城市文档信息列表，
# 得到城市名和 低气温的值，
#
# 依次和取出当前的所有城市最低气温比较，
# 如果更低，就记录到当前的低温城市列表中。

lowest = None  #  记录目前最低温，先设置为None
lowestCitys = []  # 温度最低城市列表
for one in citysWeather:
    one = one.replace(&#39;℃&#39;,&#39;&#39;)
    print(one)
    parts = one.split(&#39;\n&#39;)
    curcity = parts[0]

    lowweather = min([int(one)  for one in parts[1].split(&#39;/&#39;)])

    # 还没有最低温记录，或者发现气温更低的城市
    # 注意 条件不能写反
    if lowest==None or lowweather&lt;lowest:
        lowest = lowweather
        lowestCity = [curcity]
    #  温度和当前最低相同，加入列表
    elif lowweather ==lowest:
        lowestCity.append(curcity)

print(&#39;温度最低为%s℃, 城市有%s&#39; % (lowest, &#39; &#39;.join(lowestCity)))

# ------------------------

driver.quit()
</code></pre>
<p> <strong>方法2：</strong> 用 <strong>selenium</strong> 直接的获取我们要的数据，我们分析一下 <strong>html</strong> ，看看能否精确的直接获取每个城市的名字和温度，发现每个城市的信息都在<strong>dl</strong>里面。</p>
<pre><code>driver.get(&#39;http://www.weather.com.cn/html/province/jiangsu.shtml&#39;)

ele = driver.find_element_by_id(&quot;forecastID&quot;)
print(ele.text)


# 再从 forecastID 元素获取所有子元素dl
dls = ele.find_elements_by_tag_name(&#39;dl&#39;)

# 将城市和气温信息保存到列表citys中
citys = []
for dl in dls:
    # print dl.get_attribute(&#39;innerHTML&#39;)

    name = dl.find_element_by_tag_name(&#39;dt&#39;).text
    # 最高最低气温位置会变，根据位置决定是span还是b
    ltemp = dl.find_element_by_tag_name(&#39;span&#39;).text

    ltemp = int(ltemp.replace(&#39;℃&#39;,&#39;&#39;))
    print(name, ltemp)
    citys.append([name, ltemp])
</code></pre>
<p>既然每个城市的名字和温度都有了， 下面的做法就和前面差不多</p>
<pre><code>lowest = None
lowestCitys = []  # 温度最低城市列表
for one in citys:
    curcity = one[0]
    ltemp = one[1]
    # 发现气温更低的城市
    if lowest==None or ltemp&lt;lowest:
        lowest = ltemp
        lowestCitys = [curcity]
    #  温度和当前最低相同，加入列表
    elif ltemp ==lowest:
        lowestCitys.append(curcity)

print(&#39;温度最低为%s℃, 城市有%s&#39; % (lowest, &#39; &#39;.join(lowestCitys)))
</code></pre>
<p> <strong>方法3:</strong> 取回 整个<strong>html</strong>代码片段， 用<strong>beatifulsoup</strong> 分析大体思路和方法二 一样， 唯一的区别在于，我们不是用<strong>selenium</strong>获取每个城市温度对应的<strong>web</strong>元素信息而是用<strong>BS</strong>本地操作。</p>
<pre><code>driver.get(&#39;http://www.weather.com.cn/html/province/jiangsu.shtml&#39;)

ele = driver.find_element_by_id(&quot;forecastID&quot;)
print(ele.text)

# -----------------------------------
# 再从 forecastID 元素获取所有子元素dl
html_doc = ele.get_attribute(&#39;innerHTML&#39;)

from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, &quot;html5lib&quot;)

# 发现每个城市的信息都在dl里面
dls = soup.find_all(&#39;dl&#39;)

# 将城市和气温信息保存到列表citys中
citys = []
for dl in dls: 
    name = dl.a.string
ltemp = dl.b.string
ltemp = int(ltemp.replace(&#39;℃&#39;,&#39;&#39;))
    print(name, ltemp)
    citys.append([name,ltemp])
</code></pre>
<p>后面的代码一模一样，直接拷贝即可</p>
<pre><code>lowest = None
lowestCitys = []  # 温度最低城市列表
for one in citys:
    curcity = one[0]
    ltemp = one[1]
    # 发现气温更低的城市
    if lowest==None or ltemp&lt;lowest:
        lowest = ltemp
        lowestCitys = [curcity]
    #  温度和当前最低相同，加入列表
    elif ltemp ==lowest:
        lowestCitys.append(curcity)
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>01_selenium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium-webdriver环境搭建</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/01_selenium-webdriver%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>selenium是浏览器自动化工具（使用代码控制浏览器，执行浏览器操作），注意不是自动化测试工具，所以要完成自动化测试工作需要selenium + unittest &#x2F; pytest 来完成</p>
<p>比如手工点击最大化，最小化，输入内容等操作，都可以使用代码来控制浏览器完成操作</p>
<p>安装selenium:</p>
<p>浏览器（最好安装谷歌，火狐）<br>webdirver驱动 （可以通过这个网址来下载<a href="https://npmmirror.com/mirrors">https://npmmirror.com/mirrors</a>）<br>语言绑定包 pip install selenium &#x3D;&#x3D; 3.1.4（注意下载的是4.0.0版本的运行报错的话，可以下载3版本的）<br>第一步：浏览器我已经安装好了，所以就不操作了，我安装的是谷歌</p>
<p>第二步：打开<a href="https://npmmirror.com/mirrors%EF%BC%8C%E6%89%BE%E5%88%B0ChromeDriver%EF%BC%8C%E9%80%89%E6%8B%A9%E4%B8%8E%E8%87%AA%E5%B7%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E4%B8%80%E8%87%B4%E7%9A%84%E9%A9%B1%E5%8A%A8">https://npmmirror.com/mirrors，找到ChromeDriver，选择与自己浏览器版本一致的驱动</a></p>
<p><img src="/assets/2/image-20220515144157-gm6vwfh.png" alt="image.png"></p>
<p> 我的谷歌浏览器是96.0.4664.45，所以就下载96版本的驱动（最好选择最新日期的，bug少一点）</p>
<p><img src="/assets/2/image-20220515144211-wz0w02e.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515144225-5zu0802.png" alt="image.png"></p>
<p> 电脑是什么系统的，就对应下载什么版本</p>
<p><img src="/assets/2/image-20220515144236-qy16bhj.png" alt="image.png"></p>
<p>驱动下载完成后，可以解压放在与python.exe同一个目录下即可</p>
<p><img src="/assets/2/image-20220515144249-2cfk3ap.png" alt="image.png"></p>
<p>第三步：打开pycharm，安装selenium，pip install selenium，安装完成后，就可以导入编写代码</p>
<blockquote>
<p>from selenium import webdriver</p>
<p>得到一个浏览器Chrome</p>
<p>executable_path表示浏览器驱动的文件路径</p>
<p>browser &#x3D; webdriver.Chrome(executable_path&#x3D;’chromedriver.exe’)</p>
<p>如果不想传浏览器的路径，可以事先把chromedriver.exe放到python.exe同目录下</p>
<p>browser &#x3D; webdriver.Chrome()</p>
</blockquote>
<p>运行结果：（打开了一个chrom浏览器）</p>
<p><img src="/assets/2/image-20220515144341-xwpnc6r.png" alt="image.png"></p>
<p>注意：</p>
<p>因为python.exe设置了环境变量，所以把浏览器驱动放到与python.exe同目录下，就不用再单独设置浏览器驱动的环境变量了<br>python中浏览器驱动名称要与放到环境变量下的浏览器驱动名称要一致<br>浏览器驱动如果未设置环境变量的话，一定要写executable_path&#x3D;’浏览器驱动名称’<br>如果安装的selenium是4.0.0版本的话，要设置一下</p>
<blockquote>
<p>service &#x3D; Service(executable_path&#x3D;’chromedriver_96.exe’)<br /></p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
        <category>01_selenium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>UI自动化测试介绍</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/02_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>1.框架搭建<br> 优化前的框架：        <img src="/assets/2/image-20220515114816-ypndfv1.png" alt="image.png">                         优化后的框架：<img src="/assets/2/image-20220515114824-d81cuex.png" alt="image.png"></p>
<p>UI自动化框架跟接口自动化框架相似，我们拿到一个项目之后，首先把需要的框架先搭建好，然后再一点一点去进行优化，不要急着一步到位，先把基本的流程跑通</p>
<p>gitignore文件：存放不上传到git上的内容</p>
<p>README文件：这个是框架的简单说明，供同事，领导等查看，以及自己时间长了记不清楚查看</p>
<p>requirements.txt文件：需要安装的第三方库</p>
<p>run.py文件：收集并运行用例</p>
<p>tests文件：存放所有的测试用例</p>
<p>data文件：存放所有的测试数据，如登录的账号密码</p>
<p>drivers文件：存放不同版本的驱动</p>
<p>output文件：存放allure生成的测试报告文件</p>
<p>pages文件：存放所有的页面元素操作封装的内容</p>
<p>report文件：pytest生成的测试报告（测试报告二选一即可）</p>
<p>setting文件：存放配置文件</p>
<p>2.UI自动化测试的地位<br>UI自动化测试在整个测试过程中占据的地位：</p>
<p>这个比例主要还是看公司，手工测试&#x2F;自动化测试，60%&#x2F;40%（比较厉害的公司）大多数公司自动化占据的比例还是相对要少的，自动化占20%左右</p>
<p>自动化测试又分：接口自动化&#x2F;UI自动化&#x2F;性能&#x2F;安全</p>
<pre><code>                        70-80%/20-30%
</code></pre>
<p>优先实现正向用例，回归</p>
<p>3.UI自动化测试的特征<br>界面修改频繁（前端喜欢加<div></div>）<br>界面需求变动也大<br>运行速度很慢（浏览器打开速度慢，页面加载速度慢，占用CPU很多）<br>界面稳定性不够<br>界面排版是不方便做自动化<br>4.UI自动化测试流程<br>需求分析<br>用例设计：提供什么参数以及数据，测试步骤<br>用例评审（这步就不详细介绍了，主要看公司如何做）<br>编写代码<br>测试报告<br>4.1需求分析<br>拿到一个项目后，首先是分析这个产品是做什么的，都有什么样的功能，例如课堂派web端，先整理出都分什么角色，分别对应什么功能，进行自动化测试前，肯定是手工测试已经进行了测试，并且功能稳定没有bug</p>
<p><img src="/assets/2/image-20220515141332-pdcyjeb.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515141343-exip85r.png" alt="image.png"></p>
<p>4.2用例设计<br>编写UI自动化测试用例的流程：</p>
<p>手工测试用例编写<br>自动化测试用例代码编写<br>测试用例其实就是一个脚本script（这里指的不是代码中的脚本），作用是为了记录自己的一个思路，方便下次再去根据这个脚本去测试，方便管理，以免漏测等</p>
<p><img src="/assets/2/image-20220515141351-688r0ys.png" alt="image.png"></p>
<p>我这里为了介绍就不一一去编写了，实际工作中需要把所有的用例测试点都转化成测试用例 ，有了测试用例之后，我们就可以把用例转化成自动化测试代码了</p>
<p>4.3编写代码<br>根据编写的测试用例，进行代码编写，如登录功能</p>
<p>步骤：</p>
<p>输入登录url：<a href="https://v4.ketangpai.com/Home/User/login.html">https://v4.ketangpai.com/Home/User/login.html</a><br>输入用户名：aaa  name&#x3D;”account”<br>输入密码:123  name&#x3D;”pass”<br>点击登录按钮：class&#x3D;”btn-btn” （虽然找到两个相同元素，但fide_element只取第一个，正好我们需要的是第一个）<br>进行断言<br> 具体代码如下：</p>
<blockquote>
<p>from selenium import webdriver<br>from selenium.webdriver.common.by import By</p>
<p>class TestSignIn:<br>    def test_sing_in_01(self):<br>        username &#x3D; ‘aaa’<br>        password &#x3D; ‘123’<br>        expected &#x3D; ‘密码有效长度是6到30个字符’<br>        with webdriver.Chrome(executable_path&#x3D;r’E:\lemon\lianxi\day39_web框架搭建\chromedriver_96.exe’) as browser:<br>            browser.implicitly_wait(5)<br>            browser.maximize_window()<br>            # 访问url<br>            url &#x3D; ‘<a href="https://v4.ketangpai.com/Home/User/login.html&#39;">https://v4.ketangpai.com/Home/User/login.html&#39;</a><br>            browser.get(url)<br>            # 输入用户名<br>            el_user &#x3D; browser.find_element(By.NAME, ‘account’)<br>            el_user.clear()<br>            el_user.send_keys(username)<br>            # 输入密码<br>            el_pwd &#x3D; browser.find_element(By.NAME, ‘pass’)<br>            el_pwd.clear()<br>            el_pwd.send_keys(password)<br>            # 点击登录按钮<br>            browser.find_element(By.CSS_SELECTOR, ‘.btn-btn’).click()<br>            # 获取登录后报错的文本<br>            actual &#x3D; browser.find_element(By.CSS_SELECTOR, ‘.error-tips’).text<br>            # 通过属性名称获取属性值<br>            # actual &#x3D; browser.find_element(‘xpath’, ‘&#x2F;&#x2F;p[@class&#x3D;”error-tips”]’).get_attribute(‘name’)<br>            assert expected &#x3D;&#x3D; actual</p>
</blockquote>
<p>注意：</p>
<p>executable_path&#x3D;r’E:\lemon\lianxi\day39_web框架搭建\chromedriver_96.exe’这个是可以不用填写的前提是：把该驱动放到了环境变量中了，前面有介绍，可以参考此篇文章：selenium-webdriver环境搭建_晒不黑的黑煤球的博客-CSDN博客<br>之所以编写此名代码，是在实际项目中，可能会测试多个不同版本的驱动与浏览器时方便管理<br>这是拿到一个项目后，先保证编写的代码可以顺利的执行没有报错，再去进行优化，我这里是演示就不一一编写所有用例代码了，编写过程是一样的，就是输入的数据与断言有所有更改</p>
<p>接下来，我们就对代码进行各种封装及优化</p>
<p>4.3.1优化代码<br>优化方向：</p>
<p>更好用<br>更易懂<br>维护代码方便<br>更通用<br>扩展性<br>优化点：</p>
<p>隔离测试数据，当需要添加或修改数据时，可以在单独的模块中进行修改<br>浏览器管理可以重复使用，所以可以进行单独封装<br>需要把驱动进行隔离管理：1.可以存储多个浏览器驱动，2.想用哪个用哪个<br>base url域名ip<br>登录操作可以重复使用（项目通用）<br>登录操作：已经登录过了，不需要重新再登录，记住用户登录状态<br>PO模式<br>优化第一点：</p>
<p>测试数据我们可以从配置文件，或者execl表格获取，也可以直接新建一个模块来保存数据，我这里新建了一个login_data.py来存储</p>
<blockquote>
<p>login_fail &#x3D; {‘username’: ‘aaa’, ‘password’: ‘123’, ‘expected’: ‘密码有效长度是6到30个字符’}</p>
</blockquote>
<p>自动化测试用例修改如下：</p>
<p><img src="/assets/2/image-20220515141532-m5u304v.png" alt="image.png"></p>
<p> 优化第二点：</p>
<p>因为我们执行测试用例之前是先打开浏览器操作，用例执行后再进行浏览器关闭，因此把浏览器的封装放到夹具中最合适，之前我们介绍过共享fixture，就是把所有的夹具放到固定的conftest.py文件中，这样不需要导入，pytest会自动调用</p>
<p>注意：conftest.py文件不能放到其他包下，放在根目录或tests包下即可，否则会报错</p>
<blockquote>
<p>import pytest<br>from selenium import webdriver</p>
<p>打开浏览器</p>
<p>def get_browser():<br>    # 因为要在测试用例后执行闭关浏览器，因为不要使用with的打开方式<br>    browser &#x3D; webdriver.Chrome(executable_path&#x3D;r’E:\lemon\lianxi\day39_web框架搭建\chromedriver_96.exe’)<br>    browser.implicitly_wait(5)<br>    browser.maximize_window()<br>    return browser</p>
<p>设置夹具</p>
<p>@pytest.fixture()<br>def browser():<br>    driver &#x3D; get_browser()<br>    yield driver<br>    driver.quit()</p>
</blockquote>
<p>自动化测试用例修改如下：</p>
<p><img src="/assets/2/image-20220515141700-v7pe1yx.png" alt="image.png"></p>
<p>把相关打开浏览器，设置隐性等待，窗口最大化的代码删除掉，只传入夹具browser即可</p>
<p>优化第三点：</p>
<p>把所有的驱动放到一个目录中，这样方便管理与操作，我新建了drivers目录存放驱动，新建了setting包，config.py配置文件（为了动态获取驱动的目录）</p>
<p><img src="/assets/2/image-20220515141708-fcexfc2.png" alt="image.png"></p>
<p>config.py代码如下：</p>
<blockquote>
<p>import os</p>
<p>获取config.py当前文件的路径</p>
<p>curren_path &#x3D; os.path.abspath(<strong>file</strong>)</p>
<p>配置文件目录的路径</p>
<p>config_dir &#x3D; os.path.dirname(curren_path)</p>
<p>setting包的路径</p>
<p>cf_dir &#x3D; os.path.dirname(config_dir)</p>
<p>host地址</p>
<p>host &#x3D; ‘<a href="https://v4.ketangpai.com/&#39;">https://v4.ketangpai.com/&#39;</a></p>
<p>驱动的路径</p>
<p>driver_dir &#x3D; os.path.join(cf_dir, ‘drivers’)</p>
</blockquote>
<p>修改conftest.py代码如下：</p>
<p><img src="/assets/2/image-20220515141832-np7g5wm.png" alt="image.png"></p>
<p>4.3.2PO模式<br>PO&#x2F;POM模式（Page Object 或Page Object Model）是UI测试模式，字面意思就是页面对象模型，从本质上来说就是把页面的元素操作封装成类当中的方法，在测试过程中不再需要关注页面的结构，只需要关心执行的操作，这样测试用例中的代码看起来简单明了易懂</p>
<p><img src="/assets/2/image-20220515141844-l8jo9gu.png" alt="image.png"></p>
<p>具体操作就是上面优化第七点的过程，好处就是：</p>
<p>测试用例中的代码变更加精简<br>代码可读性变强<br>页面操作封装完成，进行隔离管理（也就是分层设计理念）：前端发生变化，只需要维护PO封装后的代码，如果测试数据修改了，只需要修改测试数据即可<br>PO封装的页面操作是可以重复使用的<br>PO的封装有以下原则，如果遵守的话会达到更好的效果：</p>
<p>最后两条可以不参考</p>
<p>页面封装里不应该包含断言或者测试，否则就不能做到页面操作和测试操作分离<br>唯一可以放在页面当中的测试是判断一个元素是否能找到<br>不需要封装所有的页面操作，用到什么封装什么<br>页面封装也可以使用组件方式：如导航栏，object，footer object等在多个页面重复出现的，使用组件可以增强代码复用性</p>
<p><img src="/assets/2/image-20220515141917-zduu7fa.png" alt="image.png"><br>封装方法返回self，其他po，或者基础数据结构，string，dates，不应该element对象等<br>如果同一个操作引发不同的结果，可以封装多个方法，如：login_failed，login_success<br>优化第七点：</p>
<p>就是使用PO模式进行封装代码，把页面操作的相关代码都封装到单独的类方法中，具体操作如下</p>
<p>新建page目录下login_page.py文件，代码如下：</p>
<blockquote>
<p>from selenium.webdriver.common.by import By</p>
<p>class LoginPage:<br>    def <strong>init</strong>(self, browser):<br>        self.browser &#x3D; browser</p>
<p>  def login(self, username, password):<br>        “””登录”””<br>        # 输入用户名<br>        el_user &#x3D; self.browser.find_element(By.NAME, ‘account’)<br>        el_user.clear()<br>        el_user.send_keys(username)<br>        # 输入密码<br>        el_pwd &#x3D; self.browser.find_element(By.NAME, ‘pass’)<br>        el_pwd.clear()<br>        el_pwd.send_keys(password)<br>        # 点击登录按钮<br>        self.browser.find_element(By.CSS_SELECTOR, ‘.btn-btn’).click()</p>
<p> def get_error_tips(self):<br>        “””获取错误信息”””<br>        return self.browser.find_element(By.CSS_SELECTOR, ‘.error-tips’).text</p>
</blockquote>
<p>自动化测试用例修改如下：</p>
<p><img src="/assets/2/image-20220515142021-ddrmr9b.png" alt="image.png"></p>
<p>此步还可以进一步优化，设置一个夹具，依赖browser夹具，然后测试用例就不需要初始化loginpage了，直接调用login_page夹具即可</p>
<p>修改conftest.py代码如下：</p>
<blockquote>
<p>import pytest<br>import os<br>from selenium import webdriver<br>from setting import config<br>from pages.login_page import LoginPage</p>
<p>driver &#x3D; os.path.join(config.driver_dir, ‘chromedriver_96.exe’)</p>
<p>打开浏览器</p>
<p>def get_browser():<br>    # 因为要在测试用例后执行闭关浏览器，因为不要使用with的打开方式<br>    browser &#x3D; webdriver.Chrome(executable_path&#x3D;driver)<br>    browser.implicitly_wait(5)<br>    browser.maximize_window()<br>    return browser</p>
<p>设置夹具</p>
<p>@pytest.fixture()<br>def browser():<br>    driver &#x3D; get_browser()<br>    yield driver<br>    driver.quit()</p>
<p>依赖上一个夹具（上一个夹具是这个夹具的前置条件）</p>
<p>@pytest.fixture()<br>def login_page(browser):<br>    return LoginPage(browser)</p>
</blockquote>
<p>夹具的套娃：（一个夹具可以依赖另一个夹具）</p>
<p>夹具 –&gt; 用例的依赖关系</p>
<p>夹具 –&gt; 夹具的依赖关系</p>
<p>自动化测试用例修改如下：</p>
<p><img src="/assets/2/image-20220515142154-poxodgz.png" alt="image.png"></p>
<p>这个封装的过程就是PO模式，所有的页面操作代码都不会编写在测试用例代码中，而是放在一个类中独立管理</p>
<p>优化第四点：</p>
<p>url也放到login_page.py文件中，增加一个加载登录页面的方法，代码如下</p>
<blockquote>
<p>from selenium.webdriver.common.by import By<br>from setting import config</p>
<p>class LoginPage:<br>        url &#x3D; config.host + ‘User&#x2F;login.html’</p>
<pre><code>    def __init__(self, browser):
        self.browser = browser

def load(self):
        &quot;&quot;&quot;加载页面&quot;&quot;&quot;
        self.browser.get(self.url)

def login(self, username, password):
        &quot;&quot;&quot;登录&quot;&quot;&quot;
        # 输入用户名
        el_user = self.browser.find_element(By.NAME, &#39;account&#39;)
        el_user.clear()
        el_user.send_keys(username)
        # 输入密码
        el_pwd = self.browser.find_element(By.NAME, &#39;pass&#39;)
        el_pwd.clear()
        el_pwd.send_keys(password)
        # 点击登录按钮
        self.browser.find_element(By.CSS_SELECTOR, &#39;.btn-btn&#39;).click()

def get_error_tips(self):
        &quot;&quot;&quot;获取错误信息&quot;&quot;&quot;
        return self.browser.find_element(By.CSS_SELECTOR, &#39;.error-tips&#39;).text
</code></pre>
</blockquote>
<p>自动化测试用例修改如下：</p>
<blockquote>
<p>from data.login_data import login_fail</p>
<p>class TestSignIn:<br>    def test_sing_in_01(self, login_page):<br>        # 数据<br>        username &#x3D; login_fail[‘username’]<br>        password &#x3D; login_fail[‘password’]<br>        expected &#x3D; login_fail[‘expected’]<br>        # 获取实际结果<br>        login_page.load()<br>        login_page.login(username, password)<br>        actual &#x3D; login_page.get_error_tips()<br>        # 断言<br>        assert expected &#x3D;&#x3D; actual</p>
</blockquote>
<p>调用过程图如下：</p>
<p><img src="/assets/2/image-20220515142403-zflcdq6.png" alt="image.png"></p>
<p>剩下还没优化的点，在之后的文章中会详细介绍，此篇就介绍到这里</p>
<p>4.4测试报告<br>获取当前系统时间戳来生成测试报告名+时间戳来存储测试报告，具体代码如下：</p>
<blockquote>
<p>import pytest<br>import datetime</p>
<p>获取当前时间戳</p>
<p>ts &#x3D; datetime.datetime.now().strftime(‘%Y-%m-%d-%H-%M-%S’)</p>
<p>路径拼接</p>
<p>filename &#x3D; f’reports&#x2F;report-{ts}.html’</p>
<p>收集并执行用例（注意加上[]）</p>
<p>pytest.main([f’–html&#x3D;{filename}’])<br><br /></p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>UI自动化理论</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>一、原理<br>1、什么是UI自动化测试<br>使用工具或者脚本对需要测试的软件的前端界面在预设的条件下和已经的测试数据下运行系统或者应用程序，并获取其前端页面显示的数据结果进行校验，评估得出测试结论。</p>
<p>2、UI自动化测试可用于哪里<br>基于测试渠道可分为：手机App、Pc web端、手机Web端等；</p>
<p>基于测试阶段可分为：冒烟测试、回归测试、生产验收、兼容性测试</p>
<p>3、为什么要使用UI自动化测试<br>（1）目前测试案例数量过多导致人工执行测试案例耗时过长，并且会出现无法执行完该执行的测试案例导致版本无法按预期上线；</p>
<p>（2）案例的步骤繁琐，场景复杂，制作测试数据的过程复杂，导致人工执行时间过长；</p>
<p>（3）需求简单，无前端功能开发的需求可以使用UI自动化进行测试并得出结论；</p>
<p>（4）可以帮助开发人员进行自测。</p>
<p>4、哪些测试可以执行UI自动化<br>（1）已经比较成熟的项目，暂无任何大的改动需求的项目；</p>
<p>（2）人工执行耗时长，流程繁琐的项目；</p>
<p>（3）单纯的数据校验，列表功能校验；</p>
<p>5、怎么执行自动化测试<br>（1）开发提测前自用，配置环境和工具，下载脚本执行，可通过测试报告查看执行情况和结果；</p>
<p>（2）冒烟测试中，测试在开发提测后执行，通过测试报告查看执行情况和测试结果；</p>
<p>（3）回归测试中，测试人员执行执行纳入回归测试的测试脚本并执行</p>
<p>（4）生产验收，UI自动化测试脚本可用于生产验收中，无须手动操作就可验证生产的情况。</p>
<p>6、UI自动化测试的利与弊<br>利处：快捷、方便、无须手工操作</p>
<p>弊端：脚本编写成本高、案例开发时间长、需要长期维护</p>
<p>二、总结<br>UI自动化应用于项目组的所负责的系统需求较多，测试案例数量也较多，测试场景复杂，测试数据制作复杂，并且有部分系统已经趋于成熟。</p>
<p>UI自动化测试其实是一门【水】很深的工作，因为UI自动化测试是需要根据前端页面元素，也就是HTML脚本来进行元素提取、操作、验证的测试流程，另外再加上项目的测试环境软件硬件的因素，在编写自动化测试脚本的时候需要考虑到很多的情况出现而要去判断当前页面出现的元素到底是什么情况，不然脚本的稳定性很不好，维护工作也会非常的高。另外在编写自动化脚本的时候，你会慢慢的熟悉你项目系统前端页面的代码，当下很多前端开发人员在制作新的项目前端页面时都会直接用现成的组件生成，这种HTML代码会使你开发脚本时难上加难，因为里面的标签命名根本就是乱来的。</p>
<p>三、自动化框架<br>搭建测试框架，框架目录解析</p>
<p><img src="/assets/2/image-20220510223500-pv7tycu.png" alt="image.png"></p>
<h2 id="config-配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini"><a href="#config-配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini" class="headerlink" title="config : 配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini"></a>config : 配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini</h2><p><strong>ini文件介绍</strong></p>
<p>以[section]开始</p>
<p>以[option&#x3D;value]结尾</p>
<p>备注以；开头</p>
<p>section不可重名</p>
<p><strong>yaml文件介绍</strong></p>
<p>以—开头，表明文件的开始</p>
<p>列表中的所有成员都开始于相同的缩进级别，并且使用一个“-”作为开头（一个横杠和一个空格）</p>
<p>一个字典是由一个简单的键：值的形式（这个冒号后面必须是一个空格）</p>
<p><strong>ini读取文件封装,yaml读取文件封装</strong></p>
<p><strong>configutil.py</strong></p>
<pre><code class="text">import configparser
import os
import yaml
class ReadIni():
    def read_ini(file, section, option):
        conf = configparser.ConfigParser()
        conf.read(file)
        res=conf.get(section, option)
        print(res)
        return res


class ReafYaml():
    def read_yaml(file,key):
        f=open(file,encoding=&#39;utf-8&#39;)
        file_data =f.read()
        res=yaml.load(file_data,Loader=yaml.FullLoader)
        print(res.get(key))
        return res.get(key)

if __name__ == &#39;__main__&#39;:
    current_path = os.path.dirname(os.path.realpath(__file__))
    config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;
    yaml_file = os.path.join(config_path, &#39;test.yaml&#39;)
    ReafYaml.read_yaml(yaml_file, &#39;username&#39;)
</code></pre>
<h2 id="data-数据文件，将测试用例参数化相关的文件放在这里，xlsx-csv-json"><a href="#data-数据文件，将测试用例参数化相关的文件放在这里，xlsx-csv-json" class="headerlink" title="data : 数据文件，将测试用例参数化相关的文件放在这里，xlsx,csv,json"></a>data : 数据文件，将测试用例参数化相关的文件放在这里，xlsx,csv,json</h2><h2 id="driver-：驱动文件"><a href="#driver-：驱动文件" class="headerlink" title="driver ：驱动文件"></a>driver ：驱动文件</h2><h2 id="log-：日志文件，如test-log-error-log"><a href="#log-：日志文件，如test-log-error-log" class="headerlink" title="log ：日志文件，如test log,error log"></a>log ：日志文件，如test log,error log</h2><h2 id="report-：测试报告"><a href="#report-：测试报告" class="headerlink" title="report ：测试报告"></a>report ：测试报告</h2><h2 id="test-：测试文件"><a href="#test-：测试文件" class="headerlink" title="test ：测试文件"></a>test ：测试文件</h2><p>case-测试用例</p>
<p><strong>test.py</strong></p>
<pre><code class="text">import unittest
from selenium import webdriver
from test.locators import *
from utils.configutil import ReadIni,ReafYaml
from test.page import *
from utils.excelutil import *
from selenium.webdriver.common.action_chains import ActionChains
import yaml
import os
from utils.logutil import *

current_path = os.path.dirname(os.path.realpath(__file__))
config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;
ini_file = os.path.join(config_path, &#39;test.ini&#39;)
ip = ReadIni.read_ini(ini_file, &#39;ip_address&#39;, &#39;ip&#39;)
# print(ip)
url = &#39;&#123;&#125;user/login?redirect=http%3A%2F%2Fmis-next.aunbox.ce%2FuserDetail&#39;.format(ip)
excel_file = os.path.join(os.path.dirname(current_path) + os.sep + &quot;data&quot;, &#39;case.xlsx&#39;)
username = ReadExcel.read_excel(excel_file,&#39;Sheet1&#39;,&#39;A&#39;)

class LoginTest(unittest.TestCase):
    def setUp(self):
        self.driver = webdriver.Chrome()
        self.driver.maximize_window()
        self.driver.implicitly_wait(10)
        self.driver.get(url)

    def test_login(self):
        Logger(&#39;C:\\Users\\Administrator\\PycharmProjects\\yunding\\log\\test.log&#39;,&#39;info&#39;).info(&#39;add project&#39;)
        for user in username:
            loginpage=LoginPage(self.driver)
            loginpage.enter_username(user)
            loginpage.enter_password()
            loginpage.click_login_button()
            self.assertEqual(&#39;超级管理员&#39;,loginpage.get_login_name())
            quitlogin=self.driver.find_element_by_xpath(&#39;//*[@id=&quot;root&quot;]/section/section/header/div[2]/span&#39;)
            ActionChains(self.driver).move_to_element(quitlogin).perform()
            self.driver.find_element_by_class_name(&#39;ant-dropdown-menu-item&#39;).click()
            self.driver.get(url)
        # self.driver.find_element(*LoginLocators.username).send_keys(&quot;&#123;&#125;&quot;.format(user))
        # self.driver.find_element(*LoginLocators.password).send_keys(&quot;&#123;&#125;&quot;.format(pad))
        # self.driver.find_element(*LoginLocators.loginbutton).click()
        # id=self.driver.find_element(*LoginLocators.loginname)
        # self.assertEqual(&#39;超级管理员&#39;,id.text)

    def tearDown(self):
        self.driver.quit()

if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<p>common-测试相关的抽象通用代码</p>
<p>page-页面类</p>
<p>元素定位</p>
<p><strong>locators.py</strong></p>
<pre><code class="text">from selenium.webdriver.common.by import By

# 页面元素
class LoginLocators():
    username=(By.ID,&#39;account&#39;)
    password=(By.ID,&#39;password&#39;)
    loginbutton=(By.CLASS_NAME,&#39;ant-btn&#39;)
    loginname=(By.CLASS_NAME,&#39;userName___fQOhV&#39;)
</code></pre>
<p>元素操作</p>
<p><strong>page.py</strong></p>
<pre><code class="text">from test.locators import *

# 页面元素的操作
class BasePage():
    def __init__(self,driver):
        self.driver = driver

class LoginPage(BasePage):
    &#39;&#39;&#39;
    用户登录页面元素的操作,,,到这里消失
    &#39;&#39;&#39;
    UserName = (By.XPATH,&#39;//*[@id=&quot;username&quot;]&#39;) #登录名
    def enter_username(self,name):
        ele = self.driver.find_element(*LoginLocators.username)
        # ele.clear()
        ele.send_keys(name)  #对用户名元素进行输入

    def enter_password(self):
        ele = self.driver.find_element(*LoginLocators.password)
        ele.send_keys(&#39;123456&#39;) #输入密码

    def click_login_button(self):
        ele = self.driver.find_element(*LoginLocators.loginbutton)
        ele.click()  #点击登录按钮

    def get_login_name(self):
        ele = self.driver.find_element(*LoginLocators.loginname)
        return ele.text  #返回登录名
</code></pre>
<h2 id="utils-：公共方法"><a href="#utils-：公共方法" class="headerlink" title="utils ：公共方法"></a>utils ：公共方法</h2><p>config的类</p>
<p>log的类</p>
<p><strong>logutil.py</strong></p>
<pre><code class="text">import logging
from logging import handlers

class Logger(object):
    level_relations = &#123;
        &#39;debug&#39;:logging.DEBUG,
        &#39;info&#39;:logging.INFO,
        &#39;warning&#39;:logging.WARNING,
        &#39;error&#39;:logging.ERROR,
        &#39;critical&#39;:logging.CRITICAL
    &#125;

    def __init__(self,fp=&#39;d:\\Project_Redmine_01\\log\\test.log&#39;,level=&#39;info&#39;):
        self.level = self.level_relations.get(level)
        self.logger = logging.getLogger(fp)
        self.logger.setLevel(self.level)
        formatter = logging.Formatter(&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;)
        th = handlers.TimedRotatingFileHandler(fp)
        th.setFormatter(formatter)
        th.setLevel(self.level)
        self.logger.addHandler(th)

    def debug(self,msg):
        self.logger.debug(msg)

    def info(self,msg):
        self.logger.info(msg)

    def warning(self,msg):
        self.logger.warning(msg)

    def error(self,msg):
        self.logger.error(msg)

    def critical(self,msg):
        self.logger.critical(msg)

if __name__ == &#39;__main__&#39;:
    log = Logger(&#39;abcd.log&#39;,&#39;debug&#39;)
    log.info(&#39;this is info msg&#39;)
    log.critical(&#39;this is critical msg&#39;)
</code></pre>
<p>读，写excel的类</p>
<p><strong>excelutil.py</strong></p>
<pre><code class="text">import configparser
import os
import yaml
class ReadIni():
    def read_ini(file, section, option):
        conf = configparser.ConfigParser()
        conf.read(file)
        res=conf.get(section, option)
        print(res)
        return res
class ReafYaml():
    def read_yaml(file,key):
        f=open(file,encoding=&#39;utf-8&#39;)
        file_data =f.read()
        res=yaml.load(file_data,Loader=yaml.FullLoader)
        print(res.get(key))
        return res.get(key)


if __name__ == &#39;__main__&#39;:
    current_path = os.path.dirname(os.path.realpath(__file__))
    config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;
    yaml_file = os.path.join(config_path, &#39;test.yaml&#39;)
    ReafYaml.read_yaml(yaml_file, &#39;username&#39;)
</code></pre>
<p>生成报告的类</p>
<p><strong>run.py</strong></p>
<pre><code class="text">import os
import time
import unittest
import HTMLTestRunner
current_path = os.path.dirname(os.path.realpath(__file__))
# print(current_path)
report_path = os.path.join(current_path,&#39;report&#39;)
# print(report_path)
case_path = os.path.join(current_path,&#39;test&#39;)
# print(case_path)
report_name = time.strftime(&#39;%Y%m%d%H%M%S&#39;,time.localtime((time.time())))

testsuite = unittest.TestLoader().discover(case_path)
filename = &quot;&#123;&#125;\\&#123;&#125;.html&quot;.format(report_path,report_name)
f = open(filename,&#39;wb&#39;)
runner = HTMLTestRunner.HTMLTestRunner(stream=f,title=&#39;report&#39;,description=&#39;this is a report&#39;)
runner.run(testsuite)
f.close()
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础练习</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>一. 数据类型</p>
<ol>
<li>数据类型实战<ol>
<li>示例1：存在一个变量number &#x3D;1 ，如果需要输出格式为“001”应如何实现？<ol start="4">
<li><blockquote>
<p>number &#x3D;1<br>print(“03d” %number)</p>
</blockquote>
</li>
<li>上面的实例中，变量number的数据类型是数值型，如果需要格式化字符串输出，则需要使用%d,相当于使用%d替换number变量的真实值1,即如果表达式是”%d”%number,那么结果实际是输出1;而题目要求输出格式是001，则需要在1前面添加两个0，所以此时可以通过使用03d表示输出3位数值型;如果真实数值只有1位，则会在高位自动补0输出，所以结果可以得到001。</li>
<li>注意：<br> 此处有同学可能会想可不可直接使用pit(0O1)?若采用这种方式输出，终端会提示“不允许十进制<br> 整数前添加0：八进制整型文字前可以使用0作为前缀”。</li>
</ol>
</li>
<li>示例2：存在一个变量number1&#x3D;1.222222,如果需要保留两位小数应如何实现？<ol>
<li><blockquote>
<p>print (“8.2f”Snumber1)</p>
</blockquote>
</li>
<li>上面的示例与示例1类似，示例1主要是对整数的处理，示例2主要是对小数的处理。小数的格式化输出需要使用%f,结合示例1综合分析可知保留两位小数表示为%.2f。</li>
</ol>
</li>
<li>示例3：存在一个变量number2&#x3D;1,如果需要输出“%d1”应如何实现？<ol>
<li><blockquote>
<p>print(“%%d%d”%number2)</p>
</blockquote>
</li>
<li>示例3需要输出“%d”字符串，在字符串格式化输出中%d表示整型占位符，如果需要以字符串的形式输出，则需要在%d前面添加%进行转义。所以上述代码中%%d表示输出“%d”字符串，第二个%d表示number2的占位符，即可得到结果“%d1”。</li>
</ol>
</li>
</ol>
</li>
<li>字符串主流机制问题<ol>
<li>在Python中会出现字符串驻留(intern)的情况，这是由于CPython的优化产生的，即在某些情况下尝试使用现有的不可变对象，而不是每次都创建一个新对象，这些驻留的对象在内部使用类似字典的结构（驻留池）进行驻留。在被驻留之后，许多变量可能指向内存中的相同字符串对象，从而节省内存。简单来说，字符串驻留表示一种方法，能够实现仅仅存储一份相同而又不可变的字符串。字符串存储的非驻留机制与驻留机制如图1.1所示。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>APP自动化</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_APP%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[<p>APP自动化</p>
<h2 id="什么是App自动化？为什么要做App自动化？"><a href="#什么是App自动化？为什么要做App自动化？" class="headerlink" title="什么是App自动化？为什么要做App自动化？"></a>什么是App自动化？为什么要做App自动化？</h2><p>App自动化是指给 Android或iOS上的软件应用程序做的自动化测试。<br><strong>手工测试和自动化测试的对比如下：</strong><br> <strong>手工测试优势：</strong> 不可替代、发现更多bug、包含了人的想象力与理解力。</p>
<blockquote>
<p>注意，不是所有功能都需要自动化。<br> <strong>自动化测试优势：</strong> 可重复、效率高，增加软件信任度。<br>执行自动化测试可以让测试同事有更多的精力来关注复杂场景，做更多更深层次的测试。</p>
</blockquote>
<h2 id="风险分析"><a href="#风险分析" class="headerlink" title="风险分析"></a><strong>风险分析</strong></h2><p><strong>自动化测试的主要风险分析如下：</strong><br>（1）测试用例覆盖率（覆盖率决定测试效率，选择合适用例，应约占功能用例集的20%~50%）<br>（2）测试结果准确度（准确度决定了测试有效性，应尽可能减少误报）。<br>（3）自动化代码维护（维护决定了成本，数据关键字驱动自动化框架，代码应尽可能优化和少改动）。<br>（4）版本开发和测试时间进度（当项目需求和功能较为稳定时，建议用自动化）。<br>（5）开发对控件元素增修改的程度（需开发人员尽可能地用name元素，并且和UI设计一致，修改变动程度不大，测试人员可根据提供的元素提前介入，开发自动化脚本）。<br>App源码权限控制，iOS上测试需要源码。实际测试只需SVN或者git下载权限，而不需要上传权限。防止改动SVN或者git 上的源码。</p>
<hr>
<h2 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a><strong>技术框架</strong></h2><p><strong>1、自动化学习过程</strong><br>自动化测试环境的部署–&gt;自动化测试脚本开发能力—&gt;自动化测试框架研发—&gt;手机自动化持续集成<br><strong>2、andorid 系统架构图</strong><br><img src="/assets/1/image-20211205190326-wan8a0k.png" alt="image.png"><br><strong>3、手机自动化测试环境</strong><br>安装Appium–&gt;安装手机模拟器–&gt;安装selenium和appium的客户端–&gt;安装被测试app<br><strong>4、</strong> <strong>Appium 软件架构</strong><br><img src="/assets/1/image-20211205190332-te9euht.png" alt="image.png"><br>5、<strong>常用的定位技术和工具</strong><br><img src="/assets/1/image-20211205190339-t5x1z1g.png" alt="image.png"><br><strong>6、自动化测试脚本技术</strong><br><img src="/assets/1/image-20211205190345-dv6lxzo.png" alt="image.png"><br><strong>7、技术框架结构图</strong><br><img src="/assets/1/image-20211205190351-9b4ojeg.png" alt="image.png"></p>
<hr>
<h2 id="APP自动化测试流程"><a href="#APP自动化测试流程" class="headerlink" title="APP自动化测试流程"></a><strong>APP自动化测试流程</strong></h2><p><strong>1、环境的安装</strong><br><strong>1.1 环境的准备</strong></p>
<ul>
<li>jdk1.6以上</li>
<li>python2.7以上</li>
<li>android-sdk</li>
<li>Appium desktop 安装</li>
</ul>
<p><strong>1.2 jdk 安装</strong></p>
<ul>
<li>下载JDK后傻瓜式安装，<strong>注意：不要有中文路径和空格</strong></li>
<li><strong>配置环境变量：</strong></li>
</ul>
<p><strong>右击“我的电脑”–&gt;”属性”–&gt;”高级系统设置”–&gt;”高级”–&gt;”环境变量”</strong></p>
<ol>
<li>在系统变量里新建”JAVA_HOME”变量，变量值为：C:\Program Files\Java\jdk1.8.0_60（根据自己的jdk的安装路径填写）</li>
<li>在系统变量里新建”classpath”变量，变量值为：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar <strong>(注意最前面有一点)</strong></li>
<li>找到path变量（已存在不用新建）添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</li>
</ol>
<p><strong>1.3 python 安装</strong></p>
<ol>
<li><strong>傻瓜式安装</strong> ，</li>
<li><strong>配置环境变量</strong> ：电脑属性系统变量添加python根目录</li>
</ol>
<p><strong>1.4 安装Android的测试开发环境</strong></p>
<ol>
<li><strong>Android-SDK的安装：</strong> SDK manager.exe 双击打开下载<br><img src="/assets/1/image-20211205190359-2l4539b.png" alt="image.png"></li>
</ol>
<p><strong>2.android-sdk环境变量的配置</strong><br>具体操作步骤：</p>
<ul>
<li><strong>新建ANDROID_HOME</strong><br>路径为C:\Program Files (x86)\Android\android-sdk\</li>
<li><strong>在Path 变量中加入路径</strong><br>%ANDROID_HOME%\platform-tools 和 %ANDROID_HOME%\tools</li>
</ul>
<p><strong>3.检查adb 环境变量</strong><br><img src="/assets/1/image-20211205190406-lp0oe3n.png" alt="image.png"><br><strong>4.连接手机</strong><br>如果是真机，手机插上USB连接电脑，打开开发者模式，cmd输入adb devices<br>如果是模拟器，需要输入adb connect 127.0.0.1:62001或者52001连接，然后再输入adb devices<br><strong>Appium desktop 安装</strong><br>下载地址：<a href="https://github.com/appium/appium-desktop/releases/tag/v1.3.1">https://github.com/appium/appium-desktop/releases/tag/v1.3.1</a><br>傻瓜式安装 注意：一定要选择所有用户权限要不然用不了<strong>UiAutomator2</strong><br><strong>2、 API脚本</strong><br><strong>2.1 如何获取APP启动的AppPackage和AppActivity</strong></p>
<ol>
<li><strong>通过appt获取切换到aapt所在的目录，执行aapt dump</strong> （aapt是sdk自带的一个工具，在sdk\builds-tools\目录下）使用命令aapt dump badging “D:\ jinritoutiao_7500.apk”运行后的结果中以下两行分别是应用包名package和入口activity名称<br>package: name&#x3D;’ com.ss.android.article.news’<br>launchable-activity: name&#x3D;‘com.ss.android.article.news.activity.LaunchActivity’</li>
</ol>
<p>**2. 通过 adb shell am start **com.ss.android.article.news&#x2F;com.ss.android.article.news.activity.MainActivity<br>来判断启动的app 是否正确<br><strong>2.2 启动appium</strong><br><img src="/assets/1/image-20211205190411-bss5xmz.png" alt="image.png"><br><img src="/assets/1/image-20211205190416-w001ahq.png" alt="image.png"><br><strong>2.3 写脚本</strong><br> <strong>1.platformName：</strong> 这里是 android 的 apk<br> <strong>2.deviceName：</strong> 手机设备名称，通过 adb devices 查看<br> <strong>3.platformVersion：</strong> android 系统的版本号<br> <strong>4.appPackage：</strong> apk 包名<br> <strong>5.appActivity：</strong> apk 的 launcherActivity<br><img src="/assets/1/image-20211205190422-d8tyhef.png" alt="image.png"><br><strong>2.4生成测试报告</strong><br><img src="/assets/1/image-20211205190433-n8seppi.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>接口自动化</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[<ol>
<li>自动化测试具体怎么做的（流程怎么样的？）<ol>
<li>？？？？？<ol>
<li>用什么做的？</li>
<li>需要注意什么？核心关键是什么？</li>
<li>具体步骤是怎样的？</li>
</ol>
</li>
<li>接口自动化这块，我们当时用的 python+requests 库来写脚本的，例外，也会用到其他的一些库像ddt,unittest,xlrd,json,re,pymysql,htmlreport 等另外的话，我觉得做接口自动化，最关键的还是’用例数据的准备’，’请求数据的组装’，’及请求发送’， 和对’响应数据的提取处理’，与’判断校验&#x2F;做断言’。当然要做自动化，首先就是要搭建好自动化测试环境，之后就准备好用例数据嘛，像用例数据这块的话，公司统一要求用 excel 表格来管理的，这里面主要就是用例标题，url,请求方式，请求头，请求参数，用来做断言的响应数据。其实主要目的就是起到数据与脚本的分离方便后期的管理。数据准备好了之后，然后就开始写脚本，首先把相关的包导入进来，之后调用封装好的函数来读取excel表格中的用例数据，数据返回出来是一个列表形式。然后就是定义个类，去继承unittest.TestCase 基类,并重写其中 setUp,tearDown方法，在setUp方法中主要就是做一些初始化的准备工作，tearDown 中主要完成一些回收工作，比如，像连接数据库可以放在setUp方法中，在 tearDown 方法关闭数据库的连接然后实现用例函数，用例函数必须要以 test开头，这里的话，用例函数中主要就是实现请求数据的组装，还有就是调用 requests库中的get或 post方法发请求，把相关的参数传进去，请求参数这块我们需要用到 ddt 模型，去引用前面提取出来的 list 中的额数据这边请求发送之后会返回一个响应对象，这里面接下来其实最主要的就是对响应对象中的数据进行提取处理，并判断校验并做断言。断言这块这一块的话，主要就是关注几个点，一个就是状态码，还有就是响应信息，不过，这里面最重要的是响应的正文内容的判断。主要就是判断这几个块与结构文档是否一致。对于响应的正文内容，可能会比较麻烦一点，因为一般后台会返回两种格式的数据，一种是 json 格式的数据，其实对于 json 格式的数据我们需要把它转化为字典形式，治理其实主要就是调用response.json()函数就已经转为字典，然后去提取其中的一些核心信息去做断言判断就可以了。例外，如果返回的是 html 格式的数据，我们需要用到一个 re 库，并调用其中的一个函数 findall 结合正则表达式提取关键信息做断言判断。断言的一些函数，其实都是调用 unittest 框架中的函数实现,像assertEqual，assertIn,以及做全量对标的话，需要用到 assertListEuqal,assertDictEqual 主要就是这些。脚本这块差不多就是这么写的，最后我们需要引入一个 htmlreport 库去自动生成自动化报告，然后就是对报告进行分析，报告这一块的话，主要有通过，异常，失败几种请情况，如果如果错误的话，基本一般都是脚本问题，这个时候我们需要去重新调试我们的脚本，如果是失败的话，一般来说，我都会先检查自己的脚本是否有问题，如果没有问题基本就可以提 Bug了。接口自动化我们当时就这么做的。</li>
</ol>
</li>
<li><h3 id="request框架有哪些方法？"><a href="#request框架有哪些方法？" class="headerlink" title="request框架有哪些方法？"></a><strong>request</strong>框架有哪些方法？</h3><ol>
<li>像用来发送请求的一般都是调用以下方法<br> reponse &#x3D; requests.get()<br> reponse &#x3D; requests.post()<br> 获取响应数据一般都是调用以下方法<br> reponse.status_code<br> reponse.reason<br> reponse.text reponse.json()<br> reponse.headers<br> reponse.cookies</li>
</ol>
</li>
<li><h3 id="接口自动化用过哪些库？"><a href="#接口自动化用过哪些库？" class="headerlink" title="接口自动化用过哪些库？"></a>接口自动化用过哪些库？</h3><ol>
<li>Requests 库   这个里面主要封装了各种发送请求处理请求的方法<br> Json 库           这个库主要用来将 json 格式转化为字典，或者将字典转化为 json 格式数据<br> Re 库             这个库当时是针对后台返回的是 html 格式，用来提取html 格式中的数据的<br> Xlrd库            这个库当时主要用来读取 excel 表格数据的<br> Ddt 库           这个库主要用来实现数据驱动的<br> Pymysql库     这个库主要就是用来读取数据库，操作数据库的。差不多当时好像这些库都是有用过的吧。</li>
</ol>
</li>
<li><h3 id="如果要传递请求头如何处理？"><a href="#如果要传递请求头如何处理？" class="headerlink" title="如果要传递请求头如何处理？"></a>如果要传递请求头如何处理？</h3><ol>
<li>传递请求头，其实还是比较简单的，首先要搞清楚这个接口需要传递哪些请求求参数，然后订制一个请求头，一般都是组装成一个字典，然后在调用 post 或 get 方法发请求的时候，在这两个函数中有一个参数headers，这个参数就是用来传递请求头的，把组装好的请求头通过headers 参数进行传递就可以了。</li>
</ol>
</li>
<li><h3 id="你们做接口自动化，用例数据是怎么组织，管理的？"><a href="#你们做接口自动化，用例数据是怎么组织，管理的？" class="headerlink" title="你们做接口自动化，用例数据是怎么组织，管理的？"></a>你们做接口自动化，用例数据是怎么组织，管理的？</h3><ol>
<li>用例数据这块，当时公司要求使用 excel 表格来进行管理，其实这里主要也是为了实现数据与脚本的分离，提高整个工程后期的维护与优化，这里把数据封装到 excel 表格之后<br> 我们在脚本中通过调用封装好的读取 excel 表格的数据函数，然后利用 ddt 模型来引用这些数据组织请求参数或头，发请求。<br> 对 excel 表格中的用例数据，我们是这么组织的，会有以下几个字段像用例标题，请求地址， 请求方式，请求头，请求参数，响应结果，这个几个部分，对于请求头跟请求参数，因为<br> 脚本中发请求都是通过组装成字典的形式来发送的，所以这里我们也是通过类似于字典的形式文本格式来进行组织，主要就是方便后期脚本的提取与引用。<br> 其实我觉得，这样去处理的好处就是，后期如果用例数据有变动，或者需要增加或删除部分用例直接针对excel 表格数据进行操作就可以了，不需要改动脚本。<br> 这也就方便整个项目工程的管理与维护了。</li>
</ol>
</li>
<li><h3 id="接口自动化的用例又是怎么管理的？"><a href="#接口自动化的用例又是怎么管理的？" class="headerlink" title="接口自动化的用例又是怎么管理的？"></a>接口自动化的用例又是怎么管理的？</h3><ol>
<li>自动化用例这块，我们利用 unittest 框架来编写的，然后利用unittest 帮我们去统一加载执行用例。如果要全量执行的话， 通过调用 unittest 里面提供的 defaultTestLoader.discover()这个函数来加载test_case目录下的所有用例执行即可， 如果某条用例没有通过， 需要单独调试， 可以通过unittest.TestLoader()来创建一个加载器，加载具体的某条用例进行执行，调试即可。最后就是结合HTMLReport 这个库最终会自动帮我们生成报告。</li>
</ol>
</li>
<li><h3 id="对于返回的数据，你怎么检查校验？"><a href="#对于返回的数据，你怎么检查校验？" class="headerlink" title="对于返回的数据，你怎么检查校验？"></a>对于返回的数据，你怎么检查校验？</h3><ol>
<li>这块的话，首先我们一定得搞清楚后台返回的到底是什么格式的数据，一般都是两种情况，一种就是json格式的数据，一种就是 html格式的数据，关注几个点一般有以下几个点，1.  状态码   2.  响应信息对不对     3.也是最重要的就是响应内容，如果正文内容是 json 格式的数据，我们就使用 response.json()函数来提取就可以了，如果是正文内容 html格式的数据，我们就使用 response.text来提取，然后利用re 库中 findall函数结合正则表达式来提取核心字段进行校验。对于响应内容，我们需要根据接口文档的说明， 去检查一些核心的字段信息，去判断就行了。例外，如果有些接口需要检查数据库的话，那我们去连接数据库，查询对应数据，然后去判断校验,断言这块我当时就是这么做的。</li>
</ol>
</li>
<li><h3 id="对于接口响应数据，你是怎么做断言的？"><a href="#对于接口响应数据，你是怎么做断言的？" class="headerlink" title="对于接口响应数据，你是怎么做断言的？"></a>对于接口响应数据，你是怎么做断言的？</h3><ol>
<li>我首先确定需要检查的键是否存在，assertIn 去判断键是否存在，如果键存在，然后根据键去获取其中的值，如果值是变化的，有可能有，有可能没有，或者值本身在发生变化，这里需要读取数据库中的实际对应的字段值，然后判断返回结果中的对应字段的值与数据库中读取出来的值是否一致。</li>
</ol>
</li>
<li><h3 id="你写了多少接口自动化用例"><a href="#你写了多少接口自动化用例" class="headerlink" title="你写了多少接口自动化用例"></a>你写了多少接口自动化用例</h3><ol>
<li>自动化用例，也没有具体数过，当时我负责的所有模块的接口的自动用例都是我这边独立完成的，有模块的用例会多一点，有些会少一点，这具体看接口的参数有多少，参数多限制条件多的，一般用例会比较多一点，我负责的模块大概有 100多条用例是有的吧！</li>
</ol>
</li>
<li><h3 id="你们接口自动化用例是怎么跑的？"><a href="#你们接口自动化用例是怎么跑的？" class="headerlink" title="你们接口自动化用例是怎么跑的？"></a>你们接口自动化用例是怎么跑的？</h3><ol>
<li>一般正常我们都是全量跑的，如果要全量跑，我们一般都是加载用例目录也就是 testcase下的所有用例文件这里主要就是调用unittest.defaultTestLoader.discover(用例目录的路径，匹配规则)函数进行加载所有用例文件。有时候如果只是某个模块的用例执行不通过，需要单独执行调试某个模块的用例。这里可以先创建一个套件，调用 unittest.testsuite()来进行创建然后调用  unittest.testLoader()函数来创建一个加载器然后在加载具体某个模块的具体用例去执行调试。如果要定时全量跑所有的用例，一般我们都是在每周五下午会定时全量跑所有的用例，然后周一过来看报告分析报告，这里就需要用到持续集成，我们当时用的 jenkins，从 SVN上检出自动化脚本，然后让jenkins自动帮我们去跑。</li>
</ol>
</li>
<li><h3 id="有没有了解过数据驱动？"><a href="#有没有了解过数据驱动？" class="headerlink" title="有没有了解过数据驱动？"></a>有没有了解过数据驱动？</h3><ol>
<li>数据驱动就是把用例数据与脚本代码进行分离，把用例数据进行独立出来嘛，它的好处就在于方便后台的管理维护。这样的话，如果数据后期发生变化，只要维护修改 excel 表格中的数据就可以，比如，需要增加数据或者需要删除某条用例数据，或者修改数据就变得比较方便。<br> 对于自动化用例数据我们公司当时要求放在 Excel 表格中来管理的，然后保存在工程中的 data 目录下，之后就是通过调用封装好的函数去读取数据，然后利用 ddt 模型来实现数据的驱动，对于 ddt 模型， 它所采用的就是 python 装饰器的原理来引用数据的。<br> 例外，对于一些其他的一些常量数据，比如：文件的路径，用例的路径，邮件的配置信息，数据库的一些配置信息，我们都是通过配置文件来管理的，我们会在工程中创建一个 config目录，然后把配置文件都是放在这个目录下的。<br> 当时数据驱动这块就是这么来实现的。</li>
</ol>
</li>
<li><h3 id="有没有自己封装过函数"><a href="#有没有自己封装过函数" class="headerlink" title="有没有自己封装过函数]()?"></a><strong>有没有自己封装过函数]()</strong>?</h3><ol>
<li>也有自己封装过，但是不很多，大部分都调用公司&#x2F;老大封装好的函数来进行实现的像当时那个数据操作的相关模块这边是我封装，例外，像读取 Excel 表格数据的模块<br> 也是我这边封装，除了这个之外，还封装过一些其他函数，比如获取 cookie 值，获取手机验证码的函数等，这边都是有封装过的……</li>
<li><img src="/assets/1/image-20211203223308-nfhjajx.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211203223328-08gzxth.png" alt="image.png"></li>
</ol>
</li>
<li><h3 id="接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？"><a href="#接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？" class="headerlink" title="接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？"></a>接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？</h3><ol>
<li>报告这一块，我们当时是用那个htmlreport 这个库去生成的？首先主要关注运行结果，看有多少用例通过了，有多少执行失败，有多少执行错误。一般报告上都会详细说明，我们主要看失败用例以及错误用例，对于失败的用例跟错误的用例一般在报告上都会有详细细节说明，到底哪里执行没有通过。对于执行错误的用例，一般都是自己的脚本编写有问题，这个我一般会找到对应用例代码去调试查看。<br> 对于失败用例，我一般首先怀疑自己的脚本，先检查自己的脚本有没有问题，如果不是自己脚本问题导致的，那这就说明这条用例真的执行失败了，一般就提 BUG 就可以了。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/README/</url>
    <content><![CDATA[<h1 id="md"><a href="#md" class="headerlink" title="md"></a>md</h1><p>自己使用</p>
]]></content>
  </entry>
  <entry>
    <title>Apache环境部署</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/01_apache%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h1><h2 id="1-1-环境"><a href="#1-1-环境" class="headerlink" title="1.1 环境"></a>1.1 环境</h2><p>操作系统：centos7（CentOS-7-x86_64-Minimal-1708）</p>
<p>硬件：（这个根据项目运行和配置建议设置，一般我先配个1核1G）</p>
<h2 id="1-2-关闭selinux"><a href="#1-2-关闭selinux" class="headerlink" title="1.2 关闭selinux"></a>1.2 关闭selinux</h2><p>#修改selinux的配置文件</p>
<pre><code>vim /etc/selinux/config
</code></pre>
<p>将内容中的SELINUX&#x3D;enforcing修改为SELINUX&#x3D;disabled，wq保存。</p>
<p>#本次不重启关闭selinux</p>
<pre><code>setenforce 0
</code></pre>
<h2 id="1-3-更新"><a href="#1-3-更新" class="headerlink" title="1.3 更新"></a>1.3 更新</h2><pre><code>yum update -y
</code></pre>
<h2 id="1-4-安装vim、wget"><a href="#1-4-安装vim、wget" class="headerlink" title="1.4 安装vim、wget"></a>1.4 安装vim、wget</h2><pre><code>yum install -y vim wget    
</code></pre>
<hr>
<h1 id="二、部署apache"><a href="#二、部署apache" class="headerlink" title="二、部署apache"></a>二、部署apache</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><pre><code>yum install -y httpd
</code></pre>
<h2 id="2-2-启动服务"><a href="#2-2-启动服务" class="headerlink" title="2.2 启动服务"></a>2.2 启动服务</h2><h1 id="启动apache"><a href="#启动apache" class="headerlink" title="启动apache"></a>启动apache</h1><pre><code>systemctl start httpd
</code></pre>
<h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><pre><code>systemctl enable httpd
</code></pre>
<h2 id="2-3-查看apache版本"><a href="#2-3-查看apache版本" class="headerlink" title="2.3 查看apache版本"></a>2.3 查看apache版本</h2><pre><code>httpd -v
</code></pre>
<p><img src="/assets/1/image-20211122230737-ixxygo6.png" alt="image.png"></p>
<p> 可以看到apache安装的是2.4.6，也可以知道apache安装成功。</p>
<h2 id="2-4-开启80端口"><a href="#2-4-开启80端口" class="headerlink" title="2.4 开启80端口"></a>2.4 开启80端口</h2><h1 id="添加80端口永久开启"><a href="#添加80端口永久开启" class="headerlink" title="添加80端口永久开启"></a>添加80端口永久开启</h1><pre><code>firewall-cmd --add-port=80/tcp --permanent
</code></pre>
<h1 id="防火墙修改立即生效"><a href="#防火墙修改立即生效" class="headerlink" title="防火墙修改立即生效"></a>防火墙修改立即生效</h1><pre><code>firewall-cmd --reload
</code></pre>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<h1 id="三、部署mysql"><a href="#三、部署mysql" class="headerlink" title="三、部署mysql"></a>三、部署mysql</h1><h2 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h2><h1 id="获取rpm包"><a href="#获取rpm包" class="headerlink" title="获取rpm包"></a>获取rpm包</h1><pre><code>wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
</code></pre>
<h1 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h1><pre><code>rpm -ivh mysql-community-release-el7-5.noarch.rpm
</code></pre>
<h1 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h1><pre><code>yum install -y mysql-community-server
</code></pre>
<h2 id="3-2-启动"><a href="#3-2-启动" class="headerlink" title="3.2 启动"></a>3.2 启动</h2><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><pre><code>systemctl start mysql
</code></pre>
<h1 id="开机启动-1"><a href="#开机启动-1" class="headerlink" title="开机启动"></a>开机启动</h1><pre><code>systemctl enable mysql
</code></pre>
<h2 id="3-3-修改root密码并设置允许远程连接"><a href="#3-3-修改root密码并设置允许远程连接" class="headerlink" title="3.3 修改root密码并设置允许远程连接"></a>3.3 修改root密码并设置允许远程连接</h2><h1 id="进入mysql"><a href="#进入mysql" class="headerlink" title="进入mysql"></a>进入mysql</h1><pre><code>mysql -uroot
</code></pre>
<h1 id="设置root密码为123456"><a href="#设置root密码为123456" class="headerlink" title="设置root密码为123456"></a>设置root密码为123456</h1><pre><code>mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39; =password(&#39;123456&#39;);
</code></pre>
<h1 id="设置允许用root账户进行远程连接，并设置其密码为123456"><a href="#设置允许用root账户进行远程连接，并设置其密码为123456" class="headerlink" title="设置允许用root账户进行远程连接，并设置其密码为123456"></a>设置允许用root账户进行远程连接，并设置其密码为123456</h1><pre><code>mysql&gt; grant all privileges on *.* to root@&#39;%&#39;identified by &#39;123456&#39;;
</code></pre>
<h1 id="修改的配置立即生效"><a href="#修改的配置立即生效" class="headerlink" title="修改的配置立即生效"></a>修改的配置立即生效</h1><pre><code>mysql&gt; flush privileges;
</code></pre>
<h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><pre><code>mysql&gt; exit;
</code></pre>
<h2 id="3-4-查看mysql版本"><a href="#3-4-查看mysql版本" class="headerlink" title="3.4 查看mysql版本"></a>3.4 查看mysql版本</h2><pre><code>mysql -V
</code></pre>
<p><img src="/assets/1/image-20211122230745-87is6zt.png" alt="image.png"></p>
<hr>
<h1 id="四、部署php"><a href="#四、部署php" class="headerlink" title="四、部署php"></a>四、部署php</h1><h2 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h2><pre><code>yum install -y php
</code></pre>
<h2 id="4-2-安装组件是php支持mysql"><a href="#4-2-安装组件是php支持mysql" class="headerlink" title="4.2 安装组件是php支持mysql"></a>4.2 安装组件是php支持mysql</h2><pre><code>yum install -y php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash
</code></pre>
<h2 id="4-3-查看php版本"><a href="#4-3-查看php版本" class="headerlink" title="4.3 查看php版本"></a>4.3 查看php版本</h2><pre><code>php --version
</code></pre>
<p><img src="/assets/1/image-20211122230751-hh1f83z.png" alt="image.png"></p>
<h2 id="4-4-查看详细信息"><a href="#4-4-查看详细信息" class="headerlink" title="4.4 查看详细信息"></a>4.4 查看详细信息</h2><h1 id="新增文件phpmess-php"><a href="#新增文件phpmess-php" class="headerlink" title="新增文件phpmess.php"></a>新增文件phpmess.php</h1><pre><code>vim /var/www/html/phpmess.php
</code></pre>
<p> 增加下面的内容，wq保存。</p>
<pre><code>&lt;?php
    phpinfo();
</code></pre>
<p>浏览器访问ip&#x2F;phpmess.php查看，出现类似下面的内容就说明php安装是成功的。</p>
<p><img src="/assets/1/image-20211122230756-t0j1bii.png" alt="image.png"></p>
<h2 id="4-5-安全其他版本PHP"><a href="#4-5-安全其他版本PHP" class="headerlink" title="4.5 安全其他版本PHP"></a>4.5 安全其他版本PHP</h2><p>卸载原来低版本的PHP</p>
<pre><code>rpm -qa |grep php|xargs rpm -e
</code></pre>
<p>更新yum源</p>
<p>&#x2F;&#x2F;CentOS&#x2F;RHEL 7.x<br>rpm -Uvh <a href="https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm">https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</a><br>rpm -Uvh <a href="http://rpms.famillecollet.com/enterprise/remi-release-7.rpm">http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</a></p>
<p>查看可使用的php包</p>
<pre><code>yum list | grep php
</code></pre>
<p>安装PHP常用模块</p>
<p>yum -y install php72-php php72-php-common php72-php-devel php72-php-gd php72-php-mysqlnd php72-php-pecl-mysql php72-php-pecl-memcached php72-php-pecl-memcache php72-php-pecl-redis php72-php-opcache</p>
<p>&#x2F;&#x2F;装好后看一下装了哪些包<br>yum list installed |grep php</p>
<p>&#x2F;&#x2F;最后重启下httpd<br>systemctl restart httpd<br><img src="/assets/1/image-20211122230802-4mgxljy.png" alt="image.png"></p>
<h2 id="5-更改Apache网站默认目录"><a href="#5-更改Apache网站默认目录" class="headerlink" title="5.更改Apache网站默认目录"></a>5.更改Apache网站默认目录</h2><p>Apache默认的网站目录是在&#x2F;var&#x2F;www&#x2F;html，</p>
<p>现在要把网站目录更改到&#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs，</p>
<p>操作如下<br><strong>准备工作：</strong><br>创建目录：<br>cd &#x2F;home<br>mkdir wwwroot<br>cd wwwroot<br>mkdir web1<br>cd web1<br>mkdir htdocs<br>touch index.php<br><strong>操作步骤：</strong><br>1、vi &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf<br>找到 DocumentRoot “&#x2F;var&#x2F;www&#x2F;html” 这一段     #apache的根目录<br>把&#x2F;var&#x2F;www&#x2F;html 这个目录改为&#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs<br>再找到 &lt;Directory “&#x2F;var&#x2F;www&#x2F;html”&gt;   #定义apache &#x2F;var&#x2F;www&#x2F;html这个区域<br>把 &#x2F;var&#x2F;www&#x2F;html改成&#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs<br>这样我们就把apahce的默认路径改掉了<br>service httpd restart  #重启Apache服务器<br>2、访问localhost的时候，会发现访问拒绝，这是为什么呢？<br>系统运维 <a href="http://www.osyunwei.com/">www.osyunwei.com</a> 温馨提醒：qihang01原创内容©版权所有,转载请注明出处及原文链接<br>主要是因为你的&#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs的权限是750，apache这个用户没有权限访问，你需要更改掉权限，可以这样改<br>chmod -R 755 &#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs<br>然后去访问 发现正常运行了（apache的用户：apache 运行apache的组：apache）<br> <strong>至此，</strong> <strong>Apache****默认网站目录更改成功。</strong></p>
<h2 id="6-绑定域名"><a href="#6-绑定域名" class="headerlink" title="6.绑定域名"></a>6.绑定域名</h2><p>vi &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf　　更改配置文件</p>
<p><img src="/assets/1/image-20211122230808-8zh112f.png" alt="image.png"></p>
<p> 在配置文件最后加入如下</p>
<h1 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h1><p>&lt;VirtualHost *:80&gt;<br>DocumentRoot “&#x2F;www&#x2F;dz&#x2F;“<br>ServerName dz.m616.top<br></VirtualHost></p>
<p><img src="/assets/1/image-20211122230814-l1ybpb2.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>15_环境部署_持续集成</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat环境部署</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/02_Tomcat%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="yum方式安装JDK"><a href="#yum方式安装JDK" class="headerlink" title="yum方式安装JDK"></a>yum方式安装JDK</h2><p>“*”表示将java-1.8.0的所有相关Java程序都安装上（是不是很方便快捷）</p>
<pre><code>[root@test ~]# yum -y install java-1.8.0-openjdk*
</code></pre>
<p>查看是否安装成功java -version（出现版本号代表安装成功）</p>
<pre><code>[root@test ~]# java -version
openjdk version &quot;1.8.0_212&quot;
OpenJDK Runtime Environment (build 1.8.0_212-b04)
OpenJDK 64-Bit Server VM (build 25.212-b04, mixed mode)
</code></pre>
<h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><p>1.将tomcat安装在usr&#x2F;lcoal下一般软件安装处</p>
<p>将入其文件夹</p>
<p>[root@test ~]# cd &#x2F;usr&#x2F;local</p>
<p>2.去tomcat官网复制你想下载的版本下载链接。注意一定要选择tar.gz这是liunx下的安装包，比如链接：<a href="https://links.jianshu.com/go?to=http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.19/bin/apache-tomcat-9.0.19.tar.gz">http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.19/bin/apache-tomcat-9.0.19.tar.gz</a></p>
<p><img src="/assets/1/image-20211125152847-ggl37xb.png" alt="image.png"></p>
<p>在这里插入图片描述</p>
<p>3.wget命令下载安装包</p>
<blockquote>
<ol>
<li>[root@test ~]# wget <a href="http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.62/bin/apache-tomcat-9.0.62.tar.gz">http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.62/bin/apache-tomcat-9.0.62.tar.gz</a></li>
</ol>
</blockquote>
<p>4.查看</p>
<pre><code>[root@instance-wi0t3arq local]# ls
</code></pre>
<p><img src="/assets/1/image-20211125152852-2lujja3.png" alt="image.png"></p>
<p>在这里插入图片描述</p>
<p>5.解压</p>
<p>个人习惯喜欢把安装包改一下名字</p>
<blockquote>
<p>[root@instance-wi0t3arq local]# mv apache-tomcat-9.0.19.tar.gz tomcats<br>[root@instance-wi0t3arq local]# tar -zxvf tomcats<br>[root@instance-wi0t3arq local]# mv apache-tomcat-9.0.19  tomcat</p>
</blockquote>
<p>6.查看是否安装成功</p>
<p>进入tomcat bin目录启动Tomcat（显示Tomcat started.则启动成功）</p>
<pre><code>[root@instance-wi0t3arq local]# cd tomcat
[root@instance-wi0t3arq tomcat]# cd bin
[root@instance-wi0t3arq bin]# ./startup.sh
Using CATALINA_BASE:   /usr/local/tomcat
Using CATALINA_HOME:   /usr/local/tomcat
Using CATALINA_TMPDIR: /usr/local/tomcat/temp
Using JRE_HOME:        /usr
Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar
Tomcat started.
</code></pre>
<p>用curl命令测试本地能不能访问8080端口</p>
<pre><code>[root@instance-wi0t3arq bin]# curl http://localhost:8080
</code></pre>
<p>出现页面代码表示tomcat安装成功</p>
<p><img src="/assets/1/image-20211125152856-tpa141d.png" alt="image.png"></p>
<p>在这里插入图片描述</p>
<hr>
<p>如果curl <a href="http://localhost:8080出现未知错误：需修改配置文件">http://localhost:8080出现未知错误：需修改配置文件</a>  操作如下：</p>
<p>[root@instance-wi0t3arq bin]#  cd ..</p>
<p>[root@instance-wi0t3arq tomcat]#  cd conf</p>
<p>[root@instance-wi0t3arq conf]#  vi server.xml</p>
<pre><code class="把">~~~~~~~~~~~~~~~~ 把  8080  改为 其他如  80~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p><img src="/assets/1/image-20220415181625-p6oh0j3.png" alt="image.png"></p>
<p>7.启动远程访问（不要瞎改配置这只会让你陷入死循环。按照这三步来一点问题都没有）</p>
<p>a.关闭防火墙并关机禁止启动</p>
<pre><code>[root@instance-wi0t3arq bin]# systemctl stop firewalld
[root@instance-wi0t3arq bin]# systemctl status firewalld 
?firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)
[root@instance-wi0t3arq bin]#  systemctl disable firewalld
</code></pre>
<p>b.安全组配置8080端口(这个去云服务商网站配置一下就ok了)</p>
<p><img src="/assets/1/image-20211125152901-aehe6s1.png" alt="image.png"></p>
<p>在这里插入图片描述</p>
<p>c.重启tomcat</p>
<p>然后在你的浏览器里输入ip+:8080就可以访问到tomcat界面了</p>
<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>1.准备</p>
<pre><code># 下载mysql源安装包
 [root@instance-wi0t3arq bin]# wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm
# 安装mysql源
 [root@instance-wi0t3arq bin]# yum localinstall mysql57-community-release-el7-8.noarch.rpm
检查mysql源是否安装成功
//不出现错误信息代表安装成功
 [root@instance-wi0t3arq bin]#  yum repolist enabled | grep &quot;mysql.*-community.*&quot;
</code></pre>
<p>2、安装MySQL</p>
<pre><code> [root@instance-wi0t3arq bin]#  yum install mysql-community-server
</code></pre>
<p>3、启动MySQL服务</p>
<pre><code> [root@instance-wi0t3arq bin]#  systemctl start mysqld
</code></pre>
<p>4.查看MySQL的启动状态</p>
<p>[root@instance-wi0t3arq bin] systemctl status mysqld</p>
<p>5.登录mysql修改本地登录密码</p>
<p>查看本机密码</p>
<p>[root@instance-wi0t3arq bin]  grep ‘temporary password’ &#x2F;var&#x2F;log&#x2F;mysqld.log</p>
<p><img src="/assets/1/image-20211125152906-kwvgdv6.png" alt="image.png"></p>
<p>在这里插入图片描述</p>
<p>登录修改密码：注意此处密码一定要按照此格式来因为有验证规则。</p>
<pre><code>  [root@instance-wi0t3arq local]#  mysql -u root -p
Enter password: 
mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass4!&#39;; 
</code></pre>
<p>6.开启远程连接</p>
<p>a.配置安全组3306端口</p>
<p><img src="/assets/1/image-20211125152910-ziubdm5.png" alt="image.png"></p>
<p>在这里插入图片描述</p>
<p>b.开启远程访问</p>
<blockquote>
<p><code>mysql &gt;  GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;fanggus@1s23&#39; WITH GRANT OPTION;</code></p>
</blockquote>
<p>远程连接一下即可连接。</p>
<h2 id="出现其他问题"><a href="#出现其他问题" class="headerlink" title="出现其他问题"></a>出现其他问题</h2><p>1.本机版本与我的不一致我的linux内核版本是：centos7.5(换一下系统)</p>
<p>2.系统本身存在jdk、tomcat、mysql（重装）</p>
<p>3.如果系统不是第一次使用，建议重装系统这样不至于出现覆盖现象。如果不方便重装的话，就先将本机的jdk、mysql、tomcat卸载。</p>
<p>检索命令：</p>
<pre><code>[root@test ~]# yum list installed |grep java
</code></pre>
<p>查看版本命令：</p>
<pre><code>java -version
</code></pre>
<p>移除命令</p>
<pre><code>yum -y remove java-1.7.0-openjdk*
</code></pre>
<p>嗯哼，通过这三个命令移除吧</p>
<pre><code>yum -y install libaio
yum -y install net-tools
yum -y install perl
</code></pre>
<h2 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h2><blockquote>
<p>在&#x2F;usr&#x2F;local目录下新建mysql目录</p>
</blockquote>
<pre><code>mkdir /usr/local/mysql
</code></pre>
<h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><blockquote>
<p>进入mysql目录,解压缩</p>
</blockquote>
<pre><code>tar xvf mysql-5.7.30-1.el7.x86_64.rpm-bundle.tar
</code></pre>
<p>在这里插入图片描述<br><img src="https://lexiangla.com/assets/1/d1c7d855e0624a266d378bdde1956586?from_outside=1" alt="在这里插入图片描述"></p>
<h2 id="安装服务器端程序"><a href="#安装服务器端程序" class="headerlink" title="安装服务器端程序"></a>安装服务器端程序</h2><pre><code>[root@localhost src]# rpm -ivh mysql-community-common-5.7.32-1.el7.x86_64.rpm

[root@localhost src]# rpm -ivh mysql-community-libs-5.7.32-1.el7.x86_64.rpm

[root@localhost src]# rpm -ivh mysql-community-client-5.7.32-1.el7.x86_64.rpm

[root@localhost src]# rpm -ivh mysql-community-server-5.7.32-1.el7.x86_64.rpm
</code></pre>
<h2 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务"></a>启动mysql服务</h2><p>查看mysql状态</p>
<pre><code>service mysqld status
</code></pre>
<p>启动mysql</p>
<pre><code>service mysqld start
</code></pre>
<h2 id="查看并修改临时MySQL密码"><a href="#查看并修改临时MySQL密码" class="headerlink" title="查看并修改临时MySQL密码"></a>查看并修改临时MySQL密码</h2><pre><code>#查看临时密码：得知临时密码就是如图
grep password /var/log/mysqld.log
</code></pre>
<p><img src="https://lexiangla.com/assets/1/33ff088d3189441e781c1276b12695fe?from_outside=1" alt="在这里插入图片描述"></p>
<pre><code>#用临时密码登录mysql
[root@localhost src]# mysql -uroot –p
#修改成新的密码
mysql&gt; set password = password(&quot;Root_123&quot;);
</code></pre>
<p><img src="https://lexiangla.com/assets/1/7a8743824a3c49b453cbfe5c9e37611d?from_outside=1" alt="在这里插入图片描述"></p>
<h2 id="开启远程连接-允许远程连接数据库"><a href="#开启远程连接-允许远程连接数据库" class="headerlink" title="开启远程连接,允许远程连接数据库"></a>开启远程连接,允许远程连接数据库</h2><blockquote>
<p>设置远程访问（使用root密码）</p>
</blockquote>
<pre><code>mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;Mysql_123456&#39; WITH GRANT OPTION;
</code></pre>
<h2 id="配置mysql的配置文件my-cnf"><a href="#配置mysql的配置文件my-cnf" class="headerlink" title="配置mysql的配置文件my.cnf"></a>配置mysql的配置文件my.cnf</h2><pre><code>#打开配置文件my.cnf
[root@localhost src]# vi /etc/my.cnf
#在[mysqld]下面配置几行
lower_case_table_names=1   #配置表名不区分大小写 1：不区分大小写 0：区分大小写  这行必须配置 默认表名是区分大小写的，不利于开发
character-set-server=utf8          #设置为默认编码为utf8
init_connect=&#39;SET NAMES utf8&#39;
max_connections=1024             #设置最大连接数
skip-name-resolve                #在连接远程数据库的时候，直接跳过MySQL的DNS解析
[root@localhost src]# service mysqld restart  #重启mysql 重启配置才能生效
</code></pre>
<h2 id="防火墙设置允许3306端口"><a href="#防火墙设置允许3306端口" class="headerlink" title="防火墙设置允许3306端口"></a>防火墙设置允许3306端口</h2><pre><code>vim /etc/sysconfig/iptables
</code></pre>
<p>模仿22端口开放命令添加如图所示的一行即表示对外开放3306端口<br><img src="https://lexiangla.com/assets/1/b075e7556ef2404d6bac3b3de8763b05?from_outside=1" alt="在这里插入图片描述"></p>
<blockquote>
<p>重启防火墙</p>
</blockquote>
<pre><code>service iptables restart
</code></pre>
<p><strong>第二种方法启动远成端口</strong></p>
<pre><code>firewall-cmd --zone=public --add-port=3306/tcp --permanent
firewall-cmd --reload
</code></pre>
<h2 id="设置开机启动MySQL"><a href="#设置开机启动MySQL" class="headerlink" title="设置开机启动MySQL"></a>设置开机启动MySQL</h2><blockquote>
<p>编辑文件</p>
</blockquote>
<pre><code>vi /etc/rc.local
</code></pre>
<p>加入mysql启动命令<br><img src="https://lexiangla.com/assets/1/c07c0b30d3a7456a6e85c952a2034310?from_outside=1" alt="在这里插入图片描述"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote>
<p>使用sqlyog连接mysql<br><img src="https://lexiangla.com/assets/1/719d1d2aec4b46437bfdabe5839cf993?from_outside=1" alt="在这里插入图片描述"></p>
</blockquote>
<h1 id="安装tomcat-1"><a href="#安装tomcat-1" class="headerlink" title="安装tomcat"></a>安装tomcat</h1><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><blockquote>
<p>在&#x2F;usr&#x2F;local目录下新建tomcat目录</p>
</blockquote>
<pre><code>mkdir /usr/local/tomcat
</code></pre>
<blockquote>
<p>将apache-tomcat-7.0.57.tar.gz 上传到该目录</p>
</blockquote>
<h2 id="解压缩-1"><a href="#解压缩-1" class="headerlink" title="解压缩"></a>解压缩</h2><blockquote>
<p>进入&#x2F;usr&#x2F;local&#x2F;tomcat 目录并解压apache-tomcat-7.0.57.tar.gz 文件</p>
</blockquote>
<pre><code>$ tar -xvf apache-tomcat-7.0.57.tar.gz
</code></pre>
<h2 id="防火墙设置允许8080端口"><a href="#防火墙设置允许8080端口" class="headerlink" title="防火墙设置允许8080端口"></a>防火墙设置允许8080端口</h2><pre><code>/****in/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT
/etc/rc.d/init.d/iptables save
</code></pre>
<h2 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h2><blockquote>
<p>进入到tomcat的安装目录下的bin目录：&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat-7.0.57&#x2F;bin</p>
</blockquote>
<pre><code>./startup.sh
</code></pre>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><blockquote>
<p>访问 http:&#x2F;&#x2F;虚拟机地址:8080</p>
</blockquote>
<p><img src="https://lexiangla.com/assets/1/25bbfa73c8fe4d354ae7c2c10a38b22f?from_outside=1" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>15_环境部署_持续集成</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>持续集成</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/03_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h1><p>Java环境安装配置</p>
<h2 id="Java环境安装"><a href="#Java环境安装" class="headerlink" title="Java环境安装"></a>Java环境安装</h2><p><strong>由于许多工具配套支持的jdk版本为1.8版本，所以尽量选择</strong>jdk1.8<strong>版本使用。</strong></p>
<h3 id="1-下载jdk"><a href="#1-下载jdk" class="headerlink" title="1.  下载jdk"></a>1.  <strong>下载</strong>jdk</h3><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p>
<p><strong>选择对应系统版本匹配的</strong>JDK<strong>，点击右边的下载。</strong></p>
<p><img src="/assets/1/image-20220324172511-lke1vl3.png" alt="image.png"></p>
<p><strong>在弹出的窗口中勾选同意用户协议，并点击下载，若没有登录则会弹出登录界面，注册一个账号进行下载即可。</strong></p>
<p><img src="/assets/1/image-20220324172521-1ya4f0w.png" alt="image.png"></p>
<p><strong>JDK</strong>下载完成后，直接双击运行安装，建议默认安装到C:\Program Files\Java，记住自己的安装路径。点击下一步等待安装即可。</p>
<p><img src="/assets/1/image-20220324172527-erl5zf5.png" alt="image.png"></p>
<p><strong>之后会弹出JRE环境安装的提示，建议同样使用默认路径，直接下一步。等待安装完成之后关闭。</strong></p>
<p><img src="/assets/1/image-20220324172533-ettqoz2.png" alt="image.png"></p>
<p><img src="/assets/1/image-20220324172539-8x11wj1.png" alt="image.png"></p>
<h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.  配置环境变量"></a>2.  <strong>配置环境变量</strong></h3><p><strong>配置环境变量之前，先检查确认java安装成功：</strong></p>
<p><strong>进入安装目录中，确认安装目录下jdk和jre都已经安装成功。确认jdk目录的bin目录下，包含java.exe，javac.exe,javaw.exe。如果没有，尝试卸载重装。</strong></p>
<p><img src="/assets/1/image-20220324172545-zymly6w.png" alt="image.png"></p>
<p><img src="/assets/1/image-20220324172550-2jd1t1a.png" alt="image.png"></p>
<p><strong>环境变量操作方法：</strong></p>
<p><strong>Win7</strong>：<a href="https://jingyan.baidu.com/article/d5a880eb6aca7213f047cc6c.html">https://jingyan.baidu.com/article/d5a880eb6aca7213f047cc6c.html</a></p>
<p><strong>Win10</strong>：<a href="https://jingyan.baidu.com/article/ad310e80d2ebe31848f49e59.html">https://jingyan.baidu.com/article/ad310e80d2ebe31848f49e59.html</a></p>
<p><strong>以</strong>WIN10<strong>为例：</strong></p>
<h4 id="一、在系统变量中，添加JAVA-HOME变量，值为JDK安装目录。"><a href="#一、在系统变量中，添加JAVA-HOME变量，值为JDK安装目录。" class="headerlink" title="一、在系统变量中，添加JAVA_HOME变量，值为JDK安装目录。"></a>一、在系统变量中，添加<strong>JAVA_HOME</strong>变量，值为<strong>JDK</strong>安装目录。</h4><p><img src="/assets/1/image-20220324172557-k5e0kcd.png" alt="image.png"></p>
<h4 id="二、编辑系统变量中的Path"><a href="#二、编辑系统变量中的Path" class="headerlink" title="二、编辑系统变量中的Path:"></a>二、编辑系统变量中的P<strong>ath</strong>:</h4><p><strong>1、删除变量</strong>C:\Program Files (x86)\Common Files\Oracle\Java\javapath，通常在第一个。</p>
<p><strong>确认是</strong>Oracle\Java\javapath再删除！！！<img src="/assets/1/image-20220324172606-hx3wr2s.png" alt="image.png"></p>
<p><strong>2、在Path中新建</strong>%<strong>JAVA_HOME%\bin</strong>请确保这个目录下包含<strong>java.exe</strong>和<strong>javac.exe。</strong></p>
<p><img src="/assets/1/image-20220324172626-q4ank4m.png" alt="image.png"></p>
<h4 id="三-安装检查"><a href="#三-安装检查" class="headerlink" title="三.  安装检查"></a>三.  <strong>安装检查</strong></h4><p><strong>检查</strong>path<strong>：在</strong>cmd<strong>下输入 echo %path% ，确保</strong>path<strong>里面，</strong>java<strong>的路径是正确的，并且没有其他</strong>java<strong>的路径。</strong></p>
<p><img src="/assets/1/image-20220324172632-c5i0tqu.png" alt="image.png"></p>
<p><strong>cmd</strong>在任意目录下，执行<strong>java -version</strong>和<strong>javac -version</strong>。两个版本与安装版本一致，说明配置成功。</p>
<p><img src="/assets/1/image-20220324172638-br4z8gt.png" alt="image.png"></p>
<h1 id="Jenkins安装部署"><a href="#Jenkins安装部署" class="headerlink" title="Jenkins安装部署"></a>Jenkins安装部署</h1><h2 id="Tomcat下载解压："><a href="#Tomcat下载解压：" class="headerlink" title="Tomcat下载解压："></a>Tomcat下载解压：</h2><p><strong>tomcat是非常常用的轻量级web应用服务器，用于进行web项目的发布。要完成jenkins的部署，首先需要安装Java环境和tomcat。</strong></p>
<p><strong>Java环境的安装请参考文档中的《java环境搭建》一文。</strong></p>
<p>1、下载tomcat： <a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a></p>
<p><strong>2、下载之后直接解压即可使用。</strong></p>
<h2 id="Jenkins部署到tomcat启动"><a href="#Jenkins部署到tomcat启动" class="headerlink" title="Jenkins部署到tomcat启动"></a>Jenkins部署到tomcat启动</h2><p>1、下载Jenkins.war，联系悠米老师领取或者从官网下载均可： <a href="https://www.jenkins.io/download/">https://www.jenkins.io/download/</a></p>
<p><strong>2、将Jenkins.war包复制到到Tomcat的webapps目录下，然后在tomcat的bin目录下运行startup.bat，启动tomcat。</strong></p>
<p><img src="/assets/1/image-20220324172712-md4nob9.png" alt="image.png"></p>
<p><strong>3、   在浏览器中访问<a href="http://localhost:8080/jenkins%EF%BC%8C%E7%AD%89%E5%BE%85%E7%BD%91%E9%A1%B5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%8A%9F%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%87%BA%E7%8E%B0%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%95%8C%E9%9D%A2%EF%BC%9A">http://localhost:8080/jenkins，等待网页初始化成功，直到出现下面的界面：</a></strong></p>
<p><img src="/assets/1/image-20220324172717-fw32cnu.png" alt="image.png"></p>
<p><strong>4、  用记事本或Notepad++等文本编辑工具</strong>打开图中红色标识目录中的<strong>initialAdminPassword</strong>文件，复制里面的字符串，粘贴到图中输入框。然后点击图中的继续按钮。</p>
<p><strong>5、   跳转</strong>到下图页面，建议选择Install suggested plugins安装推荐插件，熟悉基本插件之后，可以选择Select plugins to install自定义配置安装的插件。</p>
<p><img src="/assets/1/image-20220324172725-r2o7lwv.png" alt="image.png"></p>
<hr>
<p><strong>6、    <strong>等待插件安装（需要较长时间），当进度条读满，所有插件项目都变成红色或者绿色之后，说明安装结束，如果安装完成页面没有自动跳转，请</strong>手动刷新浏览器页面。</strong></p>
<p><img src="/assets/1/image-20220324172731-py63260.png" alt="image.png"></p>
<p><strong>7、    <strong>忽略安装失败，点击</strong>continue</strong>。</p>
<p><img src="/assets/1/image-20220324172737-a5ccczb.png" alt="image.png"></p>
<p><strong>8、    <strong>创建一个管理员用户名密码，请</strong>记住</strong>用户名和密码，用于之后登录使用。配置完成点击<strong>save and finish</strong>结束。</p>
<p><img src="/assets/1/image-20220324172743-yybujku.png" alt="image.png"></p>
<p><strong>9、    <strong>进入</strong>Jenkins</strong>页面。此时，安装完成</p>
<p><img src="/assets/1/image-20220324172750-9wxgelu.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>15_环境部署_持续集成</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>truetimec++ java visual basic</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/14_%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/07_truetimec++%20java%20visual%20basic/01_truetimec++%20java%20visual%20basic/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>14_白盒测试工具</category>
        <category>07_truetimec++ java visual basic</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>boundscheckerc++ delphiapi ole</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/14_%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_boundscheckerc++%20delphiapi%20ole/01_boundscheckerc++%20delphiapi%20ole/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>14_白盒测试工具</category>
        <category>06_boundscheckerc++ delphiapi ole</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>phpunitphp</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/14_%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_phpunitphp/01_phpunitphp/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>14_白盒测试工具</category>
        <category>05_phpunitphp</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>gtest</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/14_%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_gtest/01_gtest/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>14_白盒测试工具</category>
        <category>04_gtest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>cppunit</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/14_%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_cppunit/01_cppunit/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>14_白盒测试工具</category>
        <category>03_cppunit</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>junit</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/14_%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_junit/01_junit/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>14_白盒测试工具</category>
        <category>02_junit</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>charles安装与使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/12_Charles/01_charles%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、charles简介"><a href="#一、charles简介" class="headerlink" title="一、charles简介"></a>一、charles简介</h1><p>　　<a href="http://www.charlesproxy.com/">Charles</a> 是常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。</p>
<p>　　Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p>
<p>　　除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p>
<h1 id="二、charles安装与破解"><a href="#二、charles安装与破解" class="headerlink" title="二、charles安装与破解"></a>二、charles安装与破解</h1><h2 id="1-charles安装"><a href="#1-charles安装" class="headerlink" title="1.charles安装"></a>1.charles安装</h2><p>　　　charles的安装非常简单，直接通过<a href="http://www.charlesproxy.com/">charles官网</a>安装最新版即可。</p>
<p>　　　Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。</p>
<h2 id="2-破解"><a href="#2-破解" class="headerlink" title="2.破解"></a>2.破解</h2><p>　　　在线破解：<a href="https://www.zzzmode.com/mytools/charles/">https://www.zzzmode.com/mytools/charles/</a></p>
<p>　　　注册名称随意填写，然后选择自己安装的charles版本号，点击即可生成一个charles.jar包，将生成的charles.jar替换原来安装目录lib下的charles.jar包即可。</p>
<p>　　　注意：生成的jar包只有10分钟的有效期，需要在10分钟内完成破解的操作</p>
<h1 id="三、基本配置"><a href="#三、基本配置" class="headerlink" title="三、基本配置"></a>三、基本配置</h1><p>　　我使用的是win7的系统，所以以下配置适用于win7的电脑系统，win10也是类似的配置</p>
<h2 id="1-PC端安装证书"><a href="#1-PC端安装证书" class="headerlink" title="1.PC端安装证书"></a>1.PC端安装证书</h2><p>　　打开charles，选择help–&gt;SSL Proxying–&gt; Install Charles Root Ceriticate，点击安装证书，一直点击下一步完成即可成功安装。如下图所示：</p>
<p><img src="/assets/1/image-20211122223234-nojtb3x.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211122223242-xn8ntu6.png" alt="image.png"></p>
<p>　　</p>
<h2 id="2-web端抓包配置"><a href="#2-web端抓包配置" class="headerlink" title="2.web端抓包配置"></a>2.web端抓包配置</h2><p>　　　以火狐浏览器为例，其它浏览器类似配置即可。</p>
<p>　　　安装charles后访问火狐浏览器，无论访问什么链接都会提示您的连接不安全，解决办法与fiddler同理，需要安装charles证书</p>
<p><img src="/assets/1/image-20211122223251-00hwiqu.png" alt="image.png"></p>
<p>　　　　　a.将charles证书保存到本地，选择help→SSL Proxying→Save Charles Certificate</p>
<p><img src="/assets/1/image-20211122223300-pys14z8.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211122223306-sd4git4.png" alt="image.png"></p>
<p>　　　　　b.进入Firefox浏览器选择—高级-证书，点击查看证书—导入，选择本地保存的证书，勾选信任，导入即可。</p>
<p><img src="/assets/1/image-20211122223313-6yf2nee.png" alt="image.png"></p>
<p>　　　　</p>
<p>　　　　　c.重启火狐浏览器，发现网页可以正常打开，charles也可以正常抓包</p>
<p> 　　</p>
<h2 id="3-手机抓包配置"><a href="#3-手机抓包配置" class="headerlink" title="3.手机抓包配置"></a>3.手机抓包配置</h2><h3 id="1-手机端设置代理"><a href="#1-手机端设置代理" class="headerlink" title="1)手机端设置代理"></a>1)手机端设置代理</h3><p>　　　　　此时你的手机必须和电脑在同一个网络&#x2F;wifi里,手机选择和电脑相同wifi—&gt;长按此wifi弹框中选择修改网络—&gt;显示高级选项—&gt;服务器主机名输入框中输入电脑ip地址,服务器端口号填写8888——&gt;保存即可,此时手机和电脑绑定在一起一遍电脑抓手机上请求网络数据</p>
<p><img src="/assets/1/image-20211122223322-4svba9s.png" alt="image.png"></p>
<p>　　　　第一次设置成功代理后，随便打开一个需要网络的应用，PC端会自动弹出以下提示，选择allow允许Charles代理</p>
<p><img src="/assets/1/image-20211122223329-5n7vd3g.png" alt="image.png"></p>
<p>　　　　如果没有弹出该提示，也可以在菜单栏中的proxy—Access Control settings中手动将手机和电脑的ip加入其中（手机的ip地址怎么查看可以自行百度）</p>
<p><img src="/assets/1/image-20211122223335-gs6uiq5.png" alt="image.png"></p>
<h3 id="2-手机安装charles证书"><a href="#2-手机安装charles证书" class="headerlink" title="2)手机安装charles证书"></a>2)手机安装charles证书</h3><h4 id="a-IOS客户端"><a href="#a-IOS客户端" class="headerlink" title="a.IOS客户端"></a>a.IOS客户端</h4><p>　　　　　　前提：手机WiFi代理已经设置好，参考前文设置　　　</p>
<p>　　　　　　1、打开Charles，选择help→SSL Proxying→Install Charles Root Certificate on a Mobile Device or Remote Browser</p>
<p>　　　　　　2、手机连接电脑代理，打开safari，输入网址：chls.pro&#x2F;ssl</p>
<p>　　　　　　3、手机弹出提示：此网站正尝试打开“设置”已向您显示一个配置描述文件。您要允许吗？忽略|允许，选择允许，安装描述文件，并信任</p>
<p>　　　　　　4、iOS10以上的手机需要在：设置→ 通用 → 关于本机 → 证书信任设置→ 找到charles proxy CA证书，打开信任即可</p>
<h4 id="b-android客户端"><a href="#b-android客户端" class="headerlink" title="b.android客户端"></a>b.android客户端</h4><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><p>　　　　　　点击 help–&gt;SSL Proxying–&gt; Install Charles Root Ceriticate on a Mobile Device or Remote Browser,</p>
<p><img src="/assets/1/image-20211122223345-8gyec9n.png" alt="image.png"></p>
<p>　　　手机设置好WiFi代理后,在手机浏览器打开下面弹框里提到的链接chls.pro&#x2F;ssl,下载证书,安装即可(华为手机最好不要用自带的浏览器，因为自带的浏览器下载的证书为pem格式，无法直接安装，我用的百度浏览器)</p>
<p>　　　cer格式的证书下载完可以直接点击安装，安装证书过程中会要求输入锁屏密码</p>
<p><img src="/assets/1/image-20211122223353-794bj8s.png" alt="image.png"></p>
<h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><p>　　　　　　1、打开Charles，选择help→SSL Proxying→Save Charles Certificate，然后将证书导入到手机中</p>
<p>　　　　　　2、导入后直接点击安装证书，提示无法打开（pem格式），cer格式的key直接安装，可以忽略第三步</p>
<p>　　　　　　3、进入手机设置—&gt;安全和隐私—&gt;更多安全设置—&gt;加密和凭据—&gt;从存储设备安装—&gt;选择我们刚下载的证书,安装即可（华为手机的安装方式，其它安卓机型可以自行百度）</p>
<p><img src="/assets/1/image-20211122223400-1qxenel.png" alt="image.png"></p>
<p>　　　　　　常见手机：小米手机，华为手机，需要设置手机锁屏密码</p>
<p><img src="/assets/1/image-20211122223300-pys14z8.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211122223422-xh9tzfh.png" alt="image.png"></p>
<p> 　</p>
<h2 id="4-设置抓取https"><a href="#4-设置抓取https" class="headerlink" title="4.设置抓取https"></a>4.设置抓取https</h2><p> 　　　　默认charles只可以抓取http协议的包，https的更安全，需要如下配置方可</p>
<p>　　　　菜单栏 Proxy–&gt;SSL Proxying Setting–&gt;选择SSL Proxying——&gt;点击add在弹框中port里填写443(443代表通用https端口号)， host中的*代表抓取所有地址的包</p>
<p><img src="/assets/1/image-20211122223428-zyk9mt1.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211122223435-52u5oe8.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>12_Charles</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jtestjava</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/14_%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_jtestjava/01_jtestjava/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>14_白盒测试工具</category>
        <category>01_jtestjava</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>fiddle实现手机抓包</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_fiddler/999_fiddler%E6%96%87%E4%BB%B6/06_fiddle%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>Fiddler是我最喜爱的工具，几乎每天都用， 我已经用了8年了。 至今我也只学会其中大概50%的功能。 Fiddler绝对称得上是”神器”， 任何一个搞IT的人都得着的。</p>
<p>小弟我立志， 一定要把Fiddler的所有的功能和用法都写出来。 写成一个完整系列的教程。</p>
<p>Fiddler不但能截获各种浏览器发出的HTTP请求, 也可以截获各种智能手机发出的HTTP&#x2F;HTTPS请求。</p>
<p>Fiddler能捕获IOS设备发出的请求，比如IPhone, IPad, MacBook. 等等苹果的设备。  同理，也可以截获Andriod，Windows Phone的等设备发出的HTTP&#x2F;HTTPS。</p>
<p>本文介绍Fiddler截获IPhone发出的HTTP&#x2F;HTTPS包</p>
<p>前提条件是：安装Fiddler的机器，跟Iphone 在同一个网络里， 否则IPhone不能把HTTP发送到Fiddler的机器上来。</p>
<p><img src="/assets/1/wpsBBA7.tmp-20211222153414-4k7ab2o.jpg"></p>
<h1 id="截获智能手机发出的HTTP包有什么用"><a href="#截获智能手机发出的HTTP包有什么用" class="headerlink" title="截获智能手机发出的HTTP包有什么用?"></a><strong>截获智能手机发出的HTTP包有什么用?</strong></h1><p>用处一： 手机软件程序员利用Fiddler，可以截获手机发出的HTTP包， 从而调试程序</p>
<p>用处二： 软件测试人员用于测试智能手机上的软件。</p>
<p>用处三： 可以用来在App应用商店中刷排名</p>
<p>用处四： 截获了HTTP&#x2F;HTTPS后，你想干什么就干什么，比如修改Request，或者Response.</p>
<h1 id="配置Fiddler-允许”远程连接”"><a href="#配置Fiddler-允许”远程连接”" class="headerlink" title="配置Fiddler,  允许”远程连接”"></a><strong>配置Fiddler,  允许”远程连接”</strong></h1><p>打开Fiddler,     Tools-&gt; Fiddler Options 。  （配置完后记得要重启Fiddler）.</p>
<p>选中”Decrpt HTTPS traffic”,    Fiddler就可以截获HTTPS请求</p>
<p>选中”Allow remote computers to connect”.  是允许别的机器把HTTP&#x2F;HTTPS请求发送到Fiddler上来</p>
<p><img src="/assets/1/wpsBBA8.tmp-20211222153414-p1ehtm5.png"><img src="/assets/1/wpsBBA9.tmp-20211222153414-e9jz0p5.jpg"></p>
<p><img src="/assets/1/wpsBBAA.tmp-20211222153414-m1e3p7w.png"><img src="/assets/1/wpsBBAB.tmp-20211222153414-1qorg2w.jpg"></p>
<h1 id="获取Fiddler所在机器的IP地址"><a href="#获取Fiddler所在机器的IP地址" class="headerlink" title="获取Fiddler所在机器的IP地址"></a><strong>获取Fiddler所在机器的IP地址</strong></h1><p>这个简单吧。   我Fidder所在的机器地址是: 192.168.1.104</p>
<h1 id="IPhone上安装Fiddler证书"><a href="#IPhone上安装Fiddler证书" class="headerlink" title="IPhone上安装Fiddler证书"></a><strong>IPhone上安装Fiddler证书</strong></h1><p>这一步是为了让Fiddler能捕获HTTPS请求。 如果你只需要截获HTTP请求， 可以忽略这一步</p>
<ol>
<li>首先要知道Fiddler所在的机器的IP地址：　假如我安装了Fiddler的机器的IP地址是:192.168.1.104</li>
<li>打开IPhone 的Safari, 访问  <a href="http://192.168.1.104:8888，">http://192.168.1.104:8888，</a> 点”FiddlerRoot certificate” 然后安装证书</li>
</ol>
<p><img src="/assets/1/wpsBBAC.tmp-20211222153414-c3e8vfu.png"><img src="/assets/1/wpsBBAD.tmp-20211222153414-7xz2llb.jpg"></p>
<p> <img src="/assets/1/wpsBBAE.tmp-20211222153414-6h56pvh.jpg"></p>
<p><img src="/assets/1/wpsBBAF.tmp-20211222153414-rc0e4xc.png"></p>
<h1 id="IPhone上配置Fiddler为代理"><a href="#IPhone上配置Fiddler为代理" class="headerlink" title="IPhone上配置Fiddler为代理"></a><strong>IPhone上配置Fiddler为代理</strong></h1><p> 打开IPhone,  找到你的网络连接， 打开HTTP代理， 输入Fiddler所在机器的IP地址(比如:192.168.1.104) 以及Fiddler的端口号8888</p>
<p><img src="/assets/1/wpsBBB0.tmp-20211222153414-1jct4ls.png"><img src="/assets/1/wpsBBB1.tmp-20211222153414-f7fgldl.jpg"></p>
<h1 id="大功告成，开始抓包"><a href="#大功告成，开始抓包" class="headerlink" title="大功告成，开始抓包"></a><strong>大功告成，开始抓包</strong></h1><p>现在IPhone上的应用（比如Safari, Firefox, Itunes, App Store）发出的HTTP&#x2F;HTTPS都可以被Fiddler获取。</p>
<p>实例：　打开Safari，　　</p>
<ol>
<li>输入<a href="http://www.cnblogs.com/tankxiao">http://www.cnblogs.com/tankxiao</a>.  看看Fiddler能否捕获。</li>
<li>输入<a href="https://dynamic.12306.cn/otsweb/">https://dynamic.12306.cn/otsweb/</a>   看看Fiddler能否捕获。</li>
</ol>
<p>是不是HTTP和HTTPS都截获到了？？？？，  你不但能截获， 还可以下断点，修改Request, 修改Response, Do what you want.</p>
<p>用完了， 记得把IPhone上的Fiddler代理关闭， 以免IPhone上不了网。</p>
<h1 id="只能捕获HTTP-而不能捕获HTTPS的解决办法"><a href="#只能捕获HTTP-而不能捕获HTTPS的解决办法" class="headerlink" title="只能捕获HTTP,而不能捕获HTTPS的解决办法"></a><strong>只能捕获HTTP,而不能捕获HTTPS的解决办法</strong></h1><p>有时候会发现， Fiddler 只能捕获IPhone发出得HTTP请求， 而不能捕获HTTPS请求， 原因可能是证书没有安装好。 解决办法是：</p>
<ol>
<li>先把IPhone上所有的Fiddler证书删除 (拿出IPhone， 点”设置“-&gt;“通用”-&gt;”描述文件”)</li>
<li>安装上面的方法，重新安装Fiddler证书</li>
</ol>
<h1 id="Fiddler捕获其他手机或者平板"><a href="#Fiddler捕获其他手机或者平板" class="headerlink" title="Fiddler捕获其他手机或者平板"></a><strong>Fiddler捕获其他手机或者平板</strong></h1><p>方法类似</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>11_fiddler</category>
        <category>999_fiddler文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>fiddler弱网测试</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_fiddler/999_fiddler%E6%96%87%E4%BB%B6/07_fiddler%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><img src="/assets/1/image-20220312103112-7w4grsr.png" alt="image.png"></p>
<h1 id="【Fiddler】Fiddler实现弱网测试"><a href="#【Fiddler】Fiddler实现弱网测试" class="headerlink" title="【Fiddler】Fiddler实现弱网测试"></a>【Fiddler】Fiddler实现弱网测试</h1><p><img src="/assets/1/image-20220312103118-u6c78jk.png" alt="image.png"></p>
<p>南京理工大学 理学硕士</p>
<p>57 人赞同了该文章</p>
<h2 id="一、弱网简介"><a href="#一、弱网简介" class="headerlink" title="一、弱网简介"></a><strong>一、弱网简介</strong></h2><p>弱网看字面意思就是网络比较弱，我们通称为信号差，网速慢。</p>
<p><strong>1、弱网的影响</strong></p>
<p>在地铁、隧道、电梯和车库等场景下使用APP ，网络会出现延时、中断和超时等情况。</p>
<ul>
<li>如果我们处于网速慢的地段，我们请求某个功能，app会响应非常慢，页面加载不出来，对于我们测试人员来看，就是用户请求这个API，API加载速度比较慢。</li>
<li>大家都喜欢刷抖音当我们在地铁上刷抖音，滑到下一个时候突然间就会页面卡住，这也是网络的原因导致的。</li>
<li>很多bug都会在弱网的情况下展现出来，如由于响应慢而多次请求，最终导致app出现ANR问题。</li>
</ul>
<p><img src="/assets/1/image-20220312103127-7z69ay8.png" alt="image.png"></p>
<p><strong>2、弱网定义</strong></p>
<p>现在很多时候2G或者在地铁、电梯等场景的3G网，均可定义为弱网，下面是常见网络制式的上行、下载速度表，可以参考。</p>
<p><img src="/assets/1/image-20220312103131-u2uo06z.png" alt="image.png"></p>
<h2 id="二、Fiddler实现弱网的测试"><a href="#二、Fiddler实现弱网的测试" class="headerlink" title="二、Fiddler实现弱网的测试"></a><strong>二、Fiddler实现弱网的测试</strong></h2><p>无论是做web端还是app端的测试，我们都需要对弱网进行测试，对于弱网方法有很多种，如：Fiddler模拟弱网，控制电脑的网速等，今天介绍下Fiddler如何进行弱网测试。</p>
<p><strong>1、Fiddler中启动弱网</strong></p>
<p>打开Fiddler，Rules-&gt;Performance-&gt;勾选 Simulate Modem Speeds，勾选之后访问网站会发现网络慢了很多。</p>
<p><img src="/assets/1/image-20220312103136-fl10m66.png" alt="image.png"></p>
<p><strong>2、设置弱网的参数</strong></p>
<p>菜单Rules—&gt;Cutomize Rules</p>
<p><img src="/assets/1/image-20220312103140-aj3g5w6.png" alt="image.png"></p>
<p>让我们来分析一下这几行代码：</p>
<pre><code class="text">        if (m_SimulateModem) &#123;
            // Delay sends by 300ms per KB uploaded.
            oSession[&quot;request-trickle-delay&quot;] = &quot;300&quot;; 
            // Delay receives by 150ms per KB downloaded.
            oSession[&quot;response-trickle-delay&quot;] = &quot;150&quot;; 
        &#125;
</code></pre>
<ul>
<li>首先来判断m_SimulateModem是否为true（是否开启），也就是是否设置了弱网模式。</li>
<li>oSession[“request-trickle-delay”] &#x3D; “300”;</li>
</ul>
<blockquote>
<p>Delay sends by 300ms per KB uploaded：上传1KB内容需要300ms，转化一下上传速度：1Kb&#x2F;0.3s &#x3D; 3.3KB&#x2F;s，也就是说网络上行速度只有3.3KB。</p>
</blockquote>
<ul>
<li>oSession[“response-trickle-delay”] &#x3D; “150”;</li>
</ul>
<blockquote>
<p>Delay receives by 150ms per KB downloaded：下载1KB内容需要150ms，转化后的下载速度：1KB&#x2F;0.15s&#x3D;6.6KB&#x2F;s,也就是说网络下载速度只有6.6KB。</p>
</blockquote>
<ul>
<li>如果你想设置下载的速度为50KB&#x2F;s，你则需要设置Delay 时间为 20ms。</li>
<li>也可以限制上传的速度，调整oSession[“response-trickle-delay”]的值即可。</li>
</ul>
<p><strong>3、验证效果</strong></p>
<p>同样的接口，开启弱网前后分别运行一次，查看统计数据。</p>
<p><img src="/assets/1/image-20220312103144-imlxacs.png" alt="image.png"></p>
<p><strong>4、恢复设置</strong></p>
<p>完成测试之后，需要再次执行：打开Fiddler，Rules-&gt;Performance-&gt;勾选 Simulate Modem Speeds，关闭弱网模拟。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>11_fiddler</category>
        <category>999_fiddler文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>FiddlerComposer创建和发送http请求</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_fiddler/999_fiddler%E6%96%87%E4%BB%B6/05_FiddlerComposer%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>Fiddler的功能还有很多， 很多功能都没有被挖掘出来。这次我们介绍Fiddler中的一个非常有用的功能Composer，是用来创建和发送HTTP Request的。Composer的使用方法很简单，看下就知道用了。</p>
<h1 id="Fiddler-Composer介绍"><a href="#Fiddler-Composer介绍" class="headerlink" title="Fiddler Composer介绍"></a><strong>Fiddler Composer介绍</strong></h1><p>Composer的官方帮助文档：<a href="http://www.fiddler2.com/fiddler/help/composer.asp">http://www.fiddler2.com/fiddler/help/composer.asp</a></p>
<p>Fiddler的作者把HTTP Request发射器取名叫Composer(中文意思是：乐曲的创造者), 很有诗意</p>
<p>Fiddler Composer的功能就是用来创建HTTP Request 然后发送。 你可以自定义一个Request, 也可以手写一个Request, 你甚至可以在Web会话列表中拖拽一个已有的Request. 来创建一个新的HTTP Request.</p>
<p><img src="/assets/1/wpsF35A.tmp-20211222153217-qqxckyq.png"></p>
<h1 id="Fiddler-Composer比其他工具的优势"><a href="#Fiddler-Composer比其他工具的优势" class="headerlink" title="Fiddler Composer比其他工具的优势"></a><strong>Fiddler Composer比其他工具的优势</strong></h1><p>能创建发送HTTP Request的工具很多很多。 但是Fiddler的功能有如下的优势。</p>
<ol>
<li>能从”Web会话列表”中 拖拽一个先前捕获到的Request, 然后稍微修改一下</li>
<li>发送Request后，还能设置断点，继续修改Request.</li>
<li>支持在Request中上传文件</li>
<li>支持发送多次Request.</li>
</ol>
<h1 id="实例-模拟京东商城的登录"><a href="#实例-模拟京东商城的登录" class="headerlink" title="实例: 模拟京东商城的登录"></a><strong>实例: 模拟京东商城的登录</strong></h1><p>启动Fiddler, 启动IE, 打开京东，然后输入用户名和密码，登录。   Fiddler 将捕获到这个登录的Request.</p>
<ol>
<li>首先找出哪个Request 是用来登录的， 然后把它拖拽到Composer中。</li>
</ol>
<p>[用来登录的request是这个: <a href="https://passport.360buy.com/uc/loginService?uuid=6bc79fbf-e882-49bb-b63a-6fd6ee448944%5D">https://passport.360buy.com/uc/loginService?uuid=6bc79fbf-e882-49bb-b63a-6fd6ee448944]</a></p>
<ol start="2">
<li>在Composer可以看到， 登录是使用POST方法， 把用户名和密码发送给服务器。 那么我们可以修改Composer中的request内容， 比如用户名为:<a href="mailto:&#102;&#x69;&#100;&#x64;&#x6c;&#101;&#114;&#116;&#101;&#x73;&#x74;&#x40;&#102;&#105;&#100;&#x64;&#x6c;&#x65;&#x72;&#46;&#99;&#x6f;&#109;">&#102;&#x69;&#100;&#x64;&#x6c;&#101;&#114;&#116;&#101;&#x73;&#x74;&#x40;&#102;&#105;&#100;&#x64;&#x6c;&#x65;&#x72;&#46;&#99;&#x6f;&#109;</a>,密码为test1234。</li>
<li>Request造好了后， 我们按”Execute” 按钮就可以发送Request了(如果按住Shift键的同时，按”Execute”. Fiddler会自动给这个Request下断点)。</li>
<li>发送的Request，将出现在左边的Web Session列表中。</li>
</ol>
<p><img src="/assets/1/wpsF35B.tmp-20211222153217-zsavmzw.png"></p>
<h1 id="Parsed和Raw两种编辑模式"><a href="#Parsed和Raw两种编辑模式" class="headerlink" title="Parsed和Raw两种编辑模式"></a><strong>Parsed和Raw两种编辑模式</strong></h1><p>Fiddler Composer有两种编辑模式</p>
<p>Parsed模式(最常用),  把Request分为三个部分， Request line, Request Headesr,  Request Body。  很容易创建一个Request.</p>
<p>Raw模式，需要你一行一行手动写一个Request。</p>
<h1 id="同类工具-Firefox插件Rest-Client"><a href="#同类工具-Firefox插件Rest-Client" class="headerlink" title="同类工具- Firefox插件Rest Client"></a><strong>同类工具- Firefox插件Rest Client</strong></h1><p> Firefox也有一个插件叫Rest Client，  使用起来也很方便</p>
<p><img src="/assets/1/wpsF35C.tmp-20211222153217-bz2x5gm.png"></p>
<h1 id="同类工具-Linux上的Curl"><a href="#同类工具-Linux上的Curl" class="headerlink" title="同类工具: Linux上的Curl"></a><strong>同类工具: Linux上的Curl</strong></h1><p> curl是个命令行工具， 功能也很强大</p>
<p><img src="/assets/1/wpsF35D.tmp-20211222153217-wet74aw.jpg"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>11_fiddler</category>
        <category>999_fiddler文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>fiddle利用AutoResponder进行调试</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_fiddler/999_fiddler%E6%96%87%E4%BB%B6/04_fiddle%E5%88%A9%E7%94%A8AutoResponder%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<pre><code>一、将服务器的返回数据（即原资源）重定向到本地的文件进行调试
</code></pre>
<p>1、打开fiddler，打开浏览器输入<a href="https://www.baidu.com(已百度为例),再回到fiddler进行设置/">https://www.baidu.com(已百度为例)，再回到fiddler进行设置</a></p>
<p>2、按照截图所示，分别将4个选购全部勾选，勾选完成后，将待重定向的网址直接拖到右方【手动填写完整地址&#x2F;正则表达式进行模糊匹配的地址】即可 </p>
<p><img src="/assets/1/wpsC4D9.tmp-20211222152849-xddwtw5.png"><img src="/assets/1/wpsC4E9.tmp-20211222152849-dnpk6z2.jpg"></p>
<p>3、填写要替换的内容，下拉框有很多选项可以选择， 比如201、302、404，502等status code<br>注，我的一开始是404_Plain.dat</p>
<p><img src="/assets/1/wpsC4EA.tmp-20211222152849-7l8x6s8.png"><img src="/assets/1/wpsC4EB.tmp-20211222152849-x7naahz.jpg"></p>
<p>4、设置完成之后，刷新百度网页，请求回来的数据已经是替换后的内容了 </p>
<p><img src="/assets/1/wpsC4EC.tmp-20211222152849-llrl5ig.jpg"></p>
<p><img src="/assets/1/wpsC4ED.tmp-20211222152849-0tffmuw.png"></p>
<p>注：想取消的话，直接将第1步中勾选的Enable rules去掉即可</p>
<p>二、利用AutoResponder【重定向功能】修改返回response的数据</p>
<p>1、在fiddler中打开百度<a href="http://www.baidu.com,选择syntaxview的内容进行复制,保存到本机上,以baidu.html格式进行保存/">www.baidu.com，选择SyntaxView的内容进行复制，保存到本机上，以baidu.html格式进行保存</a></p>
<p><img src="/assets/1/wpsC4EE.tmp-20211222152849-iqjyu7d.png"><img src="/assets/1/wpsC4EF.tmp-20211222152849-74zklii.jpg"></p>
<p><img src="/assets/1/wpsC4F0.tmp-20211222152849-ogk32ph.jpg"></p>
<p><img src="/assets/1/wpsC4F1.tmp-20211222152849-vounnot.png"></p>
<p>2、点击AutoResponder，把刚才的网址拖到右边</p>
<p><img src="/assets/1/wpsC4F2.tmp-20211222152849-58xedtk.png"><img src="/assets/1/wpsC4F3.tmp-20211222152849-51zx5n6.jpg"></p>
<p>3、第一个下拉框选择Header:Accept&#x3D;html</p>
<pre><code>第二个下拉框选择你刚才保存baidu.html的路径
</code></pre>
<p><img src="/assets/1/wpsC4F4.tmp-20211222152849-8o1a79i.jpg"></p>
<p><img src="/assets/1/wpsC4F5.tmp-20211222152849-dy76gg8.png"></p>
<p>4、勾选Enable rules之类的四个，然后点击保存</p>
<p><img src="/assets/1/wpsC4F6.tmp-20211222152849-sgb5fjf.png"><img src="/assets/1/wpsC4F7.tmp-20211222152849-d28ppju.jpg"></p>
<p>5、再访问百度</p>
<p><img src="/assets/1/wpsC4F8.tmp-20211222152849-upurpao.jpg"></p>
<p><img src="/assets/1/wpsC4F9.tmp-20211222152849-o25jqlm.png"></p>
<p>注：想取消的话，直接将第1步中勾选的Enable rules去掉即可</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>11_fiddler</category>
        <category>999_fiddler文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>FiddlerScript</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_fiddler/999_fiddler%E6%96%87%E4%BB%B6/03_FiddlerScript/</url>
    <content><![CDATA[<p>现在我们来看看Fiddler的高级用法. Fiddler Script。   Fiddler中的script 可以让我们自动修改Http request和Response 的内容。  而不用手动地去下”断点”来修改http Request或Response中的值。</p>
<h1 id="Fiddler的作者"><a href="#Fiddler的作者" class="headerlink" title="Fiddler的作者"></a><strong>Fiddler的作者</strong></h1><p>Fiddler 的作者是 Eric Lawrence 是个大师级的人物， 目前在微软总部西雅图工作。 他的博客是: <a href="http://www.ericlawrence.com/Eric/">http://www.ericlawrence.com/Eric/</a></p>
<p>博客中能看到他的简历，以及一些生活照.</p>
<h1 id="遇到问题如何向Fiddler的作者请教"><a href="#遇到问题如何向Fiddler的作者请教" class="headerlink" title="遇到问题如何向Fiddler的作者请教"></a><strong>遇到问题如何向Fiddler的作者请教</strong></h1><p>Eric Lawrence 在Google 论坛中建了一个Fiddler 的讨论组， 地址是:<a href="#!forum/httpfiddler">https://groups.google.com/forum/?fromgroups#!forum&#x2F;httpfiddler</a></p>
<p>在这里Fiddler的使用者如果遇到任何问题，都可以这论坛里直接问Eric Law. Eric Law一般都会很快答复你。  在问问题之前，请搜索下。因为你的问题很可能别人早就问过了。</p>
<h1 id="关于Fiddler-Script"><a href="#关于Fiddler-Script" class="headerlink" title="关于Fiddler Script"></a><strong>关于Fiddler Script</strong></h1><p>Fiddler 包含了一个脚本文件可以自动修改Http Request 和Response.这样我们就不需要手动地下”断点”去修改了，</p>
<p>实际上它是一个脚本文件CustomRules.js </p>
<p>位于: C:\Documents and Settings[your user]\My Documents\Fiddler2\Scripts\CustomRules.js 下</p>
<p>你也可以在Fiddler 中打开CustomRules.js 文件，  启动Fiddler, 点击菜单Rules-&gt;Customize Rules…</p>
<p>Fiddler Script 的官方帮助文档必须认真阅读， 地址是：<a href="http://www.fiddler2.com/Fiddler/dev/ScriptSamples.asp">http://www.fiddler2.com/Fiddler/dev/ScriptSamples.asp</a></p>
<h1 id="Fiddler-Script-是用JScript-NET语言写的"><a href="#Fiddler-Script-是用JScript-NET语言写的" class="headerlink" title="Fiddler Script 是用JScript.NET语言写的"></a><strong>Fiddler Script 是用JScript.NET语言写的</strong></h1><p>我从来没听说过JScript.NET语言，可能是JScript的升级版吧。  写起来有点类似C#</p>
<h1 id="安装Fiddler-Script-Editor"><a href="#安装Fiddler-Script-Editor" class="headerlink" title="安装Fiddler Script Editor"></a><strong>安装Fiddler Script Editor</strong></h1><p>你可以直接用notepadCustomRules.js文件，</p>
<p>强烈推荐下载Fiddler Script Editor 地址是：　<a href="http://www.fiddler2.com/fiddler/fse.asp">http://www.fiddler2.com/fiddler/fse.asp</a></p>
<p>Fiddler Script Editor 提供了语法高亮，以及智能提示的功能， 如下图:</p>
<p><img src="/assets/1/wpsAE7F.tmp-20211222152526-hmqvvef.png"></p>
<h1 id="CustomRules-js中的主要方法"><a href="#CustomRules-js中的主要方法" class="headerlink" title="CustomRules.js中的主要方法"></a><strong>CustomRules.js中的主要方法</strong></h1><p>&#x2F;&#x2F; 在这个方法中修改Request的内容， 我们用得最多,</p>
<p>static function OnBeforeRequest(oSession: Session)</p>
<p>&#x2F;&#x2F; 在这个方法中修改Response的内容，</p>
<p>static function OnBeforeResponse(oSession: Session)</p>
<p>&#x2F;&#x2F; 在个方法中包含Fiddler 命令。  在Fiddler界面中左下方的QuickExec Box</p>
<p>static function OnExecAction(sParams: String[])</p>
<h1 id="给Fiddler添加菜单"><a href="#给Fiddler添加菜单" class="headerlink" title="给Fiddler添加菜单"></a><strong>给Fiddler添加菜单</strong></h1><p>Fiddler可以模拟各种浏览器，你可以通过点击菜单 Rules-&gt;User-Agents</p>
<p>不过好像没有Iphone 4S safari 的， 我们现在添加一个。  先查询在网上Iphone 4S safari 的user-Agents, 然后添加如下代码代码就可以了</p>
<p>RulesStringValue(23, “Iphone 4S safari”, “Mozilla&#x2F;5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit&#x2F;532.9 (KHTML, like Gecko) Version&#x2F;4.0.5 Mobile&#x2F;8A293 Safari&#x2F;6531.22.7”)</p>
<p> 保存脚本， 重启Fiddler就可以看到菜单中多了个Iphone 4s</p>
<p><img src="/assets/1/wpsAE80.tmp-20211222152526-jcg446q.jpg"></p>
<p>你可以把你常用的操作，都定义成一个menu，</p>
<h1 id="修改Session在Fiddler的显示样式"><a href="#修改Session在Fiddler的显示样式" class="headerlink" title="修改Session在Fiddler的显示样式"></a><strong>修改Session在Fiddler的显示样式</strong></h1><p>我们可以控制Session在Fiddler中显示的样式， 具体文档是： <a href="http://www.fiddler2.com/Fiddler/dev/SessionFlags.asp">http://www.fiddler2.com/Fiddler/dev/SessionFlags.asp</a></p>
<p>把这段脚本放在OnBeforeRequest(oSession: Session) 方法下，并且点击”Save script”, 这样所有的cnblogs的会话都会显示红色.</p>
<pre><code> if (oSession.HostnameIs(&quot;www.cnblogs.com&quot;)) &#123;
        oSession[&quot;ui-color&quot;] = &quot;red&quot;;
    &#125;
</code></pre>
<p>运行效果如</p>
<p><img src="/assets/1/wpsAE81.tmp-20211222152526-t4u7xd4.jpg"></p>
<h1 id="如何在Fiddler-Script中修改Cookie"><a href="#如何在Fiddler-Script中修改Cookie" class="headerlink" title="如何在Fiddler Script中修改Cookie"></a><strong>如何在Fiddler Script中修改Cookie</strong></h1><p>cookie其实就是request 中的一个header.</p>
<p>&#x2F;&#x2F; 删除所有的cookie</p>
<p>oSession.oRequest.headers.Remove(“Cookie”);</p>
<p>&#x2F;&#x2F; 新建cookie</p>
<p>oSession.oRequest.headers.Add(“Cookie”, “username&#x3D;testname;testpassword&#x3D;P@ssword1”);</p>
<p>注意: Fiddler script不能直接删除或者编辑单独的一个cookie， 你需要用replace方法或者正则表达式的方法去操作cookie的string</p>
<p>static function OnBeforeRequest(oSession: Session)</p>
<p>{</p>
<pre><code> if (oSession.HostnameIs(&#39;www.example.com&#39;) &amp;&amp;

      oSession.uriContains(&#39;pagewithCookie&#39;) &amp;&amp;
</code></pre>
<p>oSession.oRequest.headers.Contains(“Cookie”))</p>
<pre><code> &#123;

 var sCookie = oSession.oRequest[&quot;Cookie&quot;];

 //  用replace方法或者正则表达式的方法去操作cookie的string

 sCookie = sCookie.Replace(&quot;cookieName=&quot;, &quot;ignoreme=&quot;);

 oSession.oRequest[&quot;Cookie&quot;] = sCookie;

&#125;
</code></pre>
<h1 id="如何在Fiddler-Script中修改Request-中的body"><a href="#如何在Fiddler-Script中修改Request-中的body" class="headerlink" title="如何在Fiddler Script中修改Request 中的body"></a><strong>如何在Fiddler Script中修改Request 中的body</strong></h1><p>方法一:</p>
<p>static function OnBeforeRequest(oSession: Session)</p>
<p>{</p>
<pre><code>if(oSession.uriContains(&quot;http://www.cnblogs.com/TankXiao/&quot;))

&#123;

    // 获取Request 中的body字符串

    var strBody=oSession.GetRequestBodyAsString();

    // 用正则表达式或者replace方法去修改string

    strBody=strBody.replace(&quot;1111&quot;,&quot;2222&quot;);

    // 弹个对话框检查下修改后的body               
    FiddlerObject.alert(strBody);

    // 将修改后的body，重新写回Request中

    oSession.utilSetRequestBody(strBody);

&#125;
</code></pre>
<p>}</p>
<p>方法二:  提供了一个非常简单的方法，可以直接替换body中的数据</p>
<p> oSession.utilReplaceInRequest(“1111”, “2222”);</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>11_fiddler</category>
        <category>999_fiddler文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>fiddler常用的快捷键</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_fiddler/999_fiddler%E6%96%87%E4%BB%B6/02_fiddler%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="使用QuickExec"><a href="#使用QuickExec" class="headerlink" title="使用QuickExec"></a><strong>使用QuickExec</strong></h2><p>Fiddler2成了网页调试必备的工具，抓包看数据。Fiddler2自带命令行控制，并提供以下用法。</p>
<p>Fiddler的快捷命令框让你快速的输入脚本命令。</p>
<h2 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a><strong>键盘快捷键</strong></h2><p>按ALT+Q课迅速将焦点定位到快捷命令框。若Fiddler不在活跃状态（后台运行），可按Ctrl+Alt+F先行激活Fiddler（切换至Fiddler面板）<br>在QuickExec框，按CTRL + I插入会话列表中当前选定的会话的URL</p>
<h2 id="默认命令"><a href="#默认命令" class="headerlink" title="默认命令"></a><strong>默认命令</strong></h2><h3 id="sometext"><a href="#sometext" class="headerlink" title="?sometext"></a><strong>?sometext</strong></h3><p>当您键入一些字符串，如sometext ，Fiddler将突出会话所在的URL中包含sometext的请求 。此时按Enter键将高亮选中所有匹配的会话</p>
<table>
<thead>
<tr>
<th>1</th>
<th>?searchtext</th>
</tr>
</thead>
</table>
<p><img src="/assets/1/wps450D.tmp-20211222152711-zj3vzlo.jpg"></p>
<p>选择请求响应大小大于size字节的会话</p>
<table>
<thead>
<tr>
<th>1</th>
<th>&gt;40000 &#x2F;&#x2F;选择大小超过40kb的响应</th>
</tr>
</thead>
</table>
<h3 id="lt-size"><a href="#lt-size" class="headerlink" title="&lt;size"></a><strong>&lt;size</strong></h3><p>选择请求响应大小小于size字节的会话</p>
<table>
<thead>
<tr>
<th>1</th>
<th>&lt;5k &#x2F;&#x2F;选择小于5kb的响应</th>
</tr>
</thead>
</table>
<h3 id="x3D-status、-x3D-method"><a href="#x3D-status、-x3D-method" class="headerlink" title="&#x3D;status、  &#x3D;method"></a><strong>&#x3D;status、  &#x3D;method</strong></h3><p>选择响应状态&#x3D;status 或请求方法&#x3D;method的会话</p>
<table>
<thead>
<tr>
<th>12</th>
<th>&#x3D;301 &#x2F;&#x2F;选择301重定向响应&#x3D;POST &#x2F;&#x2F;选择POST方式的请求</th>
</tr>
</thead>
</table>
<p><a href="http://www.xuanfengge.com/wp-content/uploads/2014/02/2.gif">http://www.xuanfengge.com/wp-content/uploads/2014/02/2.gif</a></p>
<h3 id="host"><a href="#host" class="headerlink" title="@host"></a><strong>@host</strong></h3><p>选择会话中域名包含host的会话，此时按Enter键可高亮所有匹配的结果</p>
<table>
<thead>
<tr>
<th>1</th>
<th>@baidu.com &#x2F;&#x2F;选择 <a href="http://www.baidu.com/">www.baidu.com</a>, map.baidu.com, 等等</th>
</tr>
</thead>
</table>
<p><a href="http://www.xuanfengge.com/wp-content/uploads/2014/02/3.gif">http://www.xuanfengge.com/wp-content/uploads/2014/02/3.gif</a></p>
<h3 id="bold"><a href="#bold" class="headerlink" title="bold"></a><strong>bold</strong></h3><p>预先设置会话加粗：标记任何URL包含了目标字符串的后续请求<br>tip：再次输入bold取消设置</p>
<table>
<thead>
<tr>
<th>12</th>
<th>bold &#x2F;index.phpbold        &#x2F;&#x2F;调用不带任何参数的命令来清除上一设置</th>
</tr>
</thead>
</table>
<h3 id="bpafter"><a href="#bpafter" class="headerlink" title="bpafter"></a><strong>bpafter</strong></h3><p>设置中断RequestURI中包含指定字符串的任何响应<br>tip：再次输入bpafter取消设置</p>
<table>
<thead>
<tr>
<th>12</th>
<th>bpafter &#x2F;favicon.icobpafter       &#x2F;&#x2F;取消设置</th>
</tr>
</thead>
</table>
<h3 id="bps"><a href="#bps" class="headerlink" title="bps"></a><strong>bps</strong></h3><p>中断与设置的状态代码匹配的响应</p>
<table>
<thead>
<tr>
<th>12</th>
<th>bps 404bps        &#x2F;&#x2F;取消设置</th>
</tr>
</thead>
</table>
<h3 id="bpv-or-bpm"><a href="#bpv-or-bpm" class="headerlink" title="bpv or bpm"></a><strong>bpv or bpm</strong></h3><p>对指定的HTTP方法创建请求断点。设置此命令将清除该命令的任何以前的值，不带参数调用它会禁用断点</p>
<table>
<thead>
<tr>
<th>12</th>
<th>bpv POSTbpv        &#x2F;&#x2F;取消设置</th>
</tr>
</thead>
</table>
<h3 id="bpu"><a href="#bpu" class="headerlink" title="bpu"></a><strong>bpu</strong></h3><p>对包含指定字符串的URI创建请求断点。设置此命令将清除该命令的任何以前的值，不带参数调用它会禁用断点</p>
<table>
<thead>
<tr>
<th>12</th>
<th>bpu &#x2F;index.phpbpu        &#x2F;&#x2F;取消设置</th>
</tr>
</thead>
</table>
<h3 id="cls-or-clear"><a href="#cls-or-clear" class="headerlink" title="cls or clear"></a><strong>cls or clear</strong></h3><p>清空会话列表</p>
<table>
<thead>
<tr>
<th>1</th>
<th>cls</th>
</tr>
</thead>
</table>
<h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a><strong>dump</strong></h3><p>打包所有会话成zip归档文件并转存在C:\</p>
<table>
<thead>
<tr>
<th>1</th>
<th>dump</th>
</tr>
</thead>
</table>
<h3 id="g-or-go"><a href="#g-or-go" class="headerlink" title="g or go"></a><strong>g or go</strong></h3><p>恢复所有设置断点的会话</p>
<table>
<thead>
<tr>
<th>1</th>
<th>g</th>
</tr>
</thead>
</table>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a><strong>help</strong></h3><p>打开帮助页面（即本文英文版）</p>
<table>
<thead>
<tr>
<th>1</th>
<th>help</th>
</tr>
</thead>
</table>
<h3 id="hide"><a href="#hide" class="headerlink" title="hide"></a><strong>hide</strong></h3><p>隐藏Fiddler界面，系统后台运行</p>
<table>
<thead>
<tr>
<th>1</th>
<th>hide</th>
</tr>
</thead>
</table>
<h3 id="urlreplace"><a href="#urlreplace" class="headerlink" title="urlreplace"></a><strong>urlreplace</strong></h3><p>以一个不同的字符串替换URL中任何字符串。设置此命令将清除该命令的任何以前的值，不带参数调用它，将取消更换</p>
<table>
<thead>
<tr>
<th>12</th>
<th>urlreplace SeekStr ReplaceWithStrurlreplace        &#x2F;&#x2F;取消设置</th>
</tr>
</thead>
</table>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a><strong>start</strong></h3><p>注册成为系统代理</p>
<table>
<thead>
<tr>
<th>1</th>
<th>start</th>
</tr>
</thead>
</table>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a><strong>stop</strong></h3><p>取消注册为系统代理</p>
<table>
<thead>
<tr>
<th>1</th>
<th>stop</th>
</tr>
</thead>
</table>
<h3 id="show"><a href="#show" class="headerlink" title="show"></a><strong>show</strong></h3><p>将Fiddler从系统托盘中恢复，从ExecAction.exe获取更多有用的触发规则</p>
<table>
<thead>
<tr>
<th>1</th>
<th>show</th>
</tr>
</thead>
</table>
<h3 id="select-MIME"><a href="#select-MIME" class="headerlink" title="select MIME"></a><strong>select MIME</strong></h3><p>选择Content- Type头中包含指定字符串的响应，可用于选择文件格式等</p>
<table>
<thead>
<tr>
<th>123</th>
<th>select imageselect cssselect htm</th>
</tr>
</thead>
</table>
<h3 id="select-HeaderOrFlag-PartialValue"><a href="#select-HeaderOrFlag-PartialValue" class="headerlink" title="select HeaderOrFlag PartialValue"></a><strong>select HeaderOrFlag PartialValue</strong></h3><p>选择已命名的header或SessionFlag包含指定字符串的响应</p>
<table>
<thead>
<tr>
<th>12345</th>
<th>select ui-comments slowselect ui-bold *     &lt;– unless preceded by a slash, * 表示任意值select ui-comments *     &lt;– Find comments with a *select @Request.Accept html     &lt;– Find requests with Accept: htmlselect @Response.Set-Cookie domain &lt;- Find responses that Set-Cookie on a domain</th>
</tr>
</thead>
</table>
<h3 id="allbut-or-keeponly"><a href="#allbut-or-keeponly" class="headerlink" title="allbut or keeponly"></a><strong>allbut or keeponly</strong></h3><p>隐藏Content-Type头中除了包含指定字符串的所有会话，用于筛选</p>
<table>
<thead>
<tr>
<th>12</th>
<th>allbut htmlallbut java</th>
</tr>
</thead>
</table>
<h3 id="quit"><a href="#quit" class="headerlink" title="quit"></a><strong>quit</strong></h3><p>退出Fiddler</p>
<table>
<thead>
<tr>
<th>1</th>
<th>quit</th>
</tr>
</thead>
</table>
<h3 id="dns-hostname"><a href="#dns-hostname" class="headerlink" title="!dns hostname"></a><strong>!dns hostname</strong></h3><p>进行目标域名的DNS查找，并将结果显示在LOG选项卡上</p>
<table>
<thead>
<tr>
<th>12</th>
<th>!dns <a href="http://www.baidu.com!nslookup/">www.baidu.com!nslookup</a> <a href="http://www.baidu.com/">www.baidu.com</a></th>
</tr>
</thead>
</table>
<p><img src="/assets/1/wps450E.tmp-20211222152711-2llz1n1.jpg"></p>
<h3 id="listen-PORT-CERTHOSTNAME"><a href="#listen-PORT-CERTHOSTNAME" class="headerlink" title="!listen PORT [CERTHOSTNAME]"></a><strong>!listen PORT [CERTHOSTNAME]</strong></h3><p>在另一个端口增设一个监听器，选择安全的HTTPS证书</p>
<table>
<thead>
<tr>
<th>123</th>
<th>!listen 8889!listen 4443 localhost!listen 444 secure.example.com</th>
</tr>
</thead>
</table>
<p>附：</p>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Action</strong></th>
<th><strong>Sample usage</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>?</strong> <em>sometext</em></td>
<td>As you type <em>sometext</em> , Fiddler will highlight sessions where the URL contains <em>sometext</em> .  Hit Enter to set focus to the selected matches.</td>
<td>?searchtext</td>
</tr>
<tr>
<td><strong>&gt;</strong> <em>size</em></td>
<td>Select sessions where response size is greater than<em>size</em>bytes.</td>
<td>&gt;40000&lt;– Select responses over 40kb</td>
</tr>
<tr>
<td><strong>&lt;</strong> <em>size</em></td>
<td>Select sessions where response size is less than<em>size</em>bytes.</td>
<td>&lt;5k&lt;– Select responses under 5kb</td>
</tr>
<tr>
<td><strong>&#x3D;</strong> <em>status</em><br /><em>&#x3D;method</em></td>
<td>Select sessions where<strong>response status &#x3D;status</strong>or <strong>request method &#x3D;</strong>  <em>method</em> .</td>
<td>&#x3D;301&lt;– Select 301 redirect responses<br />&#x3D;POST&lt;– Select POST requests</td>
</tr>
<tr>
<td><strong>@</strong> <em>host</em></td>
<td>Select sessions where the request host contains <em>host</em> . Hit Enter to set focus to the selected matches.</td>
<td>@msn.com&lt;– Select <a href="http://www.msn.com/">www.msn.com</a>, login.msn.com, etc</td>
</tr>
<tr>
<td><strong>bold</strong></td>
<td>Mark any future sessions in bold if the url contains the target string</td>
<td><em>bold &#x2F;bar.aspx**bold</em>  &lt;– Call with no parameter to clear</td>
</tr>
<tr>
<td><strong>bpafter</strong></td>
<td>Break any response where the RequestURI contains the specified string</td>
<td><em>bpafter &#x2F;favicon.ico**bpafter</em>  &lt;– Call with no parameter to clear</td>
</tr>
<tr>
<td><strong>bps</strong></td>
<td>Break any response where the status code matches</td>
<td><em>bps 404**bps</em>  &lt;– Call with no parameter to clear</td>
</tr>
<tr>
<td><strong>bpv</strong>or<strong>bpm</strong></td>
<td>Create a request breakpoint for the specified HTTP method. Setting this command will clear any previous value for the command; calling it with no parameter will disable the breakpoint.</td>
<td><em>bpv POST**bpv</em> &lt;– Call with no parameter to clear</td>
</tr>
<tr>
<td><strong>bpu</strong></td>
<td>Create a request breakpoint for URIs containing the specified string.  Setting this command will clear any previous value for the command; calling it with no parameter will disable the breakpoint.</td>
<td><em>bpu &#x2F;myservice.asmx**bpu</em> &lt;– Call with no parameter to clear</td>
</tr>
<tr>
<td><strong>cls</strong>or<strong>clear</strong></td>
<td>clear the session list</td>
<td><em>cls</em></td>
</tr>
<tr>
<td><strong>dump</strong></td>
<td>dump all sessions to a zip archive in C:\</td>
<td><em>dump</em></td>
</tr>
<tr>
<td><strong>g</strong>or<strong>go</strong></td>
<td>Resume all breakpointed sessions</td>
<td><em>g</em></td>
</tr>
<tr>
<td><strong>help</strong></td>
<td>show this page</td>
<td><em>help</em></td>
</tr>
<tr>
<td><strong>hide</strong></td>
<td>Hide Fiddler in System tray</td>
<td><em>hide</em></td>
</tr>
<tr>
<td><strong>urlreplace</strong></td>
<td>Replace any string in URLs with a different string.  Setting this command will clear any previous value for the command; calling it with no parameter will cancel the replacement.</td>
<td><em>urlreplace SeekStr ReplaceWithStr**urlreplace</em>  &lt;– Call with no parameters to clear</td>
</tr>
<tr>
<td><strong>start</strong></td>
<td>Register as the system proxy</td>
<td><em>start</em></td>
</tr>
<tr>
<td><strong>stop</strong></td>
<td>Unregister as the system proxy</td>
<td><em>stop</em></td>
</tr>
<tr>
<td><strong>show</strong></td>
<td>Restore Fiddler from system tray – more useful when triggering rules from ExecAction.exe (see below)</td>
<td><em>show</em></td>
</tr>
<tr>
<td><strong>select</strong><em>MIME</em></td>
<td>Select any session where the response Content-Type header contains the specified string.</td>
<td><em>select image<strong>select css</strong>select htm</em></td>
</tr>
<tr>
<td><strong>select</strong><em>HeaderOrFlagPartialValue</em></td>
<td>Select any session where the named Header or SessionFlag contains the specified string.</td>
<td><em>select ui-comments slow</em><br /><br />*select ui-bold **  *&lt;– unless preceded by a slash, * means any value*<br /><br />*select ui-comments ***&lt;– Find comments with a &lt;– Find requests with Accept: html*<br /><br /> <em>select @Response.Set-Cookie domain</em> <em>&lt;- Find responses that Set-Cookie on a domain</em></td>
</tr>
<tr>
<td><strong>allbut</strong>or<strong>keeponly</strong></td>
<td>Hide all sessions except those where Content-Type header contains the specified string.</td>
<td><em>allbut xml**allbut java</em></td>
</tr>
<tr>
<td><strong>quit</strong></td>
<td>Shutdown Fiddler.</td>
<td><em>quit</em></td>
</tr>
<tr>
<td><strong>!dns</strong><em>hostname</em></td>
<td>Perform a DNS lookup of the target host and show the results on the LOG tab</td>
<td><em>!dns <a href="http://www.example.com/">www.example.com</a></em><br /><br /><em>!nslookup <a href="http://www.example.com/">www.example.com</a></em></td>
</tr>
<tr>
<td><strong>!listen</strong><em>PORT [CERTHOSTNAME]</em></td>
<td>Set up an additional listener on another port, optionally secured by a HTTPS certificate</td>
<td><em>!listen 8889</em><br /><br /><em>!listen 4443 localhost</em><br /><br /><em>!listen 444 secure.example.com</em></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>11_fiddler</category>
        <category>999_fiddler文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>fiddle的基本介绍</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_fiddler/999_fiddler%E6%96%87%E4%BB%B6/01_fiddle%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Fiddler是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据. 使用Fiddler无论对开发还是测试来说，都有很大的帮助。</p>
<h1 id="Fiddler的基本介绍"><a href="#Fiddler的基本介绍" class="headerlink" title="Fiddler的基本介绍"></a><strong>Fiddler的基本介绍</strong></h1><p>Fiddler的官方网站:  <a href="http://www.fiddler2.com/">www.fiddler2.com</a></p>
<p>Fiddler官方网站提供了大量的帮助文档和视频教程， 这是学习Fiddler的最好资料。</p>
<p>Fiddler是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据，Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.net语言进行扩展</p>
<p>你对HTTP 协议越了解， 你就能越掌握Fiddler的使用方法. 你越使用Fiddler,就越能帮助你了解HTTP协议.</p>
<p>Fiddler无论对开发人员或者测试人员来说，都是非常有用的工具</p>
<h1 id="Fiddler的工作原理"><a href="#Fiddler的工作原理" class="headerlink" title="Fiddler的工作原理"></a><strong>Fiddler的工作原理</strong></h1><p>Fiddler 是以代理web服务器的形式工作的,它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler会自动设置代理， 退出的时候它会自动注销代理，这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。解决的办法是重新启动下Fiddler.</p>
<p><img src="/assets/1/wps701A.tmp-20211222153038-q6eifas.jpg"></p>
<p><img src="/assets/1/wps701B.tmp-20211222153038-fn7pf76.jpg"></p>
<h1 id="同类的其它工具"><a href="#同类的其它工具" class="headerlink" title="同类的其它工具"></a><strong>同类的其它工具</strong></h1><p>同类的工具有: httpwatch, firebug, wireshark</p>
<h1 id="Fiddler-如何捕获Firefox的会话"><a href="#Fiddler-如何捕获Firefox的会话" class="headerlink" title="Fiddler 如何捕获Firefox的会话"></a><strong>Fiddler 如何捕获Firefox的会话</strong></h1><p>能支持HTTP代理的任意程序的数据包都能被Fiddler嗅探到，Fiddler的运行机制其实就是本机上监听8888端口的HTTP代理。 Fiddler2启动的时候默认IE的代理设为了127.0.0.1:8888，而其他浏览器是需要手动设置的，所以将Firefox的代理改为127.0.0.1:8888就可以监听数据了。</p>
<p>Firefox 上通过如下步骤设置代理</p>
<p>点击: Tools -&gt; Options,  在Options 对话框上点击Advanced tab - &gt; network tab -&gt; setting.</p>
<h1 id="Firefox-中安装Fiddler插件"><a href="#Firefox-中安装Fiddler插件" class="headerlink" title="Firefox 中安装Fiddler插件"></a><strong>Firefox 中安装Fiddler插件</strong></h1><p>修改Firefox 中的代理比较麻烦， 不用fiddler的时候还要去掉代理。 麻烦</p>
<p>推荐你在firefox中使用fiddler hook 插件, 这样你非常方便的使用Fiddler获取firefox中的request 和response</p>
<p>当你安装fiddler后， 就已经装好了Fiddler hook插件， 你需要到firefox中去启用这个插件<br>打开firefox   tools-&gt;Add ons -&gt; Extensions 启动 FiddlerHook</p>
<p><img src="/assets/1/wps701C.tmp-20211222153038-4i3wuow.png"></p>
<p><img src="/assets/1/wps701D.tmp-20211222153038-evclzag.jpg"></p>
<h1 id="Fiddler如何捕获HTTPS会话"><a href="#Fiddler如何捕获HTTPS会话" class="headerlink" title="Fiddler如何捕获HTTPS会话"></a><strong>Fiddler如何捕获HTTPS会话</strong></h1><p>默认下，Fiddler不会捕获HTTPS会话，需要你设置下, 打开Fiddler  Tool-&gt;Fiddler Options-&gt;HTTPS tab</p>
<p><img src="/assets/1/wps701E.tmp-20211222153038-cycwn84.jpg"></p>
<p> 选中checkbox, 弹出如下的对话框，点击”YES”</p>
<p><img src="/assets/1/wps702F.tmp-20211222153038-bbinumj.jpg"></p>
<p><img src="/assets/1/wps7030.tmp-20211222153038-7q65chy.jpg"></p>
<p>点击”Yes” 后，就设置好了</p>
<h1 id="Fiddler的基本界面"><a href="#Fiddler的基本界面" class="headerlink" title="Fiddler的基本界面"></a><strong>Fiddler的基本界面</strong></h1><p> 看看Fiddler的基本界面</p>
<p><img src="/assets/1/wps7031.tmp-20211222153038-oq4itv1.jpg"></p>
<p>Inspectors tab下有很多查看Request或者Response的消息。 其中Raw Tab可以查看完整的消息，Headers tab 只查看消息中的header. 如下图</p>
<p><img src="/assets/1/wps7032.tmp-20211222153038-f8wa2um.jpg"></p>
<h1 id="Fiddler的HTTP统计视图"><a href="#Fiddler的HTTP统计视图" class="headerlink" title="Fiddler的HTTP统计视图"></a><strong>Fiddler的HTTP统计视图</strong></h1><p>通过陈列出所有的HTTP通信量，Fiddler可以很容易的向您展示哪些文件生成了您当前请求的页面。使用Statistics页签，用户可以通过选择多个会话来得来这几个会话的总的信息统计，比如多个请求和传输的字节数。</p>
<p>选择第一个请求和最后一个请求，可获得整个页面加载所消耗的总体时间。从条形图表中还可以分别出哪些请求耗时最多，从而对页面的访问进行访问速度优化</p>
<p><img src="/assets/1/wps7033.tmp-20211222153038-plyv1mk.jpg"></p>
<h1 id="QuickExec命令行的使用"><a href="#QuickExec命令行的使用" class="headerlink" title="QuickExec命令行的使用"></a><strong>QuickExec命令行的使用</strong></h1><p>Fiddler的左下角有一个命令行工具叫做QuickExec,允许你直接输入命令。</p>
<p>常见得命令有</p>
<p>help  打开官方的使用页面介绍，所有的命令都会列出来</p>
<p>cls    清屏  (Ctrl+x 也可以清屏)</p>
<p>select  选择会话的命令</p>
<p>?.png  用来选择png后缀的图片</p>
<p>bpu  截获request</p>
<p><img src="/assets/1/wps7034.tmp-20211222153038-y77q9rt.jpg"></p>
<h1 id="Fiddler中设置断点修改Request"><a href="#Fiddler中设置断点修改Request" class="headerlink" title="Fiddler中设置断点修改Request"></a><strong>Fiddler中设置断点修改Request</strong></h1><p>[[作者：小坦克]](<a href="http://www.cnblogs.com/TankXiao/admin/[%E4%BD%9C%E8%80%85%EF%BC%9A%E5%B0%8F%E5%9D%A6%E5%85%8B]">http://www.cnblogs.com/TankXiao/admin/[%E4%BD%9C%E8%80%85%EF%BC%9A%E5%B0%8F%E5%9D%A6%E5%85%8B]</a> http:&#x2F;<a href="http://www.cnblogs.com/TankXiao/">www.cnblogs.com/TankXiao/</a>)  Fiddler最强大的功能莫过于设置断点了，设置好断点后，你可以修改httpRequest 的任何信息包括host, cookie或者表单中的数据。设置断点有两种方法</p>
<p>第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint  -&gt;Before Requests(这种方法会中断所有的会话)</p>
<p>如何消除命令呢？  点击Rules-&gt; Automatic Breakpoint  -&gt;Disabled</p>
<p>第二种:  在命令行中输入命令:  bpu <a href="http://www.baidu.com/">www.baidu.com</a>   (这种方法只会中断<a href="http://www.baidu.com/">www.baidu.com</a>)</p>
<p>如何消除命令呢？  在命令行中输入命令 bpu</p>
<p><img src="/assets/1/wps7035.tmp-20211222153038-zgcb88d.png"></p>
<p>看个实例，模拟博客园的登录， 在IE中打开博客园的登录页面，输入错误的用户名和密码，用Fiddler中断会话，修改成正确的用户名密码。这样就能成功登录</p>
<ol>
<li>用IE 打开博客园的登录界面  <a href="http://passport.cnblogs.com/login.aspx">http://passport.cnblogs.com/login.aspx</a></li>
<li>打开Fiddler,  在命令行中输入bpu <a href="http://passport.cnblogs.com/login.aspx">http://passport.cnblogs.com/login.aspx</a></li>
<li>输入错误的用户名和密码 点击登录</li>
<li>Fiddler 能中断这次会话，选择被中断的会话，点击Inspectors tab下的WebForms tab 修改用户名密码，然后点击Run to Completion 如下图所示。</li>
<li>结果是正确地登录了博客园</li>
</ol>
<p><img src="/assets/1/wps7036.tmp-20211222153038-l8i5okh.jpg"></p>
<h1 id="Fiddler中设置断点修改Response"><a href="#Fiddler中设置断点修改Response" class="headerlink" title="Fiddler中设置断点修改Response"></a><strong>Fiddler中设置断点修改Response</strong></h1><p>当然Fiddler中也能修改Response</p>
<p>第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint  -&gt;After Response  (这种方法会中断所有的会话)</p>
<p>如何消除命令呢？  点击Rules-&gt; Automatic Breakpoint  -&gt;Disabled</p>
<p>第二种:  在命令行中输入命令:  bpafter <a href="http://www.baidu.com/">www.baidu.com</a>   (这种方法只会中断<a href="http://www.baidu.com/">www.baidu.com</a>)</p>
<p>如何消除命令呢？  在命令行中输入命令 bpafter,</p>
<p><img src="/assets/1/wps7037.tmp-20211222153038-aaeugkg.png"></p>
<p>具体用法和上节差不多，就不多说了。</p>
<h1 id="Fiddler中创建AutoResponder规则"><a href="#Fiddler中创建AutoResponder规则" class="headerlink" title="Fiddler中创建AutoResponder规则"></a><strong>Fiddler中创建AutoResponder规则</strong></h1><p>Fiddler 的AutoResponder tab允许你从本地返回文件，而不用将http request 发送到服务器上。</p>
<p>看个实例. 1. 打开博客园首页，把博客园的logo图片保存到本地，并且对图片做些修改。</p>
<ol start="2">
<li>打开Fiddler 找到logo图片的会话， <a href="http://static.cnblogs.com/images/logo_2012_lantern_festival.gif%EF%BC%8C">http://static.cnblogs.com/images/logo_2012_lantern_festival.gif，</a>  把这个会话拖到AutoResponer Tab下</li>
<li>选择Enable automatic reaponses 和Unmatched requests passthrough</li>
<li>在下面的Rule Editor 下面选择 Find a file… 选择本地保存的图片.  最后点击Save 保存下。</li>
<li>再用IE博客园首页, 你会看到首页的图片用的是本地的。</li>
</ol>
<p><img src="/assets/1/wps7038.tmp-20211222153038-z3okqru.jpg"></p>
<p><img src="/assets/1/wps7039.tmp-20211222153038-g40yklv.jpg"></p>
<h1 id="Fiddler中如何过滤会话"><a href="#Fiddler中如何过滤会话" class="headerlink" title="Fiddler中如何过滤会话"></a><strong>Fiddler中如何过滤会话</strong></h1><p>每次使用Fiddler, 打开一个网站，都能在Fiddler中看到几十个会话，看得眼花缭乱。最好的办法是过滤掉一些会话，比如过滤掉图片的会话. Fiddler中有过滤的功能, 在右边的Filters tab中，里面有很多选项, 稍微研究下，就知道怎么用。</p>
<h1 id="Fiddler中会话比较功能"><a href="#Fiddler中会话比较功能" class="headerlink" title="Fiddler中会话比较功能"></a><strong>Fiddler中会话比较功能</strong></h1><p>选中2个会话，右键然后点击Compare，就可以用WinDiff来比较两个会话的不同了 (当然需要你安装WinDiff)</p>
<p><img src="/assets/1/wps703A.tmp-20211222153038-th26nvr.jpg"></p>
<h1 id="Fiddler中提供的编码小工具"><a href="#Fiddler中提供的编码小工具" class="headerlink" title="Fiddler中提供的编码小工具"></a><strong>Fiddler中提供的编码小工具</strong></h1><p>点击Fiddler 工具栏上的TextWizard,  这个工具可以Encode和Decode string.</p>
<p><img src="/assets/1/wps704A.tmp-20211222153038-hz5h6gx.jpg"></p>
<h1 id="Fiddler中查询会话"><a href="#Fiddler中查询会话" class="headerlink" title="Fiddler中查询会话"></a><strong>Fiddler中查询会话</strong></h1><p>用快捷键Ctrl+F 打开 Find Sessions的对话框，输入关键字查询你要的会话。 查询到的会话会用黄色显示</p>
<p><img src="/assets/1/wps704B.tmp-20211222153038-hl6aiol.jpg"></p>
<h1 id="Fiddler中保存会话"><a href="#Fiddler中保存会话" class="headerlink" title="Fiddler中保存会话"></a><strong>Fiddler中保存会话</strong></h1><p>有些时候我们需要把会话保存下来，以便发给别人或者以后去分析。  保存会话的步骤如下：</p>
<p>选择你想保存的会话，然后点击File-&gt;Save-&gt;Selected Sessions</p>
<h1 id="Fiddler的script系统"><a href="#Fiddler的script系统" class="headerlink" title="Fiddler的script系统"></a><strong>Fiddler的script系统</strong></h1><p>Fiddler最复杂的莫过于script系统了 官方的帮助文档: <a href="http://www.fiddler2.com/Fiddler/dev/ScriptSamples.asp">http://www.fiddler2.com/Fiddler/dev/ScriptSamples.asp</a></p>
<p>首先先安装SyntaxView插件，Inspectors tab-&gt;Get SyntaxView tab-&gt;Download and Install SyntaxView Now… 如下图</p>
<p><img src="/assets/1/wps704C.tmp-20211222153038-b5r8aw6.jpg"></p>
<p>安装成功后Fiddler 就会多了一个Fiddler Script tab, 如下图</p>
<p><img src="/assets/1/wps704D.tmp-20211222153038-20jrxw6.jpg"></p>
<p>在里面我们就可以编写脚本了， 看个实例 让所有cnblogs的会话都显示红色。</p>
<p>把这段脚本放在OnBeforeRequest(oSession: Session) 方法下，并且点击”Save script”</p>
<pre><code> if (oSession.HostnameIs(&quot;www.cnblogs.com&quot;)) &#123;
        oSession[&quot;ui-color&quot;] = &quot;red&quot;;
    &#125;
</code></pre>
<p>这样所有的cnblogs的会话都会显示红色</p>
<h1 id="如何在VS调试网站的时候使用Fiddler"><a href="#如何在VS调试网站的时候使用Fiddler" class="headerlink" title="如何在VS调试网站的时候使用Fiddler"></a><strong>如何在VS调试网站的时候使用Fiddler</strong></h1><p>我们在用visual stuido 开发ASP.NET网站的时候也需要用Fiddler来分析HTTP， 默认的时候Fiddler是不能嗅探到localhost的网站。不过只要在localhost后面加个点号，Fiddler就能嗅探到。</p>
<p>例如：原本ASP.NET的地址是 <a href="http://localhost:2391/Default.aspx%EF%BC%8C">http://localhost:2391/Default.aspx，</a>  加个点号后，变成 <a href="http://localhost.:2391/Default.aspx">http://localhost.:2391/Default.aspx</a> 就可以了</p>
<p><img src="/assets/1/wps704E.tmp-20211222153038-bt0z5s3.jpg"></p>
<p>第二个办法就是在hosts文件中加入  127.0.0.1  localsite</p>
<p>如何你访问<a href="http://localsite:端口号">http://localsite:端口号</a>   。  这样Fiddler也能截取到了。</p>
<h1 id="Response-是乱码的"><a href="#Response-是乱码的" class="headerlink" title="Response 是乱码的"></a><strong>Response 是乱码的</strong></h1><p>有时候我们看到Response中的HTML是乱码的， 这是因为HTML被压缩了， 我们可以通过两种方法去解压缩。</p>
<ol>
<li>点击Response Raw上方的”Response is encoded any may need to be decoded before inspection. click here to transform”</li>
<li>选中工具栏中的”Decode”。  这样会自动解压缩。</li>
</ol>
<p><img src="/assets/1/wps704F.tmp-20211222153038-l1ovf1e.jpg"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>11_fiddler</category>
        <category>999_fiddler文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Fiddler</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_fiddler/01_Fiddler/</url>
    <content><![CDATA[<ol>
<li><p>Fiddler安装</p>
<ol>
<li><p>fiddler官网：<a href="http://www.telerik.com/fiddler">http://www.telerik.com/fiddler</a></p>
<p> <a href="https://www.telerik.com/download/fiddler">Download Fiddler Web Debugging Tool for Free by Telerik</a></p>
<p> <img src="/assets/1/image-20211120154151-201812f.png" alt="image.png"></p>
</li>
</ol>
</li>
<li><h3 id="fiddler配置"><a href="#fiddler配置" class="headerlink" title="fiddler配置"></a>fiddler配置</h3><ol>
<li><p>电脑端监听</p>
<ol>
<li><p>我们双击打开软件，进入到如下的一个界面，然后点击某一个请求，你会发现请求的内容是一堆明显不对的文字，然后该请求的左边是一个锁的样式，联想到https加密，你会发现原因可能是没有配置Fiddler。然后解释一下右边的默认返回内容，第一句是<strong>“这是一个CONNECT隧道，加密的HTTPS流量通过该隧道流动。”</strong>，就证实了我们的猜测，果然是因为https加密的原因。</p>
</li>
<li><p><img src="/assets/1/image-20211206235443-9sw26h0.png" alt="image.png"></p>
</li>
<li><p>那么如何配置FIddler来解析这些加密的请求呢？方法一是查官网的安装文档，二是看提示，软件公司还是很人性化的在返回内容里面提示了需要在哪里设置，就是第二行那一句：<br> “enable the Tools &gt; Options &gt; HTTPS &gt; Decrypt HTTPS traffic option.”</p>
</li>
<li><p>我们按照提示来进行设置，先在左上角的工具栏里面找到Tools，然后依次选择Options、HTTPS ，然后勾选Decrypt HTTPS traffic选项，勾选后安装证书。</p>
</li>
<li><p><img src="/assets/1/image-20211206235455-7c8ozta.png" alt="image.png"></p>
</li>
<li><p>安装证书两种方法：</p>
<ol>
<li>勾选后点击右边的Actions按钮选择<strong>“Trust Root Certificate”</strong>选项，然后全部选择是就行了。<br> 勾选后点击右边的Actions按钮选择第二个选项将证书导出到桌面，然后再在对应的浏览器里面添加即可。<br> 然后我们再打开一个新的网页(例如百度)，查看请求</li>
<li><img src="/assets/1/image-20211206235506-fikwx80.png" alt="image.png"></li>
</ol>
</li>
<li><p>至此，已经可以监听PC端浏览器的请求了。</p>
</li>
</ol>
</li>
<li><p>手机端监听<br> 安卓手机<br> 但是如果你想要对手机上的app进行抓包怎么办呢，那么你还需要进行以下操作：</p>
<p> 首先你的Fiddler所在的电脑和手机必须处在同一个局域网内(即连着同一个路由器)。</p>
<p> 查看你的本机IP地址，在Fiddler的右上角有一个Online按钮，点击一下会显示你的IP信息</p>
<ul>
<li>配置连接信息：Tools &gt; Options &gt;Connections</li>
<li>端口默认是8888，你可以进行修改。</li>
<li>勾选Allow remote computers to connect选项，然后重启Fiddler，再次打开时会弹出一个信息，选择ok即可。</li>
<li><img src="/assets/1/image-20211206235517-m2n8ick.png" alt="image.png"></li>
<li>打开你的手机，找到你所连接的WIFI，长按选择修改网络，输入密码后往下拖动，然后勾选显示高级选项，然后在代理一栏选择手动，再将你先前查看的IP地址和端口号输入进去，然后保存。</li>
<li><img src="/assets/1/image-20211206235528-67kuq5q.png" alt="image.png"></li>
</ul>
</li>
<li><p>最后安装手机证书，在手机浏览器一栏输入电脑的IP地址和端口号</p>
</li>
<li><p>这里我是192.168.1.157:8888</p>
</li>
<li><p>进入一个网页，点击最下面那个FiddlerRoot certificate下载证书，下载成功后在设置里面安装，安装步骤：打开高级设置-&gt;安全-&gt;从SD卡安装证书-&gt;找到证书文件-&gt;点击后为证书命名点击确定即可安装成功<br> (我的手机是华为的，具体过程请根据实际机型百度查找，关键词是从SD卡安装证书)</p>
</li>
<li><p><img src="/assets/1/image-20211206235543-5koccay.png" alt="image.png"></p>
</li>
<li><p>测试一下，比如在手机上打开抖音app，找到评论的那一个请求。</p>
</li>
<li><p>可以看到我们已经成功的找到了评论所对应的那个请求</p>
</li>
<li><br /></li>
</ol>
</li>
<li><p>安卓手机7.0 以上版本 不能抓https的包  解决方法： 安装Xposed模块</p>
<ol>
<li><p>太极app是干嘛的，有什么作用，这是一款可以帮助自己手机中应用渡劫的软件，所谓渡劫就是创建一个虚拟空间，防止系统检测的功能，可以自由的双开应用，功能非常强大，安全性也非常高，无需root就可以使用，有需要的用户朋友快来下载吧！</p>
<p> 太极app介绍<br> 太极app是一个无需Root、不用解锁Bootloader，也不需要刷机就能使用 Xposed 模块的一个APP，原名exposed与VirtualXposed据说是同一个作者，但这两者都基于VirtualApp来实现APP进程入口劫持，从而实现Xposed框架的部分功能。</p>
<p> 个人理解，原理大概就是利用Android自带的多用户功能，创建一个完全独立的虚拟环境空间(很早以前介绍过island就是这个节奏)，这个空间本身就具备读写管理的权限，因此能够在这个空间里面为所欲为，但是对于设备本身核心的系统功能却无能为力。</p>
<p> 太极app特色<br> 1、这款应用让你不用刷机、告别ROOT权限以及不用解锁Bootloader就可以使用xPosed框架，就是这么简单粗暴;</p>
<p> 2、实用性绝对是不容置疑的，主要是无任何的广告而且还是免费使用的，操作步骤会有提示带着你，我不担心乐友不会;</p>
<p> 3、需要注意的是渡劫的过程中是需要你卸载你需要渡劫的那款应用的，所以有些重要的东西记得提前备份好，方便便捷;</p>
<p> 4、渡劫后可能会出现的一些问题也要注意，例如MIUI&#x2F;华为等第三方ROM的系统分身功能冲突，请果断的删掉所有系统分身。</p>
<p> 但使用Xposed框架的基本前提，便是需要手机root权限</p>
<p> 由于刷机root越来越麻烦，很多朋友也懒得去弄</p>
<p> 所以小手今天为各位推荐一款名为「太极」的app</p>
<p> 「太极」无需获取root权限，即可使用Xposed框架</p>
<p> 由大神weishu开发出的一款神器</p>
<p> 软件使用方法也十分简单，只需将应用添加，再删除原版应用(注意备份重要数据)</p>
<p> 我们即可在手机下载安装Xposed模块(下方提供模块下载地址)</p>
<p> 「太极」内置了部分模块功能，只需勾选需要使用的功能，再停止对应应用，重新打开即可生效</p>
<p> <img src="/assets/1/image-20211206235848-uhjjksw.png" alt="image.png"></p>
<p> p.s：「太极」会与应用分身冲突，需要使用的朋友请先卸载分身类应用。另「太极」只能添加修改的应用的模块，修改系统模块暂不支持</p>
</li>
<li><p>太极app 下载路径：<a href="https://taichi.cool/zh/download.html">太极下载 | 太极 (taichi.cool)</a></p>
</li>
</ol>
</li>
<li><p><a href="../999_fiddler%E6%96%87%E4%BB%B6/01_fiddle%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/">fiddle的基本介绍</a></p>
</li>
<li><p><a href="../999_fiddler%E6%96%87%E4%BB%B6/02_fiddler%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/">fiddler常用的快捷键</a></p>
</li>
<li><p><a href="../999_fiddler%E6%96%87%E4%BB%B6/03_FiddlerScript/">Fiddler Script</a></p>
</li>
<li><p><a href="../999_fiddler%E6%96%87%E4%BB%B6/04_fiddle%E5%88%A9%E7%94%A8AutoResponder%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/">fiddle 利用AutoResponder 进行调试</a></p>
</li>
<li><p><a href="../999_fiddler%E6%96%87%E4%BB%B6/05_FiddlerComposer%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82/">Fiddler Composer  创建和发送http请求</a></p>
</li>
<li><p><a href="../999_fiddler%E6%96%87%E4%BB%B6/06_fiddle%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85/">fiddle 实现手机抓包</a></p>
</li>
<li><p><a href="../999_fiddler%E6%96%87%E4%BB%B6/07_fiddler%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/">fiddler 弱网测试</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>11_fiddler</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>burpsuite</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/10_burpsuite/01_burpsuite/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>10_burpsuite</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>N-StalkerFreeVersion</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_N-StalkerFreeVersion/01_N-StalkerFreeVersion/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>05_N-StalkerFreeVersion</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>skipfish</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_skipfish/01_skipfish/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>06_skipfish</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>scrawlr</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/07_scrawlr/01_scrawlr/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>07_scrawlr</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>webscarab</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/09_webscarab/01_webscarab/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>09_webscarab</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>watcher</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/08_watcher/01_watcher/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>08_watcher</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>wapiti</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_wapiti/01_wapiti/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>04_wapiti</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>iperf</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/12_%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_iperf/01_iperf/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>12_网络测试工具</category>
        <category>05_iperf</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpping</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/12_%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_tcpping/01_tcpping/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>12_网络测试工具</category>
        <category>06_tcpping</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>appscan</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_appscan/01_appscan/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>01_appscan</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>NetsparkerCommunityEdition</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_NetsparkerCommunityEdition/01_NetsparkerCommunityEdition/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>02_NetsparkerCommunityEdition</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>websecurify</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/13_web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_websecurify/01_websecurify/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>13_web安全测试工具</category>
        <category>03_websecurify</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>tc</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/12_%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_tc/01_tc/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>12_网络测试工具</category>
        <category>04_tc</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>wirshark</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/12_%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_wirshark/01_wirshark/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>12_网络测试工具</category>
        <category>03_wirshark</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>lxia</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/12_%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_lxia/01_lxia/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>12_网络测试工具</category>
        <category>02_lxia</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>思博伦</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/12_%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%80%9D%E5%8D%9A%E4%BC%A6/01_%E6%80%9D%E5%8D%9A%E4%BC%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>12_网络测试工具</category>
        <category>01_思博伦</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>tscancode</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/06_tscancode/01_tscancode/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>11_代码扫描工具</category>
        <category>06_tscancode</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>cppcheck++</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/02_cppcheck%20c++/01_cppcheck%20c++/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>11_代码扫描工具</category>
        <category>02_cppcheck c++</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>gcover</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/03_gcover/01_gcover/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>11_代码扫描工具</category>
        <category>03_gcover</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>findbugs</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/04_findbugs/01_findbugs/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>11_代码扫描工具</category>
        <category>04_findbugs</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>sonarlint</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/05_sonarlint/01_sonarlint/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>11_代码扫描工具</category>
        <category>05_sonarlint</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>coverity</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/11_%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/01_coverity/01_coverity/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>11_代码扫描工具</category>
        <category>01_coverity</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>qtp</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/10_C_S%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/01_qtp/01_qtp/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>10_C_S自动化工具</category>
        <category>01_qtp</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>winrunner</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/10_C_S%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/02_winrunner/01_winrunner/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>10_C_S自动化工具</category>
        <category>02_winrunner</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>autoit</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/10_C_S%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/03_autoit/01_autoit/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>10_C_S自动化工具</category>
        <category>03_autoit</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>测试专家</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/09_%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/01_%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>09_编程工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>notepad++</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/08_%E8%BE%85%E5%8A%A9%E6%B5%8B%E8%AF%95%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/notepad++/01_notepad++/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>08_辅助测试编程工具</category>
        <category>notepad++</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>HBuilderX</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/08_%E8%BE%85%E5%8A%A9%E6%B5%8B%E8%AF%95%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/HBuilderX/01_HBuilderX/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>08_辅助测试编程工具</category>
        <category>HBuilderX</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>hudson安装以及使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/07_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7/02_hudson/01_hudson%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>之前已经记录了maven和sonar的安装以及使用：</p>
<p>本篇文章将hudson安装使用说明一下，hudson 与 jenkins一样是可扩展的持续集成引擎。</p>
<p>持续化集成环境</p>
<p>   1.JDK:1.8.0_60</p>
<p>   2.hudson-3.2.2</p>
<p>   3.操作系统 win8 64位</p>
<p>   4.tomcat版本apache-tomcat-8.0.24</p>
<p>   5.环境变量配置的maven是3.3.9版本(版本有误,所以最终没有用到)</p>
<p>   6.重新下载的maven版本3.1.1</p>
<p>运行war包和可执行jar的环境：</p>
<p>   1.(dubbo服务)为linux环境。(ip:192.168.103.228)</p>
<p>注意事项：由于处于两个服务器，所以特别需要注意项目打包使用的jdk和最后jar&#x2F;war包运行的环境中tomcat所使用的jdk要保持一致。</p>
<p>当时由于配置了使用3.3.9版本maven时执行hudson Job时报错，所以重新又下载了maven 3.1.1,系统管理中配置的maven的maven_home是新的maven 3.1.1的安装主目录</p>
<p>hudson 的运行,将下载的hudson-3.2.2.war包改个名字为hudson然后丢到tomcat的webapps下(D:\Program Files (x86)\apache-tomcat-8.0.24\webapps)</p>
<p>插件的安装：</p>
<p>下载插件的网址：<a href="http://hudson-ci.org/download/plugins/">http://hudson-ci.org/download/plugins/</a></p>
<p>方法1. 系统管理-》管理插件  如果这种安装方法出现了问题。可以换成第二种方法</p>
<p>方法2. 从<a href="http://hudson-ci.org/download/plugins/%E7%BD%91%E5%9D%80%E4%B8%8B%E4%B8%8B%E8%BD%BD%E5%A5%BD%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%A4%8D%E5%88%B6%E5%88%B0hudson%E7%9A%84%E7%94%A8%E6%88%B7%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%9AC:/Users/a/.hudson/plugins%EF%BC%8C%E7%84%B6%E5%90%8E%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8hudson%E5%8D%B3%E5%8F%AF%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%E3%80%82">http://hudson-ci.org/download/plugins/网址下下载好插件，复制到hudson的用户目录下：C:\Users\a\.hudson\plugins，然后重新启动hudson即可自动安装。</a></p>
<p>用到的插件名字：</p>
<p><img src="/assets/2/image-20220508220051-kncrryg.png" alt="image.png"></p>
<p>deploy.hpi是将jar包或者war包部署到tomcat，使用tomcat自带的部署方式，只要指定用户名密码和url即可。url:<a href="http://127.0.0.1:8180/">http://127.0.0.1:8180/</a> 通过tomcat自带的项目管理发布的</p>
<p>sonar.hpi为sonar插件</p>
<p>scp.hpi是通过scp方式传输文件之类。(ssh协议)</p>
<p>ssh.hpi 默认端口22,远程执行脚本</p>
<p>maven-plugin.hpi为maven插件 但是我还是禁用了，使用自己单独下载的。maven-plugin.hpi.disabled表示禁用吧，其实我猜的。</p>
<p><img src="/assets/2/image-20220508220107-bfzjg4s.png" alt="image.png"></p>
<p>hudson用户目录</p>
<p>hudson主目录下C:\Users\a.hudson\jobs下是每个hudson的job运行时所用的工作区间，在每个job下的工作区间有一个workspace目录，这个目录是从svn上拉下来的代码存放的位置。</p>
<p>新建一个job是在advanced job options中有一个选项Clean workspace before build可以clean workspace在每次build之前可以clean掉workspace。</p>
<p>操作步骤：</p>
<p>hudson系统配置</p>
<ol>
<li><p><img src="/assets/2/image-20220508220123-n6qsb2s.png" alt="image.png"></p>
</li>
<li><p><img src="/assets/2/image-20220508220133-dh9w0vh.png" alt="image.png"></p>
</li>
<li><p><img src="/assets/2/image-20220508220139-6etkvzt.png" alt="image.png"></p>
</li>
<li><p>配置sonar-qube服务器,点击advanced配置选项</p>
<p> <img src="/assets/2/image-20220508220150-wq4flc8.png" alt="image.png"></p>
</li>
</ol>
<p>5.这个一个新的job，负责是打包dubbo服务的成为一个可执行的jar包。</p>
<p><img src="/assets/2/image-20220508220200-7zuogii.png" alt="image.png"></p>
<ol start="6">
<li>clean deploy 并且 删除远程服务器上之前的上传的jar和lib包</li>
</ol>
<p>Build Triggers部分配置的是触发构建的方式。可选的三种方式分别为：</p>
<p>□Build after other project are built：在其他项目构建完成之后构建本项目。</p>
<p>□Build periodically：周期性地构建本项目。</p>
<p>□Poll SCM：周期性地轮询源码仓库，发现有更新的时候构建本项目。</p>
<p><img src="/assets/2/image-20220508220220-k6mcthc.png" alt="image.png"></p>
<ol start="7">
<li>配置build完之后接着执行job(pubDobboService)以及通过scp插件上传hudson用户目录下job目录下workspace下执行完deploy之后最新的jar到远程服务器上</li>
</ol>
<p>当前目录是workspace目录,必须使用相对路径。配置中source为hudson所在的目录，destination为hudson系统配置下scp repository hosts(SCP sites)配置的远程服务器。</p>
<p>此处上传了一个可执行jar包和该jar包执行时所需要的jar包(放在lib文件夹下)。</p>
<blockquote>
<plugins>
            <!-- 打包jar文件时，配置manifest文件，加入lib包的jar依赖 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <configuration>
                    <classesDirectory>target/classes/</classesDirectory>
                    <archive>
                        <manifest>
                            <mainClass>com.alibaba.dubbo.container.Main</mainClass>
                            <!-- 打包时 MANIFEST.MF文件不记录的时间戳版本 -->
                            <useUniqueVersions>false</useUniqueVersions>
                            <addClasspath>true</addClasspath>
                            <classpathPrefix>lib/</classpathPrefix>
                        </manifest>
                        <manifestEntries>
                            <Class-Path>.</Class-Path>
                        </manifestEntries>
                    </archive>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-dependency-plugin</artifactId>
                <executions>
                    <execution>

<pre><code>                    &lt;id&gt;copy-dependencies&lt;/id&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;copy-dependencies&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;type&gt;jar&lt;/type&gt;
                        &lt;includeTypes&gt;jar&lt;/includeTypes&gt;
                        &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt;
                        &lt;outputDirectory&gt;
                            $&#123;project.build.directory&#125;/lib
                        &lt;/outputDirectory&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
</code></pre>
</blockquote>
<p><img src="/assets/2/image-20220508220240-0vvbzyo.png" alt="image.png"></p>
<p>8.这个是在上个job(负责打包可执行jardubbo服务上传到远程服务器)之后执行的。所以Build Triggers中Build after other jobs are built选项勾上，jobs names 为efp-service-core</p>
<p><img src="/assets/2/image-20220508220248-dnkpelv.png" alt="image.png"></p>
<ol start="9">
<li><img src="/assets/2/image-20220508220255-k6sx3xn.png" alt="image.png"></li>
</ol>
<p>efpDubboService.sh(参考网址：<a href="http://blog.csdn.net/chenli522/article/details/47083443">http://blog.csdn.net/chenli522/article/details/47083443</a>)</p>
<blockquote>
<p>#!&#x2F;bin&#x2F;sh</p>
<h2 id="java-env"><a href="#java-env" class="headerlink" title="java env"></a>java env</h2><p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_80<br>export JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</p>
<h2 id="service-name"><a href="#service-name" class="headerlink" title="service name"></a>service name</h2><p>APP_NAME&#x3D;dubboService</p>
<p>SERVICE_DIR&#x3D;&#x2F;efp&#x2F;service&#x2F;$APP_NAME<br>SERVICE_NAME&#x3D;efpDubboService<br>JAR_NAME&#x3D;$SERVICE_NAME.jar<br>PID&#x3D;$SERVICE_NAME.pid</p>
<p>cd $SERVICE_DIR</p>
<p>case “$1” in</p>
<pre><code>start)
    nohup $JRE_HOME/bin/java -Xms256m -Xmx512m -jar $JAR_NAME &gt;/dev/null 2&gt;&amp;1 &amp;
    echo $! &gt; $SERVICE_DIR/$PID
    echo &quot;=== start $SERVICE_NAME&quot;
    ;;

stop)
    if [ -f $SERVICE_DIR/$PID ]; then
    txtP_ID=`cat $SERVICE_DIR/$PID`
    kill -9 $txtP_ID
        rm -rf $SERVICE_DIR/$PID
    fi&lt;br /&gt;        echo &quot;=== stop $SERVICE_NAME&quot;

    sleep 5

    P_ID=`ps -ef | grep -w $JAR_NAME | grep -v &quot;grep&quot; | awk &#39;&#123;print $2&#125;&#39;`
    if [ &quot;$P_ID&quot; == &quot;&quot; ]; then
        echo &quot;=== $SERVICE_NAME process not exists or stop success&quot;
    else
        echo &quot;=== $SERVICE_NAME process pid is:$P_ID&quot;
        echo &quot;=== begin kill $SERVICE_NAME process, pid is:$P_ID&quot;
        kill -9 $P_ID
    fi
    ;;

restart)
    $0 stop
    sleep 2
    $0 start
    echo &quot;=== restart $SERVICE_NAME&quot;
    ;;

*)
    ## restart
    $0 stop
    sleep 2
    $0 start
    ;;
</code></pre>
<p>esac<br>exit 0<br /></p>
</blockquote>
<ol start="10">
<li></li>
</ol>
<p>efp-web-fore项目是web项目是需要打成war包的,所以需要之前各个模块的打成jar包的build deploy job任务已经完成。</p>
<p><img src="/assets/2/image-20220508220310-9p96ji0.png" alt="image.png"></p>
<ol start="11">
<li>build Environment中勾选Execute shell script on remote host using ssh</li>
</ol>
<p>SSH site 是在系统配置中配置的SSH remote sites配置的</p>
<p>SSH sites。<br>此处写了停止tomcat(在build之前执行)和运行tomcat的脚本并且删除之前的efp war包(在build之后执行)</p>
<p>build执行的是maven指令 clean deploy -Dmaven.test.skip&#x3D;true 表示clean 打包 发布但是跳过执行单元测试</p>
<p><img src="/assets/2/image-20220508220321-yoqe748.png" alt="image.png"></p>
<ol start="12">
<li><p>build完成之后通过scp插件将生成的war包上传到远程服务器上。</p>
<p> <img src="/assets/2/image-20220508220332-t6sp991.png" alt="image.png"></p>
</li>
<li><p>这是一个新的job 负责执行sonar代码检查。</p>
</li>
</ol>
<p>多个模块，我就在一个父文件夹下建立一个sonar-project.properties文件</p>
<p>sonar-project.properties内容</p>
<blockquote>
<h1 id="Root-project-information"><a href="#Root-project-information" class="headerlink" title="Root project information"></a>Root project information</h1><p>sonar.projectKey&#x3D;efp<br>sonar.projectName&#x3D;efp<br>sonar.projectVersion&#x3D;1.0.0</p>
<h1 id="Some-properties-that-will-be-inherited-by-the-modules"><a href="#Some-properties-that-will-be-inherited-by-the-modules" class="headerlink" title="Some properties that will be inherited by the modules"></a>Some properties that will be inherited by the modules</h1><p>sonar.sources&#x3D;src&#x2F;main&#x2F;java</p>
<h1 id="List-of-the-module-identifiers"><a href="#List-of-the-module-identifiers" class="headerlink" title="List of the module identifiers"></a>List of the module identifiers</h1><p>sonar.modules&#x3D;efp-common-config,efp-facade-core,efp-common-web,efp-common-util,efp-service-core,efp-web-fore</p>
<h1 id="Properties-can-obviously-be-overriden-for"><a href="#Properties-can-obviously-be-overriden-for" class="headerlink" title="Properties can obviously be overriden for"></a>Properties can obviously be overriden for</h1><h1 id="each-module-just-prefix-them-with-the-module-ID"><a href="#each-module-just-prefix-them-with-the-module-ID" class="headerlink" title="each module - just prefix them with the module ID"></a>each module - just prefix them with the module ID</h1><p>#efp-common-config module<br>efp-common-config.sonar.projectName&#x3D;efp-common-config<br>efp-common-config.sonar.sources&#x3D;src</p>
<p>#efp-facade-core<br>efp-facade-core.sonar.projectName&#x3D;efp-facade-core</p>
<p>#efp-common-web<br>efp-common-web.sonar.projectName&#x3D;efp-common-web<br>efp-common-web.sonar.exclusions&#x3D;&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;zbiti&#x2F;platform&#x2F;web&#x2F;filter&#x2F;<strong>, src&#x2F;main&#x2F;java&#x2F;com&#x2F;zbiti&#x2F;platform&#x2F;core&#x2F;</strong></p>
<p>#efp-common-util<br>efp-common-util.sonar.projectName&#x3D;efp-common-util</p>
<p>#efp-service-core<br>efp-service-core.sonar.projectName&#x3D;efp-service-core</p>
<p>#efp-web-fore<br>efp-web-fore.sonar.projectName&#x3D;efp-web-fore</p>
</blockquote>
<p><img src="/assets/2/image-20220508220345-6kmlxyv.png" alt="image.png"></p>
<ol start="14">
<li>之前安装了sonar插件,所以在这里add build step有一个选项Invoke standalone sonar analysis,增加一个 这个选项，jdk选择系统配置中配置的。就好了。</li>
</ol>
<p>由于sonar和sonar runner在之前hudson系统配置中已经配置，所以就可以调用了。</p>
<p><img src="/assets/2/image-20220508220356-v6wjyip.png" alt="image.png"></p>
<p>参考网址：</p>
<p><a href="http://www.cnblogs.com/AlanLee/p/5372283.html">http://www.cnblogs.com/AlanLee/p/5372283.html</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>07_持续集成工具</category>
        <category>02_hudson</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Hudson的使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/07_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7/02_hudson/02_Hudson%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Hudson之——Hudson的使用（使用-Hudson-来自动化编译、分析、打包、发布、部署项目）"><a href="#Hudson之——Hudson的使用（使用-Hudson-来自动化编译、分析、打包、发布、部署项目）" class="headerlink" title="Hudson之——Hudson的使用（使用 Hudson 来自动化编译、分析、打包、发布、部署项目）"></a>Hudson之——Hudson的使用（使用 Hudson 来自动化编译、分析、打包、发布、部署项目）</h2><p>添加项目</p>
<p><img src="/assets/2/image-20220508221334-gk5k0ho.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221340-c16t81i.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221351-l752mzc.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221358-wfw05al.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221419-px8s80t.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221427-d9t0fj1.png" alt="image.png"></p>
<p>edu-common-parent为所有项目的父级项目，没有任务Java代码，如果项目中有Java代码，则与上述配置稍微有点区别，具体看下面的步骤。</p>
<p><img src="/assets/2/image-20220508221440-gpkcq72.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221447-0nmzqyi.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221453-jovsw4g.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221459-jvx6n3r.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221506-hr223s4.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221513-3z1s497.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221519-9tu6ftx.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221552-90dkabg.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221559-rkjzp80.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508221604-pbz1sht.png" alt="image.png"></p>
<p>附录：</p>
<p>service-user.sh代码如下：</p>
<blockquote>
<p>#!&#x2F;bin&#x2F;sh</p>
<h2 id="java-env"><a href="#java-env" class="headerlink" title="java env"></a>java env</h2><p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.7.0_72<br>export JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</p>
<h2 id="service-name"><a href="#service-name" class="headerlink" title="service name"></a>service name</h2><p>APP_NAME&#x3D;user</p>
<p>SERVICE_DIR&#x3D;&#x2F;home&#x2F;wusc&#x2F;edu&#x2F;service&#x2F;$APP_NAME<br>SERVICE_NAME&#x3D;edu-service-$APP_NAME<br>JAR_NAME&#x3D;$SERVICE_NAME.jar<br>PID&#x3D;$SERVICE_NAME.pid</p>
<p>cd $SERVICE_DIR</p>
<p>case “$1” in</p>
<pre><code>start)
    nohup $JRE_HOME/bin/java -Xms256m -Xmx512m -jar $JAR_NAME &gt;/dev/null 2&gt;&amp;1 &amp;
    echo $! &gt; $SERVICE_DIR/$PID
    echo &quot;=== start $SERVICE_NAME&quot;
    ;;

stop)
    kill `cat $SERVICE_DIR/$PID`
    rm -rf $SERVICE_DIR/$PID
    echo &quot;=== stop $SERVICE_NAME&quot;

    sleep 5
    P_ID=`ps -ef | grep -w &quot;$SERVICE_NAME&quot; | grep -v &quot;grep&quot; | awk &#39;&#123;print $2&#125;&#39;`
    if [ &quot;$P_ID&quot; == &quot;&quot; ]; then
        echo &quot;=== $SERVICE_NAME process not exists or stop success&quot;
    else
        echo &quot;=== $SERVICE_NAME process pid is:$P_ID&quot;
        echo &quot;=== begin kill $SERVICE_NAME process, pid is:$P_ID&quot;
        kill -9 $P_ID
    fi
    ;;

restart)
    $0 stop
    sleep 2
    $0 start
    echo &quot;=== restart $SERVICE_NAME&quot;
    ;;

*)
    ## restart
    $0 stop
    sleep 2
    $0 start
    ;;
</code></pre>
<p>esac<br>exit 0</p>
</blockquote>
<p>restart.sh代码如下：</p>
<blockquote>
<h2 id="java-env-1"><a href="#java-env-1" class="headerlink" title="java env"></a>java env</h2><p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.7.0_72<br>export JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</p>
<h2 id="restart-tomcat"><a href="#restart-tomcat" class="headerlink" title="restart tomcat"></a>restart tomcat</h2><p>&#x2F;home&#x2F;wusc&#x2F;edu&#x2F;web&#x2F;boss-tomcat&#x2F;bin&#x2F;shutdown.sh<br>sleep 3<br>rm -rf &#x2F;home&#x2F;wusc&#x2F;edu&#x2F;web&#x2F;boss-tomcat&#x2F;webapps&#x2F;edu-web-boss<br>&#x2F;home&#x2F;wusc&#x2F;edu&#x2F;web&#x2F;boss-tomcat&#x2F;bin&#x2F;startup.sh</p>
</blockquote>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>07_持续集成工具</category>
        <category>02_hudson</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/07_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7/01_jenkins/01_jenkins/</url>
    <content><![CDATA[<p>大纲</p>
<p><img src="/assets/2/image-20220508214427-30ucs3r.png" alt="image.png"></p>
<p>1.背景<br>　　在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>
<p>　　或者前后端分离后，经常会修改接口，然后重新部署；</p>
<p>　　这些情况都会涉及到频繁的打包部署；</p>
<p>　　手动打包常规步骤：</p>
<p>　　1.提交代码</p>
<p>　　2.问一下同组小伙伴有没有要提交的代码</p>
<p>　　3.拉取代码并打包（war包，或者jar包）</p>
<p>　　4.上传到Linux服务器</p>
<p>　　5.查看当前程序是否在运行</p>
<p>　　6.关闭当前程序</p>
<p>　　7.启动新的jar包</p>
<p>　　8.观察日志看是否启动成功</p>
<p>　　9.如果有同事说，自己还有代码没有提交……再次重复1到8的步骤！！！！！（一上午没了）</p>
<p>　　那么，有一种工具能够实现，将代码提交到git后就自动打包部署勒，答案是肯定的：Jenkins</p>
<p>　　当然除了Jenkins以外，也还有其他的工具可以实现自动化部署，如Hudson等</p>
<p>　　只是Jenkins相对来说，使用得更广泛。</p>
<p>2.Jenkins服务器搭建及基本配置<br>2.1.简介<br>　　Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<p>2.2.Jenkins自动化部署实现原理<br>　　<img src="/assets/2/image-20220508214439-29idy7v.png" alt="image.png"></p>
<p> 2.3.Jenkins部署环境<br>　　基本环境：</p>
<p>　　1.jdk环境，Jenkins是java语言开发的，因需要jdk环境。</p>
<p>　　2.git&#x2F;svn客户端，因一般代码是放在git&#x2F;svn服务器上的，我们需要拉取代码。</p>
<p>　　3.maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle</p>
<p>　　以上是自动化部署java程序jenkins需要的基本环境，请自己提前安装好，下面着重讲解Jenkins的安装部署配置。</p>
<p>2.4.Jenkins安装<br>　　1.下载安装包jenkins.war；</p>
<p>　　2.在安装包根路径下，运行命令 java -jar jenkins.war –httpPort&#x3D;8080，（linux环境、Windows环境都一样）；</p>
<p>　　补充:一个童鞋遇到的问题,反馈说,git自动触发时报错403,启动加如下参数可以解决问题</p>
<p>　　nohup java -jar -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION&#x3D;true  &#x2F;usr&#x2F;local&#x2F;jenkins&#x2F;jenkins.war –httpPort&#x3D;8080  &amp;</p>
<p>　　3.打开浏览器进入链接 <a href="http://localhost:8080/">http://localhost:8080</a>.</p>
<p>　　4.填写初始密码，激活系统</p>
<p>　　<img src="/assets/2/image-20220508214450-efrghfb.png" alt="image.png"></p>
<p>　　5.进入插件安装选择</p>
<p>　　这里建议选择，推荐安装的插件，保证基本常用的功能可以使用。</p>
<p>　　<img src="/assets/2/image-20220508214456-nqlpd1r.png" alt="image.png"></p>
<p>　　选择后，进入插件安装页面</p>
<p>　　<img src="/assets/2/image-20220508214504-gj4fcah.png" alt="image.png"></p>
<p>　　6.设置初始用户和密码</p>
<p>　　<img src="/assets/2/image-20220508214510-ojaxcg6.png" alt="image.png"></p>
<p>　　7.进入系统，安装完成</p>
<p><img src="/assets/2/image-20220508214518-0mita5n.png" alt="image.png"></p>
<p>　　注意，如果还是进入不了系统，需要稍等一下，或者刷新页面，如果还是进入不了，需要重新启动jenkinds服务器。</p>
<p>2.5.Jenkins基本配置<br>2.5.1.系统初始化配置<br>　　<img src="/assets/2/image-20220508214528-z8d4eqq.png" alt="image.png"></p>
<p>　　1.Configure System (系统设置)</p>
<p>　　在系统设置这里，我们只需要设置最后面的一项，配置远程服务器地址，</p>
<p>　　即我们代码最终运行的服务器地址信息，就像我们之前手动部署时使用xshell登录Linux服务器一样，</p>
<p>　　当然这里是可以配置多台远程Linux服务器的，配置完成后点击保存即可，为后面我们配置自动化部署做准备，配置如下图</p>
<p>　　<img src="/assets/2/image-20220508214537-hamyd5k.png" alt="image.png"></p>
<p>　　2.Configure  Global Security (全局安全配置)</p>
<p>　　a.配置用户相关的权限</p>
<p>　　<img src="/assets/2/image-20220508214544-jnt5etc.png" alt="image.png"></p>
<p>　　b.配置钩子程序（当用代码更新时通知）访问权限，避免报403错误</p>
<p>　　默认是勾选上了的，这里去掉勾选</p>
<p>　　<img src="/assets/2/image-20220508214551-t46m6x0.png" alt="image.png"></p>
<p>　　3.Global Tool Configuration (全局工具配置 )</p>
<p>　　a.配置maven的全局settings路径</p>
<p>　　<img src="/assets/2/image-20220508214557-6feagj8.png" alt="image.png"></p>
<p>　　b.配置jdk</p>
<p>　　<img src="/assets/2/image-20220508214602-2wm5owl.png" alt="image.png"></p>
<p>　　c.配置git</p>
<p>　　<img src="/assets/2/image-20220508214609-pqaytah.png" alt="image.png"></p>
<p>　　d.配置maven的安装路径</p>
<p>　　<img src="/assets/2/image-20220508214615-toa8bq1.png" alt="image.png"></p>
<p> 　　4.配置必要插件</p>
<p>　　 主要是检查如下这两个插件是否已安装</p>
<p>　　插件1：Publish over SSH<br>　　插件2：Deploy to container Plugin</p>
<p>　　<img src="/assets/2/image-20220508214622-i27iubb.png" alt="image.png"></p>
<p>　　到这里，我们配置一个自动化部署的的java程序（springBoot+maven+gitHub），基本必要配置就差不多了，后面配置过程中如果需要在配置。</p>
<p>3.Jenkins自动化部署（springBoot+maven+gitHub）项目<br>　3.1.Jenkins服务器上创建项目和配置<br>　　大体步骤：General(基础配置)–》源码管理–》构建触发器–》构建环境–》构建–》构建后操作</p>
<p>　　1.创建一个工程</p>
<p>　　<img src="/assets/2/image-20220508214629-eu7q3g4.png" alt="image.png"></p>
<p>　　2.General(基础配置)</p>
<p>　　仅需填写标准部分，其他可不填写</p>
<p>　　<img src="/assets/2/image-20220508214635-w7c8vc5.png" alt="image.png"></p>
<p>　　3.源码管理</p>
<p>　　<img src="/assets/2/image-20220508214641-3b18j8o.png" alt="image.png"></p>
<p>　　上图中点击“添加”按钮添加一组账号和密码</p>
<p>　　<img src="/assets/2/image-20220508214648-wrivq5s.png" alt="image.png"></p>
<p>　　4.构建触发器</p>
<p>　　<img src="/assets/2/image-20220508214654-smg7s25.png" alt="image.png"></p>
<p>　　如上图：当前项目的回调地址为：</p>
<p>　　<a href="http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>
<p>　　只要执行这个地址（在浏览器上访问改地址），该项目就会发起一次构建项目，即拉取代码打包部署操作，</p>
<p>　　在实际中，是由git服务器回调改地址，在后面讲git服务器配置时详细讲解 ，</p>
<p>　　值得注意的是，如果你是学习测试，使用的是GitHub服务，要确保你的回调地址已经试外网映射过的，即往外网可以访问</p>
<p>　　5.构建环境（无需配置）</p>
<p>　　6.构建</p>
<p>　　<img src="/assets/2/image-20220508214700-y1ag6px.png" alt="image.png"></p>
<p>　　7.构建后操作</p>
<p>　　构建后操作的意思是，jar打包好后，要将jar发送到哪里去，发送后去和启动等</p>
<p>　　这里需要提前在需要部署的服务器上配置好路径，写好启动和停止项目的脚本，并设置为可以执行的脚本，</p>
<p>　　其实就是我们平时在Linux上手动部署项目操作的脚本</p>
<p>　　<img src="/assets/2/image-20220508214707-n9obb2d.png" alt="image.png"></p>
<p>　　案例中给出的stop.sh脚本如下：</p>
<p>1 #!&#x2F;bin&#x2F;bash<br>2 echo “Stop Procedure : demo2-0.0.1-SNAPSHOT.jar”<br>3 pid&#x3D;<code>ps -ef |grep java|grep demo2-0.0.1-SNAPSHOT.jar|awk &#39;&#123;print $2&#125;&#39;</code><br>4 echo ‘old Procedure pid:’$pid<br>5 if [ -n “$pid” ]<br>6 then<br>7 kill -9 $pid<br>8 fi</p>
<p>　　案例中给出的start.sh脚本如下：</p>
<p>1 #!&#x2F;bin&#x2F;bash<br>2 export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_131<br>3 echo ${JAVA_HOME}<br>4 echo ‘Start the program : demo2-0.0.1-SNAPSHOT.jar’<br>5 chmod 777 &#x2F;home&#x2F;ldp&#x2F;app&#x2F;demo2-0.0.1-SNAPSHOT.jar<br>6 echo ‘——-Starting——-‘<br>7 cd &#x2F;home&#x2F;ldp&#x2F;app&#x2F;<br>8 nohup ${JAVA_HOME}&#x2F;bin&#x2F;java -jar demo2-0.0.1-SNAPSHOT.jar &amp;<br>9 echo ‘start success’</p>
<p> 　　到此，Jenkinds服务器配置完成，接下来我还有要配置Linux服务器和Git服务器。</p>
<p>3.2.Linux服务器配置<br>　　在Liux服务上，上传上文中的两个脚本，用于启动和停止</p>
<p>　　<img src="/assets/2/image-20220508214722-wh8h3vb.png" alt="image.png"></p>
<p>3.3.GitHub服务器配置<br>　　在GitHub服务器上的指定项目里面配置上文中提到的回调地址</p>
<p>　　特别注意：为了保证回调地址网可以使用，</p>
<p>　　我已经将地址：<a href="http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2%EF%BC%8C">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2，</a></p>
<p>　　通过花生壳进行外网映射为：<a href="http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2">http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>
<p>　　所以，下面配置的是外网映射地址。</p>
<p>　　<img src="/assets/2/image-20220508214729-mhj5qon.png" alt="image.png"></p>
<p>　　到这里所有配置搞定，只需修改代码，提交到git,然后访问程序看是否生效。</p>
<p> 4.测试<br> 　　1.测试代码</p>
<p>　　<img src="/assets/2/image-20220508214736-mdbd2ps.png" alt="image.png"></p>
<p>　　2.提交代码到git,触发构建</p>
<p>　　3.在GitHub服务器上去看，是否已经触发</p>
<p>　　<img src="/assets/2/image-20220508214742-8qgbsd0.png" alt="image.png"></p>
<p>　　4.在Jenkins的控制台查看是否，正在构建</p>
<p>　　从下图中可以看出，正在构建</p>
<p>　　<img src="/assets/2/image-20220508214749-q9snkr8.png" alt="image.png"></p>
<p>　　5.查看当次构建的控制台日志</p>
<p>　　<img src="/assets/2/image-20220508214756-y5xggdu.png" alt="image.png"></p>
<p>　　说明已经启动成功</p>
<p>　　6.查看Linux服务器，是否上传代码</p>
<p>　　<img src="/assets/2/image-20220508214802-wy8v8sv.png" alt="image.png"></p>
<p>　　7.在Linux上使用命令jps，查看是否启动</p>
<p>　　<img src="/assets/2/image-20220508214808-81pbset.png" alt="image.png"></p>
<p>　　8.浏览器上访问，看是否能用</p>
<p>　　<img src="/assets/2/image-20220508214814-8odu8d3.png" alt="image.png"></p>
<p>　　说明，已经正常启动可以使用。</p>
<p>　　9.再次确认是否能自动化部署</p>
<p>　　修改代码，重新提交代码，循环1到8步查看。</p>
<p>　　如果测试结果是你预期的，那么自动化部署成功。</p>
<p>5.总结&amp;资料下载<br>5.1.总结<br>　　自动化部署Jenkins，作为一款工具，有着非常强大的功能，</p>
<p>　　上面我们只是讲了生产上做Java自动化部署的一个主要流程，</p>
<p>　　其他的功能，大家可以参看官方文档：<a href="https://jenkins.io/zh/doc/">https://jenkins.io/zh/doc/</a></p>
<p>　　但是，本着学习是为了解决生产的原则，</p>
<p>　　个人建议，用到Jenkins的什么功能就学什么就可以了，</p>
<p>　　没必要把Jenkins的所有功能都学完在使用，</p>
<p>　　就如同我们使用word文档一样，并没有系统的他word文档学完后，在开始使用，而是用到什么功能就学习什么功能！</p>
<p>5.2.相关资料<br>　　1.案例中的源码地址：<a href="https://github.com/bangbangw/demo01.git">https://github.com/bangbangw/demo01.git</a></p>
<p>　　2.官方文档：<a href="https://jenkins.io/zh/doc/">https://jenkins.io/zh/doc/</a><br><br /></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>07_持续集成工具</category>
        <category>01_jenkins</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>monkey</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/03_APP%E8%87%AA%E5%8A%A8%E5%8C%96/04_monkey/01_monkey/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>03_APP自动化</category>
        <category>04_monkey</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MonkeyRunner</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/03_APP%E8%87%AA%E5%8A%A8%E5%8C%96/05_MonkeyRunner/01_MonkeyRunner/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>03_APP自动化</category>
        <category>05_MonkeyRunner</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Robotium</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/03_APP%E8%87%AA%E5%8A%A8%E5%8C%96/06_Robotium/01_Robotium/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>03_APP自动化</category>
        <category>06_Robotium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>APP自动化</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/03_APP%E8%87%AA%E5%8A%A8%E5%8C%96/01_APP%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>03_APP自动化</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>appium</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/03_APP%E8%87%AA%E5%8A%A8%E5%8C%96/01_appium/01_appium/</url>
    <content><![CDATA[<ol>
<li><p>准备<br> 安装sdk<br> 安装jdk<br> 使用 cmd 查看移动设备的服务ip+端口</p>
</li>
<li><p>Appium Server GUI<br>安装 Appium Server GUI<br><a href="http://appium.io/">下载地址</a><br>使用 Appium Server GUI<br>点击 startServer</p>
</li>
<li><p>Appium Inspector<br>安装 Appium Inspector<br><a href="https://github.com/appium/appium-inspector">下载地址</a><br>使用 Appium Inspector<br>配置 appnium服务链接<br>    Remote Host：127.0.0.1 （默认）<br>    Remote Port：4723（默认）<br>    Remote Path：&#x2F;wd&#x2F;hub（需要自行添加）<br>Desired Capabilities配置：（项目以QQ为例）<br>    deviceName：   移动设备的服务ip+端口（设备名称） 通过adb devices来获取<br>            <a href="https://blog.csdn.net/cai217/article/details/114026902">如果 adb devices 不能监听到信息：可以访问此链接进行配置</a><br>    platformName： 移动设备的类型 如安卓、苹果（操作系统名称：Android）<br>    platformVersion：移动设备的版本<br>    appPackage： 需要控制的app的包名<br>        注释： 在cmd中输入  adb shell—–&gt; 	  查看设备的所有包名<br>                                   —–&gt; pm list package -3 查看设备的第三方包名<br>    appActivity （被测程序主入口）<br>        注释： zaicme中输入 adb shell—–&gt; dumpsys window windows |grep -i current<br>                前提（先打开需要控制的app界面）<br>                点击 start session 启动服务<br>    noRest （是否重置）<br>    举例：			<br>    json格式：{<br>          “appium:deviceName”: “127.0.0.1:62001”,<br>          “appium:platformName”: “Android”,<br>          “appium:platformVersion”: “7.1.2”,<br>          “appium:appPackage”: “com.ss.android.ugc.aweme”,<br>          “appium:appActivity”: “splash.SplashActivity”,<br>          “appium:noRest”: true<br>    }</p>
</li>
</ol>
<p>注释： <a href="https://w3c.github.io/webdriver/#capabilities">webdriver服务说明</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>03_APP自动化</category>
        <category>01_appium</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>instruments</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/03_APP%E8%87%AA%E5%8A%A8%E5%8C%96/02_instruments/01_instruments/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>03_APP自动化</category>
        <category>02_instruments</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>uiautomator</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/03_APP%E8%87%AA%E5%8A%A8%E5%8C%96/03_uiautomator/01_uiautomator/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>03_APP自动化</category>
        <category>03_uiautomator</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>API自动化</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/02_API%E8%87%AA%E5%8A%A8%E5%8C%96/01_API%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[<p>我相信自动化技能已经成为高级测试工程师总体技能的标配。敏捷和持续测试破坏了传统的测试自动化实践，导致测试工程师重新考虑自动化的完成方式。当今的自动化工程师需要在GUI的下方深入到API级别完成软件质量的保护。</p>
<p>导致转向API测试的第二个变化是物联网。物联网是具有嵌入式功能的日常对象，允许它使用HTTP或HTTPS在Web上进行通信以与远程后端服务进行通信。</p>
<p>下面分享一下API测试的基础使用指南：</p>
<h2 id="什么是API测试？"><a href="#什么是API测试？" class="headerlink" title="什么是API测试？"></a><strong>什么是API测试？</strong></h2><p>应用程序编程接口（API）是充当软件组件接口的规范。大多数功能测试都涉及测试网页或表单等用户界面，而API测试涉及绕过用户界面并通过调用其API直接与服务程序通信。</p>
<p>API测试允许测试绕过GUI并将请求直接发送到应用程序的后端或服务，并在验证响应内容以确保按预期运行的同时收到响应。</p>
<p><img src="/assets/2/image-20220516194445-4df8f0j.png" alt="image.png"></p>
<p>上面的示例通常称为客户&#x2F;服务器关系。客户端通过请求资源来发出请求，然后请求出去寻找将满足请求的服务器。服务器找到所需的资源，然后将响应发送回客户端。</p>
<h2 id="为什么API测试很重要？"><a href="#为什么API测试很重要？" class="headerlink" title="为什么API测试很重要？"></a><strong>为什么API测试很重要？</strong></h2><p>随着敏捷开发成为大多数互联网公司的标准，我们开发软件和自动化测试的方式已经发生了巨大变化。在敏捷开发之前，大部分自动化时间都是通过图形用户界面（GUI）完成的。这是Selenium和UFT&#x2F;QTP等工具处理的部分。</p>
<p>但是，如果您已经进行了一段时间的自动化操作，您就会知道这些类型的测试是多么耗时，脆弱且难以维护。企业投入大量资金来创建自定义功能GUI测试自动化框架，单很可能最终使他们对其可靠性失去了信心，直到人们停止投入。</p>
<p>同样，针对用户界面的GUI测试往往需要花费很长时间才能运行。对于某些敏捷实践（例如连续构建），迁入新代码时，从GUI回归测试套件接收反馈所花费的时间是不能被接受的。</p>
<ul>
<li>API快速反馈</li>
</ul>
<p>在这些情况下，需要更快的反馈。发现错误的时间越早越好，因为开发人员会立即知道他们所做的代码更改已破坏了构建，因此需要进行检查。在测试驱动的流程中，用户需要大量测试集才能快速且频繁地运行，并且必须能够将它们集成到开发生命周期中。</p>
<p>GUI测试仍然非常重要。它是唯一能够真正测试用户在生产过程中如何体验应用程序的测试类型。某些缺陷只能通过GUI测试来捕获。换句话说，尽管至关重要，但GUI不应是用户关注的唯一自动化类型，也不应该是自动化测试总量中最大的一部分。</p>
<p>敏捷关注的自动化类型是更可靠的API下层测试，而较少涉及GUI自动化。</p>
<h2 id="API测试金字塔"><a href="#API测试金字塔" class="headerlink" title="API测试金字塔"></a><strong>API测试金字塔</strong></h2><p><img src="/assets/2/image-20220516194452-duupqlm.png" alt="image.png"></p>
<h3 id="GUI测试"><a href="#GUI测试" class="headerlink" title="GUI测试"></a><strong>GUI测试</strong></h3><p>GUI测试专注于测试应用程序用户界面，以确保其功能正确。GUI测试位于金字塔的顶部，仅占应该创建的自动化测试类型总数的一小部分。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a><strong>单元测试</strong></h3><p>单元测试构成了金字塔的最大部分，形成了坚实的基础。创建单元测试以验证源代码的单个单元，例如方法。通过这样做，开发人员可以隔离其代码中最小的可测试部分。单元测试是最容易创建的，并能带来最大的收益。由于单元测试通常是用与编写应用程序相同的语言编写的，因此开发人员可以轻松将它们添加到开发过程中。</p>
<h3 id="API测试"><a href="#API测试" class="headerlink" title="API测试"></a><strong>API测试</strong></h3><p>中间服务层是创建诸如Rest-Assured和Postman之类的工具的“最佳位置” 。</p>
<p>服务测试的重点是验证许多小组件的交互是否可以集成在一起而不会出现问题。由于API测试绕过了用户界面，因此它们往往比GUI测试更快，更可靠。</p>
<p>最重要的是：由于API测试不依赖UI即可完成，因此可以在开发周期的早期创建它们。</p>
<h2 id="API负载测试"><a href="#API负载测试" class="headerlink" title="API负载测试"></a><strong>API负载测试</strong></h2><p>API测试的另一个好处是，您可以利用相同的功能性API自动测试来在性能测试工作中使用。很多公司使用JMeter进行负载测试，而这些测试用例都是基于API功能测试。</p>
<p>基本思想是，您正在使用工具进行性能测试，但是在针对您的API运行例如负载测试之前，需要确保它实际上可以正常工作。因此，您想先进行功能测试，然后可以利用功能测试脚本完成性能测试。</p>
<p>因此，API测试脚本是性能测试工作流程中的一大优势。</p>
<h2 id="API测试工具如何选择"><a href="#API测试工具如何选择" class="headerlink" title="API测试工具如何选择"></a><strong>API测试工具如何选择</strong></h2><p>您可以使用许多工具来帮助您进行API测试自动化。</p>
<h2 id="如何测试Web服务"><a href="#如何测试Web服务" class="headerlink" title="如何测试Web服务"></a><strong>如何测试Web服务</strong></h2><p>测试任何其他应用程序一样！通常，对于Web服务，正常功能测试的最佳方法是相同的（除了与大多数其他应用程序不同的是，Web服务没有GUI用户界面这一区别除外）。</p>
<p>因此，一直使用的功能测试技术仍然适用。只需将Web服务视为没有业务流程，然后相应地编写测试用例。</p>
<p>自动化Web服务时要问的一些好问题：</p>
<ul>
<li>服务是否以正确的值响应？</li>
<li>该行为是否符合最终用户的预期要求？</li>
<li>该服务多快将响应发送给用户？</li>
<li>服务可以处理预期和意外的用户负载吗？</li>
<li>服务可以处理无效数据和错误数据导致的异常吗？</li>
<li>Web服务测试术语</li>
</ul>
<p>对于大多数测试人员而言，最大的障碍是适应谈论Web服务时使用的术语。</p>
<p>例如：</p>
<ul>
<li>XML格式 XML是一种创建标记语言的方法，您可以使用它定义自己的标签。XML允许用户与众多系统共享结构化数据，包括通过Internet。</li>
<li>REST REST（表示性传输状态）是用于开发使用HTTP协议的Web服务的轻量级选项。</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><strong>HTTP</strong></h2><p>HTTP是一种通过网络传输消息的通信协议。HTTP也被称为无状态协议，因为它发出的每个请求都独立于所有先前的请求。</p>
<p>Cookies用于跟踪会话的先前请求的状态。Cookies是存储在客户端上的文件，具有从HTTP标头信息中添加的信息。当向用户已经访问过的网站发出请求时，存储在Cookies中的信息将发送回浏览器。以这种方式，网站能够记住用户的先前活动和当前的状态。</p>
<ul>
<li>理解HTTP将为我们了解大多数API测试工具功能奠定良好的基础。</li>
</ul>
<h3 id="关于HTTP请求"><a href="#关于HTTP请求" class="headerlink" title="关于HTTP请求"></a><strong>关于HTTP请求</strong></h3><p>HTTP客户端请求包含三个主要部分。他们是：</p>
<h3 id="请求行（HTTP方法）"><a href="#请求行（HTTP方法）" class="headerlink" title="请求行（HTTP方法）"></a><strong>请求行（HTTP方法）</strong></h3><p>告诉服务器正在发出什么类型的请求。在上面的示例中，我们发出了GET请求，但您可以使用更多请求，具体取决于您需要发出的请求类型。HTTP方法具有以下选项（前四个方法是最常见的）：</p>
<p>GET –从指定来源检索数据 POST –将新数据发送到指定的源 PUT –更新指定来源的信息 DELETE –从指定的源中删除数据 TRACE –要求代理人声明自己 选项 –询问有关服务器上可用选项的信息 HEAD –与GET请求类似，但仅发送有关文档的信息 CONNECT –客户端必须使用HTTPS服务器时使用</p>
<h3 id="标头"><a href="#标头" class="headerlink" title="标头"></a><strong>标头</strong></h3><p>包含要发送到服务器的其他信息，例如浏览器，操作系统，接受和Cookie信息。标头的不同类型是：</p>
<p>常规 -可选的标头，其中包含诸如当前时间之类的信息 请求 -向服务器提供有关客户端的更多信息 实体 -包含有关发送文档的特定信息，例如长度和编码方案。</p>
<h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a><strong>请求体</strong></h3><p>包含用于需要它的方法的数据，Get方法为空。</p>
<p>从服务器返回的响应也包含三个部分，就像我们在HTTP请求中看到的那样：</p>
<ul>
<li>响应行（状态码）</li>
<li>标头信息</li>
<li>包含响应中所有文本的正文</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h3><p>在我们的示例中，状态代码为200，表示一切正常。状态代码将根据原始请求发生的情况而有所不同。</p>
<p>可以从服务器返回的状态码是：</p>
<blockquote>
<p>“ 1xx – 100-199范围内的响应表示服务器正在处理请求。 2xx – 200-299范围内的响应表示请求成功。 3xx –响应范围在300-399之间表示未执行请求-需要采取进一步的措施。 4xx –响应范围为400-499，表示请求不完整，可能需要更多信息。 5xx – 500-599范围内的响应表示服务器遇到错误。</p>
</blockquote>
<h2 id="什么是REST-API？"><a href="#什么是REST-API？" class="headerlink" title="什么是REST API？"></a><strong>什么是REST API？</strong></h2><p>REST（表示性传输状态）是用于使用HTTP协议开发Web服务的轻量级选项，这一事实使其比使用SOAP协议的Web服务更简单，开销也更少。当API遵循REST体系结构时，它称为REST API。当围绕REST标准设计服务时，可以说使该服务“ RESTful”。</p>
<p>REST API由大量资源组成。这称为资源模型，它利用统一资源标识（URI）。URI语法允许您指定一个查询，该查询从REST API返回所需的信息。REST系统的主要元素是：</p>
<ul>
<li>资源是客户端请求从主机获取的信息，例如网页或数据库记录。</li>
<li>资源标识符是用于命名资源的URI。</li>
<li>表示形式是服务器发送带有完成格式的资源的响应时。</li>
<li>REST API测试（如何创建REST API测试）</li>
</ul>
<h3 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a><strong>什么是JSON</strong></h3><p>JSON代表JavaScript Object Notation，并且被设计为轻量级的数据交换格式。JSON无疑变得越来越流行，并且在某些情况下正在取代XML进行API数据交换。<a href="http://www.json.org网站描述了如何在两种结构上构建JSON：">http://www.json.org网站描述了如何在两种结构上构建JSON：</a></p>
<p>“ 名称&#x2F;值对的集合。在各种语言中，这被实现为对象，记录，结构，字典，哈希表，键列表或关联数组。 “值的有序列表。在大多数语言中，这是通过数组，向量，列表或序列来实现的。”</p>
<p>末了，极力推荐《图解HTTP协议》这本书。 <img src="/assets/2/http.svg" alt="图解HTTP脑图"><br><img src="F:/assets/2/http.svg"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>02_API自动化</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>UI自动化测试框架_关键字驱动+数据驱动</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6_%E5%85%B3%E9%94%AE%E5%AD%97%E9%A9%B1%E5%8A%A8+%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<ol>
<li><p>关键字驱动框架简介<br> 原理及特点<br> 关键字驱动测试是数据驱动测试的一种改进类型，它也被称为表格驱动测试或者基于动作字的测试。<br> 主要关键字包括三类：被操作对象（Item）、操作行为（Operation）和操作值（Value），用面向对象形式可将其表现为 Item.Operation(Value)。<br> 将测试逻辑按照这些关键字进行分解，形成数据文件。<br> 用关键字的形式将测试逻辑封装在数据文件中，测试工具只要能够解释这些关键字即可对其应用自动化。</p>
<p> <img src="/assets/2/image-20220510224044-p91vm0i.png" alt="image.png"></p>
</li>
</ol>
<p>优势<br>执行人员可以不需要太多的技术：一旦框架建立，手工测试人员和非技术人员都可以很容易的编写自动化测试脚本。<br>简单易懂：它存在Excel表格中，没有编码，测试脚本容易阅读和理解。关键字和操作行为这样的手工测试用例，使它变得更容易编写和维护。<br>早期介入：可以在应用未提交测试之前，就可以建立关键字驱动测试用例对象库，从而减少后期工作。使用需求和其它相关文档进行收集信息，关键字数据表可以建立手工测试程序。<br>代码的重用性：用关键字的形式将测试用例及数据进行组装并解释执行，提高代码的可重用性。</p>
<ol start="2">
<li>工程结构说明<br> 工程结构<br> 整个测试框架分为四层，通过分层的方式，测试代码更容易理解，维护起来较为方便。</li>
</ol>
<p>第一层是“测试工具层”：</p>
<p>util 包：用于实现测试过程中调用的工具类方法，例如读取配置文件、页面元素的操作方法、操作 Excel 文件、生成测试报告、发送邮件等。<br>conf 包：配置文件及全局变量。<br>log 目录：日志输出文件。<br>exception_pic 目录：失败用例的截图保存目录。<br>第二层是“服务层”：相当于对测试对象的一个业务封装。对于接口测试，是对远程方法的一个实现；对于 UI 测试，是对页面元素或操作的一个封装。</p>
<p>action 包：封装具体的页面动作，如点击、输入文本等。<br>第三层是“测试用例逻辑层”：该层主要是将服务层封装好的各个业务对象，组织成测试逻辑，进行校验。</p>
<p>bussiness_process 包：基于关键字的形式，实现单条、多条用例的测试脚本逻辑。<br>test_data 目录：Excel 数据文件，包含用例步骤、被操作对象、操作动作、操作值、测试结果等。<br>第四层是“测试场景层”：将测试用例组织成测试场景，实现各种级别 cases 的管理，如冒烟，回归等测试场景。</p>
<p>main.py：本框架工程的运行主入口。</p>
<p><img src="/assets/2/image-20220510224058-kw8qpal.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220510224106-pu6cppw.png" alt="image.png"></p>
<p>框架特点<br>基于关键字测试框架，即使不懂开发技术的测试人员也可以实施自动化测试，便于在整个测试团队中推广和使用自动化测试技术，降低自动化测试实施的技术门槛。<br>使用外部测试数据文件，使用Excel管理测试用例的集合和每个测试用例的所有执行步骤，实现在一个文件中完成测试用例的维护工作。<br>通过定义关键字、操作元素的定位方式和定位表达式和操作值，就可以实现每个测试步骤的执行，可以更加灵活地实现自动化测试的需求。<br>基于关键字的方式，可以进行任意关键字的扩展，以满足更加复杂的自动化测试需求。<br>实现定位表达式和测试代码的分离，实现定位表达式直接在数据文件中进行维护。<br>框架提供日志功能，方便调试和监控自动化测试程序的执行。</p>
<ol start="3">
<li>工程代码实现<br> action 包<br> action 包为框架第二层“服务层”，相当于对测试对象的一个业务封装。对于接口测试，是对远程方法的一个实现；对于 UI 测试，是对页面元素或操作的一个封装。</li>
</ol>
<p>page_action.py<br>该模块基于关键字格式，封装了页面操作的常用函数，如打开浏览器、点击、输入文本等。</p>
<p>  1 from selenium import webdriver<br>  2 import time<br>  3 import traceback<br>  4 from util.datetime_util import *<br>  5 from util.find_element_util import *<br>  6 from util.ini_parser import *<br>  7 from util.log_util import *<br>  8<br>  9<br> 10 DRIVER &#x3D; “”<br> 11<br> 12<br> 13 # 初始化浏览器<br> 14 def init_browser(browser_name):<br> 15     global DRIVER<br> 16     if browser_name.lower() &#x3D;&#x3D; “chrome”:<br> 17         DRIVER &#x3D; webdriver.Chrome(CHROME_DRIVER)<br> 18     elif browser_name.lower() &#x3D;&#x3D; “firefox”:<br> 19         DRIVER &#x3D; webdriver.Firefox(FIREFOX_DRIVER)<br> 20     elif browser_name.lower() &#x3D;&#x3D; “ie”:<br> 21         DRIVER &#x3D; webdriver.Ie(IE_DRIVER)<br> 22     else:<br> 23         warning(“浏览器【%s】不支持，已默认启动chrome” % browser_name)<br> 24         DRIVER &#x3D; webdriver.Chrome(CHROME_DRIVER)<br> 25<br> 26<br> 27 # 访问指定url<br> 28 def visit(url):<br> 29     global DRIVER<br> 30     DRIVER.get(url)<br> 31<br> 32<br> 33 # 输入操作<br> 34 def input(locate_method, locate_exp, value):<br> 35     global DRIVER<br> 36     # 方式1：直接传定位方式和定位表达式<br> 37     if locate_method in [“id”, “xpath”, “classname”, “name”, “tagname”, “linktext”,<br> 38                              “partial link text”, “css selector”]:<br> 39         find_element(DRIVER, locate_method, locate_exp).send_keys(value)<br> 40     # 方式2：通过ini文件的key找到value，再分割定位方式和定位表达式<br> 41     else:<br> 42         parser &#x3D; IniParser(ELEMENT_FILE_PATH)<br> 43         locate_method, locate_exp &#x3D; tuple(parser.get_value(locate_method, locate_exp).split(“&gt;”))<br> 44         find_element(DRIVER, locate_method, locate_exp).send_keys(value)<br> 45<br> 46<br> 47 # 点击操作<br> 48 def click(locate_method, locate_exp):<br> 49     global DRIVER<br> 50     # 方式1：直接传定位方式和定位表达式<br> 51     if locate_method in [“id”, “xpath”, “classname”, “name”, “tagname”, “linktext”,<br> 52                              “partial link text”, “css selector”]:<br> 53         find_element(DRIVER, locate_method, locate_exp).click()<br> 54     # 方式2：通过ini文件的key找到value，再分割定位方式和定位表达式<br> 55     else:<br> 56         parser &#x3D; IniParser(ELEMENT_FILE_PATH)<br> 57         locate_method, locate_exp &#x3D; tuple(parser.get_value(locate_method, locate_exp).split(“&gt;”))<br> 58         find_element(DRIVER, locate_method, locate_exp).click()<br> 59<br> 60<br> 61 # 清空输入框操作<br> 62 def clear(locate_method, locate_exp):<br> 63     global DRIVER<br> 64     # 方式1：直接传定位方式和定位表达式<br> 65     if locate_method in [“id”, “xpath”, “classname”, “name”, “tagname”, “linktext”,<br> 66                              “partial link text”, “css selector”]:<br> 67         find_element(DRIVER, locate_method, locate_exp).clear()<br> 68     # 方式2：通过ini文件的key找到value，再分割定位方式和定位表达式<br> 69     else:<br> 70         parser &#x3D; IniParser(ELEMENT_FILE_PATH)<br> 71         locate_method, locate_exp &#x3D; tuple(parser.get_value(locate_method, locate_exp).split(“&gt;”))<br> 72         find_element(DRIVER, locate_method, locate_exp).clear()<br> 73<br> 74<br> 75 # 切换frame<br> 76 def switch_frame(locate_method, locate_exp):<br> 77     global DRIVER<br> 78     # 方式1：直接传定位方式和定位表达式<br> 79     if locate_method in [“id”, “xpath”, “classname”, “name”, “tagname”, “linktext”,<br> 80                              “partial link text”, “css selector”]:<br> 81         DRIVER.switch_to.frame(find_element(DRIVER, locate_method, locate_exp))<br> 82     # 方式2：通过ini文件的key找到value，再分割定位方式和定位表达式<br> 83     else:<br> 84         parser &#x3D; IniParser(ELEMENT_FILE_PATH)<br> 85         locate_method, locate_exp &#x3D; tuple(parser.get_value(locate_method, locate_exp).split(“&gt;”))<br> 86         DRIVER.switch_to.frame(find_element(DRIVER, locate_method, locate_exp))<br> 87<br> 88<br> 89 # 切换主frame<br> 90 def switch_home_frame():<br> 91     global DRIVER<br> 92     DRIVER.switch_to.default_content()<br> 93<br> 94<br> 95 # 断言<br> 96 def assert_word(keyword):<br> 97     global DRIVER<br> 98     assert keyword in DRIVER.page_source<br> 99<br>100<br>101 # 休眠<br>102 def sleep(times):<br>103     time.sleep(int(times))<br>104<br>105<br>106 # 关闭浏览器<br>107 def quit():<br>108     global DRIVER<br>109     DRIVER.quit()<br>110<br>111<br>112 # 截图函数<br>113 def take_screenshot():<br>114     global DRIVER<br>115     # 创建当前日期目录<br>116     dir &#x3D; os.path.join(SCREENSHOT_PATH, get_chinese_date())<br>117     if not os.path.exists(dir):<br>118         os.makedirs(dir)<br>119     # 以当前时间为文件名<br>120     file_name &#x3D; get_chinese_time()<br>121     file_path &#x3D; os.path.join(dir, file_name+”.png”)<br>122     try:<br>123         DRIVER.get_screenshot_as_file(file_path)<br>124         # 返回截图文件的绝对路径<br>125         return file_path<br>126     except:<br>127         error(“截图发生异常【{}】\n{}”.format(file_path, traceback.format_exc()))<br>128         return file_path<br>129<br>130<br>131 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>132     init_browser(“chrome”)<br>133     visit(“<a href="http://mail.126.com&quot;/">http://mail.126.com&quot;</a>)<br>134     print(take_screenshot())</p>
<p>business_process 包<br>business_process 包是框架第三层“测试用例逻辑层”，该层主要是将服务层封装好的各个业务对象，组织成测试逻辑，进行校验。</p>
<p>case_process.py<br>测试用例文件的一行数据，拼接其中的操作动作、操作对象、操作值等关键字，形成与 page_action.py 中的函数相对应的字符串，并通过 eval() 转成表达式以执行用例。<br>记录该用例的测试结果，如测试执行结果、测试执行时间等。<br>如需数据驱动的用例集，则获取数据驱动的数据源集合，循环将每组数据传递给用例步骤。<br>如果遇到需要参数化的值 ${变量名}，则根据数据驱动的数据源，根据变量名进行参数化。</p>
<p> 1 import traceback<br> 2 import re<br> 3 from util.global_var import *<br> 4 from util.log_util import *<br> 5 from util.datetime_util import *<br> 6 from util.excel_util import Excel<br> 7 from action.page_action import *<br> 8<br> 9<br>10 # 执行一条测试用例（即一行测试数据）<br>11 def execute_case(excel_file_path, case_data, test_data_source&#x3D;None):<br>12     # 用例数据格式校验<br>13     if not isinstance(case_data, (list, tuple)):<br>14         error(“测试用例数据格式有误！测试数据应为列表或元组类型！【%s】” % case_data)<br>15         case_data[TEST_SCRIPT_EXCEPTION_INFO_COL] &#x3D; “测试用例数据格式有误！应为列表或元组类型！【%s】” % case_data<br>16         case_data[TEST_SCRIPT_TEST_RESULT_COL] &#x3D; “Fail”<br>17     # 该用例无需执行<br>18     if case_data[TEST_SCRIPT_IS_EXECUTE_COL].lower() &#x3D;&#x3D; “n”:<br>19         info(“测试用例步骤【%s】无需执行” % case_data[TEST_SCRIPT_NAME_COL])<br>20         return<br>21     # excel对象初始化<br>22     if isinstance(excel_file_path, Excel):<br>23         excel &#x3D; excel_file_path  # 如果传入的是excel对象，则直接使用<br>24     else:<br>25         excel &#x3D; Excel(excel_file_path)  # 如果传入的是文件路径，则初始化excel对象<br>26     # 获取各关键字<br>27     operation_action &#x3D; case_data[TEST_SCRIPT_ACTION_COL]  # 操作动作（即函数名）<br>28     locate_method &#x3D; case_data[TEST_SCRIPT_LOCATE_METHOD_COL]  # 定位方式<br>29     locate_expression &#x3D; case_data[TEST_SCRIPT_LOCATE_EXPRESSION_COL]  # 定位表达式<br>30     operation_value &#x3D; case_data[TEST_SCRIPT_VALUE_COL]  # 操作值<br>31     # 由于数据驱动，需要进行参数化的值<br>32     if test_data_source:<br>33         if re.search(r”${\w+}“, str(operation_value)):<br>34             # 取出需要参数化的值<br>35             key &#x3D; re.search(r”${(\w+)}“, str(operation_value)).group(1)<br>36             operation_value &#x3D; re.sub(r”${\w+}“, str(test_data_source[key]), str(operation_value))<br>37             # 将参数化后的值回写excel测试结果中，便于回溯<br>38             case_data[TEST_SCRIPT_VALUE_COL] &#x3D; operation_value<br>39     # 拼接关键字函数<br>40     if locate_method and locate_expression:<br>41         if operation_value:<br>42             func &#x3D; “%s(‘%s’, ‘%s’, ‘%s’)” % (operation_action, locate_method, locate_expression, operation_value)<br>43         else:<br>44             func &#x3D; “%s(‘%s’, ‘%s’)” % (operation_action, locate_method, locate_expression)<br>45     else:<br>46         if operation_value:<br>47             func &#x3D; “%s(‘%s’)” % (operation_action, operation_value)<br>48         else:<br>49             func &#x3D; “%s()” % operation_action<br>50     # 执行用例<br>51     try:<br>52         eval(func)<br>53         info(“测试用例步骤执行成功：【{}】 {}”.format(case_data[TEST_SCRIPT_NAME_COL], func))<br>54         case_data[TEST_SCRIPT_TEST_RESULT_COL] &#x3D; “Pass”<br>55     except:<br>56         info(“测试用例步骤执行失败：【{}】 {}”.format(case_data[TEST_SCRIPT_NAME_COL], func))<br>57         case_data[TEST_SCRIPT_TEST_RESULT_COL] &#x3D; “Fail”<br>58         error(traceback.format_exc())<br>59         # 进行截图<br>60         case_data[TEST_SCRIPT_SCREENSHOT_PATH_COL] &#x3D; take_screenshot()<br>61         # 异常信息记录<br>62         case_data[TEST_SCRIPT_EXCEPTION_INFO_COL] &#x3D; traceback.format_exc()<br>63     # 测试时间记录<br>64     case_data[TEST_SCRIPT_TEST_TIME_COL] &#x3D; get_english_datetime()<br>65     return case_data<br>66<br>67<br>68 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>69     excel &#x3D; Excel(TEST_DATA_FILE_PATH)<br>70     excel.get_sheet(“登录（调试用）”)<br>71     all_data &#x3D; excel.get_all_row_data()<br>72     for data in all_data[1:]:<br>73         execute_case(excel, data)</p>
<p>data_source_process.py<br>本模块实现了获取数据驱动所需的数据源集合。</p>
<p>根据数据源 sheet 名，获取该 sheet 所有行数据，每行数据作为一组测试数据。<br>每行数据作为一个字典，存储在一个列表中。如 [{“登录用户名”: “xxx”, “登录密码”: “xxx”, …}, {…}, …]</p>
<p> 1 from util.excel_util import Excel<br> 2 from util.global_var import *<br> 3 from util.log_util import *<br> 4<br> 5<br> 6 # 数据驱动<br> 7 # 每行数据作为一个字典，存储在一个列表中。如[{“登录用户名”: “xxx”, “登录密码”: “xxx”, …}, {…}, …]<br> 8 def get_test_data(excel_file_path, sheet_name):<br> 9     # excel对象初始化<br>10     if isinstance(excel_file_path, Excel):<br>11         excel &#x3D; excel_file_path<br>12     else:<br>13         excel &#x3D; Excel(excel_file_path)<br>14     # 校验sheet名<br>15     if not excel.get_sheet(sheet_name):<br>16         error(“sheet【】不存在，停止执行！” % sheet_name)<br>17         return<br>18     result_list &#x3D; []<br>19     all_row_data &#x3D; excel.get_all_row_data()<br>20     if len(all_row_data) &lt;&#x3D; 1:<br>21         error(“sheet【】数据不大于1行，停止执行！” % sheet_name)<br>22         return<br>23     # 将参数化的测试数据存入全局字典<br>24     head_line_data &#x3D; all_row_data[0]<br>25     for data in all_row_data[1:]:<br>26         if data[-1].lower() &#x3D;&#x3D; “n”:<br>27             continue<br>28         row_dict &#x3D; {}<br>29         # 最后一列为“是否执行”列，无需取值<br>30         for i in range(len(data[:-1])):<br>31             row_dict[head_line_data[i]] &#x3D; data[i]<br>32         result_list.append(row_dict)<br>33     return result_list<br>34<br>35<br>36 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>37     from util.global_var import *<br>38     print(get_test_data(TEST_DATA_FILE_PATH, “搜索词”))<br>39     # [{‘搜索词’: ‘python’, ‘断言词’: ‘python’}, {‘搜索词’: ‘mysql’, ‘断言词’: ‘mysql5.6’}]</p>
<p>main_process.py<br>本模块基于 case_process.py 和 data_source_process.py，实现关键字驱动+数据驱动的测试用例集的执行。</p>
<p>suite_process()：执行具体的测试用例步骤 sheet（如“登录”sheet、“添加联系人”sheet 等）<br>main_suite_process()：执行“测试用例”主 sheet 的用例集。每行用例集对应一个用例步骤 sheet 和数据源 sheet。</p>
<p>  1 from util.excel_util import *<br>  2 from util.datetime_util import *<br>  3 from util.log_util import *<br>  4 from util.global_var import *<br>  5 from business_process.case_process import execute_case<br>  6 from business_process.data_source_process import get_test_data<br>  7<br>  8<br>  9 # 执行具体模块的用例sheet（登录sheet，添加联系人sheet等）<br> 10 def suite_process(excel_file_path, sheet_name, test_data_source&#x3D;None):<br> 11     “””<br> 12     :param excel_file_path: excel文件绝对路径或excel对象<br> 13     :param sheet_name: 测试步骤sheet名<br> 14     :param test_data_source: 数据驱动的数据源，默认没有<br> 15     :return:<br> 16     “””<br> 17     # 记录测试结果统计<br> 18     global TOTAL_CASE<br> 19     global PASS_CASE<br> 20     global FAIL_CASE<br> 21     # 整个用例sheet的测试结果，默认为全部通过<br> 22     suite_test_result &#x3D; True<br> 23     # excel对象初始化<br> 24     if isinstance(excel_file_path, Excel):<br> 25         excel &#x3D; excel_file_path<br> 26     else:<br> 27         excel &#x3D; Excel(excel_file_path)<br> 28     if not excel.get_sheet(sheet_name):<br> 29         error(“sheet【%s】不存在，停止执行！” % sheet_name)<br> 30         return<br> 31     # 获取测试用例集sheet的全部行数据<br> 32     all_row_data &#x3D; excel.get_all_row_data()<br> 33     if len(all_row_data) &lt;&#x3D; 1:<br> 34         error(“sheet【%s】数据不大于1行，停止执行！” % sheet_name)<br> 35         return<br> 36     # 标题行数据<br> 37     head_line_data &#x3D; all_row_data[0]<br> 38     # 切换到测试结果明细sheet，准备写入测试结果<br> 39     if not excel.get_sheet(“测试结果明细”):<br> 40         error(“【测试结果明细】sheet不存在，停止执行！”)<br> 41         return<br> 42     excel.write_row_data(head_line_data, None, True, “green”)<br> 43     # 执行每行的测试用例<br> 44     for row_data in all_row_data[1:]:<br> 45         result_data &#x3D; execute_case(excel, row_data, test_data_source)<br> 46         # 无需执行的测试步骤，跳过<br> 47         if result_data is None:<br> 48             continue<br> 49         TOTAL_CASE +&#x3D; 1<br> 50         if result_data[TEST_SCRIPT_TEST_RESULT_COL].lower() &#x3D;&#x3D; “fail”:<br> 51             suite_test_result &#x3D; False<br> 52             FAIL_CASE +&#x3D; 1<br> 53         else:<br> 54             PASS_CASE +&#x3D; 1<br> 55         excel.write_row_data(result_data)<br> 56     # 切换到测试结果统计sheet，写入统计数据<br> 57     if not excel.get_sheet(“测试结果统计”):<br> 58         error(“【测试结果统计】sheet不存在，停止执行！”)<br> 59         return<br> 60     excel.insert_row_data(1, [TOTAL_CASE, PASS_CASE, FAIL_CASE])<br> 61     return excel, suite_test_result<br> 62<br> 63<br> 64 # 执行【测试用例集】主sheet的用例集<br> 65 def main_suite_process(excel_file_path, sheet_name):<br> 66     # 初始化excel对象<br> 67     excel &#x3D; Excel(excel_file_path)<br> 68     if not excel:<br> 69         error(“excel数据文件【%s】不存在！” % excel_file_path)<br> 70         return<br> 71     if not excel.get_sheet(sheet_name):<br> 72         error(“sheet名称【%s】不存在！” % sheet_name)<br> 73         return<br> 74     # 获取所有行数据<br> 75     all_row_datas &#x3D; excel.get_all_row_data()<br> 76     if len(all_row_datas) &lt;&#x3D; 1:<br> 77         error(“sheet【%s】数据不大于1行，停止执行！” % sheet_name)<br> 78         return<br> 79     # 标题行数据<br> 80     head_line_data &#x3D; all_row_datas[0]<br> 81     for row_data in all_row_datas[1:]:<br> 82         # 校验用例步骤sheet名是否存在<br> 83         if row_data[MAIN_CASE_SCRIPT_SHEET_COL] not in excel.get_all_sheet():<br> 84             error(“#” * 50 + “ 用例步骤集【%s】不存在！ “ % row_data[MAIN_CASE_SCRIPT_SHEET_COL] + “#” * 50 + “\n”)<br> 85             row_data[MAIN_CASE_TEST_RESULT_COL] &#x3D; “Fail”<br> 86             excel.write_row_data(head_line_data, None, True, “red”)<br> 87             excel.write_row_data(row_data)<br> 88             continue<br> 89         # 跳过不需要执行的测试用例集<br> 90         if row_data[MAIN_CASE_IS_EXECUTE_COL].lower() &#x3D;&#x3D; “n”:<br> 91             info(“#” * 50 + “ 测试用例集【%s】无需执行！” % row_data[MAIN_CASE_CASE_NAME_COL] + “#” * 50 + “\n”)<br> 92             continue<br> 93         # 记录本用例集的测试时间<br> 94         row_data[MAIN_CASE_TEST_TIME_COL] &#x3D; get_english_datetime()<br> 95         # 判断本测试用例集是否进行数据驱动<br> 96         if row_data[MAIN_CASE_DATA_SOURCE_SHEET_COL]:<br> 97             # 校验测试数据集sheet名是否存在<br> 98             if row_data[MAIN_CASE_DATA_SOURCE_SHEET_COL] not in excel.get_all_sheet():<br> 99                 error(“#” * 50 + “ 测试数据集【%s】不存在！ “ % row_data[MAIN_CASE_DATA_SOURCE_SHEET_COL] + “#” * 50 + “\n”)<br>100                 row_data[MAIN_CASE_TEST_RESULT_COL] &#x3D; “Fail”<br>101                 excel.write_row_data(head_line_data, None, True, “red”)<br>102                 excel.write_row_data(row_data)<br>103                 continue<br>104             # 获取测试数据集<br>105             test_data_source &#x3D; get_test_data(excel, row_data[MAIN_CASE_DATA_SOURCE_SHEET_COL])<br>106             # 每条数据进行一次本用例集的测试<br>107             for data_source in test_data_source:<br>108                 info(“-“ * 50 + “ 测试用例集【%s】开始执行！” % row_data[MAIN_CASE_CASE_NAME_COL] + “-“ * 50)<br>109                 excel, test_result_flag &#x3D; suite_process(excel, row_data[MAIN_CASE_SCRIPT_SHEET_COL], data_source)<br>110                 # 记录本用例集的测试结果<br>111                 if test_result_flag:<br>112                     info(“#” * 50 + “ 测试用例集【%s】执行成功！ “ % row_data[MAIN_CASE_CASE_NAME_COL] + “#” * 50 + “\n”)<br>113                     row_data[MAIN_CASE_TEST_RESULT_COL] &#x3D; “Pass”<br>114                 else:<br>115                     error(“#” * 50 + “ 测试用例集【%s】执行失败！ “ % row_data[MAIN_CASE_CASE_NAME_COL] + “#” * 50 + “\n”)<br>116                     row_data[MAIN_CASE_TEST_RESULT_COL] &#x3D; “Fail”<br>117                 # 全部测试步骤结果写入后，最后写入本用例集的标题行和测试结果行数据<br>118                 # 切换到“测试结果明细”sheet，以写入测试执行结果<br>119                 excel.get_sheet(“测试结果明细”)<br>120                 excel.write_row_data(head_line_data, None, True, “red”)<br>121                 excel.write_row_data(row_data)<br>122         # 本用例集无需数据驱动<br>123         else:<br>124             info(“-“ * 50 + “ 测试用例集【%s】开始执行！” % row_data[MAIN_CASE_CASE_NAME_COL] + “-“ * 50)<br>125             excel, test_result_flag &#x3D; suite_process(excel, row_data[MAIN_CASE_SCRIPT_SHEET_COL])<br>126             # 记录本用例集的测试结果<br>127             if test_result_flag:<br>128                 info(“#” * 50 + “ 测试用例集【%s】执行成功！ “ % row_data[MAIN_CASE_SCRIPT_SHEET_COL] + “#” * 50 + “\n”)<br>129                 row_data[MAIN_CASE_TEST_RESULT_COL] &#x3D; “Pass”<br>130             else:<br>131                 error(“#” * 50 + “ 测试用例集【%s】执行失败！ “ % row_data[MAIN_CASE_SCRIPT_SHEET_COL] + “#” * 50 + “\n”)<br>132                 row_data[MAIN_CASE_TEST_RESULT_COL] &#x3D; “Fail”<br>133             # 全部测试步骤结果写入后，最后写入本用例集的标题行和测试结果行数据<br>134             # 切换到“测试结果明细”sheet，以写入测试执行结果<br>135             excel.get_sheet(“测试结果明细”)<br>136             excel.write_row_data(head_line_data, None, True, “red”)<br>137             excel.write_row_data(row_data)<br>138     return excel<br>139<br>140<br>141 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>142     from util.report_util import create_excel_report_and_send_email<br>143     # excel, _ &#x3D; suite_process(TEST_DATA_FILE_PATH_1, “登录1”)<br>144     excel &#x3D; main_suite_process(TEST_DATA_FILE_PATH, “测试用例集”)<br>145     create_excel_report_and_send_email(excel, “<a href="mailto:&#x31;&#x38;&#x32;&#x32;&#x33;&#x30;&#49;&#x32;&#x34;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#x31;&#x38;&#x32;&#x32;&#x33;&#x30;&#49;&#x32;&#x34;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>“, “UI自动化测试”, “请查收附件：UI自动化测试报告”)</p>
<p>util 包<br>util 包属于第一层的测试工具层：用于实现测试过程中调用的工具类方法，例如读取配置文件、页面元素的操作方法、操作 Excel 文件、生成测试报告、发送邮件等。</p>
<p>global_var.py<br>本模块用于定义测试过程中所需的全局变量。</p>
<p> 1 import os<br> 2<br> 3<br> 4 # 工程根路径<br> 5 PROJECT_ROOT_PATH &#x3D; os.path.dirname(os.path.dirname(os.path.abspath(<strong>file</strong>)))<br> 6<br> 7 # 元素定位方法的ini配置文件路径<br> 8 ELEMENT_FILE_PATH &#x3D; os.path.join(PROJECT_ROOT_PATH, “conf”, “ElementsRepository.ini”)<br> 9<br>10 # excel文件路径<br>11 TEST_DATA_FILE_PATH &#x3D; os.path.join(PROJECT_ROOT_PATH, “test_data”, “test_case.xlsx”)<br>12<br>13 # 驱动路径<br>14 CHROME_DRIVER &#x3D; “E:\auto_test_driver\chromedriver.exe”<br>15 IE_DRIVER &#x3D; “E:\auto_test_driver\IEDriverServer.exe”<br>16 FIREFOX_DRIVER &#x3D; “E:\auto_test_driver\geckodriver.exe”<br>17<br>18 # 截图路径<br>19 SCREENSHOT_PATH &#x3D; os.path.join(PROJECT_ROOT_PATH, “exception_pic”)<br>20<br>21 # 日志配置文件路径<br>22 LOG_CONF_FILE_PATH &#x3D; os.path.join(PROJECT_ROOT_PATH, “conf”, “Logger.conf”)<br>23<br>24 # 测试报告存放路径<br>25 TEST_REPORT_FILE_DIR &#x3D; os.path.join(PROJECT_ROOT_PATH, “test_report”)<br>26<br>27 # 对应excel测试数据文件中具体模块sheet中的列号<br>28 TEST_SCRIPT_NAME_COL &#x3D; 1<br>29 TEST_SCRIPT_ACTION_COL &#x3D; 2<br>30 TEST_SCRIPT_LOCATE_METHOD_COL &#x3D; 3<br>31 TEST_SCRIPT_LOCATE_EXPRESSION_COL &#x3D; 4<br>32 TEST_SCRIPT_VALUE_COL &#x3D; 5<br>33 TEST_SCRIPT_IS_EXECUTE_COL &#x3D; 6<br>34 TEST_SCRIPT_TEST_TIME_COL &#x3D; 7<br>35 TEST_SCRIPT_TEST_RESULT_COL &#x3D; 8<br>36 TEST_SCRIPT_EXCEPTION_INFO_COL &#x3D; 9<br>37 TEST_SCRIPT_SCREENSHOT_PATH_COL &#x3D; 10<br>38<br>39 # 对应excel测试数据文件中“测试用例集”sheet列号<br>40 MAIN_CASE_CASE_NAME_COL &#x3D; 3<br>41 MAIN_CASE_BROWSER_NAME_COL &#x3D; 5<br>42 MAIN_CASE_SCRIPT_SHEET_COL &#x3D; 6<br>43 MAIN_CASE_DATA_SOURCE_SHEET_COL &#x3D; 7<br>44 MAIN_CASE_IS_EXECUTE_COL &#x3D; 8<br>45 MAIN_CASE_TEST_TIME_COL &#x3D; 9<br>46 MAIN_CASE_TEST_RESULT_COL &#x3D; 10<br>47<br>48 # 测试结果统计<br>49 TOTAL_CASE &#x3D; 0<br>50 PASS_CASE &#x3D; 0<br>51 FAIL_CASE &#x3D; 0<br>52<br>53<br>54 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>55     print(PROJECT_ROOT_PATH)</p>
<p>find_element_util.py<br>本模块封装了基于显式等待的界面元素定位方法。</p>
<p> 1 from selenium.webdriver.support.ui import WebDriverWait<br> 2<br> 3<br> 4 # 显式等待一个元素<br> 5 def find_element(driver, locate_method, locate_exp):<br> 6     # 显式等待对象（最多等10秒，每0.2秒判断一次等待的条件）<br> 7     return WebDriverWait(driver, 10, 0.2).until(lambda x: x.find_element(locate_method, locate_exp))<br> 8<br> 9 # 显式等待一组元素<br>10 def find_elements(driver, locate_method, locate_exp):<br>11     # 显式等待对象（最多等10秒，每0.2秒判断一次等待的条件）<br>12     return WebDriverWait(driver, 10, 0.2).until(lambda x: x.find_elements(locate_method, locate_exp))</p>
<p>excel_util.py<br>本模块封装了对 excel 的读写操作（openpyxl 版本：3.0.4）。</p>
<p>  1 import os<br>  2 from openpyxl import load_workbook<br>  3 from openpyxl.styles import PatternFill, Font, Side, Border<br>  4 from util.datetime_util import *<br>  5 from util.global_var import *<br>  6 from util.log_util import *<br>  7<br>  8<br>  9 # 支持excel读写操作的工具类<br> 10 class Excel:<br> 11<br> 12     # 初始化读取excel文件<br> 13     def <strong>init</strong>(self, file_path):<br> 14         if not os.path.exists(file_path):<br> 15             return<br> 16         self.wb &#x3D; load_workbook(file_path)<br> 17         # 初始化默认sheet<br> 18         self.ws &#x3D; self.wb.active<br> 19         self.data_file_path &#x3D; file_path<br> 20         # 初始化颜色字典，供设置样式用<br> 21         self.color_dict &#x3D; {“red”: “FFFF3030”, “green”: “FF008B00”}<br> 22<br> 23     def get_all_sheet(self):<br> 24         return self.wb.get_sheet_names()<br> 25<br> 26     # 打开指定sheet<br> 27     def get_sheet(self, sheet_name):<br> 28         if sheet_name not in self.get_all_sheet():<br> 29             error(“sheet名称【%s】不存在！” % sheet_name)<br> 30             return<br> 31         self.ws &#x3D; self.wb.get_sheet_by_name(sheet_name)<br> 32         return True<br> 33<br> 34     # 获取最大行号<br> 35     def get_max_row_no(self):<br> 36         # openpyxl的API的行、列索引默认都从1开始<br> 37         return self.ws.max_row<br> 38<br> 39     # 获取最大列号<br> 40     def get_max_col_no(self):<br> 41         return self.ws.max_column<br> 42<br> 43     # 获取所有行数据<br> 44     def get_all_row_data(self, head_line&#x3D;True):<br> 45         # 是否需要标题行数据的标识，默认需要<br> 46         if head_line:<br> 47             min_row &#x3D; 1  # 行号从1开始，即1为标题行<br> 48         else:<br> 49             min_row &#x3D; 2<br> 50         result &#x3D; []<br> 51         # min_row&#x3D;None：默认获取标题行数据<br> 52         for row in self.ws.iter_rows(min_row&#x3D;min_row, max_row&#x3D;self.get_max_row_no(), max_col&#x3D;self.get_max_col_no()):<br> 53             result.append([cell.value for cell in row])<br> 54         return result<br> 55<br> 56     # 获取指定行数据<br> 57     def get_row_data(self, row_num):<br> 58         # 0 为标题行<br> 59         return [cell.value for cell in self.ws[row_num+1]]<br> 60<br> 61     # 获取指定列数据<br> 62     def get_col_data(self, col_num):<br> 63         # 索引从0开始<br> 64         return [cell.value for cell in tuple(self.ws.columns)[col_num]]<br> 65<br> 66     # 追加行数据且可以设置样式<br> 67     def write_row_data(self, data, font_color&#x3D;None, border&#x3D;True, fill_color&#x3D;None):<br> 68         if not isinstance(data, (list, tuple)):<br> 69             print(“写入数据失败：数据不为列表或元组类型！【%s】” % data)<br> 70         self.ws.append(data)<br> 71         # 设置字体颜色<br> 72         if font_color:<br> 73             if font_color.lower() in self.color_dict.keys():<br> 74                 font_color &#x3D; self.color_dict[font_color]<br> 75         # 设置单元格填充颜色<br> 76         if fill_color:<br> 77             if fill_color.lower() in self.color_dict.keys():<br> 78                 fill_color &#x3D; self.color_dict[fill_color]<br> 79         # 设置单元格边框<br> 80         if border:<br> 81             bd &#x3D; Side(style&#x3D;”thin”, color&#x3D;”000000”)<br> 82         # 记录数据长度（否则会默认与之前行最长数据行的长度相同，导致样式超过了该行实际长度）<br> 83         count &#x3D; 0<br> 84         for cell in self.ws[self.get_max_row_no()]:<br> 85             # 设置完该行的实际数据长度样式后，则退出<br> 86             if count &gt; len(data) - 1:<br> 87                 break<br> 88             if font_color:<br> 89                 cell.font &#x3D; Font(color&#x3D;font_color)<br> 90             # 如果没有设置字体颜色，则默认给执行结果添加字体颜色<br> 91             else:<br> 92                 if cell.value is not None and isinstance(cell.value, str):<br> 93                     if cell.value.lower() &#x3D;&#x3D; “pass” or cell.value &#x3D;&#x3D; “成功”:<br> 94                         cell.font &#x3D; Font(color&#x3D;self.color_dict[“green”])<br> 95                     elif cell.value.lower() &#x3D;&#x3D; “fail” or cell.value &#x3D;&#x3D; “失败”:<br> 96                         cell.font &#x3D; Font(color&#x3D;self.color_dict[“red”])<br> 97             if border:<br> 98                 cell.border &#x3D; Border(left&#x3D;bd, right&#x3D;bd, top&#x3D;bd, bottom&#x3D;bd)<br> 99             if fill_color:<br>100                 cell.fill &#x3D; PatternFill(fill_type&#x3D;”solid”, fgColor&#x3D;fill_color)<br>101             count +&#x3D; 1<br>102<br>103     # 指定行插入数据（行索引从0开始）<br>104     def insert_row_data(self, row_no, data, font_color&#x3D;None, border&#x3D;True, fill_color&#x3D;None):<br>105         if not isinstance(data, (list, tuple)):<br>106             print(“写入数据失败：数据不为列表或元组类型！【%s】” % data)<br>107         for idx, cell in enumerate(self.ws[row_no+1]):  # 此处行索引从1开始<br>108             cell.value &#x3D; data[idx]<br>109<br>110     # 生成写入了测试结果的excel数据文件<br>111     def save(self, save_file_name, timestamp):<br>112         save_dir &#x3D; os.path.join(TEST_REPORT_FILE_DIR, get_chinese_date())<br>113         if not os.path.exists(save_dir):<br>114             os.mkdir(save_dir)<br>115         save_file &#x3D; os.path.join(save_dir, save_file_name + “_” + timestamp + “.xlsx”)<br>116         self.wb.save(save_file)<br>117         info(“生成测试结果文件：%s” % save_file)<br>118         return save_file<br>119<br>120<br>121 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>122     from util.global_var import *<br>123     from util.datetime_util import *<br>124     excel &#x3D; Excel(TEST_DATA_FILE_PATH)<br>125     excel.get_sheet(“测试结果统计”)<br>126     # print(excel.get_all_row_data())<br>127     # print(excel.get_row_data(1))<br>128     # print(excel.get_col_data(1))<br>129     # excel.write_row_data([“4”, None, “嘻哈”], “green”, True, “red”)<br>130     excel.insert_row_data(1, [1,2,3])<br>131     excel.save(get_timestamp())</p>
<p>ini_reader.py<br>本模块封装了对 ini 配置文件的读取操作。</p>
<p> 1 import configparser<br> 2<br> 3<br> 4 class IniParser:<br> 5<br> 6     # 初始化打开指定ini文件并指定编码<br> 7     def <strong>init</strong>(self, file_path):<br> 8         self.cf &#x3D; configparser.ConfigParser()<br> 9         self.cf.read(file_path, encoding&#x3D;”utf-8”)<br>10<br>11     # 获取所有分组名称<br>12     def get_sections(self):<br>13         return self.cf.sections()<br>14<br>15     # 获取指定分组的所有键<br>16     def get_options(self, section):<br>17         return self.cf.options(section)<br>18<br>19     # 获取指定分组的键值对<br>20     def get_items(self, section):<br>21         return self.cf.items(section)<br>22<br>23     # 获取指定分组的指定键的值<br>24     def get_value(self, section, key):<br>25         return self.cf.get(section, key)<br>26<br>27<br>28 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>29     from conf.global_var import *<br>30     parser &#x3D; IniParser(ELEMENT_FILE_PATH)<br>31     print(parser.get_sections())<br>32     print(parser.get_options(“126mail_indexPage”))<br>33     print(parser.get_value(“126mail_indexPage”, ‘indexpage.frame’))</p>
<p>email_util.py<br>本模块封装了邮件发送功能。（示例代码中的用户名&#x2F;密码已隐藏）</p>
<p> 1 import yagmail<br> 2 import traceback<br> 3 from util.log_util import *<br> 4<br> 5<br> 6 def send_mail(attachments_report_name, receiver, subject, content):<br> 7     try:<br> 8         # 连接邮箱服务器<br> 9         # 注意：若使用QQ邮箱，则password为授权码而非邮箱密码；使用其它邮箱则为邮箱密码<br>10         # encoding设置为GBK，否则中文附件名会乱码<br>11         yag &#x3D; yagmail.SMTP(user&#x3D;”<strong><strong><strong>@163.com”, password&#x3D;”</strong></strong></strong>“, host&#x3D;”smtp.163.com”, encoding&#x3D;’GBK’)<br>12<br>13         # 收件人、标题、正文、附件（若多个收件人或多个附件，则可使用列表）<br>14         yag.send(to&#x3D;receiver, subject&#x3D;subject, contents&#x3D;content, attachments&#x3D;attachments_report_name)<br>15<br>16         # 可简写：yag.send(“****@163.com”, subject, contents, report)<br>17<br>18         info(“测试报告邮件发送成功!【邮件标题：%s】【邮件附件：%s】【收件人：%s】” % (subject, attachments_report_name, receiver))<br>19     except:<br>20         error(“测试报告邮件发送失败!【邮件标题：%s】【邮件附件：%s】【收件人：%s】” % (subject, attachments_report_name, receiver))<br>21         error(traceback.format_exc())<br>22<br>23<br>24 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>25    send_mail(“e:\code.txt”, “<a href="mailto:&#49;&#x38;&#x32;&#x32;&#51;&#48;&#x31;&#50;&#x34;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#x38;&#x32;&#x32;&#51;&#48;&#x31;&#50;&#x34;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>“, “测试邮件”, “正文”)</p>
<p>datetime_util.py<br>该模块实现了获取各种格式的当前日期时间。</p>
<p> 1 import time<br> 2<br> 3<br> 4 # 返回中文格式的日期：xxxx年xx月xx日<br> 5 def get_chinese_date():<br> 6     year &#x3D; time.localtime().tm_year<br> 7     if len(str(year)) &#x3D;&#x3D; 1:<br> 8         year &#x3D; “0” + str(year)<br> 9     month &#x3D; time.localtime().tm_mon<br>10     if len(str(month)) &#x3D;&#x3D; 1:<br>11         month &#x3D; “0” + str(month)<br>12     day &#x3D; time.localtime().tm_mday<br>13     if len(str(day)) &#x3D;&#x3D; 1:<br>14         day &#x3D; “0” + str(day)<br>15     return “{}年{}月{}日”.format(year, month, day)<br>16<br>17<br>18 # 返回英文格式的日期：xxxx&#x2F;xx&#x2F;xx<br>19 def get_english_date():<br>20     year &#x3D; time.localtime().tm_year<br>21     if len(str(year)) &#x3D;&#x3D; 1:<br>22         year &#x3D; “0” + str(year)<br>23     month &#x3D; time.localtime().tm_mon<br>24     if len(str(month)) &#x3D;&#x3D; 1:<br>25         month &#x3D; “0” + str(month)<br>26     day &#x3D; time.localtime().tm_mday<br>27     if len(str(day)) &#x3D;&#x3D; 1:<br>28         day &#x3D; “0” + str(day)<br>29     return “{}&#x2F;{}&#x2F;{}”.format(year, month, day)<br>30<br>31<br>32 # 返回中文格式的时间：xx时xx分xx秒<br>33 def get_chinese_time():<br>34     hour &#x3D; time.localtime().tm_hour<br>35     if len(str(hour)) &#x3D;&#x3D; 1:<br>36         hour &#x3D; “0” + str(hour)<br>37     minute &#x3D; time.localtime().tm_min<br>38     if len(str(minute)) &#x3D;&#x3D; 1:<br>39         minute &#x3D; “0” + str(minute)<br>40     second &#x3D; time.localtime().tm_sec<br>41     if len(str(second)) &#x3D;&#x3D; 1:<br>42         second &#x3D; “0” + str(second)<br>43     return “{}时{}分{}秒”.format(hour, minute, second)<br>44<br>45<br>46 # 返回英文格式的时间：xx:xx:xx<br>47 def get_english_time():<br>48     hour &#x3D; time.localtime().tm_hour<br>49     if len(str(hour)) &#x3D;&#x3D; 1:<br>50         hour &#x3D; “0” + str(hour)<br>51     minute &#x3D; time.localtime().tm_min<br>52     if len(str(minute)) &#x3D;&#x3D; 1:<br>53         minute &#x3D; “0” + str(minute)<br>54     second &#x3D; time.localtime().tm_sec<br>55     if len(str(second)) &#x3D;&#x3D; 1:<br>56         second &#x3D; “0” + str(second)<br>57     return “{}:{}:{}”.format(hour, minute, second)<br>58<br>59<br>60 # 返回中文格式的日期时间<br>61 def get_chinese_datetime():<br>62     return get_chinese_date() + “ “ + get_chinese_time()<br>63<br>64<br>65 # 返回英文格式的日期时间<br>66 def get_english_datetime():<br>67     return get_english_date() + “ “ + get_english_time()<br>68<br>69<br>70 # 返回时间戳<br>71 def get_timestamp():<br>72     year &#x3D; time.localtime().tm_year<br>73     if len(str(year)) &#x3D;&#x3D; 1:<br>74         year &#x3D; “0” + str(year)<br>75     month &#x3D; time.localtime().tm_mon<br>76     if len(str(month)) &#x3D;&#x3D; 1:<br>77         month &#x3D; “0” + str(month)<br>78     day &#x3D; time.localtime().tm_mday<br>79     if len(str(day)) &#x3D;&#x3D; 1:<br>80         day &#x3D; “0” + str(day)<br>81     hour &#x3D; time.localtime().tm_hour<br>82     if len(str(hour)) &#x3D;&#x3D; 1:<br>83         hour &#x3D; “0” + str(hour)<br>84     minute &#x3D; time.localtime().tm_min<br>85     if len(str(minute)) &#x3D;&#x3D; 1:<br>86         minute &#x3D; “0” + str(minute)<br>87     second &#x3D; time.localtime().tm_sec<br>88     if len(str(second)) &#x3D;&#x3D; 1:<br>89         second &#x3D; “0” + str(second)<br>90     return “{}{}{}_{}{}{}”.format(year, month, day, hour, minute, second)<br>91<br>92<br>93 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>94     print(get_chinese_datetime())<br>95     print(get_english_datetime())</p>
<p>log_util.py<br>该模块封装了日志打印输出、级别设定等功能。</p>
<p> 1 import logging<br> 2 import logging.config<br> 3 from conf.global_var import *<br> 4<br> 5<br> 6 # 日志配置文件：多个logger，每个logger指定不同的handler<br> 7 # handler：设定了日志输出行的格式<br> 8 #          以及设定写日志到文件（是否回滚）？还是到屏幕<br> 9 #          还定了打印日志的级别<br>10 logging.config.fileConfig(LOG_CONF_FILE_PATH)<br>11 logger &#x3D; logging.getLogger(“example01”)<br>12<br>13<br>14 def debug(message):<br>15     logging.debug(message)<br>16<br>17<br>18 def info(message):<br>19     logging.info(message)<br>20<br>21<br>22 def warning(message):<br>23     logging.warning(message)<br>24<br>25<br>26 def error(message):<br>27     logging.error(message)<br>28<br>29<br>30 if <strong>name</strong>&#x3D;&#x3D;”<strong>main</strong>“:<br>31     debug(“hi”)<br>32     info(“hiphop”)<br>33     warning(“hello”)<br>34     error(“这是一个error日志”)</p>
<p>report_util.py<br>生成测试结果文件并发送邮件。</p>
<p> 1 from util.email_util import send_mail<br> 2 from util.datetime_util import *<br> 3<br> 4<br> 5 # 生成测试报告并发送邮件<br> 6 def create_excel_report_and_send_email(excel_obj, receiver, subject, content):<br> 7     “””<br> 8     :param excel_obj: excel对象用于保存文件<br> 9     :param timestamp: 用于文件命名的时间戳<br>10     :return: 返回excel测试报告文件名<br>11     “””<br>12     time_stamp &#x3D; get_timestamp()<br>13     report_path &#x3D; excel_obj.save(subject, time_stamp)<br>14     send_mail(report_path, receiver, subject+”_”+time_stamp, content)</p>
<p>conf 目录<br>conf 目录属于第一层测试工具层，用于存储各配置文件。</p>
<p>elements_repository.ini<br>该配置文件存储了各页面的元素对象的定位方式和定位表达式。</p>
<p> 1 [126mail_indexPage]<br> 2 indexPage.loginlink&#x3D;xpath&gt;&#x2F;&#x2F;a[contains(text(),’密码登录’)]<br> 3 indexPage.frame&#x3D;xpath&gt;&#x2F;&#x2F;iframe[contains(@id,’x-URS-iframe’)]<br> 4 indexPage.username&#x3D;xpath&gt;&#x2F;&#x2F;input[@name&#x3D;’email’]<br> 5 indexPage.password&#x3D;xpath&gt;&#x2F;&#x2F;input[@name&#x3D;’password’]<br> 6 indexPage.loginbutton&#x3D;id&gt;dologin<br> 7<br> 8 [126mail_homePage]<br> 9 homePage.addressLink&#x3D;xpath&gt;&#x2F;&#x2F;div[text()&#x3D;’通讯录’]<br>10<br>11 [126mail_contactPersonPage]<br>12 contactPersonPage.createButton&#x3D;xpath&gt;&#x2F;&#x2F;span[text()&#x3D;’新建联系人’]<br>13 contactPersonPage.name&#x3D;xpath&gt;&#x2F;&#x2F;a[@title&#x3D;’编辑详细姓名’]&#x2F;preceding-sibling::div&#x2F;input<br>14 contactPersonPage.email&#x3D;xpath&gt;&#x2F;&#x2F;<em>[@id&#x3D;’iaddress_MAIL_wrap’]&#x2F;&#x2F;input<br>15 contactPersonPage.starContacts&#x3D;xpath&gt;&#x2F;&#x2F;span[text()&#x3D;’设为星标联系人’]&#x2F;preceding-sibling::span&#x2F;b<br>16 contactPersonPage.phone&#x3D;xpath&gt;&#x2F;&#x2F;</em>[@id&#x3D;’iaddress_TEL_wrap’]&#x2F;&#x2F;dd&#x2F;&#x2F;input<br>17 contactPersonPage.otherinfo&#x3D;xpath&gt;&#x2F;&#x2F;textarea<br>18 contactPersonPage.confirmButton&#x3D;xpath&gt;&#x2F;&#x2F;span[.&#x3D;’确 定’]</p>
<p>logger.conf</p>
<p>###############################################<br>[loggers]<br>keys&#x3D;root,example01,example02<br>[logger_root]<br>level&#x3D;DEBUG<br>handlers&#x3D;hand01,hand02</p>
<p>[logger_example01]<br>handlers&#x3D;hand01,hand02<br>qualname&#x3D;example01<br>propagate&#x3D;0</p>
<p>[logger_example02]<br>handlers&#x3D;hand01,hand03<br>qualname&#x3D;example02<br>propagate&#x3D;0</p>
<p>###############################################<br>[handlers]<br>keys&#x3D;hand01,hand02,hand03</p>
<p>[handler_hand01]<br>class&#x3D;StreamHandler<br>level&#x3D;INFO<br>formatter&#x3D;form01<br>args&#x3D;(sys.stderr,)</p>
<p>[handler_hand02]<br>class&#x3D;FileHandler<br>level&#x3D;DEBUG<br>formatter&#x3D;form01<br>args&#x3D;(‘E:\pycharm_project_dir\UIKeywordFramework\log\ui_test.log’, ‘a’)</p>
<p>[handler_hand03]<br>class&#x3D;handlers.RotatingFileHandler<br>level&#x3D;INFO<br>formatter&#x3D;form01<br>args&#x3D;(‘E:\pycharm_project_dir\UIKeywordFramework\log\ui_test.log’, ‘a’, 10<em>1024</em>1024, 5)</p>
<p>###############################################<br>[formatters]<br>keys&#x3D;form01,form02</p>
<p>[formatter_form01]<br>format&#x3D;%(asctime)s [%(levelname)s] %(message)s<br>datefmt&#x3D;%Y-%m-%d %H:%M:%S</p>
<p>[formatter_form02]<br>format&#x3D;%(name)-12s: [%(levelname)-8s] %(message)s<br>datefmt&#x3D;%Y-%m-%d %H:%M:%S</p>
<p>test_data 目录<br>test_data 目录用于存放测试数据文件（Excel），存储了用例步骤、用例执行关键字、数据源等测试数据。</p>
<p><img src="/assets/2/image-20220510224210-86i3t56.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220510224216-eb51jsa.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220510224222-xoo66lr.png" alt="image.png"></p>
<p>main.py<br>本模块是本框架的运行主入口，属于第四层“测试场景层”，将测试用例组织成测试场景，实现各种级别 cases 的管理，如冒烟，回归等测试场景。</p>
<p>基于 business_process&#x2F;main_process.py 中的模块用例 sheet 执行函数或主 sheet 执行函数，组装测试场景。<br>可直接用代码组装测试场景，也可根据 excel 数据文件的用例集合和用例步骤的维护来设定测试场景。<br>完成测试执行后生成测试结果文件并发送邮件。</p>
<p> 1 from business_process.main_process import *<br> 2 from util.report_util import *<br> 3<br> 4<br> 5 # 组装测试场景<br> 6 # 冒烟测试<br> 7 def smoke_test(report_name):<br> 8     excel, _ &#x3D; suite_process(TEST_DATA_FILE_PATH, “登录（非数据驱动）”)<br> 9     excel, _ &#x3D; suite_process(excel, “关闭浏览器”)<br>10     # 生成测试报告并发送邮件<br>11     create_excel_report_and_send_email(excel, [‘<a href="mailto:&#105;&#116;&#x73;&#106;&#x75;&#x6e;&#x6f;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;">&#105;&#116;&#x73;&#106;&#x75;&#x6e;&#x6f;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;</a>‘, ‘<a href="mailto:&#x31;&#56;&#x32;&#50;&#x33;&#48;&#49;&#x32;&#52;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#56;&#x32;&#50;&#x33;&#48;&#49;&#x32;&#52;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#x6d;</a>‘], report_name, “请查收附件：UI自动化测试报告”)<br>12<br>13<br>14 # 全量测试：执行主sheet的用例集<br>15 def suite_test(report_name):<br>16     excel &#x3D; main_suite_process(TEST_DATA_FILE_PATH, “测试用例集”)<br>17     create_excel_report_and_send_email(excel, [‘<a href="mailto:&#105;&#x74;&#x73;&#x6a;&#x75;&#x6e;&#x6f;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;">&#105;&#x74;&#x73;&#x6a;&#x75;&#x6e;&#x6f;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;</a>‘, ‘<a href="mailto:&#x31;&#56;&#x32;&#50;&#51;&#x30;&#49;&#50;&#52;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#x31;&#56;&#x32;&#50;&#51;&#x30;&#49;&#50;&#52;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a>‘], report_name, “请查收附件：UI自动化测试报告”)<br>18<br>19<br>20 if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>21     # smoke_test(“UI自动化测试报告_冒烟测试”)<br>22     suite_test(“UI自动化测试报告_全量测试”)</p>
<p><img src="/assets/2/image-20220510224231-f0bp0i7.png" alt="image.png"></p>
<p>test_report 目录<br>本目录用于存放测试结果文件。</p>
<p><img src="/assets/2/image-20220510224246-mblacyv.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220510224252-wzmcw0q.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220510224258-cxousa9.png" alt="image.png"></p>
<p>exception_pic 目录<br>本目录用于存放失败用例的截图。</p>
<p><img src="/assets/2/image-20220510224309-zvu91ms.png" alt="image.png"></p>
<p>log 目录<br>本目录用于存放日志输出文件（日志内容同时也会输出到控制台）。</p>
<p>log&#x2F;ui_test.log：</p>
<p><img src="/assets/2/image-20220510224316-xhmpjmi.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>02_自动化实操</category>
        <category>01_UI自动化</category>
        <category>UI自动化测试框架</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python自动化篇</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/05_python_%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>01_pycharm</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python配置环境变量</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/04_python%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="环境变量配置："><a href="#环境变量配置：" class="headerlink" title="环境变量配置："></a>环境变量配置：</h3><pre><code>     方法一：使用cmd命令添加path环境变量

              在cmd下输入： path**=%**path**%;**D**:**\Python27  接着按&quot;Enter&quot;回车键。

              其中**: **D:\Python27  是Python的安装目录。

     方法二：在环境变量中添加Python目录

              (1) 右键点击&quot;计算机&quot;，然后点击&quot;属性&quot;

              (2) 然后点击&quot;高级系统设置&quot;

              (3) 选择&quot;系统变量&quot;窗口下面的&quot;Path&quot;,双击即可！

              (4) 然后在&quot;Path&quot;行，添加python安装路径即可(我的D:\Python27)。 **ps：记住，路径直接用分号&quot;；&quot;隔开！**
</code></pre>
<p><img src="/assets/1/image-20211205192132-euadow9.png" alt="image.png"></p>
<pre><code>            (5) 最后设置成功以后，在cmd命令行，输入命令&quot;python&quot;，就可以有相关显示。
</code></pre>
<p><img src="/assets/1/image-20211205192137-hjgzfd8.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>01_pycharm</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>认识PycharmPython</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/01_%E8%AE%A4%E8%AF%86PycharmPython/</url>
    <content><![CDATA[<p>一、python与pycharm区别</p>
<p>1、编程语言：解释型（python）、编译(java)</p>
<p>2、pycharm：用来写python代码的工具</p>
<p>二、pycharm安装</p>
<p>1、pycharm官网：<a href="https://www.jetbrains.com/pycharm/download/#section=windows">https://www.jetbrains.com/pycharm/download/#section=windows</a></p>
<p>2、<a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/02_pycharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">pycharm安装教程</a></p>
<p>三、python安装、配置</p>
<p>1、python官网：<a href="https://www.python.org/">https://www.python.org/</a></p>
<p>2、<a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/03_python%E5%AE%89%E8%A3%85/">python安装</a></p>
<p>3、<a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/04_python%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/">配置环境变量</a></p>
<p>四、pycharm的使用</p>
<p>1、字体设置：file&gt;&gt;&gt;settings &gt;&gt;&gt; Editor&gt;&gt;&gt;Font&gt;&gt;&gt;size</p>
<p>2、主题设置 ：file&gt;&gt;&gt;settings &gt;&gt;&gt; Editor&gt;&gt;&gt;Color Scheme&gt;&gt;&gt;General&gt;&gt;&gt;选择想要的主题</p>
<p>3、选择解释器：file&gt;&gt;&gt;settings &gt;&gt;&gt;Project:项目名称&gt;&gt;&gt;Project Interpreter&gt;&gt;选择解释器</p>
<p>4、添加注释：file&gt;&gt;&gt;settings &gt;&gt;&gt; Editor&gt;&gt;&gt;File and Code Templates&gt;&gt;&gt;Python Script&gt;&gt;&gt;添加注释信息</p>
<p>-<em>- coding: utf-8 -</em>-</p>
<p>@Time: ${DATE} ${TIME}</p>
<p>@Author: name</p>
<p>@File: ${NAME}.py</p>
<p>五、python文件执行</p>
<p>1、右键：run xxx.py</p>
<p>2、导航栏：三角形（绿色）</p>
<p>3、控制台左侧：三角形（绿色）</p>
<p>六、项目创建</p>
<p>1、项目创建：file&gt;&gt;&gt;new project</p>
<p>2.创建包：在项目文件夹右键&gt;&gt;&gt;new&gt;&gt;&gt;python Package</p>
<p>3.创建文件：在项目包上右键&gt;&gt;&gt;new &gt;&gt;&gt;python file</p>
<p>七、python包管理</p>
<p>环境变量：计算机 右键&gt;属性&gt;高级系统设置&gt;环境变量&gt;系统环境变量新增PATH：python安装路径</p>
<p>pip 用来管理第三方的包</p>
<p>1、查看已经安装的python包：pip list</p>
<p>2、安装：pip install package_name</p>
<p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> package_name</p>
<p>国内源：</p>
<p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a><br>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a><br>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>3、卸载包： pip unisntall package_name</p>
<p>4、更新包：pip install -U package_name</p>
<p>5、虚拟环境相关(l了解)：</p>
<p>导出依赖包：pip freeze&gt;requirement.txt</p>
<p>安装依赖包：pip install -r  requirement.txt</p>
<p>八、python基础语法</p>
<p>1、缩进区分代码块</p>
<p>tab键 &#x3D;&#x3D; 4个空格</p>
<p>2、换行：表示一行代码执行结束</p>
<p>3、注释：# 选中+Ctrl+&#x2F;</p>
<pre><code>            三个单引号，三个双引号（英文模式下）
</code></pre>
<p>4、输出：</p>
<pre><code>          print（&#39;Hello Python!&#39;）

         \：续行符
</code></pre>
<p>九、python变量和标识符</p>
<p>1、什么是变量：计算机当中用来存储值的抽象的概念</p>
<p>&#x3D;：赋值</p>
<p>2、变量命名规则</p>
<pre><code>a、由字母、数字、下划线组成

 b、不能以数字开头

 c、区分大小写（大小写敏感）

 d、不能使用关键字
</code></pre>
<p>   import keyword<br>   print(keyword.kwlist)#打印关键字<br>     e、可读性要强，见名知意</p>
<p>3、标识符</p>
<pre><code>a、什么是标识符：用来指定某个实体的符号

b、变量、包名称、文件名称、函数名称、类名称

c、命名风格

    大驼峰（FirstName）、小驼峰（firstName)、下划线连接（first_name）

 d、建议命名风格

      类名：大驼峰

      函数：下划线连接

      变量名：下划线连接
</code></pre>
<p>十、python 常用数据类型</p>
<p>1、数值:10、100，int 、float</p>
<p>2、字符串:可以使用引号( ‘ 或 “ )来创建字符串</p>
<p>3、布尔值：true、false</p>
<p>4、元组: tup( )</p>
<p>5、列表: list1[ ]</p>
<p>6、字典: dict &#x3D; {key1 : value1, key2 : value2, key3 : value3 }</p>
<p>7、集合:parame &#x3D; {value01,value02,…}</p>
<p>8、None</p>
<p>怎么去判断一个变量数据类型</p>
<p>type()</p>
<p>isinstance()</p>
<p>例1：</p>
<p>str_1&#x3D;100</p>
<p>print(type(str_1))</p>
<p>例2：</p>
<p>str_1&#x3D;100</p>
<p>print(isinstance(str_1,str))<br /><br /></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>01_pycharm</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm安装教程</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/02_pycharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<ol>
<li>首先大家打开浏览器，输入PyCharm点击搜索，点击标题进入网页，点击Professional下的DAWNLOAD<br> <a href=""><img src="https://exp-picture.cdn.bcebos.com/df087f0f8b56ad0416751b5cdae10ef85956d0b1.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="PyCharm安装教程"></a></li>
<li>2<br> 然后点击下载，下载完成后点击打开，然后点击运行，依次点击next，勾选选项，点击next，点击install，勾选选项，点击finish，点击ok，点击accept<br> <a href=""><img src="https://exp-picture.cdn.bcebos.com/50189b40102a04e278bf36f72b7aa010bd33c2b1.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="PyCharm安装教程"></a></li>
<li>3<br> 点击Send Usage Statistics，勾选Atativation Code，列表框中需要填入注册码，返回桌面，点击打开浏览器<br> <a href=""><img src="https://exp-picture.cdn.bcebos.com/0d55dc7bd2828689f25bbb0465f97fbd4d7c37b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="PyCharm安装教程"></a></li>
<li>4<br> 输入IntelliJ IDEA注册码，点击搜索，点击标题进入网页，点击获得注册码，点击鼠标右键，点击复制，点击之前打开的安装窗口<br> <a href=""><img src="https://exp-picture.cdn.bcebos.com/023cff37c97622bc1dd8c3d2a05fd546049628b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="PyCharm安装教程"></a></li>
<li>5<br> 电脑已自动粘贴好安装码，返回桌面点击这台电脑，打开里面的Windows点击Systems32，点击Drivers里面的ect，右击hosts点击复制<br> <a href=""><img src="https://exp-picture.cdn.bcebos.com/32fe25ef354f50b8c423a46edc4afa32929c18b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="PyCharm安装教程"></a></li>
<li>6<br> 再返回桌面点击粘贴，点击hosts里的打开方式，点击记事本，返回注册网页，选中代码并复制，再修改host文件<br> <a href=""><img src="https://exp-picture.cdn.bcebos.com/cfadcdd96975f2c46e8455f68f0148fe1f4206b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="PyCharm安装教程"></a></li>
<li>7<br> 最后点击OK并重启电脑即可<br> <a href=""><img src="https://exp-picture.cdn.bcebos.com/acfda02f477046184dc7e88eb08602214e5776b6.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="PyCharm安装教程"></a></li>
</ol>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>01_pycharm</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/03_python%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>一、python3.6安装步骤</p>
<p>1.首先我们移步官网，下载最新版本的python-3.6.0。</p>
<p><img src="/assets/1/image-20211205191754-q9d0cb5.png" alt="image.png"></p>
<p>在DownLoad下拉框中点击Windows,选择要下载的文件：</p>
<p><img src="/assets/1/image-20211205191802-efs237e.png" alt="image.png"></p>
<p>windows32位系统请选择第一个点击下载，windows64位系统请点击第二个。下载完成后，得到一个可执行文件：</p>
<p><img src="/assets/1/image-20211205191819-dr03qw4.png" alt="image.png"></p>
<p>双击执行：博主已经安装过python，关于下面的四张图片引用自百度经验，但与原安装步骤一模一样，请谅解：</p>
<p><img src="/assets/1/image-20211205191826-95lilx8.png" alt="image.png"></p>
<p>先勾选最下方的选项，然后点击Customize installation,注意一定要勾选最下面一个选项，它可以自动帮你添加windows环境变量。点击完成后，进入下一个步骤：</p>
<p><img src="/assets/1/image-20211205191834-bi9glqd.png" alt="image.png"></p>
<p>默认全选就好，继续点击下一步：</p>
<p><img src="/assets/1/image-20211205191842-bhq3nt4.png" alt="image.png"></p>
<p>记得勾选第一项，并选择自己想要安装的路径。然后点击Install后，等几分钟就好了。</p>
<p>安装完成后，是不是着急要测一测自己安装的python是否好用呢？</p>
<p>我们按Ctrl+R，输入cmd，打开命令提示符窗口，输入python，如果你出现下面的情况，说明你的python安装成功了！</p>
<p><img src="/assets/1/image-20211205191854-ok25viy.png" alt="image.png"></p>
<p>如果没有出现下面的情况，不要着急，可能是你的环境变量没有修改成功，我们执行一下步骤就好</p>
<p>右键点击”我的电脑”-&gt;属性-&gt;高级系统设置-&gt;环境变量</p>
<p>在系统变量栏目中，找到PATH，双击编辑后，添加你刚才安装python的路径就可以啦！</p>
<p>这里注意，可能系统版本不一样，有时候PATH是在一行显示的，那样的话需要在原来的PATH后面加上; 然后在后面加上刚才的python安装路径即可。</p>
<p>二、安装beautifulsoup4-4.5.1</p>
<p>去官网，BeautifulSoup4源码下载，下载源码，编译运行。BeautifulSoup4-4.5.1源码下载</p>
<p>选择第二个，右键目标另存为，选择路径即可。</p>
<p>然后将下载后的压缩包剪切到本机的python安装目录中，解压后，打开命令提示符窗口，输入python d:\python3.6\beautifulsoup4-4.5.1\setup.py build 即可完成安装。</p>
<p>安装完成后，输入以下命令，若出现下图情况，则安装成功！</p>
<p><img src="/assets/1/image-20211205191917-hiupflh.png" alt="image.png"></p>
<p>三、安装html5lib</p>
<p>我们安装网页文件解析器htm5lib，只需直接运行pip install html5lib即可。</p>
<p><img src="/assets/1/image-20211205191928-78h61ze.png" alt="image.png"></p>
<p>四、安装lxml</p>
<p>首先去官网下载对应的.whl文件，根据自己的系统版本和python版本选择适合的文件。</p>
<p>戳我下载：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml">https://www.lfd.uci.edu/~gohlke&#x2F;pythonlibs&#x2F;#lxml</a></p>
<p>然后进行安装，首先在cmd中输入pip install wheel安装wheel工具，做好准备工作。</p>
<p>接着运行pip install *.whl文件，我的对应版本为lxml-3.6.0-cp35-cp35m-win_amd64.whl即可成功安装lxml解析器。</p>
<p>五、request安装</p>
<p>打开cmd，直接pip install requests即可安装。<br><br /></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>06_自动化</category>
        <category>01_pycharm</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>siege</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_siege/01_siege/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>05_性能测试工具</category>
        <category>06_siege</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>gatling</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/07_gatling/01_gatling/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>05_性能测试工具</category>
        <category>07_gatling</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>webbench</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_webbench/01_webbench/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>05_性能测试工具</category>
        <category>03_webbench</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>loadUI</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_loadUI/01_loadUI/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>05_性能测试工具</category>
        <category>04_loadUI</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>httperf</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_httperf/01_httperf/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>05_性能测试工具</category>
        <category>05_httperf</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>loadrunner</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_loadrunner/01_loadrunner/</url>
    <content><![CDATA[<p>文章目录</p>
<ul>
<li><a href="https://blog.csdn.net/ip66666/article/details/119648720#Virtural_User_Generator_2">Virtural User Generator</a></li>
<li><a href="https://blog.csdn.net/ip66666/article/details/119648720#Controller_6">Controller</a></li>
<li><a href="https://blog.csdn.net/ip66666/article/details/119648720#Analysis_10">Analysis</a></li>
<li><a href="https://blog.csdn.net/ip66666/article/details/119648720#loadrunner_20">loadrunner的使用</a></li>
</ul>
<p>Virtural User Generator<br>：录制脚本，编写并发测试代码于需求，设计并发测试实施的代码逻辑和执行思路</p>
<p>Controller<br>：场景测试，收集并发测试的数据，显示执行并发过程中的各数据的动态图表（多个用户并发场景）</p>
<p>Analysis<br>：分析系统并发测试的数据，生成报告和图标</p>
<p>loadrunner做性能测试的原理？<br>性能测试主要是多用户的并发，就是多线程模拟用户的操作，<br>什么是集合点，为什莫需要集合点？<br>因为先初始化好的线程需要等待后面还没初始化好的线程，所以设置一个集合点，用来等待。<br>性能测试的过程<br>在做系统的性能测试时，已经知道性能测试的范围，如何选取性能测试的主要功能？<br>在测试范围内，选取用户经常使用的功能，</p>
<p>loadrunner的使用</p>
<p><img src="/assets/2/image-20220508163245-29h8tps.png" alt="image.png"><br>1，先启动启动它自身的服务器<br>首先在安装目录下开启loadrunner服务</p>
<p><img src="/assets/2/image-20220508163256-a24p1sz.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508163305-uqm1ue8.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508163313-fybw2p3.png" alt="image.png"></p>
<p>2，然后启动Virtual User Generrator</p>
<p>新建文件</p>
<p><img src="/assets/2/image-20220508163323-i0x10x3.png" alt="image.png"></p>
<p>选择协议；选择http协议，此次性能测试完成loadrunner自带的浏览器的多用户登录并发操作</p>
<p>3，点击录制，配置集合点，集合点放在事务之前。</p>
<p><img src="/assets/2/image-20220508163333-94l1kao.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508163340-bb7hv51.png" alt="image.png"></p>
<p>脚本录制结束。<br>给录制脚本中插入事务或者检查点</p>
<p><img src="/assets/2/image-20220508163348-mfcja8d.png" alt="image.png"></p>
<p>如何判断虚拟用户登陆成功？<br>使用检查点，插入登陆成功后的语句，于Welcome, jojo, to the Web Tours reservation pages.进行比较，判断是否登录成功。后面插入检查点：“SaveCount&#x3D;reservation_Count”<br>关联：“NotFound&#x3D;warning”</p>
<p><img src="/assets/2/image-20220508163356-tb22lgb.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508163405-7u9sds6.png" alt="image.png"></p>
<p>加入检查点之后运行看是否成功。<br>常见的函数：<br>lr_eval_string 该函数功能是得到参数（参数化输入中）当前的值<br>exg: lr_output_message(“temp &#x3D; %s”, lr_eval_string(“{WCSParam2}”));<br>lr_save_string 该函数功能是把一个字符串保存到参数中<br>exg: lr_save_string(“439”,“WCSParam3”);<br>6，参数化</p>
<p><img src="/assets/2/image-20220508163415-x2gx1ox.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508163422-9am7gu4.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508163429-fm7g1c5.png" alt="image.png"></p>
<p>添加用户数量，</p>
<p><img src="/assets/2/image-20220508163437-5rb2534.png" alt="image.png"></p>
<p>在这个目录下添加用户名</p>
<p>使用参数，把所有的用户名改变，</p>
<p><img src="/assets/2/image-20220508163445-52mw2li.png" alt="image.png"></p>
<p>Sequential：每运行一次选择一个用户。<br>Each itretion：每一次取新一行的变量<br>Each ocurrence：每一次随机取值<br>Onece：每一次都取相同的值</p>
<p><img src="/assets/2/image-20220508163455-458c0sf.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508163503-1fdcnje.png" alt="image.png"></p>
<p>设置了4个用户，这里设置为4<br>那怎么设置能知道本次的登录的用户就是你想要其登录的用户，就是输出本次用户名。</p>
<p><img src="/assets/2/image-20220508163511-gjmyo1d.png" alt="image.png"></p>
<p>判断当前用户是不是jojo，如果是输出名字，如果不是输出this is not jojo！</p>
<p><img src="/assets/2/image-20220508163517-uvdm70k.png" alt="image.png"></p>
<p>7，虚拟用户的数量怎么设置？<br>根据测试场景，做并发测试，测试系统在不同的用户数量的级别下， 系统的表现，找出系统性能的拐点。<br>3个用户并发访问loadrunner自带的功能登录功能的性能指标<br>5个<br>7个<br>场景运行时间比较短，3-5min<br>设置并发数，打开Controller。</p>
<p><img src="/assets/2/image-20220508163527-j9eponj.png" alt="image.png"></p>
<p>做并发测试：loadrunner自带的服务，我们要查看测试在不同的用户数量级别下登录操作的性能指标。 首先使用3个用户来测试。响应时间是否在3s内。（运行时间在3-5分钟）</p>
<p><img src="/assets/2/image-20220508163535-9xkn06o.png" alt="image.png"></p>
<p>在controller中设置具体的参数。</p>
<p>哪一种测试类型需要性能测试的时间比较长？<br>可靠性测试。（军事系统要求系统可靠性达到99.9999%）<br>loadrunner通过多线程来模拟虚拟用户，</p>
<p>生成测试报表</p>
<p><img src="/assets/2/image-20220508163546-bz8mgji.png" alt="image.png"></p>
<p>不同的参数，</p>
<p>如何排查系统性能达到瓶颈？<br>各参数是否达到需求要求的临界值。<br>————————————————<br>版权声明：本文为CSDN博主「小小小小滴」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ip66666/article/details/119648720">https://blog.csdn.net/ip66666/article/details/119648720</a></p>
<h1 id="在zhifu-statues方法中，依赖了zhifu方法，但由于zhifu支付方法的接口是由另外一个同事开发，正常情况下，你同事开发的进度你是无法控制的，需要等他开发完了你才能进行联调你所负责的zhifu-statues接口，因此我们可以通过引入Mock来解决这个问题。"><a href="#在zhifu-statues方法中，依赖了zhifu方法，但由于zhifu支付方法的接口是由另外一个同事开发，正常情况下，你同事开发的进度你是无法控制的，需要等他开发完了你才能进行联调你所负责的zhifu-statues接口，因此我们可以通过引入Mock来解决这个问题。" class="headerlink" title="在zhifu_statues方法中，依赖了zhifu方法，但由于zhifu支付方法的接口是由另外一个同事开发，正常情况下，你同事开发的进度你是无法控制的，需要等他开发完了你才能进行联调你所负责的zhifu_statues接口，因此我们可以通过引入Mock来解决这个问题。"></a>在zhifu_statues方法中，依赖了zhifu方法，但由于zhifu支付方法的接口是由另外一个同事开发，正常情况下，你同事开发的进度你是无法控制的，需要等他开发完了你才能进行联调你所负责的zhifu_statues接口，因此我们可以通过引入Mock来解决这个问题。</h1>]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>05_性能测试工具</category>
        <category>02_loadrunner</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>FinalShell使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/07_FinalShell/02_FinalShell%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>使用的前提是：cuda python pytorch都已经在服务器安装成功，环境也配置好了，具体不再赘述（友情提示：一定要有耐心~我也就……搞了一下午加一晚上而！已！╥﹏╥）。</p>
<p>打开finalshell</p>
<p><img src="/assets/2/image-20220515014332-czfewyb.png" alt="image.png"></p>
<p>打开环境，键入</p>
<blockquote>
<p>source  activate<br><br /></p>
</blockquote>
<p><img src="/assets/2/image-20220515014358-wnemb5p.png" alt="image.png"></p>
<ol start="3">
<li>把要运行的程序的文件夹（我的是famework）直接上传到root文件夹</li>
<li>转到famework路径下，键入：</li>
</ol>
<blockquote>
<p>cd &#x2F;famework<br><br /></p>
</blockquote>
<p><img src="/assets/2/image-20220515014414-ulmdyv2.png" alt="image.png"></p>
<ol start="5">
<li>比如我要运行train_add_test.py，键入：</li>
</ol>
<blockquote>
<p>python train_add_test.py</p>
</blockquote>
<p>训练ing…</p>
<p><img src="/assets/2/image-20220515014422-aeo5ljn.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>07_FinalShell</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/05_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_jmeter/01_jmeter/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>05_性能测试工具</category>
        <category>01_jmeter</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>FinalShell安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/07_FinalShell/01_FinalShell%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>良心国产软件，可替换xShell。xShell容易被起诉,动不动公司就要你卸载。毕竟别人家软件要收费的。试试FinalShell吧。免费的。</p>
<p>特色功能:<br>云端同步,免费海外服务器远程桌面加速,ssh加速,本地化命令输入框,支持自动补全,命令历史,自定义命令参数</p>
<p>Windwos下安装 直接双击</p>
<p><img src="/assets/2/image-20220515014047-es6mhl3.png" alt="image.png"></p>
<p> 然后无脑点击下一步，选择安装路径【建议非C盘】，然后继续…直到出现该提示，安装这个Winpcap.</p>
<p><img src="/assets/2/image-20220515014057-h56ym2f.png" alt="image.png"></p>
<p> 安装完成打开就是这样子。</p>
<p><img src="/assets/2/image-20220515014057-h56ym2f.png" alt="image.png"></p>
<p> 连接Linux，安下图点开配置信息连接即可</p>
<p><img src="/assets/2/image-20220515014110-dg00u5y.png" alt="image.png"></p>
<p><a href="http://www.hostbuf.com/">官网地址</a></p>
<p>Windows版下载地址:<br><a href="http://www.hostbuf.com/downloads/finalshell_install.exe">http://www.hostbuf.com/downloads/finalshell_install.exe</a></p>
<p>macOS版下载地址:<br><a href="http://www.hostbuf.com/downloads/finalshell_install.pkg" title="http://www.hostbuf.com/downloads/finalshell_install.pkg">http://www.hostbuf.com/downloads/finalshell_install.pkg</a><br><br /></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>07_FinalShell</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MobaXterm使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/06_MobaXterm/02_MobaXterm%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/assets/2/image-20220515013806-lchx9th.png" alt="image.png"></p>
<p>MobaXterm作为一款优秀的远程连接工具，很多朋友在日常当中都会使用到，今天小编给大家介绍一下MobaXterm从下载到安装使用的图文教程，感兴趣的朋友，可以下载试试！</p>
<p>1、<strong>下载MobaXterm</strong></p>
<p>进到MobaXterm的官网，我们可以看到，官网为我们提供了两种形式的MobaXterm，一种是绿色版，一种是安装版，我个人比较喜欢绿色版，当切换工作机时，ssh记录等一些信息能够直接使用。</p>
<p><img src="/assets/2/image-20220515013824-0hyolsy.png" alt="image.png"></p>
<p>2、<strong>安装打开MobaXterm</strong></p>
<p>下载完成之后解压出来的目录是这样式的，版本的不同文件结构可能也会不同， 双击MobaXterm_Personal_9.4.exe即可打开软件，软件启动之后界面如图：</p>
<p><img src="/assets/2/image-20220515013838-yptgqgy.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515013843-ecy8xqr.png" alt="image.png"></p>
<p>3、<strong>建立SSH连接到一台服务器</strong></p>
<p>点击左上角的Session新建一个会话，在会话对话框中点击SSH，切换到SSH配置参数页。remote host填写远端服务器的地址，Specify username填写用户名，port填写端口，点击OK就可以登录到正常远端服务器了。</p>
<p><img src="/assets/2/image-20220515013849-ood24ow.png" alt="image.png"></p>
<p>4、<strong>终端服务</strong></p>
<p>连上远端服务器之后，便可以通过shell命令来操作我们的服务器了，比如ls列出当前目录下的所有文件，MobaXterm自带一套彩色的配置，这是我喜欢它的原因之一</p>
<p><img src="/assets/2/image-20220515013854-320ufds.png" alt="image.png"></p>
<p>5、<strong>sftp 文件传输服务</strong></p>
<p>终端操作只是我们平常管理服务器的一部分，还有很多什么我们需要从服务器下载文件或者是上传文件到服务器，尤其是上传文件，在部署工程的时候是很有必要的。当我们连接上服务器之后，可以看到右侧中部多了一个菜单项sftp，点击它默认列出了家目录下所有文件</p>
<p><img src="/assets/2/image-20220515013859-ulrva3r.png" alt="image.png"></p>
<p>6、<strong>上传下载文件</strong></p>
<p>上传文件：直接将要上传的文件拖拽到sftp面板就可以了</p>
<p>下载文件：在sftp面板选中想要下载的文件，右键download</p>
<p>其他操作：如新建文件夹什么的，右键面板空白处便可以找到</p>
<p><img src="/assets/2/image-20220515013904-9zuwjss.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515013911-xj5eps8.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515013917-kfguzhc.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>06_MobaXterm</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MobaXterm安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/06_MobaXterm/01_MobaXterm%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>一、下载MobaXterm安装包<br><a href="https://mobaxterm.mobatek.net/">点击进入官网</a></p>
<p><a href="https://mobaxterm.mobatek.net/download-home-edition.html">点击进入下载链接</a></p>
<p><img src="/assets/2/image-20220515013454-gupl7l1.png" alt="image.png"></p>
<p>二、MobaXterm安装</p>
<p><img src="/assets/2/image-20220515013508-3676aol.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515013514-p87kn4v.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515013523-df1jnq4.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515013528-jvm30bz.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515013535-thxefhh.png" alt="image.png"></p>
<p>三、MobaXterm的使用</p>
<p><code>程序第一次运行需要等待一会</code></p>
<p><img src="/assets/2/image-20220515013547-zu1luc9.png" alt="image.png"></p>
<p><code>会话 -&gt; SSH -&gt; 主机IP -&gt; 用户名称</code></p>
<p><img src="/assets/2/image-20220515013612-nfjqycx.png" alt="image.png"></p>
<p><code>输入密码</code></p>
<p><img src="/assets/2/image-20220515013632-hqmge5v.png" alt="image.png"></p>
<p><code>连接成功</code></p>
<p><img src="/assets/2/image-20220515013648-gmbca8t.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>06_MobaXterm</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>PuTTY安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/05_PuTTY/01_PuTTY%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>安装<br>putty是一款windows上很好用的连接远程服务器的小工具。下载地址：<a href="https://www.puttygen.com/download-putty">网址</a>。进入网址，找到如下内容下载即可：</p>
<p><img src="/assets/2/image-20220515012518-lvxjhn1.png" alt="image.png"></p>
<p>也可以下载历史版本：<a href="http://www.putty.be/latest.html">历史版本下载</a>。</p>
<p>也可以直接下载我上传这个安装文件：<a href="https://download.csdn.net/download/weixin_42638946/66306771">网址</a>。下载解压后，双击.msi文件安装即可。</p>
<p>安装过程一路默认，最后会多出四个程序，如下图：</p>
<p><img src="/assets/2/image-20220515012633-d3x67pg.png" alt="image.png"></p>
<p>我们可以打开这些应用的位置，默认位置是：C:\Program Files\PuTTY，这个路径已经加入到环境变量中了，因此可以使用这个路径下的.exe作为命令，该文件夹中的内容如下：</p>
<p><img src="/assets/2/image-20220515012640-3ms22ya.png" alt="image.png"></p>
<p>这里简单说明一下次文件夹中6个.exe文件的作用：</p>
<p>putty.exe：远程连接服务器，最为常用；</p>
<p>puttygen.exe：生成公钥和私钥，用于免密登陆远程服务器；</p>
<p>psftp.exe：用于在本地、远程服务器之间相互传输文件；</p>
<p>pscp.exe：和psftp.exe作用一样，不过命令不同，该命令类似于linux中的scp命令；</p>
<p>plink.exe：用于在本地执行远程服务器的命令；</p>
<p>pageant.exe：用于管理秘钥。</p>
<p>下面介绍上图框出来的五个工具的使用方式。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>05_PuTTY</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>PuTTY使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/05_PuTTY/02_PuTTY%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>使用<br>2.1 putty.exe<br>这是putty套件中最为常用的工具，打开的初始界面如下：</p>
<p><img src="/assets/2/image-20220515012655-vk2y0lo.png" alt="image.png"></p>
<p>这里输入远程服务器的IP地址，以及登陆的端口号（SSH默认端口号为22），点击Open后，在弹出的界面中输入账号和密码后就可以登陆。如下图：</p>
<p><img src="/assets/2/image-20220515012655-vk2y0lo.png" alt="image.png"></p>
<p>这里演示的登陆阿里云服务器，用户名为wxx，输入的密码会隐藏（即我们输入的密码不会显示）。<br>如果要登陆多台服务器，我们可以保存为session，如下图，保存了两个session（分别叫做：aliyun、django）：</p>
<p><img src="/assets/2/image-20220515012713-gekyuce.png" alt="image.png"></p>
<p>输入IP地址、端口、以及会话名称，最后保存即可，如下图：</p>
<p><img src="/assets/2/image-20220515012713-gekyuce.png" alt="image.png"></p>
<p>可以看到上面登陆终端后，字体很小，因此需要设置终端中字体的大小，这里很可能设置完成后，下次重启又会失效，这里介绍如何避免这个问题。</p>
<p>我这里一共有三个session（两个自己创建的，一个默认的Default Settings），每个都需要单独设置，可以理解为每个session的配置都是独立的。</p>
<p>这里以设置aliyun这个session为例，主要讲解如何设置终端的字体大小，步骤如下：</p>
<p>（1）点击aliyun，然后点击Load按钮，如下图：</p>
<p><img src="/assets/2/image-20220515012728-gq14vsv.png" alt="image.png"></p>
<p>（2）点击左侧菜单栏中的Window-&gt;Appearance，并改变其中的字体大小，如下图：</p>
<p><img src="/assets/2/image-20220515012728-gq14vsv.png" alt="image.png"></p>
<p>（3）点击左侧菜单栏中的Session，之后点击右侧的Save按钮，如下图：</p>
<p><img src="/assets/2/image-20220515012741-nj6tpoo.png" alt="image.png"></p>
<p>这样之后及时重启putty，对于aliyun这个session，设置都是生效的。其它的设置也是类似的步骤，只需要改变第（2）步即可。例如后面2.2节中私钥位置的配置。</p>
<p>注意：后面的psftp、pscp、plink命令都是针对Default Settings这个session进行操作的。这个后面还会说到。</p>
<p>2.2 puttygen.exe<br>我们每次登陆远程服务器都需要输入用户名和密码，特别是输入密码，十分麻烦，这个工具就是要解决这个问题的。</p>
<p>点击puttygen.exe，默认界面如下：</p>
<p><img src="/assets/2/image-20220515012750-lp53hyz.png" alt="image.png"></p>
<p>点击Generate按钮，鼠标在空白处随意移动，生成公钥和私钥，演示如下：</p>
<p><img src="/assets/2/698a913f8e5a448e89assets/2/6e5d1af-20220515012923-nqrb8p3.gif" alt="image.gif"></p>
<p>这里最终生成的界面如下：</p>
<p><img src="/assets/2/image-20220515012940-yowm3i6.png" alt="image.png"></p>
<p>可以看到加密算法使用的是RSA算法，关于该算法的讲解可以参考：RSA公钥加密算法。该算法会生成公钥和私钥，公钥可以公开，私钥不能公开。</p>
<p>需要将公钥上传到服务器上，私钥保存到本地即可。点击上图中的Save private key，如果弹出警告框，点击是即可，然后给保存的私钥命名保存即可。如下图是需要保存的私钥，和公钥（直接复制到txt中即可）：</p>
<p><img src="/assets/2/image-20220515012949-u8hr45j.png" alt="image.png"></p>
<p>我在电脑中公钥和私钥保存位置如下（私钥是点击按钮生成的，公钥是新建txt文件，然后将内容复制进去的）：</p>
<p><img src="/assets/2/image-20220515012957-m6rrdz4.png" alt="image.png"></p>
<p>接着可以配置免密登陆，首先使用用户名和密码登陆服务器，创建.ssh文件夹，文件夹中创建authorized_keys文件，该文件用于存放之前生成的公钥（可以存放多个公钥），命令如下：<br>mkdir .ssh<br>cd .ssh<br>touch authorized_keys<br>1<br>2<br>3<br>然后将之前生成的公钥复制到文件authorized_keys中。</p>
<p>之后需要配置需要免密登陆的session，设置只有第（2）步操作不同，如下图：</p>
<p><img src="/assets/2/image-20220515013005-ga7djxz.png" alt="image.png"></p>
<p>之后记得保存设置。</p>
<p>然后登陆，可以发现，只需要输入用户名即可登陆远程服务器，如下图：</p>
<p><img src="/assets/2/image-20220515013011-lmy5use.png" alt="image.png"></p>
<p>2.3 psftp.exe<br>用于在本地和服务器之间传递文件，可以在cmd窗口中直接输入命令psftp，需要输入用户名、密码进行登陆。如果在putty中配置了免密登陆，则只需要输入用户名即可。</p>
<p>注意：这里默认连接的远程服务器是putty中Default Settings中对应的服务器。</p>
<p>使用该命令进入的界面如下，可以通过help查看提供的命令：</p>
<p><img src="/assets/2/image-20220515013020-ppn9n6x.png" alt="image.png"></p>
<p>常用命令：</p>
<blockquote>
<p>pwd			# 在远程服务器中显示当前所在目录<br>cd			# 在远程服务器上切换目录<br>ls			# 显示远程服务器文件夹中的文件</p>
<p>lpwd		# 在本地中显示当前所在目录<br>lcd			# 在本地切换目录<br>!dir		# 显示本地文件夹中的文件</p>
<p>put			# 上传本地文件到服务器<br>get			# 下载服务器文件到本地</p>
</blockquote>
<p>文件、文件夹的传输：<br>（1）将本地文件上传到服务器中（D:\psftp\local_file.txt –&gt; &#x2F;home&#x2F;wxx&#x2F;）：</p>
<blockquote>
<p>put d:\psftp\local_file.txt</p>
</blockquote>
<p>（2）将远程服务器上的文件下载到本地（&#x2F;home&#x2F;wxx&#x2F;.bashrc –&gt; D:\psftp\）</p>
<blockquote>
<p>lcd d:\psftp		# 本地目录切换<br>get .bashrc</p>
</blockquote>
<p>（3）将本地文件夹上传到服务器中（D:\psftp\local_test\ –&gt; &#x2F;home&#x2F;wxx&#x2F;）：</p>
<blockquote>
<p>put -r d:\psftp\local_test</p>
</blockquote>
<p>（4）将远程服务器上的文件夹下载到本地（&#x2F;home&#x2F;wxx&#x2F;.ssh&#x2F; –&gt; D:\psftp\）</p>
<blockquote>
<p>lcd d:\psftp		# 本地目录切换<br>get -r .ssh</p>
</blockquote>
<p>2.4 pscp.exe<br>和psftp功能基本一致，用于本地和远程之间文件传输。</p>
<p>这里使用另外一台服务器django演示，这台服务器是通过docker搭建的，搭建在aliyun服务器上，有端口映射，aliyun上的20000端口映射到了docker内部的22端口。</p>
<p>如果没指定端口，则端口是putty中Default Settings这个session对应的端口。</p>
<p>文件、文件夹的传输（直接在cmd中输入下面的命令即可）：</p>
<p>（1）将本地文件上传到服务器中（D:\psftp\local_file.txt –&gt; &#x2F;home&#x2F;acs&#x2F;）：</p>
<blockquote>
<p>pscp -P 20000 d:\psftp\local_file.txt <a href="mailto:&#x61;&#99;&#x73;&#x40;&#49;&#x31;&#50;&#46;&#x31;&#x32;&#54;&#46;&#55;&#x38;&#x2e;&#x31;&#56;&#54;">&#x61;&#99;&#x73;&#x40;&#49;&#x31;&#50;&#46;&#x31;&#x32;&#54;&#46;&#55;&#x38;&#x2e;&#x31;&#56;&#54;</a>:&#x2F;home&#x2F;acs&#x2F;</p>
</blockquote>
<p>（2）将远程服务器上的文件下载到本地（&#x2F;home&#x2F;acs&#x2F;.bashrc –&gt; D:\psftp\）</p>
<blockquote>
<p>pscp -P 20000 <a href="mailto:&#x61;&#x63;&#115;&#64;&#x31;&#49;&#x32;&#46;&#x31;&#x32;&#x36;&#46;&#x37;&#x38;&#x2e;&#49;&#x38;&#x36;">&#x61;&#x63;&#115;&#64;&#x31;&#49;&#x32;&#46;&#x31;&#x32;&#x36;&#46;&#x37;&#x38;&#x2e;&#49;&#x38;&#x36;</a>:&#x2F;home&#x2F;acs&#x2F;.bashrc d:\psftp<br /></p>
</blockquote>
<p>（3）将本地文件夹上传到服务器中（D:\psftp\local_test\ –&gt; &#x2F;home&#x2F;acs&#x2F;）：</p>
<blockquote>
<p>pscp -P 20000 -r d:\psftp\local_test <a href="mailto:&#97;&#x63;&#x73;&#x40;&#49;&#49;&#50;&#x2e;&#x31;&#x32;&#x36;&#46;&#55;&#x38;&#x2e;&#49;&#x38;&#54;">&#97;&#x63;&#x73;&#x40;&#49;&#49;&#50;&#x2e;&#x31;&#x32;&#x36;&#46;&#55;&#x38;&#x2e;&#49;&#x38;&#54;</a>:&#x2F;home&#x2F;acs&#x2F;</p>
</blockquote>
<p>（4）将远程服务器上的文件夹下载到本地（&#x2F;home&#x2F;acs&#x2F;.ssh&#x2F; –&gt; D:\psftp\）</p>
<blockquote>
<p>pscp -P 20000 -r <a href="mailto:&#x61;&#99;&#115;&#x40;&#x31;&#49;&#x32;&#46;&#x31;&#x32;&#54;&#46;&#x37;&#x38;&#x2e;&#x31;&#56;&#x36;">&#x61;&#99;&#115;&#x40;&#x31;&#49;&#x32;&#46;&#x31;&#x32;&#54;&#46;&#x37;&#x38;&#x2e;&#x31;&#56;&#x36;</a>:&#x2F;home&#x2F;acs&#x2F;.ssh d:\psftp<br /></p>
</blockquote>
<p>2.5 plink.exe<br>用于在本地执行远程服务器的命令，直接在cmd中执行即可。</p>
<p>如果没指定端口，则端口是putty中Default Settings这个session对应的端口。</p>
<p>在本地执行aliyun上的命令：</p>
<blockquote>
<p>plink -P 22 <a href="mailto:&#x77;&#x78;&#120;&#64;&#x31;&#49;&#x32;&#46;&#49;&#x32;&#x36;&#x2e;&#55;&#56;&#46;&#x31;&#56;&#x36;">&#x77;&#x78;&#120;&#64;&#x31;&#49;&#x32;&#46;&#49;&#x32;&#x36;&#x2e;&#55;&#56;&#46;&#x31;&#56;&#x36;</a> “ls -al”</p>
</blockquote>
<p>在本地执行django上的命令：</p>
<blockquote>
<p>plink -P 20000 <a href="mailto:&#x61;&#x63;&#115;&#x40;&#x31;&#49;&#50;&#46;&#x31;&#x32;&#x36;&#46;&#55;&#56;&#x2e;&#x31;&#56;&#54;">&#x61;&#x63;&#115;&#x40;&#x31;&#49;&#50;&#46;&#x31;&#x32;&#x36;&#46;&#55;&#56;&#x2e;&#x31;&#56;&#54;</a> “ls -al”</p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>05_PuTTY</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>WinSCP使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/04_WinSCP/02_WinSCP%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>WinSCP使用<br>（1）双击启动软件<br>启动页面如下：</p>
<p><img src="/assets/2/image-20220515012216-79cotj4.png" alt="image.png"></p>
<p>（2）新建站点，输入主机名、用户名和密码，进行登录</p>
<p><img src="/assets/2/image-20220515012225-mzq8tjm.png" alt="image.png"></p>
<p>两种登录方式：<br>（1）点击登录<br>输入上述信息，直接点击登录（缺点是登录信息是一次性的，退出后，再次登录时需要重新填写主机名、用户名和密码）<br>（2）先保存站点信息，再点击登录（推荐使用）</p>
<p><img src="/assets/2/image-20220515012225-mzq8tjm.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515012225-mzq8tjm.png" alt="image.png"></p>
<p>（3）第一次登录，会弹出如下窗口，点击“是”</p>
<p><img src="/assets/2/image-20220515012250-avv2glb.png" alt="image.png"></p>
<p>(4)稍等片刻，登录成功，如下图:</p>
<blockquote>
<p>左侧是本地目录，右侧是远程服务端目录</p>
</blockquote>
<p><img src="/assets/2/image-20220515012315-y3d4t46.png" alt="image.png"></p>
<p>之后就可以进行文件的上传下载了。</p>
<p>本地文件上传到远端：直接鼠标拖动即可<br>远端文件下载到本地：远端文件右键删除</p>
<p><img src="/assets/2/image-20220515012324-8kchoxm.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>04_WinSCP</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>WinSCP安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/04_WinSCP/01_WinSCP%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>目录<br>一、WinSCP下载<br>二、WinSCP安装<br><br /></p>
<p>WinSCP介绍：<br>WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件。</p>
<p>一、WinSCP下载<br><a href="https://winscp.net/eng/download.php">访问官网下载地址</a>，点击要下载的版本，如下：</p>
<p><img src="/assets/2/image-20220515011917-bl7cxi7.png" alt="image.png"></p>
<p>下载的安装包如下：</p>
<p><img src="/assets/2/image-20220515011956-n7jpaza.png" alt="image.png"></p>
<p>二、WinSCP安装<br>双击安装包，进行安装<br>（1）点击接受</p>
<p><img src="/assets/2/image-20220515012007-dwxssmo.png" alt="image.png"></p>
<p>（2）安装类型：我这里选择自定义安装，点击下一步</p>
<p><img src="/assets/2/image-20220515012015-f9j7zb4.png" alt="image.png"></p>
<p>（3）配置安装路径，点击下一步</p>
<p><img src="/assets/2/image-20220515012036-gjt7x0e.png" alt="image.png"></p>
<p>（4）默认组件配置，点击下一步</p>
<p><img src="/assets/2/image-20220515012043-8zam0fn.png" alt="image.png"></p>
<p>（5）默认，直接点击下一步</p>
<p><img src="/assets/2/image-20220515012051-4bpql5j.png" alt="image.png"></p>
<p>（6）选择用户界面风格，点击下一步</p>
<p><img src="/assets/2/image-20220515012057-zpy08yw.png" alt="image.png"></p>
<p>（7）点击安装</p>
<p><img src="/assets/2/image-20220515012104-yvf0q2o.png" alt="image.png"></p>
<p>安装完成页面，如下</p>
<p><img src="/assets/2/image-20220515012114-k3nq41p.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>04_WinSCP</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>secureCRT使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/03_secureCRT/02_secureCRT%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>SecureCRT的使用教程</p>
<p><img src="/assets/2/image-20220515011727-2r89gr4.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011733-w3iyx4t.png" alt="image.png"><br>完事之后点击connect<br><img src="/assets/2/image-20220515011739-vc9qzn9.png" alt="image.png"><br>输入账号密码登录<br><img src="/assets/2/image-20220515011720-epgnkxx.png" alt="image.png"></p>
<p>登录成功之后就可以进行你的操作了！！！！！！！</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>03_secureCRT</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>secureCRT安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/03_secureCRT/01_secureCRT%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>SecureCRT安装全部教程(步骤详细)</p>
<p><a href="https://pan.baidu.com/s/1Zz006N_6yOPKUPl0jimoUg">下载安装包地址</a><br>提取码: tacx</p>
<p><a href="/assets/3/VanDyke.SecureCRT.and.SecureFX.8.3.0.Build.1514.rar">直接下载地址</a></p>
<p><img src="/assets/2/image-20220515010946-u5vixgy.png" alt="image.png"></p>
<p>双击安装程序</p>
<p><img src="/assets/2/image-20220515011334-3ahrvo7.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011340-4zuq2tn.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011346-i95a9jq.png" alt="image.png"></p>
<p>直接默认选中的点击下一步</p>
<p><img src="/assets/2/image-20220515011352-61ani2p.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011357-6g4ln5o.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011409-wb0hdch.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011416-2ovv589.png" alt="image.png"></p>
<p>安装完成之后不要打开软件<br>将Patch.And.Keymaker-ZWT 压缩文件 复制到安装目录下面，然后解压到当前文件夹</p>
<p><img src="/assets/2/image-20220515011423-agob3my.png" alt="image.png"></p>
<p>以管理员身份运行这个文件<br>如果找不到这个运行程序可能是你的系统检测拦截了，找到这个文件并还原就可以了</p>
<p><img src="/assets/2/image-20220515011429-byfkq6j.png" alt="image.png"></p>
<p>点击Generate按钮，将name、company、license复制到一个记事本上，保存这些信息。然后点击Generate按钮。再点击Patch按钮，选择安装目录下的SecureCRT.exe，运行完成会提示成功。</p>
<p><img src="/assets/2/image-20220515011440-85u8h87.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011446-coptn7t.png" alt="image.png"></p>
<p>提示成功！</p>
<p><img src="/assets/2/image-20220515011452-mjqj7e1.png" alt="image.png"></p>
<p>打开软件</p>
<p><img src="/assets/2/image-20220515011458-074wsnj.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011504-djiv8un.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011509-q4k4nmi.png" alt="image.png"></p>
<p>将刚刚从keygen 中复制出来的 license的信息粘贴进去</p>
<p><img src="/assets/2/image-20220515011539-j89jd9i.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011544-v71ylr9.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515011544-v71ylr9.png" alt="image.png"></p>
<p>我不记得我有设置密码，我就选择了下面这个(你们跟我这个不一样的话，可以不用按我这个哈)</p>
<p><img src="/assets/2/image-20220515011611-0fk8j9v.png" alt="image.png"></p>
<p>是否要检查更新(我不更新…)</p>
<p><img src="/assets/2/image-20220515011618-i45za72.png" alt="image.png"></p>
<p>好了，到这就安装并且破解完成<br><br /></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>03_secureCRT</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/01_VMware/01_VMware/</url>
    <content><![CDATA[<p>1、准备工作<br>VMware Workstation虚拟机软件<br><a href="https://www.vmware.com/cn/products/workstation-pro.html">VMware Workstation官网</a><br>系统镜像 （使用ContOS 7示例）<br><a href="https://www.centos.org/download/">ContOS 官网下载地址</a><br>2.载入镜像</p>
<p><img src="/assets/1/image-20211221100125-tks1t19.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100132-b8cmgz5.png" alt="image.png"><img src="/assets/1/image-20211221100140-5a5rsrv.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100151-6mia1zl.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100156-57s3rzq.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100200-rjkr466.png" alt="image.png"><img src="/assets/1/image-20211221100205-72zrms0.png" alt="image.png"><img src="/assets/1/image-20211221100258-myh67of.png" alt="image.png"></p>
<p>到此，我们就成功把系统镜像文件载入虚拟机了。</p>
<p>3、 安装系统<br>经过第二步系统启动后，进入这个页面，点击黑框，这时候，我们就可以操作ContOS系统了，放向键选中第一项，回车。进入系统安装。</p>
<p><img src="/assets/1/image-20211221100333-h0d8ib5.png" alt="image.png"></p>
<p>然后等待系统跑就行了。</p>
<p><img src="/assets/1/image-20211221100341-akkmb09.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100348-scaymac.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100423-3m50yno.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100428-3lbq38z.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100435-0moq65v.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100452-rw65w8t.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100503-2y2amz0.png" alt="image.png"></p>
<p>同样的，选择完毕后，点击Done</p>
<p><img src="/assets/1/image-20211221100546-f5zr9tf.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100714-j9new7l.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100551-w3o49xy.png" alt="image.png"></p>
<p>这里我是选择设置root用户密码，毕竟是虚拟机，直接用root用户就好了。</p>
<p><img src="/assets/1/image-20211221100558-47d8cxr.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100604-6m9d9h9.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100609-km8hmf7.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211221100615-nil4aae.png" alt="image.png"></p>
<p>接下来等待开机就行了,直到下图界面，才开始操作</p>
<p><img src="/assets/1/image-20211221100624-jn8575d.png" alt="image.png"></p>
<p>ok，到此完成全部安装操作<br>然后配置ip：vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</p>
<pre><code>    修改ONBOOT=no 为    ONBOOT=yes

                                                         重启系统
</code></pre>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>01_VMware</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Xshell</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/02_Xshell/01_Xshell/</url>
    <content><![CDATA[<p><strong>Xshell 是一个强大的远程管理软件，它支持SSH，TELNET 协议。Xshell可以在Windows下访问远端服务器、路由器、网络机顶盒等，类似的常用软件还有putty，以及Windows下的Telnet。</strong></p>
<p><strong>下面简单介绍一下xshell软件。</strong></p>
<p><strong>Xshell的几个特点：</strong></p>
<p><strong>1、界面设计简洁、人性，使用方便。</strong></p>
<p><strong>2、支持标签，打开多个服务器时候很方便，点击标签切换。</strong></p>
<p><strong>3、可以保存密码，注意安全，尽量不要保存，除非个人电脑。</strong></p>
<p><strong>Xshell下载安装及基本使用方法：</strong></p>
<p><strong>1、从网上搜索下载，注意别下载错了，很多混有病毒的。我一般用来管理自己的路由器，本地局域网内，用的是xshell4绿色中文版的。</strong></p>
<p><strong>2、打开xshell。</strong></p>
<p><img src="/assets/1/image-20211122223946-4zmezpj.png" alt="image.png"></p>
<p><strong>3、个性化设置。设置好，用起来更顺手。经过这样设置，以后使用事半功倍。其他地方，根据自己的喜好，可以进行相关设置。</strong></p>
<p><img src="/assets/1/image-20211122223957-ut3oqle.png" alt="image.png"></p>
<p><strong>4、连接服务器或路由器。点击打开。</strong></p>
<p><img src="/assets/1/image-20211122224005-2ek1wc5.png" alt="image.png"></p>
<p><strong>5、点击左上角，新建</strong></p>
<p><img src="/assets/1/image-20211122224012-un6v0dw.png" alt="image.png"></p>
<p><strong>6、填写完，点击确定。其他高级参数，有需要可以填写。常用的主机或路由器，可以点击身份验证，填写用户名和密码，这样不需要输入就可以直接登录系统了。</strong></p>
<p><img src="/assets/1/image-20211122224019-r50vjsq.png" alt="image.png"></p>
<p><strong>7、第一次连接会出现提示，如下图。</strong></p>
<p><img src="/assets/1/image-20211122224026-fmhe8f2.png" alt="image.png"></p>
<p><strong>8、登录成功，可以输入相关命令，进行各种操作。</strong></p>
<p><img src="/assets/1/image-20211122224032-ktayq76.png" alt="image.png"></p>
<p><strong>xshell几个常用命令以及注意事项：</strong></p>
<p><strong>cd .. 回到上级目录</strong></p>
<p><strong>cd xx 进入xx目录</strong></p>
<p><strong>rm xx 删除文件xx</strong></p>
<p><strong>rm -rf 删除目录及其所包含的所有文件，</strong>高危命令，一定谨慎</p>
<p><strong>mkdir xx 创建目录xx</strong></p>
<p><strong>vi 查看&#x2F;编辑文件 按 i进入编辑模式；按Esc键退出编辑模式。按:q退出不保存； 按：wq保存退出。</strong></p>
<p><strong>更多命令可以搜索，不同系统命令可能有所区别。</strong></p>
<p><strong>以上就是对xshell软件的简单介绍，以及几点注意事项和个人的心得体会。</strong></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>04_Linux相关</category>
        <category>02_Xshell</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>phpMyAdmin使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/04_phpMyAdmin/02_phpMyAdmin%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>下面由<a href="https://www.php.cn/tool/phpmyadmin/"><strong>phpmyadmin入门教程</strong></a>栏目给大家介绍phpmyadmin工具的使用方法，希望对需要的朋友有所帮助！</p>
<p><img src="/assets/2/image-20220515004609-7g3f231.png" alt="image.png"></p>
<p><strong>什么是phpMyAdmin ？</strong></p>
<p>phpMyAdmin 是众多 MySQL图形化管理工具中使用最为广泛的一种，是一款使用PHP 开发的基于B&#x2F;S模式的 MySQL 客户端软件，该工具是基于 Web 跨平台的管理程序，并且支持简体中文，用户可以在官网上下载最新版本的。</p>
<p>phpMyAdmin 为Web 开发人员提供了类似 Access，SQL Server 的图形化数据库操作界面，通过该管理工具可以对 MySQL 进行各种操作，如何创建数据库，数据表和生成 MySQL 数据库脚本文件等。</p>
<p><strong>功能特点</strong></p>
<p>PHP是一个基于服务端来创建动态网站的脚本语言，您可以用PHP和HTML生成网站主页。当一个访问者打开主页时，服务端便执行PHP的命令并将执行结果发送至访问者的浏览器中，这类似于ASP和CoildFusion，然而PHP和他们不同之处在于PHP开放源码和跨越平台，PHP可以运行在WINDOWSNT和多种版本的UNIX上。它不需要任何预先处理而快速反馈结果，它也不需要mod_perl的调整来使您的服务器的内存映象减小。PHP消耗的资源较少，当PHP作为ApacheWeb服务器一部分时，运行代码不需要调用外部二进制程序，服务器不需要承担任何额外的负担。</p>
<p>除了能够操作您的页面外，PHP还能发送HIIP的标题。您可以设置cookie,管理数字签名和重定向用户，而且它提供了极好的连通性到其它数据库（还有ODBC），集成各种外部库来做用PDF文档解析XML的任何事情。</p>
<p>phpMyAdmin 是一个用PHP编写的软件工具，可以通过web方式控制和操作MySQL数据库。通过phpMyAdmin 可以完全对数据库进行操作，例如建立、复制和删除数据等等。如果使用合适的工具，MySQL数据库的管理就会变得相当简单。应用 MySQL 命令行方式需要对 MySQL 知识非常熟悉，对SQL语言也是同样的道理。不仅如此，如果数据库的访问量很大，列表中数据的读取就会相当困难。</p>
<p>当前出现很多GUI MySQL客户程序，其中最为出色的是基于 Web 的phpMyAdmin 工具。这是一种 MySQL数据库前台的基于PHP的工具。</p>
<p>PhpMyAdmin 的缺点是必须安装在 Web 服务器中，所以如果没有合适的访问权限，其它用户有可能损害到 SQL 数据。</p>
<p><strong>安装过程</strong></p>
<p>如果使用集成化安装包来配置PHP的开发环境， 就无需单独下载 phpMyAdmin 图形化管理工具，因为集成化的安装包中基本上都包含了图形化管理工具。我们这里就使用了集成化安装包phpStudy，</p>
<p>如果使用的不是集成化安装包，那么就需要自己安装phpMyAdmin图形化管理工具了，大家可以去官网下载最新的版本，具体安装过程我们在这里就不详细介绍了，大家可以阅读《<a href="http://www.php.cn/php-weizijiaocheng-357397.html">http://www.php.cn/php-weizijiaocheng-357397.html</a>》这篇文章，该篇详细介绍了phpMyAdmin安装过程！</p>
<p><strong>使用</strong></p>
<p>phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的资料库管理具。</p>
<p>可以管理整个MySQL服务器(需要超级用户)，也可以管理单个数据库。为了实现后一种，你将需要合理设置MySQL用户，他只能对允许的数据库进行读&#x2F;写。那要等到你看过MySQL手册中相关的部分。</p>
<p>无论是在 Windows 操作系统还是 Linux 操作系统，phpMyAdmin图形化管理工具的使用方法都是一样。</p>
<p><strong>phpMyAdmin 图形化管理工具的可视化界面中操作数据库</strong></p>
<p><strong>操作数据库</strong></p>
<p>在浏览器的地址栏中输入：localhost&#x2F;phpMyAdmin&#x2F;，回车，就可以进入phpMyAdmin主界面了。接下来就可以进行 MySQL 数据库的操作了 。</p>
<p><strong>1.创建数据库</strong></p>
<p>在 phpMyAdmin 的主界面中，可以看见有 “语言-languange” 的下拉框，我们可以在下拉框中选择“中文-Chinese simplified”选项，然后上有个”服务器连接校对“ 我们一般会选择utf8_general_ci 简体中文编码格式，防止出现乱码的情况。</p>
<p><img src="/assets/2/image-20220515004630-491h0h4.png" alt="image.png"></p>
<p>当上面的设置好了，下面我开始创建数据库，点击左上方的数据库就会出现下面的界面：</p>
<p><img src="/assets/2/image-20220515004638-xn9e0jj.png" alt="image.png"></p>
<p>然后在文本框中输入自己的数据库名字，我们这里是”php.cn”,虽然我们在一开始就设置过了这个编码格式，但是为了万一，我们可以再在这里再次选择 “utf8_general_ci ”，然后点击创建按钮之后再左侧栏就可以看见你创建的数据库了，如下图：</p>
<p><img src="/assets/2/image-20220515004645-vsxnoml.png" alt="image.png"></p>
<p>我们可以点击一下我们创建的数据库，就可以对数据库进行管理了：</p>
<p><img src="/assets/2/image-20220515004653-ostl8e8.png" alt="image.png"></p>
<p>上面就是创建数据库成功了！</p>
<p><strong>2.修改数据库</strong></p>
<p>在数据库管理界面（上图），有个“操作”按钮，点击进入修改操作数据库的页面。</p>
<p>1.进入修改页面左上方可以对当前数据库执行创建数据表的操作，在创建数据表提示信息下的两个文本框中分别输入要创建的数据表名字和字段总数，点击“执行”按钮，就进入创建数据表结构页面，这个我们后面的文章会有详细介绍。</p>
<p>2.在进入修改页面的右上方可以对数据库重命名，在“将数据库改名为:”的文本框中输入心得数据库名字，单击“执行”就可以修改数据库名成功。</p>
<p><img src="/assets/2/image-20220515004702-j091x2w.png" alt="image.png"></p>
<p><strong>3.删除数据库</strong></p>
<p>同样是点击“操作”按钮进入修改页面，在“新建数据表”的正下面就是删除数据库，点击就可以删除数据库，</p>
<p><img src="/assets/2/image-20220515004708-68bi15z.png" alt="image.png"></p>
<p>注意：</p>
<p>数据库在我们日常开发中是非常重的，里面有很多数据，如果要删除一定要谨慎，一旦删除就不可回复，建议再删除之前先备份数据库！</p>
<p>操作数据表是以选择指定的数据库为前提，然后在该数据库中创建并管理数据表。下面我们将详细介绍如何创建，修改以及删除数据表！</p>
<p><strong>1.创建数据表</strong></p>
<p>下面我们使用用户的账户为例子，详细介绍数据表的创建方法。</p>
<p>在创建php.cn数据库之后，点击php.cn数据库，在“新建数据表”下面的文本框中输入数据表的名称以及字段数，然后点击“执行”按钮，就可以创建数据表，如下图：</p>
<p><img src="/assets/2/image-20220515004718-fhymxge.png" alt="image.png"></p>
<p>在成功创建数据表之后，将显示数据表结构的界面，在该界面的表单中输入各个字段的详细信息，包括字段名，数据类型，长度&#x2F;值，编码格式，是否为空和主键等等，以完成对表结构的详细设置，当所有的信息都填写完成之后，单击“保存”就可以创建数据表结构，如下图所显示，</p>
<p><img src="/assets/2/image-20220515004728-r2pn0im.png" alt="image.png"></p>
<p>技巧：</p>
<p>点击“保存”按钮之后，单击“数据表表名字”，可以将数据表结构以横版显示，便于编辑结构！</p>
<p><strong>2.修改数据表</strong></p>
<p>一个新的数据表创建后，进入到数据表结构页面中，在这里可以通过改变数据表的结构来修改表。可以执行添加列，删除列，索引列，修改列的数据类型或者字段的长度&#x2F;值等操作，如下图：</p>
<p><img src="/assets/2/image-20220515004736-x7msdes.png" alt="image.png"></p>
<p><strong>3.删除数据表</strong></p>
<p>删除数据表跟数据库大同小异，点击数据表进入数据表结构页面中，再右上角有一个“操作按钮”，点击进入操作页面，在该页面有对表的排序修改，可有将表移至其他数据库中，可以修改表选项，以及表维护，在右下角有一个“删除数据或者数据表”，点击“删除数据表”就可以删除数据表了！如下图：</p>
<p><img src="/assets/2/image-20220515004742-2nog8uq.png" alt="image.png"></p>
<p><strong>使用SQL语句操作数据表的图文详解</strong></p>
<p>单击 phpMyAdmin 主界面中的 “SQL”按钮，打开SQL 语句编辑区，输入完整的 SQL 语句，来实现数据的查询，添加，修改和删除操作！</p>
<p><strong>1.使用 SQL 语句插入数据</strong></p>
<p>在 SQL 语句编辑区中使用 insert 语句项数据表 php.cn 中插入数据，单击”执行”按钮，向数据表中插入一条数据，如果提交的 SQL 语句有错误的，那么系统就会给出警告，提示用户修改，如下图：</p>
<p><img src="/assets/2/image-20220515004750-bcfnxs2.png" alt="image.png"></p>
<p>如果 SQL语句没有错误提交后点击左上角的“浏览”按钮，进入数据展示页面，如下图：</p>
<p><img src="/assets/2/image-20220515004756-6dtr5vk.png" alt="image.png"></p>
<p>技巧：</p>
<p>为了编写方便，可以利用右侧的属性列表来选择要操作的列，只要选中要添加的列，双击其选项或者单击“&lt;&lt;”按钮添加列名称就可以了！</p>
<p><strong>2.使用 SQL 语句修改数据</strong></p>
<p>在 SQL编辑区使用 update 语句修改数据信息，如：id 为 1的用户的名称修改为“PHP中文网”，密码修改为：“654321”，具体看下图：</p>
<p><img src="/assets/2/image-20220515004804-4xt8p40.png" alt="image.png"></p>
<p>上面的图使之后成功之后的页面，这样就可以看下数据展示的页面，</p>
<p>修改之前的：</p>
<p><img src="/assets/2/image-20220515004811-nmao1ja.png" alt="image.png"></p>
<p>修改之后的：</p>
<p><img src="/assets/2/image-20220515004816-m5ja1xj.png" alt="image.png"></p>
<p>上面可以看出已经修改成功过了！</p>
<p><strong>3.使用 SQL 语句查询数据</strong></p>
<p>在 SQL 语句编辑区使用 select语句检索指定条件的数据信息，如：将di 小与 4 的信息全部显示出来，SQL语句如下图：</p>
<p><img src="/assets/2/image-20220515004823-rgxrpvm.png" alt="image.png"></p>
<p>单击“执行”按钮，实现如下图：</p>
<p><img src="/assets/2/image-20220515004830-6agys6e.png" alt="image.png"></p>
<p>除了对整个表的简单查询外，还可以进行一些复杂的条件查询（使用 where 子句提交 LIKE、ORDERBY，GROUP BY等条件查询语句）及多表查询！</p>
<p><strong>4.使用 SQL 语句删除数据</strong></p>
<p>在 SQL 语句编辑区使用 delete 语句检索指定条件的数据或者全部信息，比如：删除名称为 baidu.com 的信息，SQL语句如下图：</p>
<p><img src="/assets/2/image-20220515004837-jaehi21.png" alt="image.png"></p>
<p>点击“执行”之后会弹出一个框，问你是不是确认，点击确认之后，如下图：</p>
<p><img src="/assets/2/image-20220515004843-7l1zwqz.png" alt="image.png"></p>
<p>之后点击左上角的浏览，你会发现用户名为 baidu.com信息被删除了，如下图：</p>
<p><img src="/assets/2/image-20220515004854-wymjvpi.png" alt="image.png"></p>
<p>注意：如果 delete语句后面没有 where 条件语句，那么就会删除指定数据表中的全部数据。</p>
<p><strong>管理数据记录的图文详解</strong></p>
<p>在创建完数据库以及数据表后，可以通过操作数据表来管理数据记录。在本节文章中我们将分别介绍插入数据，浏览数据，搜索数据的方法！</p>
<p><strong>1.插入数据</strong></p>
<p>选择某一个数据表后，在导航位置有一个“插入”的按钮，单击进入插入页面，在页面中输入各个字段值，单击“执行”按钮，就可以插入数据，如下图所示：</p>
<p><img src="/assets/2/image-20220515004901-6ozodhv.png" alt="image.png"></p>
<p>最后点击“执行”按钮，就可以插入数据了，如下图：</p>
<p><img src="/assets/2/image-20220515004909-rfn41ti.png" alt="image.png"></p>
<p><strong>2.浏览数据</strong></p>
<p>选择某个数据或者是成功插入数据以后，点击导航栏的 “浏览”按钮，进入数据展示页面，可以单击数据列表中的“编辑”按钮，就可以对数据进行编辑，单击“删除”按钮，就可以删除该条记录！如下图：</p>
<p><img src="/assets/2/image-20220515004915-lz9qwqw.png" alt="image.png"></p>
<p><strong>3.搜索数据</strong></p>
<p>选择某一个数据表之后，在导航栏点击“搜索”按钮，进入搜索页面，可以在选择字段的列表框中选择一个或者多个列。如果选择多个列，按下 Ctrl键，然后依次单击要选择的字段名，查询结果将按照选择的字段名进行输出 。</p>
<p><img src="/assets/2/image-20220515004921-m20zqo6.png" alt="image.png"></p>
<p>在该界面中可以对记录按条件进行查询，查询方式有两种：</p>
<p>第一种：选择构建 where语句查询，直接在“添加搜索条件”文本框中输入查询语句，然后单击其后的执行按钮。</p>
<p>第二种：使用按列查询，选择查询的条件，并在文本框中输入要查询的值，单击“执行按钮”。</p>
<p><strong>导入和导出数据表的图文介绍</strong></p>
<p>导入和导出数据是互逆的两个操作，导入数据是通过扩展名为.sql的文件导入到数据库中，导出数据是将数据表结构，表记录储存为.sql的文件，可以通过导入导出实现数据库的备份和还原操作。下面我们将分别介绍导入导出的方法！</p>
<p><strong>1.导出数据表</strong></p>
<p>首先我们要选导出的数据表或者数据库，我们这里就以导出数据表为例子，选择好数据表之后，在导航栏中点击“导出”按钮，进入导出数据的页面，会有两个选择“快速”和“自定义”如下图：</p>
<p><img src="/assets/2/image-20220515004929-vpan9p1.png" alt="image.png"></p>
<p>我们正常都是直接选择快速，然后格式格式选择：SQL，最后点击执行，然后保存文件存放的位置！</p>
<p><strong>2.导入数据表</strong></p>
<p>先选择数据库，然后在导航栏中点击“导入”的按钮，进入导入的页面，然后点击“选择文件”按钮，找到.sql文件的位置，导入文件格式为SQL，点击“执行”按钮，就可以将数据表导入到数据库中，如下图：</p>
<p><img src="/assets/2/image-20220515004935-1r5fw9i.png" alt="image.png"></p>
<p>注意：</p>
<p>在导入文件前，首先确保数据库中存在与导入数据库同名的数据库，如果没有同名的，则要在数据库中创建一个名称与数据文件中数据库相同，然后在导入数据，另外，当前数据库中，不能与将要导入的数据库中的数据表重名的数据表存在，如果有重名的表存在，导入文件就会失败，并且提示错误信息。</p>
<p>总结：</p>
<p>phpMyAdmin是提供 MySQL数据库管理和操作的可视化工具，可以方便的对MySQL 数据库进行管理，通过学习本章的内容，小伙伴们可以独立安装和配置phpMyAdmin ，并且可以不在命令提示符下创建数据库和数据表的瓶颈，使用可视化的工具 phpMyAdmin 轻松的管理数据库和数据表。对于大型网站，可以使用导入导出文件来维护网站数据库！</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>04_phpMyAdmin</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>phpMyAdmin安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/04_phpMyAdmin/01_phpMyAdmin%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>管理数据库是运行网站的一个复杂但必要的部分。幸运的是，有像phpMyAdmin这样的软件可以让这个过程变得更容易。这种流行的管理工具似乎很难学习，但是一旦掌握了它，访问和修改数据库将变得轻而易举。</p>
<p>最困难的部分是知道如何安装phpMyAdmin并在您的Web服务器上进行设置。如果你遇到了麻烦，你肯定不是唯一一个。</p>
<p>在本文中，我们将逐步向您展示如何在所有主要操作系统上安装phpMyAdmin，以及如何配置它。</p>
<ol>
<li>什么是phpMyAdmin？</li>
<li>phpMyAdmin要求</li>
<li>安装phpMyAdmin</li>
<li>如何访问phpMyAdmin</li>
<li>配置phpMyAdmin</li>
<li>Adminer：一个更简单的phpMyAdmin替代方案</li>
</ol>
<h3 id="什么是phpMyAdmin？"><a href="#什么是phpMyAdmin？" class="headerlink" title="什么是phpMyAdmin？"></a><strong>什么是phpMyAdmin？</strong></h3><p>每个网站背后都有一个数据库。该数据库允许您存储从用户帐户信息到您在网站上发布的帖子的数据。虽然有许多数据库服务，但MySQL是最受欢迎的一种。并且最有可能的是您的网站正在使用的那个。MariaDB是一种常见的替代方案。</p>
<p>直接与MySQL交互可能会很复杂且令人困惑，尤其是当您不熟悉网站管理时。但是与数据库交互通常是站点维护的必要部分。</p>
<p>phpMyAdmi旨在为MySQL带来一个基于浏览器的可视化界面，并让您更轻松地使用您的数据库。由于其受欢迎程度，许多网络托管服务包括访问phpMyAdmin。</p>
<h3 id="为什么需要phpMyAdmin？"><a href="#为什么需要phpMyAdmin？" class="headerlink" title="为什么需要phpMyAdmin？"></a>为什么需要phpMyAdmin？</h3><p>如果没有像phpMyAdmin这样的工具，您访问数据库的唯一选择就是使用命令行。这意味着您没有可视化界面——只有一个文本提示，您可以在其中输入命令。这样做可能会令人困惑，甚至可能导致意外破坏您的网站。</p>
<p>phpMyAdmin是免费和开源的。广泛的网络主机支持它，您甚至可以自己安装，而无需支付一分钱。一旦您安装了它，从可视化界面执行数据库命令就会更加直观。</p>
<p>您可以自己尝试phpMyAdmin，看看它是否是您想要使用的数据库管理器。一旦您试驾并决定喜欢它，您就可以在您的服务器上安装该工具。</p>
<h3 id="phpMyAdmin要求"><a href="#phpMyAdmin要求" class="headerlink" title="phpMyAdmin要求"></a><strong>phpMyAdmin要求</strong></h3><p>幸运的是，安装phpMyAdmin的要求相对简单。如果您有任何类型的Web服务器，您几乎肯定可以让它运行。以下是详细要求：</p>
<ul>
<li>任何类型的网络服务器</li>
<li>MySQL或MariaDB 5.5或更新版本</li>
<li>支持Javascript、cookies和Bootstrap 4.5（访问phpMyAdmin）的网络浏览器</li>
<li>PHP 7.2.5或更高版本</li>
<li>其他PHP要求：会话和SPL扩展、哈希、ctype和JSON支持。其他扩展如mbstring可以提高性能或添加额外的次要功能（完整列表请参见需求页面）。</li>
</ul>
<p><img src="/assets/2/image-20220515004413-g6yc9al.png" alt="image.png"><br>phpMyAdmin系统要求</p>
<p>在您尝试安装phpMyAdmin之前，请记住许多Web主机已经安装了它。</p>
<p>在安装phpMyAdmin之前，请检查您的网络主机的文档以确保他们尚未安装它。</p>
<h3 id="安装phpMyAdmin"><a href="#安装phpMyAdmin" class="headerlink" title="安装phpMyAdmin"></a><strong>安装phpMyAdmin</strong></h3><p>一旦您检查以确保您的服务器支持phpMyAdmin，就可以开始安装它了。Web服务器有多种操作系统，因此我们包含了所有最流行的操作系统，包括Windows、Mac和多个Linux发行版。</p>
<p>有了这个，这里是安装phpMyAdmin的分步说明。</p>
<h3 id="如何在Windows-10上安装phpMyAdmin"><a href="#如何在Windows-10上安装phpMyAdmin" class="headerlink" title="如何在Windows 10上安装phpMyAdmin"></a>如何在Windows 10上安装phpMyAdmin</h3><p>根据要求，您将需要一个带有PHP的Web服务器和一个数据库才能使用phpMyAdmin。虽然您无疑可以手动下载Apache、PHP和MySQL，但还有一个更简单的选择，可以在Windows计算机上启动和运行服务器。</p>
<p>WAMP（Windows、Apache、MySQL和PHP）是免费软件，可让您轻松创建具有所有先决条件的服务器。如果XAMPP for Windows（Apache、MariaDB、PHP 和 Perl）更适合您的需求，您也可以尝试它。</p>
<p><img src="/assets/2/image-20220515004419-c91rit5.png" alt="image.png"><br>WAMPserver的主页</p>
<p>下载其中之一后，只需安装它并完成设置过程即可。</p>
<p>假设您使用的是WAMP或XAMPP。这两个都已经与phpMyAdmin一起提供了！在您的浏览器中，导航到<code>http://localhost/phpMyAdmin</code> <strong>，</strong> 您应该会看到登录屏幕，确认您已正确安装所有内容。</p>
<h3 id="如何在Mac上安装phpMyAdmin"><a href="#如何在Mac上安装phpMyAdmin" class="headerlink" title="如何在Mac上安装phpMyAdmin"></a>如何在Mac上安装phpMyAdmin</h3><p>在Mac上获取phpMyAdmin有点不同。所有的先决条件都是一样的。但由于macOS附带Apache和PHP，因此您无需下载它们。</p>
<p>对于Mac，您有两个选择：您可以像使用其他操作系统一样使用XAMPP或手动安装所有内容。</p>
<p><img src="/assets/2/image-20220515004425-lhr83xw.png" alt="image.png"><br>XAMPP OSX下载列表</p>
<p>下载适用于OS X的XAMPP，打开它，然后将其放入您的应用程序文件夹中。</p>
<p>打开XAMPP Control<code>/Applications/XAMPP/manager-osx.app</code>以启动Apache和MySQL服务器。如果您随后访问<code>http://localhost</code>，您应该会发现一切正常，并且您的phpMyAdmin登录信息位于“工具”部分。</p>
<p>如果您改为手动安装phpMyAdmin，则该过程很简单。由于您已经拥有Apache和PHP，因此您只需要下载MySQL。确保从下拉列表中选择macOS。下载并安装该文件，按照说明进行操作，并记录提供给您的所有用户名和密码。</p>
<p>然后您可以打开系统偏好设置并启动MySQL以启动服务器。您还可以通过在终端中运行以下命令来启动Apache：</p>
<pre><code class="bash">sudo apachectl start
</code></pre>
<p><img src="/assets/2/image-20220515004430-xuw8tyc.png" alt="image.png"><br>在Mac终端中启动Apache的命令</p>
<p>有了这个，剩下的就是安装phpMyAdmin。将文件夹重命名为“phpMyAdmin”并将其移动到 &#x2F;Library&#x2F;WebServer&#x2F;Documents&#x2F;。通过在浏览器中访问<a href="http://localhost/phpMyAdmin%E6%A3%80%E6%9F%A5%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%AE%83%E5%B7%B2%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E3%80%82">http://localhost/phpMyAdmin检查以确保它已正确安装。</a></p>
<p>如果您安装了Homebrew，另一个选项是输入命令：brew install phpMyAdmin。</p>
<h3 id="如何在Ubuntu上安装phpMyAdmin"><a href="#如何在Ubuntu上安装phpMyAdmin" class="headerlink" title="如何在Ubuntu上安装phpMyAdmin"></a>如何在Ubuntu上安装phpMyAdmin</h3><p>作为最受欢迎和最容易使用的Linux发行版之一，Ubuntu是您服务器的不错选择。</p>
<p>虽然总是可以手动安装Apache和MySQL，但Linux有自己的标准服务器软件“堆栈”，称为LAMP（Linux、Apache、MySQL和PHP）。与WAMP和XAMPP不同，它不随phpMyAdmin一起提供，因此您需要手动安装它。幸运的是，Ubuntu允许您通过命令行进行所有安装。</p>
<p>首先，检查是否启用了tasksel。Ubuntu的服务器版本应该安装它，但如果你有桌面版本，你可以使用以下命令启用它：</p>
<pre><code class="bash">sudo apt-get install tasksel
</code></pre>
<p>之后，您可以使用tasksel使用以下命令安装LAMP服务器：</p>
<pre><code class="bash">sudo tasksel install lamp-server
</code></pre>
<p><img src="/assets/2/image-20220515004436-0f1gc0z.png" alt="image.png"><br>在Ubuntu中通过命令行安装LAMP服务器</p>
<p>现在，您可以安装phpMyAdmin：</p>
<pre><code class="bash">sudo apt install phpMyAdmin
</code></pre>
<p>有了它，您就拥有了在计算机上运行服务器所需的所有文件。</p>
<h3 id="如何在CentOS-7上安装phpMyAdmin"><a href="#如何在CentOS-7上安装phpMyAdmin" class="headerlink" title="如何在CentOS 7上安装phpMyAdmin"></a>如何在CentOS 7上安装phpMyAdmin</h3><p>在CentOS 7上安装phpMyAdmin与其他发行版非常相似，但命令略有不同，因为该操作系统使用Yum而不是典型的apt命令。</p>
<p>也没有简单的LAMP堆栈可以一次性安装您需要的所有服务器组件，因此您需要手动下载Apache、MySQL和PHP。幸运的是，这些可以通过命令行轻松获得。</p>
<p>首先，让我们使用命令行下载LAMP堆栈，从Apache开始：</p>
<pre><code class="bash">sudo yum install httpd.service
</code></pre>
<p>要启动Apache服务器并确保它在引导时运行，请使用以下命令：</p>
<pre><code class="bash">sudo systemctl start httpd.service
sudo systemctl enable httpd.service
</code></pre>
<p>现在是安装数据库的时候了。CentOS 7默认安装MariaDB。它还与phpMyAdmin完全兼容，因此使用起来很安全。虽然可以改为下载MySQL，但这是一个复杂得多的过程。让我们使用MariaDB：</p>
<pre><code class="bash">sudo yum install mariadb-server mariadb
</code></pre>
<p>现在我们可以运行它并使其在启动时启动：</p>
<pre><code class="bash">sudo systemctl start mariadb
sudo systemctl enable mariadb.service
</code></pre>
<p>要完成MariaDB的安装并确保其安全，请使用以下命令运行安全安装设置。</p>
<pre><code class="bash">sudo mysql_secure_installation
</code></pre>
<p>最后，我们可以使用附加的MySQL包安装PHP。</p>
<pre><code class="bash">sudo yum install php php-mysql
</code></pre>
<p>您还需要重新启动Apache服务器，以便它与PHP一起正常工作。</p>
<pre><code class="bash">sudo systemctl restart httpd.service
</code></pre>
<p>这样，您就拥有了所需的LAMP堆栈，并最终可以下载phpMyAdmin。由于它不在Yum存储库中，因此您需要使用以下命令安装EPEL存储库：</p>
<pre><code class="bash">sudo yum install epel-release
</code></pre>
<p>并安装phpMyAdmin。</p>
<pre><code class="bash">sudo yum install phpMyAdmin
</code></pre>
<p>在CentOS 7上还需要几个步骤，但您现在应该有一个准备好配置的服务器。</p>
<h3 id="如何在Debian上安装phpMyAdmin"><a href="#如何在Debian上安装phpMyAdmin" class="headerlink" title="如何在Debian上安装phpMyAdmin"></a>如何在Debian上安装phpMyAdmin</h3><p>与CentOS 7非常相似，您需要使用命令行手动安装LAMP堆栈。首先，让我们使用以下命令获取Apache：</p>
<pre><code class="bash">sudo apt install apache2
</code></pre>
<p>接下来，我们将安装MariaDB。与CentOS 7一样，此Linux发行版与MariaDB配合使用效果更好，我们建议您改用该发行版。</p>
<pre><code class="bash">sudo apt install mariadb-server
</code></pre>
<p>和CentOS 7一样，您应该运行安全安装来添加数据库密码并确保一切都是安全的。</p>
<pre><code class="bash">sudo mysql_secure_installation
</code></pre>
<p>最后，我们可以安装PHP和一些您的服务器需要运行的额外包。</p>
<pre><code class="bash">sudo apt install php php-mysql libapache2-mod-php
</code></pre>
<p>我们可以通过安装phpMyAdmin来完成。</p>
<pre><code class="bash">sudo apt install phpMyAdmin
</code></pre>
<h3 id="如何访问phpMyAdmin"><a href="#如何访问phpMyAdmin" class="headerlink" title="如何访问phpMyAdmin"></a><strong>如何访问phpMyAdmin</strong></h3><p>一旦正确安装了phpMyAdmin，在任何操作系统上访问和登录都是一样的。</p>
<p>您将需要您的网络服务器地址，然后附加<code>/phpMyAdmin/</code>到它的末尾。如果您只是在计算机上设置了服务器，则地址很可能只是“localhost”，因此请访问此链接：</p>
<p><a href="http://localhost/phpMyAdmin">http://localhost/phpMyAdmin</a></p>
<p>如果这是您已经在网络上运行的服务器，它也可能是一个IP，甚至是一个命名地址。如果您不确定，您可能会在Apache或MySQL配置文件中找到该地址。</p>
<p>进入登录屏幕后，您将需要用户名和密码。如果这是全新安装，用户名可能是“root”，您可以将密码留空。如果这不起作用，密码可能是“password”。</p>
<p><img src="/assets/2/image-20220515004443-4bpahoq.png" alt="image.png"><br>phpMyAdmin登录屏幕</p>
<p>如果您无法登录，请检查phpMyAdmin或MySQL配置文件以查找您的登录信息。您可能还在安装过程中更改了登录信息。</p>
<p>如果Linux用户在访问页面或登录时遇到问题，应尝试以下命令：</p>
<pre><code class="bash">sudo dpkg-reconfigure phpMyAdmin
</code></pre>
<p>最后，您应该注意，如果您使用的是预装了phpMyAdmin的网络主机，您通常可以在您的主机仪表板中找到登录信息和链接。在这种情况下，您不需要在服务器上手动安装phpMyAdmin。</p>
<h3 id="配置phpMyAdmin"><a href="#配置phpMyAdmin" class="headerlink" title="配置phpMyAdmin"></a><strong>配置phpMyAdmin</strong></h3><p>安装数据库管理器并准备好在您的系统上运行后，您应该知道如何配置phpMyAdmin。与任何服务器软件一样，您肯定会想要对设置进行大量修改。</p>
<p>未配置的phpMyAdmin也可能带来潜在的安全风险。您需要采取一些额外的步骤来锁定您的系统。</p>
<p>如果您需要恢复数据库的备份，您可以随时使用phpMyAdmin导入新的SQL文件。在对数据库或其设置进行任何重大修改之前，请务必经常进行备份，尤其是当您不只是在测试服务器上工作时。</p>
<h3 id="如何运行SQL查询"><a href="#如何运行SQL查询" class="headerlink" title="如何运行SQL查询"></a>如何运行SQL查询</h3><p>现在您已经使用了phpMyAdmin，您应该知道如何执行它的用途：运行SQL查询。</p>
<p>您可以在主页上运行查询（这将适用于整个站点），也可以在特定的数据库或表中运行。单击屏幕顶部的<strong>SQL</strong>选项卡，输入您的命令，然后按 <strong>Go</strong> 。</p>
<p><img src="/assets/2/image-20220515004448-5alrojq.png" alt="image.png"><br>在phpMyAdmin中运行SQL查询</p>
<p>以下是常见SQL查询的列表：</p>
<ul>
<li><strong>Select：</strong> 最重要的标签，几乎在每个查询的开头使用。</li>
<li><strong>Create Table：</strong> 创建一个新表。</li>
<li><strong>Alter Table：</strong> 添加新列。</li>
<li><strong>Insert：</strong> 添加新行。</li>
<li><strong>Delete：</strong> 删除列。</li>
<li><strong>Update：</strong> 编辑表中的值。</li>
<li><strong>Sum()：</strong> 将所有值相加。</li>
<li><strong>Avg()：</strong> 取平均值。</li>
<li><strong>Count()：</strong> 计算填充的列数。</li>
<li><strong>Round()：</strong> 将值四舍五入为您设置的整数。</li>
<li><strong>Max()：</strong> 返回最大值。</li>
<li><strong>Min()：</strong> 返回最小值。</li>
<li><strong>Between：</strong> 选择特定范围内的列。</li>
<li><strong>Group By：</strong> 按数据对表格进行分组。</li>
<li><strong>Order By：</strong> 以某种方式排序结果。</li>
</ul>
<p>当然还有更多命令需要学习，但这些只是一些开始。</p>
<h3 id="如何更改phpMyAdmin默认的URL"><a href="#如何更改phpMyAdmin默认的URL" class="headerlink" title="如何更改phpMyAdmin默认的URL"></a>如何更改phpMyAdmin默认的URL</h3><p>保留phpMyAdmin访问链接的默认设置 ( <code>http://website.com/phpMyAdmin</code>) 可能会带来安全风险。</p>
<p>如果您使此页面易于查找，黑客将能够访问它并尝试暴力破解您的用户名和密码。如果您将凭据保留在默认的“root”和“密码”上，情况可能会更糟。</p>
<p>但是通过将URL更改为只有您知道的内容，您可以使未知用户访问此页面并尝试猜测密码变得更加困难。</p>
<p>在文本编辑器中打开 <strong>phpMyAdmin.conf</strong> ，您可以在Windows&#x2F;WAMP上的<code>C:\wamp\alias</code>、XAMPP上的<code>xampp\apache\conf\extra</code>、Linux上的 <code>/etc/httpd/conf.d</code>或Mac上的<code>/usr/conf/extra</code>找到它。</p>
<p>你应该在那里看到这一行：</p>
<pre><code class="apacheconf">Alias /phpMyAdmin /usr/share/phpMyAdmin
</code></pre>
<p>将<code>/phpMyAdmin</code>路径更改为您选择的新地址。例如：</p>
<pre><code class="text">Alias /exampleURL /usr/share/phpMyAdmin
</code></pre>
<p>现在，您可以通过访问您设置的自定义地址 ( <code>http://website.com/exampleURL</code>)来访问phpMyAdmin的这个唯一URL 。</p>
<h3 id="如何设置NGINX身份验证网关"><a href="#如何设置NGINX身份验证网关" class="headerlink" title="如何设置NGINX身份验证网关"></a>如何设置NGINX身份验证网关</h3><p>另一种选择是使用身份验证网关设置第二层安全性。将phpMyAdmin登录页面移至秘密位置后，您可以对该页面进行密码保护，以降低攻击者通过的可能性。</p>
<p>NGINX服务器上的Linux用户可以在命令行中运行以下命令来创建身份验证网关（这在Apache服务器上也是可能的）。</p>
<p>首先创建一个加密密码（将“example”更改为您喜欢的任何内容）并记下结果：</p>
<pre><code class="bash">openssl passwd example
</code></pre>
<p>在NGINX的文件夹中创建一个配置文件并为其命名：</p>
<pre><code class="bash">sudo nano /etc/nginx/examplename
</code></pre>
<p>像这样在这个文件中输入用户名和密码，注意不要在冒号中留下：</p>
<pre><code class="bash">exampleusername:examplepassword
</code></pre>
<p>现在打开NGINX配置文件。</p>
<pre><code class="bash">sudo nano /etc/nginx/sites-available/default
</code></pre>
<p>在“服务器”块中，我们将通过粘贴以下代码来添加我们的网关（确保更改值）。</p>
<pre><code class="nginx">location /example &#123;
auth_basic &quot;Login&quot;;
auth_basic_user_file /etc/nginx/examplename;
</code></pre>
<p>第一个<code>/example</code>应该是您将phpMyAdmin URL设置为的任何内容，您可以将<code>auth_basic</code>变量名称调整为您想要的任何名称，最后一个<code>/examplename</code>应该是您之前创建的密码文件的名称。</p>
<p>现在登录时，您甚至应该在看到phpMyAdmin登录之前输入您设置的凭据。</p>
<h3 id="Adminer：一个更简单的phpMyAdmin替代方案"><a href="#Adminer：一个更简单的phpMyAdmin替代方案" class="headerlink" title="Adminer：一个更简单的phpMyAdmin替代方案"></a>Adminer：一个更简单的phpMyAdmin替代方案</h3><p>Adminer是一个免费的开源数据库管理工具，类似于phpMyAdmin。Adminer以前称为phpMinAdmin，被明确设计为phpMyAdmin的更简单、更好的替代品。</p>
<p>可以轻松部署在任何Web服务器上。只需上传一个轻量级的PHP文件即可。</p>
<p><img src="/assets/2/image-20220515004456-vtzahy7.png" alt="image.png"><br>使用Adminer探索WordPress数据库</p>
<p>它支持许多强大的数据库管理功能，例如轻松切换数据库、查看和编辑表、操作数据库值、导入和导出数据库、运行SQL查询等等。</p>
<p><img src="/assets/2/image-20220515004502-cnnotds.png" alt="image.png"><br>Adminer为数据库管理器提供支持</p>
<p><strong>小结</strong></p>
<p>您第一次使用phpMyAdmin可能会令人生畏。但是一旦您知道如何安装和配置它，访问您的数据库就像登录WordPress一样简单。</p>
<p>Windows、Mac和Linux用户都可以使用这个宝贵的数据库管理器。只要您有一个安装了PHP的Web服务器，如果您按照我们的说明进行操作，那么运行它应该很简单。请记住正确配置它并确保它是安全的，您将永远不会再次修改您的数据库。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>04_phpMyAdmin</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>DataGrip使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/03_DataGrip/02_DataGrip%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是datagrip"><a href="#什么是datagrip" class="headerlink" title="什么是datagrip?"></a>什么是datagrip?</h2><p>datagrip是jetbrains旗下的一款数据库管理工具，相信做过java开发的同学都知道，idea就是这家公司发明的。</p>
<h2 id="为什么要使用datagrip"><a href="#为什么要使用datagrip" class="headerlink" title="为什么要使用datagrip?"></a>为什么要使用datagrip?</h2><p>datagrip的优点非常多，下面博主为大家列举一下datagrip具有哪些优点。</p>
<h3 id="多数据源支持"><a href="#多数据源支持" class="headerlink" title="多数据源支持"></a>多数据源支持</h3><p>datagrip支持非常多的数据源，datagrip2020.1这个版本支持的数据源如下图所示。</p>
<p><img src="/assets/2/image-20220515003207-scg530f.png" alt="image.png"></p>
<h4 id="连接mysql数据库"><a href="#连接mysql数据库" class="headerlink" title="连接mysql数据库"></a>连接mysql数据库</h4><p>在java开发过程当中，大家应该经常使用或者使用过mysql数据库。博主这里以mysql数据库为例。</p>
<p><img src="/assets/2/image-20220515003215-jdkdzxd.png" alt="image.png"></p>
<h4 id="连接信息配置"><a href="#连接信息配置" class="headerlink" title="连接信息配置"></a>连接信息配置</h4><p><img src="/assets/2/image-20220515003224-7zysjo9.png" alt="image.png"></p>
<h4 id="驱动配置"><a href="#驱动配置" class="headerlink" title="驱动配置"></a>驱动配置</h4><p>在drivers目录下的mysql选项中选择驱动文件的地址，也可以选择datagrip默认的下载。这里由于博主在平时的java开发过程当中已经下载过了jdbc的mysql驱动，所以从maven本地仓库中直接选择驱动文件。</p>
<p><img src="/assets/2/image-20220515003245-ygjy9he.png" alt="image.png"></p>
<h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><p>点击图片中的Test Connection，即可查看数据库连接信息 是否配置成功。<br><img src="/assets/2/image-20220515003253-lhkao47.png" alt="image.png"></p>
<h3 id="datagrip的风格"><a href="#datagrip的风格" class="headerlink" title="datagrip的风格"></a>datagrip的风格</h3><p>datagrip对sql语句的显示让人感觉更加舒适。</p>
<p><img src="/assets/2/image-20220515003301-pxfve43.png" alt="image.png"></p>
<h3 id="同一套快捷键"><a href="#同一套快捷键" class="headerlink" title="同一套快捷键"></a>同一套快捷键</h3><p>因为datagrip也是jetbrains旗下的，它具有跟idea一样的默认快捷键设置。因此，我们只需要记住一套快捷键即可，这里博主列举一下使用比较频繁的快捷键。</p>
<h4 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h4><p>快捷键命令：ctrl+al+l</p>
<p>格式化之前的sql，如下图所示：</p>
<p><img src="/assets/2/image-20220515003310-wwgi4rq.png" alt="image.png"></p>
<p>格式化之后的sql，如下图所示：</p>
<p><img src="/assets/2/image-20220515003316-8fj4y1a.png" alt="image.png"></p>
<h4 id="全局查找"><a href="#全局查找" class="headerlink" title="全局查找"></a>全局查找</h4><p>快捷键命令：shift+shift，查找界面如下图所示：</p>
<p><img src="/assets/2/image-20220515003323-wsp7zam.png" alt="image.png"></p>
<h4 id="其它快捷键"><a href="#其它快捷键" class="headerlink" title="其它快捷键"></a>其它快捷键</h4><p><img src="/assets/2/image-20220515003330-meev57y.png" alt="image.png"></p>
<h3 id="智能提示"><a href="#智能提示" class="headerlink" title="智能提示"></a>智能提示</h3><p>datagrip在智能提示这一块做的挺好的。</p>
<h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><p>这里我们估计在select语句中缺少了筛选字段，datagrip已经给出了提示。<br><img src="/assets/2/image-20220515003339-bred4if.png" alt="image.png"></p>
<h4 id="插入提示"><a href="#插入提示" class="headerlink" title="插入提示"></a>插入提示</h4><p>这里我们输入insert语句时，datagrip会自动给我们提示表的字段。<br><img src="/assets/2/image-20220515003345-7p6aa5k.png" alt="image.png"></p>
<h4 id="字段备注提示"><a href="#字段备注提示" class="headerlink" title="字段备注提示"></a>字段备注提示</h4><p>我们将鼠标悬停在字段上时，datagrip会自动给我们提示表的字段会给出字典的类型，备注提示。<br><img src="/assets/2/image-20220515003352-360uphc.png" alt="image.png"></p>
<h4 id="全表删除提示"><a href="#全表删除提示" class="headerlink" title="全表删除提示"></a>全表删除提示</h4><p>当我们进行全表数据的删除操作时，datagrip会自动给我们提示。<br><img src="/assets/2/image-20220515003358-1mmdle2.png" alt="image.png"></p>
<h3 id="导出功能"><a href="#导出功能" class="headerlink" title="导出功能"></a>导出功能</h3><p>datagrip有俩种导出功能，一种是dump to file，另外一种是mysqldump方式。</p>
<h4 id="dump-data-to-file"><a href="#dump-data-to-file" class="headerlink" title="dump data to file"></a>dump data to file</h4><p><img src="/assets/2/image-20220515003404-qkac6a6.png" alt="image.png"></p>
<p>在extractor处选择sql inserts（这种方式导出的就是insert语句），在output directory中选择要导出的路径。</p>
<p><img src="/assets/2/image-20220515003412-p2m5o4a.png" alt="image.png"></p>
<p>datagrip也只能有限表数据的导出。如下图所示，我们筛选了id为1的数据，此时在数据右键，然后选择复制，就可以将数据行转化为insert语句。</p>
<p><img src="/assets/2/image-20220515003419-4v4l9v0.png" alt="image.png"></p>
<h3 id="导入功能"><a href="#导入功能" class="headerlink" title="导入功能"></a>导入功能</h3><p>datagrip的导入分为俩种，一种是sql语句，另外一种是列数据。</p>
<h4 id="导入sql语句"><a href="#导入sql语句" class="headerlink" title="导入sql语句"></a>导入sql语句</h4><p>将我们之前导入的sql语句文件，拖入datagrip，然后点击运行。</p>
<p><img src="/assets/2/image-20220515003426-h7tpf3h.png" alt="image.png"></p>
<p>这里我们将这个sql语句，关联到对应数据库的session会话，然后再点击运行。</p>
<p><img src="/assets/2/image-20220515003434-ai8mk2i.png" alt="image.png"></p>
<h4 id="导入列数据"><a href="#导入列数据" class="headerlink" title="导入列数据"></a>导入列数据</h4><p>选择需要导入的表，右键选择import data to file，就会看到下面这张图。我们将导入之前导出的sql语句。</p>
<p><img src="/assets/2/image-20220515003441-chr6v13.png" alt="image.png"></p>
<p>点击确定之后，就会进行导入确定界面，datagrip内置的是csv和tsv俩种方式。这里我们演示csv的方式。</p>
<p><img src="/assets/2/image-20220515003448-c0iedxp.png" alt="image.png"></p>
<h3 id="导航功能"><a href="#导航功能" class="headerlink" title="导航功能"></a>导航功能</h3><p>当我们将鼠标左键点击sql语句中的role时，datagrip会将其定位role表的位置，如图中的左半部分所示。<br><img src="/assets/2/image-20220515003454-clrefix.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>03_DataGrip</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>DataGrip安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/03_DataGrip/01_DataGrip%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="DataGrip官网"><a href="#DataGrip官网" class="headerlink" title="DataGrip官网"></a><a href="https://www.jetbrains.com/datagrip/">DataGrip官网</a></h3><h4 id="就是那个开发Idea、goland、clion、pycharm等工具的jetbrins公司开发的。DataGrip是多引擎数据库环境，让使用者不用切换多种数据库工具，非常方便。满足我多平台多数据库支持的要求，但同样是收费软件。"><a href="#就是那个开发Idea、goland、clion、pycharm等工具的jetbrins公司开发的。DataGrip是多引擎数据库环境，让使用者不用切换多种数据库工具，非常方便。满足我多平台多数据库支持的要求，但同样是收费软件。" class="headerlink" title="就是那个开发Idea、goland、clion、pycharm等工具的jetbrins公司开发的。DataGrip是多引擎数据库环境，让使用者不用切换多种数据库工具，非常方便。满足我多平台多数据库支持的要求，但同样是收费软件。"></a>就是那个开发Idea、goland、clion、pycharm等工具的jetbrins公司开发的。DataGrip是多引擎数据库环境，让使用者不用切换多种数据库工具，非常方便。满足我多平台多数据库支持的要求，但同样是收费软件。</h4><p><img src="/assets/2/1002a68aac824682b9fd273765625c92.png" alt="image.png"></p>
<h3 id="datagrip下载"><a href="#datagrip下载" class="headerlink" title="datagrip下载"></a>datagrip下载</h3><p>从官网下载的dataGrip可以免费使用30天，如果已经破解过或者付费过的小伙伴可以跳过这个章节。对于未安装软件的小伙伴，博主这里收集了dataGrip的破解教程，然后发送dataGrip即可获得软件下载地址。</p>
<h3 id="datagrip安装"><a href="#datagrip安装" class="headerlink" title="datagrip安装"></a>datagrip安装</h3><p>从软件下载地址下载完压缩包之后，进行文件的解压。</p>
<h4 id="解压之后的目录"><a href="#解压之后的目录" class="headerlink" title="解压之后的目录"></a>解压之后的目录</h4><p><img src="/assets/2/image-20220515002943-lb53w3b.png" alt="image.png"></p>
<h4 id="运行datagrip-exe"><a href="#运行datagrip-exe" class="headerlink" title="运行datagrip.exe"></a>运行datagrip.exe</h4><p>双击运行图中的datagrip-2020.1.exe进行软件的安装。dataGrip的安装过程比较简单，这里就不做说明了，这里主要讲解破解的过程。</p>
<h4 id="点击安装好的datagrip"><a href="#点击安装好的datagrip" class="headerlink" title="点击安装好的datagrip"></a>点击安装好的datagrip</h4><p>datagrip运行之后会跳出一个框，让你选择激活 还是 免费使用。这里我们选择Evaluate for free，然后点击evaluate。</p>
<h4 id="查看破解前的licenses"><a href="#查看破解前的licenses" class="headerlink" title="查看破解前的licenses"></a>查看破解前的licenses</h4><p>点击datagrip的Help菜单，选择Register后，即可看到licenses。</p>
<p><img src="/assets/2/image-20220515002951-308e210.png" alt="image.png"></p>
<h4 id="安装jetbrains-plugin"><a href="#安装jetbrains-plugin" class="headerlink" title="安装jetbrains-plugin"></a>安装jetbrains-plugin</h4><p>将jetbrains-plugin.exe 拖到 datagrip的界面上，就会弹出如下提示。</p>
<p><img src="/assets/2/image-20220515003000-9g6jcli.png" alt="image.png"></p>
<p>点击restart后，会调出如下提示，点击为DataGrip安装。</p>
<p><img src="/assets/2/image-20220515003007-fjmyfdl.png" alt="image.png"></p>
<p>点击完按钮之后，跳出如下提示。</p>
<p><img src="/assets/2/image-20220515003013-wiz6018.png" alt="image.png"></p>
<h4 id="再次查看licenses"><a href="#再次查看licenses" class="headerlink" title="再次查看licenses"></a>再次查看licenses</h4><p>这里我们可以看到，我们已经破解了datagrip，并且有效期到了2089年。</p>
<p><img src="/assets/2/image-20220515003020-nnhg7fl.png" alt="image.png"></p>
<h3 id="使用汉化资源包"><a href="#使用汉化资源包" class="headerlink" title="使用汉化资源包"></a>使用汉化资源包</h3><p>将resources_zh_CN_DataGrip_2020_r1.jar拖到 datagrip的安装目录下面的<br>lib目录，这时候需要重启datagrip。</p>
<h4 id="查看汉化成功的datagrip"><a href="#查看汉化成功的datagrip" class="headerlink" title="查看汉化成功的datagrip"></a>查看汉化成功的datagrip</h4><p><img src="/assets/2/image-20220515002933-kqg9oba.png" alt="image.png"></p>
<h3 id="如何使用datagrip"><a href="#如何使用datagrip" class="headerlink" title="如何使用datagrip?"></a>如何使用datagrip?</h3><p>小伙伴们如果想到查看datagrip的使用，请看我的另外一篇博文datagrip的使用。</p>
<h3 id="博主微信公众号"><a href="#博主微信公众号" class="headerlink" title="博主微信公众号"></a>博主微信公众号</h3><p><img src="/assets/2/image-20220515002925-q3yd7oe.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>03_DataGrip</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>DBeaver安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/02_DBeaver/01_DBeaver%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>官网和 GitHub<br><a href="https://dbeaver.io/">https://dbeaver.io/</a><br><a href="https://github.com/dbeaver/dbeaver">https://github.com/dbeaver/dbeaver</a></p>
<h3 id="DBeaver官网"><a href="#DBeaver官网" class="headerlink" title="DBeaver官网"></a><a href="https://dbeaver.io/">DBeaver官网</a></h3><h5 id="支持Windows、Linux、MacOS；支持我需要的sqlite3、mysql，有社区版和企业版本，社区版满足我的需求。"><a href="#支持Windows、Linux、MacOS；支持我需要的sqlite3、mysql，有社区版和企业版本，社区版满足我的需求。" class="headerlink" title="支持Windows、Linux、MacOS；支持我需要的sqlite3、mysql，有社区版和企业版本，社区版满足我的需求。"></a>支持Windows、Linux、MacOS；支持我需要的sqlite3、mysql，有社区版和企业版本，社区版满足我的需求。</h5><p><img src="/assets/2/e677efd784194c5180ab9bf8f317d9ee.png" alt="image.png"></p>
<p>1、介绍</p>
<p><img src="/assets/2/image-20220515002241-aui2k9w.png" alt="image.png"></p>
<p>  DBeaver是一种通用数据库管理工具，适用于需要以专业方式使用数据的每个人；适用于开发人员，数据库管理员，分析师和所有需要使用数据库的人员的免费的多平台数据库工具</p>
<p>  使用DBeaver，您可以像在常规电子表格中一样处理数据，基于来自不同数据存储的记录创建分析报告，并以适当的格式导出信息。对于高级数据库用户，DBeaver建议使用功能强大的SQL编辑器，大量的管理功能，数据和模式迁移的能力，监视数据库连接会话等。</p>
<p>  开箱即用的DBeaver支持80多个数据库。支持所有流行的数据库，包括：MySQL、PostgreSQL、MariaDB、SQLite、Oracle、Db2、SQL Server、Sybase、MS Access、Teradata、Firebird、Derby 等等。商业版本更是可以支持各种 NoSQL 和大数据平台：MongoDB、InfluxDB、Apache Cassandra、Redis、Apache Hive 等。</p>
<p>以可用性为主要目标，DBeaver提供：</p>
<p>精心设计和实施的用户界面<br>支持云数据源<br>支持企业安全标准<br>具有与Excel，Git等集成的各种扩展功能。<br>大量功能<br>多平台支持<br>DBeaver 是一个基于 Java 开发，免费开源的通用数据库管理和开发工具，使用非常友好，且遵循ASL 协议。由于 DBeaver 基于 Java 开发，可以运行在各种操作系统上，比如Windows、Linux、macOS 等操作系统。DBeaver 采用 Eclipse 框架开发，支持插件扩展，并且提供了许多数据库管理工具：ER 图、数据导入&#x2F;导出、数据库比较、模拟数据生成等。</p>
<p>2、发展史<br>  DBeaver于2010年作为一个业余项目启动。它原本是免费的，开放源代码的，具有漂亮且方便的用户界面，并且包含数据库开发人员常用的功能。第一个正式版本于2011年在Freecode上发布。它迅速成为开源社区中的一种流行工具。</p>
<p>  同年，建立了官方网站，并创建了社区支持论坛（现已移至GitHub）。 2012年发布了Eclipse插件版本-此后，DBeaver成为Eclipse最受欢迎的数据库扩展之一（在所有Eclipse扩展中排名前50-60）。</p>
<p>  不久之后，各种软件供应商开始与DBeaver集成（主要是对其专有Eclipse RCP产品的扩展：Zend Studio，NXTware， DeltaDNA，等）。</p>
<p>  2014年发布了企业版（EE）版本。EE版本基于CE，但也提供对NoSQL &#x2F; BigData数据库（Cassandra，MongoDB和Redis）的支持，并包括一些其他Eclipse插件。</p>
<p>2015年，DBeaver源代码&#x2F;社区已移至GitHub。</p>
<p>  DBeaver CE在2017年获得了Apache许可的许可（从4.x版本开始）。</p>
<p>为了支持CE版本，DBeaver EE版本于2017年7月开始商业化。</p>
<p>3、版本介绍<br>社区版</p>
<p>  communityedition（CE）是DBeaver的初始版本。它于2010年发布，并于2011年成为开源（GPL）。CE版本包括对以下数据库的扩展支持：MySQL和MariaDB、PostgreSQL、Greenplum、Oracle、DB2 (LUW)、EXASOL、SQL Server、Sybase、Firebird、Teradata、Vertica、SAP HANA、Apache Phoenix、Netezza、Informix、Apache Derby、H2、SQLite、SnappyData任何其他具有JDBC或ODBC驱动程序的数据库。除了关系数据库，CE版本还支持WMI驱动程序（Windows Management Instrumentation–仅适用于Windows版本）。</p>
<p>Eclipse插件版</p>
<p>  一年后，为了响应多个用户的请求，Eclipse市场上发布了一个Eclipse插件版本。这个版本由使用eclipseide进行软件开发的程序员使用，他们的IDE中需要一个数据库管理工具。Eclipse插件包含了communityedition的大部分特性，并且也是在GPL许可下发布的。</p>
<p>企业版</p>
<p>  DBeaver 3.x宣布支持NoSQL数据库（最初的版本是Cassandra和MongoDB）。从那时起，DBeaver在社区版和企业版上被分成了两部分。企业版支持NoSQL数据库、持久查询管理器和其他一些企业级功能。EE版本不是开源的，需要购买许可证（可以免费生成试用版许可证）。</p>
<p>4、下载与安装<br>  DBeaver 社区版可以通过官方网站或者 Github 进行下载。两者都为不同的操作系统提供了安装包或者解压版，可以选择是否需要同时安装 JRE。另外，官方网站还提供了 DBeaver 的 Eclipse 插件，可以在 Eclipse 中进行集成。</p>
<p>  DBeaver 支持中文，安装过程非常简单，不多说，唯一需要注意的是 DBeaver 的运行依赖于 JRE。DBeaver 着实体贴了些许，不用注册帐号，直接下载即可，也是人生幸事！</p>
<p>1、DBeaver 下载地址：<a href="https://dbeaver.io/download/">https://dbeaver.io/download/</a></p>
<p><img src="/assets/2/image-20220515002310-txn01dt.png" alt="image.png"></p>
<p>2、选择语言和权限</p>
<p><img src="/assets/2/image-20220515002325-j20ypln.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515002331-2zhtml5.png" alt="image.png"></p>
<p>3、选定安装组件在进行选定安装组件部分，选择全部勾选。</p>
<p><img src="/assets/2/image-20220515002340-xwp28cc.png" alt="image.png"></p>
<p>4、安装即可</p>
<p><img src="/assets/2/image-20220515002347-xdlkiyj.png" alt="image.png"></p>
<p>5、DBeaver 连接数据库（MySql）<br>  DBeaver 下载安装完成后，并不是直接可以用，要进行数据库的连接。一般情况下，第一次运行，会自动弹出如下内容，进行选择即可。此外，还可以直接点击左侧蓝色按钮，即</p>
<p>进行连接。</p>
<p>1、选择连接类型本文选择 MySQL 8+ 。</p>
<p><img src="/assets/2/image-20220515002355-tw9mlvx.png" alt="image.png"></p>
<p>2、连接设置注意：数据库可以为空，不填写，但密码一定要填写！一定要！记得密码很重要，还记得之前文章提到过的密码设置吗？！</p>
<p><img src="/assets/2/image-20220515002403-lmp2yir.png" alt="image.png"></p>
<p>3、测试连接如果失败会主动弹出驱动设置，请求下载驱动文件，此刻选择下载即可。</p>
<p><img src="/assets/2/image-20220515002410-vv6sb7c.png" alt="image.png"></p>
<p>4、继续测试此刻会发生两种情况：第一种，成功了；第二种，继续失败，且会出现如下信息。</p>
<p><img src="/assets/2/image-20220515002417-v4uq30t.png" alt="image.png"></p>
<p>5、解决问题打开酷酷的终端，运行 MySQL ，并输入如下指令：</p>
<blockquote>
<p>show variables like ‘%time_zone%’;<br>set global time_zone&#x3D;’+8:00’;</p>
</blockquote>
<p>终端运行结果示意图</p>
<p><img src="/assets/2/image-20220515002439-7128f2d.png" alt="image.png"></p>
<p>6、连接成功</p>
<p>再次进行测试，显示成功。看左侧区域库与表区域，点击鼠标右键→连接即可。当小海豚下方出现一个绿色框框且有对号的图片时，即连接成功。</p>
<p><img src="/assets/2/image-20220515002446-pfvmu4h.png" alt="image.png"></p>
<p>6、DBeaver 连接数据库（Hive）<br>第一步，新建连接，选择Apache Hive</p>
<p><img src="/assets/2/image-20220515002453-25w6kxm.png" alt="image.png"></p>
<p>第二步，点击驱动属性、下载对应的驱动，驱动下载完成后，填写连接的url信息。必须开启HiveServer2服务，HiveServer2的默认端口是10000<br>  尖叫提示：如果选择自动下载驱动，会出现版本不兼容或者下载失败的情况，所以不建议使用这种方式。最简单的方式是将hive JDBC的jar包直接加载进去即可，将其放在本地的一个文件夹下(可以放置在DBeaver的安装目录下)，然后选择编辑驱动设置：如下图</p>
<p><img src="/assets/2/image-20220515002538-n15qi3p.png" alt="image.png"></p>
<p>在点击编辑驱动设置之后，会弹出一个窗口，让你选择驱动的位置，点击添加文件，选择相应的hive驱动即可。然后点击确定。</p>
<p><img src="/assets/2/image-20220515002549-56hssah.png" alt="image.png"></p>
<p>然后填写好url，点击测试链接进行测试，如下图：</p>
<p><img src="/assets/2/image-20220515002556-v984p88.png" alt="image.png"></p>
<p>成功链接之后，就可以像Hue一样操作Hive了，如下:</p>
<p><img src="/assets/2/image-20220515002556-v984p88.png" alt="image.png"></p>
<p>7、DBeaver 功能简介<br>  DBeaver 连接成功数据库之后，究竟如何操作，可以先围观一下以下信息。</p>
<p>1、操作界面功能版块划分</p>
<p><img src="/assets/2/image-20220515002611-jhjrn37.png" alt="image.png"></p>
<p>2、语言设置</p>
<p><img src="/assets/2/image-20220515002620-mnlpy0j.png" alt="image.png"></p>
<p>3、代码颜色设置</p>
<p><img src="/assets/2/image-20220515002626-5ldfs03.png" alt="image.png"></p>
<p>4、简易操作</p>
<p>在菜单栏区域，鼠标放到某个按钮下，会对应显示其功能，譬如下图按钮1，即为新建编辑器；快去尝试一下区域2 部分按钮的功能吧！</p>
<p><img src="/assets/2/image-20220515002632-u04b7eq.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>02_DBeaver</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>DBeaver使用</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/02_DBeaver/02_DBeaver%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>一、连接数据步骤：</strong></p>
<p>1、选择需要连接的数据库</p>
<p><img src="/assets/2/image-20220515003726-1rms3r9.png" alt="image.png"></p>
<p>2、配置数据库参数，首次连接需要下载对应数据库的连接驱动</p>
<p>连接 SqlServer：</p>
<p><img src="/assets/2/image-20220515003732-65s8biz.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515003738-8ohqsv7.png" alt="image.png"></p>
<p>连接 H2：</p>
<p><img src="/assets/2/image-20220515003745-3g8lna9.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220515003751-kdkqr52.png" alt="image.png"></p>
<p>连接MySQL：</p>
<p><img src="/assets/2/image-20220515003800-2xtj998.png" alt="image.png"></p>
<p>配置参考上面的配置</p>
<p><strong>二、客户端常用配置</strong></p>
<p>1、窗口-&gt;首选项-&gt;常规-&gt;键：设置常用快捷键</p>
<p><img src="/assets/2/image-20220515003807-m0v0gv4.png" alt="image.png"></p>
<p>2、窗口-&gt;首选项-&gt;数据库-&gt;Editors-&gt;SQL编辑器-&gt;模板：设置常用SQL模板</p>
<p>在SQL查询界面输入sf，再按TAB键，就能快速输入：select * from</p>
<p><img src="/assets/2/image-20220515003815-haflbkf.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>02_DBeaver</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>navicat  SQL语句练习</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/01_navicat/03_SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p><strong><a href="">SQL语句实例</a></strong></p>
<p><img src="/assets/1/image-20211120234345-rcfnit1.png" alt="image.png"></p>
<p><strong>表操作</strong></p>
<p><strong>例 1 对于表的教学管理数据库中的表 STUDENTS ，可以定义如下：</strong></p>
<p>CREATE TABLE STUDENTS</p>
<p>(SNO NUMERIC (6, 0) NOT NULL</p>
<p>SNAME CHAR (8) NOT NULL</p>
<p>AGE NUMERIC(3,0)</p>
<p>SEX CHAR(2)</p>
<p>BPLACE CHAR(20)</p>
<p>PRIMARY KEY(SNO))</p>
<p><strong>例 2 对于表的教学管理数据库中的表 ENROLLS ，可以定义如下：</strong></p>
<p>CREATE TABLE ENROLLS</p>
<p>(SNO NUMERIC(6,0) NOT NULL</p>
<p>CNO CHAR(4) NOT NULL</p>
<p>GRADE INT</p>
<p>PRIMARY KEY(SNO,CNO)</p>
<p>FOREIGN KEY(SNO) REFERENCES STUDENTS(SNO)</p>
<p>FOREIGN KEY(CNO) REFERENCES COURSES(CNO)</p>
<p>CHECK ((GRADE IS NULL) OR (GRADE BETWEEN 0 AND 100)))</p>
<p><strong>例 3 根据表的 STUDENTS 表，建立一个只包含学号、姓名、年龄的女学生表。</strong></p>
<p>CREATE TABLE GIRL</p>
<p>AS SELECT SNO, SNAME, AGE</p>
<p>FROM STUDENTS</p>
<p>WHERE SEX&#x3D;’ 女 ‘;</p>
<p><strong>例 4 删除教师表 TEACHER 。</strong></p>
<p>DROP TABLE TEACHER</p>
<p><strong>例 5 在教师表中增加住址列。</strong></p>
<p>ALTER TABLE TEACHERS</p>
<p>ADD (ADDR CHAR(50))</p>
<p><strong>例 6 把 STUDENTS 表中的 BPLACE 列删除，并且把引用 BPLACE 列的所有视图和约束也一起删除。</strong></p>
<p>ALTER TABLE STUDENTS</p>
<p>DROP BPLACE CASCADE</p>
<p><strong>例 7 补充定义 ENROLLS 表的主关键字。</strong></p>
<p>ALTER TABLE ENROLLS</p>
<p>ADD PRIMARY KEY (SNO,CNO) ；</p>
<p><strong>视图操作（虚表）</strong></p>
<p><strong>例 9 建立一个只包括教师号、姓名和年龄的视图 FACULTY 。 ( 在视图定义中不能包含 ORDER BY 子句 )</strong></p>
<p>CREATE VIEW FACULTY</p>
<p>AS SELECT TNO, TNAME, AGE</p>
<p>FROM TEACHERS</p>
<p><strong>例 10 从学生表、课程表和选课表中产生一个视图 GRADE_TABLE ， 它包括学生姓名、课程名和成绩。</strong></p>
<p>CREATE VIEW GRADE_TABLE</p>
<p>AS SELECT SNAME,CNAME,GRADE</p>
<p>FROM STUDENTS,COURSES,ENROLLS</p>
<p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO AND</p>
<p>COURSES.CNO&#x3D;ENROLLS.CNO</p>
<p><strong>例 11 删除视图 GRADE_TABLE</strong></p>
<p>DROP VIEW GRADE_TABLE RESTRICT</p>
<p><strong>索引操作</strong></p>
<p><strong>例 12 在学生表中按学号建立索引。</strong></p>
<p>CREATE UNIQUE INDEX ST</p>
<p>ON STUDENTS (SNO,ASC)</p>
<p><strong>例 13 删除按学号所建立的索引。</strong></p>
<p>DROP INDEX ST</p>
<p><strong>数据库模式操作</strong></p>
<p><strong>例 14 创建一个简易教学数据库的数据库模式 TEACHING_DB ，属主为 ZHANG 。</strong></p>
<p>CREATE SCHEMA TEACHING_DB AUTHRIZATION ZHANG</p>
<p><strong>例 15 删除简易教学数据库模式 TEACHING_DB 。（（ 1 ）选用 CASCADE ，即当删除数据库模式时，则本数据库模式和其下属的基本表、视图、索引等全部被删除。（ 2 ）选用 RESTRICT ，即本数据库模式下属的基本表、视图、索引等事先已清除，才能删除本数据库模式，否则拒绝删除。）</strong></p>
<p>DROP SCHEMA TEACHING_DB CASCADE</p>
<p><strong>单表操作</strong></p>
<p><strong>例 16 找出 3 个学分的课程号和课程名。</strong></p>
<p>SELECT CNO, CNAME</p>
<p>FROM 　 COURSES</p>
<p>WHERE 　 CREDIT ＝ 3</p>
<p><strong>例 17 查询年龄大于 22 岁的学生情况。</strong></p>
<p>SELECT *</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE ＞ 22</p>
<p><strong>例 18 找出籍贯为河北的男生的姓名和年龄。</strong></p>
<p>SELECT SNAME, AGE</p>
<p>FROM 　 STUDENTS</p>
<p>WHERE 　 BPLACE ＝ ‘ 河北 ‘ AND SEX ＝ ‘ 男 ‘</p>
<p><strong>例 19 找出年龄在 20 ～ 23 岁之间的学生的学号、姓名和年龄，并按年龄升序排序。 (ASC （升序）或 DESC （降序）声明排序的方式，缺省为升序。 )</strong></p>
<p>SELECT SNO, SNAME, AGE</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE BETWEEN 20 AND 23</p>
<p>ORDER BY AGE</p>
<p><strong>例 20 找出年龄小于 23 岁、籍贯是湖南或湖北的学生的姓名和性别。（条件比较运算符＝、＜ 和逻辑运算符 AND （与），此外还可以使用的运算符有：＞（大于）、＞＝（大于等于）、＜＝（小于等于）、＜＞（不等于）、 NOT （非）、 OR （或）等。</strong></p>
<p><strong>谓词 LIKE 只能与字符串联用，常常是 “ ＜列名＞ LIKE pattern” 的格式。特殊字符 “_” 和 “%” 作为通配符。</strong></p>
<p><strong>谓词 IN 表示指定的属性应与后面的集合（括号中的值集或某个查询子句的结果）中的某个值相匹配，实际上是一系列的 OR （或）的缩写。谓词 NOT IN 表示指定的属性不与后面的集合中的某个值相匹配。</strong></p>
<p><strong>谓词 BETWEEN 是 “ 包含于 … 之中 ” 的意思。）</strong></p>
<p>SELECT SNAME, SEX</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE ＜ 23 AND BPLACE LIKE’ 湖％ ‘</p>
<p>或</p>
<p>SELECT SNAME, SEX</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE ＜ 23 AND BPLACE IN （ ‘ 湖南 ‘ ， ‘ 湖北 ‘ ）</p>
<p><strong>例 22 找出学生表中籍贯是空值的学生的姓名和性别。（在 SQL 中不能使用条件：＜列名＞＝ NULL 。在 SQL 中只有一个特殊的查询条件允许查询 NULL 值：）</strong></p>
<p>SELECT SNAME, SEX</p>
<p>FROM STUDENTS</p>
<p>WHERE BPLACE IS NULL</p>
<p><strong>多表操作</strong></p>
<p><strong>例 23 找出成绩为 95 分的学生的姓名。（子查询）</strong></p>
<p>SELECT SNAME</p>
<p>FROM 　 STUDENTS</p>
<p>WHERE 　 SNO ＝</p>
<p>(SELECT SNO</p>
<p>FROM ENROLLS</p>
<p>WHERE GRADE ＝ 95)</p>
<p><strong>例 24 找出成绩在 90 分以上的学生的姓名。</strong></p>
<p>SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE SNO IN</p>
<p>(SELECT SNO</p>
<p>FROM ENROLLS</p>
<p>WHERE GRADE ＞ 90)</p>
<p>或</p>
<p>SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE SNO ＝ ANY</p>
<p>(SELECT SNO</p>
<p>FROM ENROLLS</p>
<p>WHERE GRADE ＞ 90)</p>
<p><strong>例 25 查询全部学生的学生名和所学课程号及成绩。（连接查询）</strong></p>
<p>SELECT SNAME, CNO, GRADE</p>
<p>FROM STUDENTS, ENROLLS</p>
<p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO</p>
<p><strong>例 26 找出籍贯为山西或河北，成绩为 90 分以上的学生的姓名、籍贯和成绩。（当构造多表连接查询命令时，必须遵循两条规则。第一，连接条件数正好比表数少 1 （若有三个表，就有两个连接条件 ) ；第二，若一个表中的主关键字是由多个列组成，则对此主关键字中的每一个列都要有一个连接条件（也有少数例外情况））</strong></p>
<p>SELECT SNAME, BPLACE, GRADE</p>
<p>FROM STUDENTS, ENROLLS</p>
<p>WHERE BPLACE IN (‘ 山西 ’ ， ‘ 河北 ’) AND GRADE ＞＝ 90 AND 　STUDENTS.SNO&#x3D;ENROLLS.SNO</p>
<p><strong>例 28 查出课程成绩在 80 分以上的女学生的姓名、课程名和成绩。（ FROM 子句中的子查询）</strong></p>
<p>SELECT SNAME,CNAME, GRADE</p>
<p>FROM (SELECT SNAME, CNAME , GRADE</p>
<p>FROM STUDENTS, ENROLLS,COURSES</p>
<p>WHERE SEX ＝ ‘ 女 ‘)</p>
<p>AS TEMP (SNAME, CNAME,GRADE)</p>
<p>WHERE GRADE ＞ 80</p>
<p><strong>表达式与函数的使用</strong></p>
<p><strong>例 29 查询各课程的学时数。（算术表达式由算术运算符＋、－、 * 、／与列名或数值常量所组成。）</strong></p>
<p>SELECT CNAME,COURSE_TIME ＝ CREDIT*16</p>
<p>FROM COURSES</p>
<p><strong>例 30 找出教师的最小年龄。（内部函数： SQL 标准中只使用 COUNT 、 SUM 、 AVG 、 MAX 、 MIN 函数，称之为聚集函数（ Set Function ）。 COUNT 函数的结果是该列统计值的总数目， SUM 函数求该列统计值之和， AVG 函数求该列统计值之平均值， MAX 函数求该列最大值， MIN 函数求该列最小值。）</strong></p>
<p>SELECT MIN(AGE)</p>
<p>FROM TEACHERS</p>
<p><strong>例 31 统计年龄小于等于 22 岁的学生人数。（统计）</strong></p>
<p>SELECT COUNT(*)</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE &lt; ＝ 22</p>
<p><strong>例 32 找出学生的平均成绩和所学课程门数。</strong></p>
<p>SELECT SNO, AVG(GRADE), COURSES ＝ COUNT(*)</p>
<p>FROM ENROLLS</p>
<p>GROUP BY SNO</p>
<p><strong>例 34 找出年龄超过平均年龄的学生姓名。</strong></p>
<p>SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE AGE ＞</p>
<p>(SELECT AVG(AGE)</p>
<p>FROM STUDENTS)</p>
<p><strong>例 35 找出各课程的平均成绩，按课程号分组，且只选择学生超过 3 人的课程的成绩。（ GROUP BY 与 HAVING</strong></p>
<p><strong>GROUP BY 子句把一个表按某一指定列（或一些列）上的值相等的原则分组，然后再对每组数据进行规定的操作。</strong></p>
<p><strong>GROUP BY 子句总是跟在 WHERE 子句后面，当 WHERE 子句缺省时，它跟在 FROM 子句后面。</strong></p>
<p><strong>HAVING 子句常用于在计算出聚集之后对行的查询进行控制。）</strong></p>
<p>SELECT CNO, AVG(GRADE), STUDENTS ＝ COUNT(*)</p>
<p>FROM ENROLLS</p>
<p>GROUP BY CNO</p>
<p>HAVING COUNT(*) &gt;&#x3D; 3</p>
<p><strong>相关子查询</strong></p>
<p><strong>例 37 查询没有选任何课程的学生的学号和姓名。（当一个子查询涉及到一个来自外部查询的列时，称为相关子查询（ Correlated Subquery) 。相关子查询要用到存在测试谓词 EXISTS 和 NOT EXISTS ，以及 ALL 、 ANY （ SOME ）等。）</strong></p>
<p>SELECT SNO, SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE NOT EXISTS</p>
<p>(SELECT *</p>
<p>FROM ENROLLS</p>
<p>WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO)</p>
<p><strong>例 38 查询哪些课程只有男生选读。</strong></p>
<p>SELECT DISTINCT CNAME</p>
<p>FROM COURSES C</p>
<p>WHERE ‘ 男 ‘ ＝ ALL</p>
<p>(SELECT SEX</p>
<p>FROM ENROLLS ， STUDENTS</p>
<p>WHERE ENROLLS.SNO&#x3D;STUDENTS.SNO AND</p>
<p>ENROLLS.CNO&#x3D;C.CNO)</p>
<p><strong>例 39 要求给出一张学生、籍贯列表，该表中的学生的籍贯省份，也是其他一些学生的籍贯省份。</strong></p>
<p>SELECT SNAME, BPLACE</p>
<p>FROM STUDENTS A</p>
<p>WHERE EXISTS</p>
<p>(SELECT *</p>
<p>FROM STUDENTS B</p>
<p>WHERE A.BPLACE&#x3D;B.BPLACE AND</p>
<p>A.SNO &lt; &gt; B.SNO)</p>
<p><strong>例 40 找出选修了全部课程的学生的姓名。</strong></p>
<p>本查询可以改为：查询这样一些学生，没有一门课程是他不选修的。</p>
<p>SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE NOT EXISTS</p>
<p>(SELECT *</p>
<p>FROM COURSES</p>
<p>WHERE NOT EXISTS</p>
<p>(SELECT *</p>
<p>FROM ENROLLS</p>
<p>WHERE ENROLLS.SNO ＝ STUDENTS.SNO</p>
<p>AND ENROLLS.CNO ＝ COURSES.CNO))</p>
<p><strong>关系代数运算</strong></p>
<p><strong>例 41 设有某商场工作人员的两张表：营业员表 SP_SUBORD 和营销经理表 SP_MGR ，其关系数据模式如下：</strong></p>
<p><strong>SP_SUBORD (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)</strong></p>
<p><strong>SP_MGR (SALPERS_ID, SALPERS_NAME, MANAGER_ID, OFFICE)</strong></p>
<p><strong>其中，属性 SALPERS_ID 为工作人员的编号 , SALPERS_NAME 为工作人员的姓名 , MANAGER_ID 为所在部门经理的编号 , OFFICE 为工作地点。</strong></p>
<p>若查询全部商场工作人员，可以用下面的 SQL 语句：</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p>UNION</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>或等价地用下面的 SQL 语句：</p>
<p>SELECT *</p>
<p>FROM (TABLE SP_SUBORD UNION TABLE SP_MGR)</p>
<p>（ 2 ） INTERSECT</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p>INTERSECT</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>或等价地用下面的 SQL 语句：</p>
<p>SELECT *</p>
<p>FROM (TABLE SP_SUBORD INTERSECT TABLE SP_MGR)</p>
<p>或用带 ALL 的 SQL 语句：</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p>INTERSECTALL</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>或</p>
<p>SELECT *</p>
<p>FROM (TABLE SP_SUBORD INTERSECT ALL TABLE SP_MGR)</p>
<p>（ 3 ） EXCEPT</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>EXCEPT</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p>或等价地用下面的 SQL 语句：</p>
<p>SELECT *</p>
<p>FROM (TABLE SP_MGR EXCEPT TABLE SP_ SUBORD)</p>
<p>或用带 ALL 的 SQL 语句：</p>
<p>(SELECT * FROM SP_MGR)</p>
<p>EXCEPT ALL</p>
<p>(SELECT * FROM SP_SUBORD)</p>
<p><strong>例 42 查询籍贯为四川、课程成绩在 80 分以上的学生信息及其成绩。（自然连接）</strong></p>
<p>(SELECT * FROM STUDENTS</p>
<p>WHERE BPLACE&#x3D;‘ 四川 ’)</p>
<p>NATURAL JOIN</p>
<p>(SELECT * FROM ENROLLS</p>
<p>WHERE GRADE &gt;&#x3D;80)</p>
<p><strong>例3.43 列出全部教师的姓名及其任课的课程号、班级。</strong></p>
<p><strong>（外连接与外部并外连接允许在结果表中保留非匹配元组，空缺部分填以 NULL 。外连接的作用是在做连接操作时避免丢失信息。</strong></p>
<p><strong>外连接有 3 类：</strong></p>
<p><strong>（ 1 ）左外连接（ Left Outer Join ）。连接运算谓词为 LEFT [OUTER] JOIN ，其结果表中保留左关系的所有元组。</strong></p>
<p><strong>（ 2 ）右外连接（ Right Outer Join ）。连接运算谓词为 RIGHT [OUTER] JOIN ，其结果表中保留右关系的所有元组。</strong></p>
<p><strong>（ 3 ）全外连接（ Full Outer Join ）。连接运算谓词为 FULL [OUTER] JOIN ，其结果表中保留左右两关系的所有元组。）</strong></p>
<p>SELECT TNAME, CNO, CLASS</p>
<p>FROM TEACHERS LEFT OUTER JOIN TEACHING USING (TNO)</p>
<p><strong>SQL 的数据操纵</strong></p>
<p><strong>例 44 把教师李映雪的记录加入到教师表 TEACHERS 中。（插入）</strong></p>
<p>INSERT INTO TEACHERS</p>
<p>VALUES(1476 ， ‘ 李映雪 ‘ ， 44 ， ‘ 副教授 ‘)</p>
<p><strong>例 45 成绩优秀的学生将留下当教师。</strong></p>
<p>INSERT INTO TEACHERS (TNO ， TNAME)</p>
<p>SELECT DISTINCT SNO ， SNAME</p>
<p>FROM STUDENTS ， ENROLLS</p>
<p>WHERE STUDENTS.SNO ＝ ENROLLS.SNO ANDGRADE ＞＝ 90</p>
<p><strong>例 47 把所有学生的年龄增加一岁。（修改）</strong></p>
<p>UPDATE STUDENTS</p>
<p>SET AGE ＝ AGE+1</p>
<p><strong>例 48 学生张春明在数据库课考试中作弊，该课成绩应作零分计。</strong></p>
<p>UPDATE ENROLLS</p>
<p>SET GRADE ＝ 0</p>
<p>WHERE CNO ＝ ‘C1’ AND</p>
<p>‘ 张春明 ‘ ＝</p>
<p>(SELECT SNAME</p>
<p>FROM STUDENTS</p>
<p>WHERE STUDENTS.SNO&#x3D;ENROLLS.SNO)</p>
<p><strong>例 49 从教师表中删除年龄已到 60 岁的退休教师的数据。（删除）</strong></p>
<p>DELETE FROM TEACHERS</p>
<p>WHERE AGE ＞＝ 60</p>
<p><strong>SQL 的数据控制</strong></p>
<p><strong>例 50 授予 LILI 有对表 STUDENTS 的查询权。（表／视图特权的授予</strong></p>
<p><strong>一个 SQL 特权允许一个被授权者在给定的数据库对象上进行特定的操作。授权操作的数据库对象包括：表 &#x2F; 视图、列、域等。授权的操作包括： INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 、 UNDER 、 USAGE 、 EXECUTE 等。其中 INSERT 、 UPDATE 、 DELETE 、 SELECT 、 REFERENCES 、 TRIGGER 有对表做相应操作的权限，故称为表特权。）</strong></p>
<p>GRANT SELECT ON STUDENTS</p>
<p>TO LILI</p>
<p>WITH GRANT OPTION</p>
<p><strong>例 51 取消 LILI 的存取 STUDENTS 表的特权。</strong></p>
<p>REVOKE ALL</p>
<p>ON STUDENTS</p>
<p>FROM LILI CASCADE</p>
<p>**不断补充中：</p>
<ol>
<li>模糊查找:<br> **它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。<br> 　　可使用以下通配字符：<br> 　　百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。<br> 　　下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。<br> 　　方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。[^]：其取值也[]相同，但它要求所匹配对象为指定字符以外的任一个字符。<br> 例如：<br> 　　限制以Publishing结尾，使用LIKE ‘%Publishing’<br> 　　限制以A开头：LIKE ‘[A]%’<br> 　　限制以A开头外：LIKE ‘[^A]%’</li>
</ol>
<p>**2.更改表格　**<br>ALTER TABLE table_name<br>ADD COLUMN column_name DATATYPE<br>说明：增加一个栏位（没有删除某个栏位的语法。)<br>ALTER TABLE table_name<br>ADD PRIMARY KEY (column_name)<br>说明：更改表得的定义把某个栏位设为主键。<br>ALTER TABLE table_name<br>DROP PRIMARY KEY (column_name)<br>说明：把主键的定义删除。</p>
<p><strong>3.group by</strong></p>
<p>在select 语句中可以使用group by 子句将行划分成较小的组，然后，使用聚组函数返回每一个组的汇总信息，另外，可以使用having子句限制返回的结果集。group by 子句可以将查询结果分组，并返回行的汇总信息Oracle 按照group by 子句中指定的表达式的值分组查询结果。</p>
<p>在带有group by 子句的查询语句中，在select 列表中指定的列要么是group by 子句中指定的列，要么包含聚组函数</p>
<p>select max(sal),job emp group byjob;<br>(注意max(sal),job的job并非一定要出现，但有意义)</p>
<p>查询语句的select 和group by ,having 子句是聚组函数唯一出现的地方，在where 子句中不能使用聚组函数。</p>
<p>select deptno,sum(sal) from empwhere sal&gt;1200 group by deptno having sum(sal)&gt;8500 order by deptno;</p>
<p>当在gropu by 子句中使用having 子句时，查询结果中只返回满足having条件的组。在一个sql语句中可以有where子句和having子句。having 与where 子句类似，均用于设置限定条件</p>
<p>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。<br>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</p>
<p>查询每个部门的每种职位的雇员数<br>select deptno,job,count(*) from emp group by deptno,job;</p>
<p><strong>4.外连接与内连接</strong></p>
<p>有时候，即使在连接的表中没有相应的行，用户可能想从一张表中看数据，Oracle提供了外连接实现该功能。<br>内连接是指连接查询只显示完全满足连接条件的记录，即等值连接，外连接的查询结果是内连接查询结果的扩展。外连接不仅返回满足连接条件的所有记录而且也返回了一个表中那些在另一个表中没有匹配行的记录。外连接的操作符是“+”。“+”号放在连接条件中信息不完全的那一边（即没有相应行的那一边）。运算符“+”影响NULL行的建立。建一行或多行NULL来匹配连接的表中信息完全的行。</p>
<p>外连接运算符“+”只能出现在where子句中表达式的一边。</p>
<p>假如在多张表之间有多个连接条件，外连接运算符不能使用or,in逻辑运算符与其它条件组合。</p>
<p>假如emp表中deptno&#x3D;10的ename为空值，dept表中deptno&#x3D;20的loc为空值：</p>
<ol>
<li></li>
</ol>
<p>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno(+)&#x3D;dept.deptno;</p>
<p>如果在dept.deptno中有的数值在emp.deptno中没有值，则在做外连接时，<br>结果中ename会产生一个空值。(emp.deptno&#x3D;10)</p>
<ol start="2">
<li></li>
</ol>
<p>select<br>ename,dept.deptno,loc<br>from<br>emp,dept<br>where<br>emp.depno&#x3D;dept.deptno(+);</p>
<p>如果在emp.deptno中有的数值在dept.deptno中没有值，则在做外连接时，<br>结果中loc会产生一个空值。。(dept.deptno&#x3D;20)</p>
<p><strong>5.自连接</strong></p>
<p>自连接是指同一张表的不同行间的连接。该连接不受其他表的影响。用自连接可以比较同一张表中不同行的某一列的值。因为自连接查询仅涉及到某一张表与其自身的连接。所以在from子句中该表名出现两次，分别用两个不同的别名表示，两个别名当作两张不同的表进行处理，与其它的表连接一样，别名之间也使用一个或多个相关的列连接。为了区分同一张表的不同行的列，在名前永别名加以限制。</p>
<p>select<br>worker.ename,<br>manager.ename manager<br>from<br>emp worker,<br>emp manager<br>where<br>work.mgr&#x3D;manager.empno;</p>
<p><strong>6.集合运算</strong></p>
<p>基合运算符可以用于从多张表中选择数据。</p>
<p>①UNION运算<br>用于求两个结果集合的并集（两个结果集合的所有记录），并自动去掉重复行。</p>
<p>select ename,sal from account where sal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;</p>
<p>注：ename,sal 是必须一致的。</p>
<p>②UNION ALL运算<br>用于求两个结果集合的并集（两个结果集中的所有记录），并且不去掉重复行。</p>
<p>select ename,sal from account wheresal&gt;2000<br>union<br>select ename,sal from research where sal&gt;2000<br>union<br>select ename,sal from sales where sal&gt;2000;</p>
<p>③INTERSECT运算<br>intersect运算返回查询结果中相同的部分。</p>
<p>各部门中有哪些相同的职位？</p>
<p>select Job from account<br>intersect<br>select Job from research<br>intersect<br>select Job from sales;</p>
<p>④MINUS运算<br>minus返回两个结果集的差集。（在第一个结果集中存在的，而在第二个结果集中不存在的行。）</p>
<p>有那些职位是财务部中有，而在销售部门中没有？</p>
<p>select Job from account<br>minus<br>select Job from sales;</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>01_navicat</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>navicat  安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/01_navicat/01_navicat%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>1.Navicat 下载安装-破解</p>
<p>1）关闭所有的杀毒软件（很重要的步骤）</p>
<p>2）如果之前装过navicat,必须彻底删除navicat的残留文件</p>
<ul>
<li>卸载    点开windows设置，选择应用，找道navicat，点击选择卸载。</li>
<li>*为了安全起见，记得去 我的电脑里把文件夹删除，如果你是默认安装的路径，那么就在 C:\Program Files\PremiumSoft 下，<ul>
<li></li>
</ul>
</li>
<li>*如果不是默认的，就去找你当时安装的路径，删除 Navicat Premium  ，这个文件夹或者是你当初另外命名的文件夹<ul>
<li></li>
</ul>
</li>
<li>*删除注册表     win+r 输入 “regedit”，回车   *</li>
<li><em>在里面找到 HKEY_CURRENT_USER\Software\PremiumSoft 这个路径下的 Navicat 的相关注册表 删除(我是有几个删几个，从不慌)，</em></li>
</ul>
<p>2.1.Navicat 下载位置：<a href="https://www.navicat.com.cn/download/navicat-premium">Navicat | 下载 Navicat Premium 14 天免费 Windows、macOS 和 Linux 的试用版</a></p>
<p>注释：可按照电脑版本下载使用</p>
<p>2.2.安装Navicat Premium15</p>
<p><img src="/assets/1/image-20211120233620-y8dv58o.png" alt="image.png"></p>
<p><strong>然后一直傻瓜式操作就行，注意看一下自己的安装目录</strong></p>
<p><strong>利用注册机激活Navicat Premium15     破解文件在附件中（Navicat Keygen Patch v5.6.0 DFoX.exe）</strong></p>
<p><img src="/assets/1/image-20211120233626-ijrquw5.png" alt="image.png"></p>
<p>如果你是默认安装的话，你的navicat的安装路径是在C:\Program Files\PremiumSoft\Navicat Premium 15，</p>
<p>navicat破解工具：[Navicat Keygen Patch v5.6.0 DFoX.exe](assets&#x2F;1&#x2F;Navicat Keygen Patch v5.6.0 DFoX-20211120233821-d5tl62s.exe)</p>
<p>然后将上述图片中的破解工具复制到C:\Program Files\PremiumSoft\Navicat Premium 15。</p>
<p>如果不是默认安装，就把破解工具放到你自定义的navicat的安装目录下</p>
<p><img src="/assets/1/image-20211120233634-ufire3z.png" alt="image.png"></p>
<h3 id="点击patch"><a href="#点击patch" class="headerlink" title="点击patch"></a>点击patch</h3><p><img src="/assets/1/image-20211120233641-lm58r9j.png" alt="image.png"></p>
<h3 id="等待出现navicat-exe-x64-gt-Cracked"><a href="#等待出现navicat-exe-x64-gt-Cracked" class="headerlink" title="等待出现navicat.exe -x64-&gt; Cracked!"></a>等待出现navicat.exe -x64-&gt; Cracked!</h3><p><img src="/assets/1/image-20211120233647-qm4cagp.png" alt="image.png"></p>
<h3 id="点击Generate"><a href="#点击Generate" class="headerlink" title="点击Generate"></a>点击Generate</h3><p><img src="/assets/1/image-20211120233654-iq1d694.png" alt="image.png"></p>
<h3 id="打开Navicat-Premium-15，点击注册"><a href="#打开Navicat-Premium-15，点击注册" class="headerlink" title="打开Navicat Premium 15，点击注册"></a>打开Navicat Premium 15，点击注册</h3><p><img src="/assets/1/image-20211120233700-0om93mu.png" alt="image.png"></p>
<h3 id="粘贴秘钥，然后点击激活按钮"><a href="#粘贴秘钥，然后点击激活按钮" class="headerlink" title="粘贴秘钥，然后点击激活按钮"></a>粘贴秘钥，然后点击<strong>激活</strong>按钮</h3><p><img src="/assets/1/image-20211120233722-y7g41tg.png" alt="image.png"></p>
<h3 id="在弹出的界面选择手动激活"><a href="#在弹出的界面选择手动激活" class="headerlink" title="在弹出的界面选择手动激活"></a>在弹出的界面选择手动激活</h3><p><img src="/assets/1/image-20211120233717-uuw1zk8.png" alt="image.png"></p>
<h3 id="将请求码粘贴到注册机Request-Code框中（完整过程看图）"><a href="#将请求码粘贴到注册机Request-Code框中（完整过程看图）" class="headerlink" title="将请求码粘贴到注册机Request Code框中（完整过程看图）"></a><em>将请求码粘贴到注册机Request Code框中（完整过程看图）</em></h3><p><img src="/assets/1/image-20211120233730-s4jcf0e.png" alt="image.png"></p>
<h3 id="点击激活页面的激活弹出（说明激活成功）"><a href="#点击激活页面的激活弹出（说明激活成功）" class="headerlink" title="点击激活页面的激活弹出（说明激活成功）"></a>点击激活页面的激活弹出（说明激活成功）</h3><p><img src="/assets/1/image-20211120233736-swj24yz.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211120233741-8iiy4vj.png" alt="image.png"></p>
<p>到此navicat15安装和破解成功</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>01_navicat</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>navicat简单教程</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/01_navicat/02_navicat%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>（1）连接</p>
<p>Navicate支持mysql、Postgresql、oracle、sqlserver等主流数据库，这里以连接mysql为例，连接名自己命名，主机为目标库的ip地址，mysql数据库的端口默认为3306，数据用户名和密码，点击确定即可连接。</p>
<p><img src="/assets/2/image-20220515005521-z6yy5a2.png" alt="image.png"></p>
<p>（2）数据传输功能</p>
<p>数据传输是将A库的表和数据传输到B库中，比较方便，需要注意的是：A库和B库的用户都要用读写的权限。</p>
<p><img src="/assets/2/image-20220515005526-a9gfees.png" alt="image.png"></p>
<p>点击下一步，选择需要传输的表，点击完成即可开始同步。</p>
<p><img src="/assets/2/image-20220515005531-upv9dyi.png" alt="image.png"></p>
<p>（3）数据同步</p>
<p>数据同步是将两个库的数据进行同步，有比对不同的数据、比对插入的数据、比对更新、删除的数据，比对相同的数据，这里以test库和test1库为例，将test库中的数据同步到test1库中，test中t_sys_city有一条数据，但在test1的t_sys_city表中没有这条数据，我们将test中新增的数据同步到test1中。</p>
<p><img src="/assets/2/image-20220515005536-2jdgue3.png" alt="image.png"></p>
<p>通过比对后我们可以看到数据的差异性，点击部署就可以将差异数据同步至test1库表中。</p>
<p><img src="/assets/2/image-20220515005541-dfeve5w.png" alt="image.png"></p>
<p>（4）数据备份和自动运行功能</p>
<p>数据备份功能搭配自动运行功能，可以定时对指定的数据进行备份，确保数据的安全性，关键时候我们可以恢复数据，确保系统能够正常运行，将风险降到最低。新建备份，然后选择自动运行。</p>
<p><img src="/assets/2/image-20220515005547-6ib8oqo.png" alt="image.png"></p>
<p>点击新建批处理作业。</p>
<p><img src="/assets/2/image-20220515005553-dz5vxzx.png" alt="image.png"></p>
<p>选择我们需要的备份，对其进行定时备份，点击保存。</p>
<p><img src="/assets/2/image-20220515005600-k56xxfz.png" alt="image.png"></p>
<p>点击保存后，选中记录，设置定时计划。</p>
<p><img src="/assets/2/image-20220515005605-5pwxnkm.png" alt="image.png"></p>
<p>在设置任务计划中点击触发器，点击左下角的新建，在新建触发器中即可设置定时任务的时间，可以按天、周、月来触发，根据自己的需求来设定。</p>
<p><img src="/assets/2/image-20220515005615-tljtvu2.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>03_数据库</category>
        <category>01_navicat</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Airtest场景处理-页面Frame操作</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/03_Airtest%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86-%E9%A1%B5%E9%9D%A2Frame%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>06_airtest</category>
        <category>01_airtest文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Airtest场景处理-文件上传</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/04_Airtest%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>06_airtest</category>
        <category>01_airtest文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Airtest场景处理-登录状态访问网页</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/05_Airtest%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86-%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>06_airtest</category>
        <category>01_airtest文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Airtest命令运行脚本与报告生成</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/06_Airtest%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%B8%8E%E6%8A%A5%E5%91%8A%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>06_airtest</category>
        <category>01_airtest文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Airtest进阶操作启动器实现Web自动化实战</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/07_Airtest%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E5%90%AF%E5%8A%A8%E5%99%A8%E5%AE%9E%E7%8E%B0Web%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>06_airtest</category>
        <category>01_airtest文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>AirtestWeb自动化基本使用与脚本录制</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/02_AirtestWeb%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>06_airtest</category>
        <category>01_airtest文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Airtest</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest/</url>
    <content><![CDATA[<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/01_AirtestWeb%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/">AirtestWeb自动化原理与配置</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/06_Airtest%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%B8%8E%E6%8A%A5%E5%91%8A%E7%94%9F%E6%88%90/">Airtest命令运行脚本与报告生成</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/03_Airtest%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86-%E9%A1%B5%E9%9D%A2Frame%E6%93%8D%E4%BD%9C/">Airtest场景处理-页面Frame操作</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/02_AirtestWeb%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6/">AirtestWeb自动化基本使用与脚本录制</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/04_Airtest%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/">Airtest场景处理-文件上传</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/05_Airtest%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86-%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5/">Airtest场景处理-登录状态访问网页</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/07_Airtest%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E5%90%AF%E5%8A%A8%E5%99%A8%E5%AE%9E%E7%8E%B0Web%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%88%98/">Airtest进阶操作启动器实现Web自动化实战</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>06_airtest</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>AirtestWeb自动化原理与配置</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/06_airtest/01_airtest%E6%96%87%E4%BB%B6/01_AirtestWeb%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>06_airtest</category>
        <category>01_airtest文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>mock</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/05_mock/01_mock/</url>
    <content><![CDATA[<p><img src="/assets/2/image-20220508161516-7fizz3n.png" alt="image.png"></p>
<ol>
<li><p>背景<br> 在实际产品开发过程中，某个服务或前端依赖一个服务接口，该接口可能依赖多个底层服务或模块，或第三方接口，比如说服务 A 依赖服务B，服务B又依赖服务 C，如下图所示：</p>
<p> <img src="/assets/2/image-20220508161535-ikefszs.png" alt="image.png"><br> 这种依赖的问题会导致原本的需求目的是要验证服务A，但由于所依赖的服务B或者服务C不稳定或者未开发完成，导致工作无法正常开展。</p>
<p> <img src="/assets/2/image-20220508161546-audsq22.png" alt="image.png"><br> 那作为测试工程师，面对这样的情形，我们该怎么办呢？解决这类问题的核心的思路：引入依赖服务替身，更通俗的叫法，引入Mock服务。</p>
</li>
</ol>
<p>今天就结合unittest框架，给大家分享一些关于Mock的一些常见使用。</p>
<ol start="2">
<li>Mock是什么<br> 可能还有些读者之前并没有接触过Mock，不清楚Mock是个啥。</li>
</ol>
<p>Mock简单来理解，就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试。而这个虚拟的对象就是mock对象。mock对象就是真实对象在调试期间的代替品。</p>
<p>有时也将Mock服务称之为测试服务替身，或者测试服务档板，下图很形象的描述了Mock的作用。</p>
<p><img src="/assets/2/image-20220508161603-96r63e8.png" alt="image.png"><br>3. Mock能做什么<br>就Mock功能而言，本身适用场景较多，但在实际项目中，引入Mock常用来解决的几类，概括起来，主要有：</p>
<p>接口间的相互依赖<br>单元测试<br>第三方接口调用<br>1.前后端联调</p>
<p>比如你是一个前端页面开发，现在需要开发一个功能：下一个订单，支付页面的接口，根据支付结果，支付成功，展示支付成功页，支付失败，展示支付失败页。要完成此功能，你需要调用后端的接口，根据返回给你的结果，来展示不同的页面。此时后端接口还没开发好，作为一个前端开发总不能等别人开发好了，你再开发，那你只有加班的命了。为了同步开发完成任务，此时，你可以根据接口文档的规定，把接口的地址和入参传过去，然后自己mock接口的不同返回界面，来完成前端的开发任务。</p>
<p>2.单元测试</p>
<p>由于单元测试仅针对当前单元进行测试，这就要求所有的内部或者外部依赖都应该是稳定的，采用mock的方法模拟跟本单元依赖的其他单元，可以将测试重点放在当前单元功能，排除外界因素干扰，提升测试精准度。</p>
<p>3.第三方接口依赖</p>
<p>在做接口自动化的时候，有时候需要调用第三方的接口，但是别人公司的接口服务不受你的控制，有可能别人提供的测试环境今天服务给你开着，别人就关掉了，给自动化接口测试带来很多的麻烦，此时就可以通过mock来模拟接口的返回数据，比如模拟各种第三方异常时的返回。</p>
<ol start="4">
<li>Mock实现方式<br> Mock虽然是作为依赖服务的替身，但并不需要原原本本去构造实现一个完整的服务逻辑，比如现在有一个A服务依赖B服务，需要通过Mock来替换B服务（做一个假的B服务替身）。</li>
</ol>
<p>在这里还是要推荐下我的软件测试学习交流地 644956177 ，群里技术大牛，如果你正在学习，小编欢迎你加入，大家都是测试开发党，不定期分享干货，包括我自己整理的一份2021最新的资料。</p>
<p><img src="/assets/2/image-20220508161622-75wiy64.png" alt="image.png"></p>
<p>那么我们做一个 Mock 服务其实就是做了一个简单的服务 B，它不需要实现原有服务 B 负载的处理逻辑，只要能按服务A需要服务B返回的处理逻辑给出对应返回数据就可以了。</p>
<p>目前常见服务或接口协议主要两种，一种是RPC，另一种是HTTP&#x2F;HTTPS，mock原理都类似，要么是修改原服务地址为Mock服务地址，要么是拦截原服务的请求Mock返回值，总之就是构造一个假的服务，替代原有服务。</p>
<p><img src="/assets/2/image-20220508161632-ktmz7q1.png" alt="image.png"><br>5. Mock市面上常见的解决方案<br>如果你不想自己动手构建一套Mock解决方案，市面上也提供了很多现存的Mock方案。常用的有：EasyMock、Mockito 、WireMock、JMockit、Mock、Moco。</p>
<p>如果你团队技术基础相对比较薄弱，推荐你看看Moco这个方案，官网如下：</p>
<p><a href="https://github.com/dreamhead/moco/">https://github.com/dreamhead/moco/</a></p>
<p><img src="/assets/2/image-20220508161640-h5odkk3.png" alt="image.png"><br>接下来，重点介绍Python系下Mock方案的使用。</p>
<p>Python下unittest.mock使用<br>unittest.mock是一个用于在Python中进行单元测试的库，顾名思义这个库的主要功能是模拟一些东西。它的主要功能是使用mock对象替代掉指定的Python对象，以达到模拟对象的行为。<br>需要注意的是在Python2.x版本中，Mock需要单独安装</p>
<blockquote>
<p>pip install -U mock</p>
</blockquote>
<p>从Python 3.3以后的版本mock已经合并到unittest模块中了，是unittest单元测试的一部分，直接导入过来就行</p>
<blockquote>
<p>from unittest import mock</p>
</blockquote>
<p>官方文档：</p>
<blockquote>
<p><a href="https://docs.python.org/dev/library/unittest.mock.html">https://docs.python.org/dev/library/unittest.mock.html</a></p>
</blockquote>
<p>unittest.mock模块中最常用的是Mock类。</p>
<p><img src="/assets/2/image-20220508161652-1gbxioy.png" alt="image.png"></p>
<p>Mock类库是一个专门用于在unittest过程中制作（伪造）和修改（篡改）测试对象的类库，避免这些对象在单元测试过程中依赖外部资源（网络资源，数据库连接，其它服务以及耗时过长等）</p>
<p>案例：如下场景：支付是一个独立的接口，由其它开发提供，根据支付的接口返回状态去显示失败，还是成功，这个是你需要实现的功能，代码存放在pay.py脚本中:</p>
<blockquote>
<p>&#x2F;usr&#x2F;bin&#x2F;python3</p>
<p>-<em>- coding: utf-8 -</em>-</p>
<p>@Author : Mike Zhou</p>
<p>@Email : 公众号：测试开发技术</p>
<p>@File : pay.py</p>
<p>def zhifu():<br>    ‘’’假设这里是一个支付的功能,未开发完<br>    支付成功返回：{“result”: “success”, “msg”:”支付成功”}<br>    支付失败返回：{“result”: “fail”, “msg”:”余额不足”}<br>    ‘’’<br>    pass</p>
<p>def zhifu_statues():<br>    ‘’’根据支付的结果success or fail，判断跳转到对应页面’’’<br>    result &#x3D; zhifu()<br>    try:<br>        if result[“result”] &#x3D;&#x3D; “success”:<br>            return “支付成功”<br>        elif result[“result”] &#x3D;&#x3D; “fail”:<br>            return “支付失败”<br>        else:<br>            return “未知错误异常”<br>    except:<br>        return “Error, 服务端返回异常!”</p>
</blockquote>
<h1 id="在zhifu-statues方法中，依赖了zhifu方法，但由于zhifu支付方法的接口是由另外一个同事开发，正常情况下，你同事开发的进度你是无法控制的，需要等他开发完了你才能进行联调你所负责的zhifu-statues接口，因此我们可以通过引入Mock来解决这个问题。"><a href="#在zhifu-statues方法中，依赖了zhifu方法，但由于zhifu支付方法的接口是由另外一个同事开发，正常情况下，你同事开发的进度你是无法控制的，需要等他开发完了你才能进行联调你所负责的zhifu-statues接口，因此我们可以通过引入Mock来解决这个问题。" class="headerlink" title="在zhifu_statues方法中，依赖了zhifu方法，但由于zhifu支付方法的接口是由另外一个同事开发，正常情况下，你同事开发的进度你是无法控制的，需要等他开发完了你才能进行联调你所负责的zhifu_statues接口，因此我们可以通过引入Mock来解决这个问题。"></a>在zhifu_statues方法中，依赖了zhifu方法，但由于zhifu支付方法的接口是由另外一个同事开发，正常情况下，你同事开发的进度你是无法控制的，需要等他开发完了你才能进行联调你所负责的zhifu_statues接口，因此我们可以通过引入Mock来解决这个问题。</h1><p>引入mock后单元测试用例代码</p>
<blockquote>
<p>!&#x2F;usr&#x2F;bin&#x2F;python3</p>
<p>-<em>- coding: utf-8 -</em>-</p>
<p>@Author : Mike Zhou</p>
<p>@Email : 公众号：测试开发技术</p>
<p>import unittest<br>from unittest import mock<br>import pay</p>
<p>class TestZhifuStatues(unittest.TestCase):<br>    ‘’’单元测试用例’’’<br>    def test_01(self):<br>        ‘’’测试支付成功场景’’’<br>        # mock一个支付成功的数据<br>        pay.zhifu &#x3D; mock.Mock(return_value&#x3D;{“result”: “success”, “msg”:”支付成功”})<br>        # 根据支付结果测试页面跳转<br>        statues &#x3D; pay.zhifu_statues()<br>        print(statues)<br>        self.assertEqual(statues, “支付成功”)</p>
<pre><code>def test_02(self):
    &#39;&#39;&#39;测试支付失败场景&#39;&#39;&#39;
    # mock一个支付失败的数据
    pay.zhifu = mock.Mock(return_value=&#123;&quot;result&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;余额不足&quot;&#125;)
    # 根据支付结果测试页面跳转
    statues = pay.zhifu_statues()
    print(statues)
    self.assertEqual(statues, &quot;支付失败&quot;)
</code></pre>
<p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    unittest.main()</p>
</blockquote>
<p>上述代码引入Mock后，我们就可以顺利完成对支付成功和支付异常两类场景的验证工作。（实际你可以补充更多）</p>
<p>mock中还有另一种实现方式，通过patch装饰器的使用,patch作为函数装饰器，为您创建模拟并将其传递到装饰函数。</p>
<p>用mock.patch实现如下：</p>
<blockquote>
<p>!&#x2F;usr&#x2F;bin&#x2F;python3</p>
<p>-<em>- coding: utf-8 -</em>-</p>
<p>@Author : Mike Zhou</p>
<p>@Email : 公众号：测试开发技术</p>
<p>import unittest<br>from unittest import mock<br>import pay</p>
<p>class TestZhifuStatues(unittest.TestCase):<br>    ‘’’单元测试用例’’’</p>
<pre><code>@mock.patch(&quot;pay.zhifu&quot;)
def test_001(self, mock_zhifu):
    &#39;&#39;&#39;测试支付成功场景&#39;&#39;&#39;
    # 方法一：mock一个支付成功的数据
    # pay.zhifu = mock.Mock(return_value=&#123;&quot;result&quot;: &quot;success&quot;, &quot;msg&quot;:&quot;支付成功&quot;&#125;)
    # print(pay.zhifu())

    # 方法二：mock.path装饰器模拟返回结果
    mock_zhifu.return_value = &#123;&quot;result&quot;: &quot;success&quot;, &quot;msg&quot;:&quot;支付成功&quot;&#125;

    # # 根据支付结果测试页面跳转
    statues = pay.zhifu_statues()
    print(statues)
    self.assertEqual(statues, &quot;支付成功&quot;)

@mock.patch(&quot;pay.zhifu&quot;)
def test_002(self, mock_zhifu):
    &#39;&#39;&#39;测试支付失败场景&#39;&#39;&#39;
    # mock一个支付失败的数据

    mock_zhifu.return_value = &#123;&quot;result&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;余额不足&quot;&#125;
    # 根据支付结果测试页面跳转
    statues = pay.zhifu_statues()
    self.assertEqual(statues, &quot;支付失败&quot;)
</code></pre>
<p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    unittest.main()</p>
</blockquote>
<blockquote>
<p>-<em>- coding: utf-8 -</em>-</p>
<p>@Author : Mike Zhou</p>
<p>@Email : 公众号：测试开发技术</p>
<p>@File : pay.py</p>
<p>def zhifu():<br>    ‘’’假设这里是一个支付的功能,未开发完<br>    支付成功返回：{“result”: “success”, “msg”:”支付成功”}<br>    支付失败返回：{“result”: “fail”, “msg”:”余额不足”}<br>    ‘’’<br>    pass</p>
<p>def zhifu_statues():<br>    ‘’’根据支付的结果success or fail，判断跳转到对应页面’’’<br>    result &#x3D; zhifu()<br>    try:<br>        if result[“result”] &#x3D;&#x3D; “success”:<br>            return “支付成功”<br>        elif result[“result”] &#x3D;&#x3D; “fail”:<br>            return “支付失败”<br>        else:<br>            return “未知错误异常”<br>    except:<br>        return “Error, 服务端返回异常!”</p>
<p>class TestZhifuStatues(unittest.TestCase):<br>    ‘’’单元测试用例’’’</p>
<pre><code>@mock.patch(&quot;pay.zhifu&quot;)
def test_001(self, mock_zhifu):
    &#39;&#39;&#39;测试支付成功场景&#39;&#39;&#39;
    # 方法一：mock一个支付成功的数据
    # pay.zhifu = mock.Mock(return_value=&#123;&quot;result&quot;: &quot;success&quot;, &quot;msg&quot;:&quot;支付成功&quot;&#125;)
    # print(pay.zhifu())

    # 方法二：mock.path装饰器模拟返回结果
    mock_zhifu.return_value = &#123;&quot;result&quot;: &quot;success&quot;, &quot;msg&quot;:&quot;支付成功&quot;&#125;

    # # 根据支付结果测试页面跳转
    statues = pay.zhifu_statues()
    print(statues)
    self.assertEqual(statues, &quot;支付成功&quot;)

@mock.patch(&quot;pay.zhifu&quot;)
def test_002(self, mock_zhifu):
    &#39;&#39;&#39;测试支付失败场景&#39;&#39;&#39;
    # mock一个支付失败的数据

    mock_zhifu.return_value = &#123;&quot;result&quot;: &quot;fail&quot;, &quot;msg&quot;: &quot;余额不足&quot;&#125;
    # 根据支付结果测试页面跳转
    statues = pay.zhifu_statues()
    self.assertEqual(statues, &quot;支付失败&quot;)
</code></pre>
<p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    unittest.main()<br><br /></p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>05_mock</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>apipost</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/04_apipost/01_apipost/</url>
    <content><![CDATA[<p>官网下载地址：<a href="https://www.apipost.cn/" title="https://www.apipost.cn/">https://www.apipost.cn/</a></p>
<h1 id="1-请求接口"><a href="#1-请求接口" class="headerlink" title="1.请求接口"></a>1.请求接口</h1><p><img src="/assets/2/image-20220508155601-btpvb85.png" alt="image.png"></p>
<h1 id="2-生成文档"><a href="#2-生成文档" class="headerlink" title="2.生成文档"></a>2.生成文档</h1><p><img src="/assets/2/image-20220508155609-t8xfsdf.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508155617-diif63q.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508155623-efzypj9.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220508155629-n9oeg1f.png" alt="image.png"></p>
<h1 id="3-变量使用"><a href="#3-变量使用" class="headerlink" title="3.变量使用"></a>3.变量使用</h1><p>ApiPost提供了5个内建变量，如下：</p>
<blockquote>
     //生成GUID
     //当前时间戳
     //当前毫秒时间戳
      //0-1000的随机整数
     //0-1000的随机浮点数
</blockquote>
<p>当我们的请求参数是一个时间戳或者随机数时，我们可以用ApiPost的内建变量。</p>
<p><img src="/assets/2/image-20220508155637-v9hqmjo.png" alt="image.png"></p>
<p>注意：</p>
<ol>
<li>ApiPost2.4.1开始支持内建变量，低版本不支持；</li>
<li>内建变量的调用方法是：，不同于普通环境变量的调用方法：（前面多了个$符号）。</li>
</ol>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>04_apipost</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>soapUI</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/03_soapUI/01_soapUI/</url>
    <content><![CDATA[<p><strong>简介</strong></p>
<p>SOAPUI,一款专业的web service的测试软件,SoapUI也是一个<a href=""><strong>开源</strong></a><strong><a href=""><strong>测试</strong></a>工具</strong>，通过soap&#x2F;http来检查、调用、实现<a href=""><strong>Web</strong></a> Service的功能&#x2F;负载&#x2F;符合性测试。该工具既可作为一个单独的测试软件使用，也可利用插件集成到Eclipse，maven2.X，Netbeans 和intellij中使用。</p>
<p>SoapUI是一个自由和开放源码的跨平台<a href=""><strong>功能测试</strong></a>解决方案。通过一个易于使用的图形界面和企业级功能，SoapUI让您轻松， 快速创建和执行自动化功能、回归、合规和负载测试。在一个测试环境，SoapUI提供完整的测试覆盖，并支持所有的标准协议和<a href=""><strong>技术</strong></a>。</p>
<p>SoapUI 基于Java 开发，支持多个平台，安装非常简单。</p>
<p><strong>下载</strong></p>
<p>下载地址：<a href="https://www.soapui.org/,%E4%B8%8B%E8%BD%BD%E5%BC%80%E6%BA%90%E7%89%88%EF%BC%8C%E5%AE%89%E8%A3%85%E5%AE%8C%E6%AF%95%E3%80%82">https://www.soapui.org/,下载开源版，安装完毕。</a></p>
<p><strong>基础知识</strong></p>
<p> soapUI所提供的测试用例管理与测试项目所需要的层级的映射关系是相当贴近的，对应关系如下图：</p>
<p><img src="/assets/1/image-20220311173236-rkcktl3.png" alt="image.png"></p>
<hr>
<p>SoapUI中的重要名词：<br>1.TestStep 测试步骤：测试步骤是最小的单位，一个完整的测试用例是由多个测试步骤所组成的，而每一个测试步骤，都需要根据实际的业务要求进行组织。</p>
<p>2.TestCase 测试用例：一个测试用例代表一个完整操作，接口测试的目的，实质在于模拟外部的调用来验证接口的功能，而接口功能的各个分支则由于入参（测试数据）的不同来遍及。</p>
<p>3.TestSuit 测试集：对于测试集，主要是为了区分大功能模块里的不同小功能点儿引入的概念，一般一个WebService都包含有多个接口，此处可根据需要添加测试集。</p>
<p>4.Project 项目：在SoapUI里，一个接口对应一个项目（project），这是由SoapUI提供的功能所决定的，在每次要测试一个新的接口时，可以右键点击WorkSpace名称，从右键菜单中选择 New SoapUI Project 来引入新的WSDL。</p>
<p>5.WorkSpace 工作空间：对应测试项目的概念，一个测试项目中可能会包含多个WebService接口，这些接口都同属于一个项目中，由工作空间来管理所有的接口项目。</p>
<hr>
<p>SoapUI中的附加名词:<br>1.WSDL：指网络服务描述语言（Web Service Description Language），是一种使用XML编写的文档。这种文档可描述某个Web Service。它可以规定服务的位置，一级此服务提供的操作</p>
<p>2.Request：SoapUI通过导入正确的WSDL，便可以解析接口需要的入参。当对特定的接口创建一个请求时，SoapUI会帮我们吧需要的Soap报文的结构以一定的形式显示出来，此时你只需要输入请求的内容，点击运行，SoapUI会将我们填写后的Soap报文完整地发送给远程服务接口进行调用。</p>
<p>3.MokeService：SoapUI同样提供了Moke服务的功能，在初期确定完接口出入参、接口名时，便可以通过SoapUI的Mock服务功能，人为地模拟细分文档中明确要求的各种情况下的返回参数（根据返回参数的类型编写对应的Soap报文），使测试人员在早期就进行接口测试用例的编写和调试。</p>
<p><strong>基本使用  （转）</strong></p>
<p><strong>1打开soapUI——2新建soap project——3创建new testSuite——4创建new testCase——5创建step和请求——6运行查看</strong></p>
<p>1、打开soapUI。</p>
<p>2、新建一个项目，实例如下：</p>
<p><img src="/assets/1/image-20220311173251-kn3ful1.png" alt="image.png"></p>
<p>点击ok后在soapUI界面左侧会显示出此项目，如图：</p>
<p>　　<img src="/assets/1/image-20220311173258-ep5vit2.png" alt="image.png"></p>
<p>3、创建测试用例：</p>
<p>a、新建用例组，选择此项目右键，新建一个用例组，如下图：</p>
<p><img src="/assets/1/image-20220311173306-s5a7j2i.png" alt="image.png"></p>
<p>　　<img src="/assets/1/image-20220311173313-e9jmupt.png" alt="image.png"></p>
<p> 用例组创建好后，在testhah项目中能看到查看到login_test,</p>
<p>b、创建测试用例，选中测试组名称右键新建测试用例，如下图：</p>
<p><img src="/assets/1/image-20220311173320-fcebrbb.png" alt="image.png"></p>
<p>　　<img src="/assets/1/image-20220311173343-smnjo26.png" alt="image.png"></p>
<p>检查是否新建好：</p>
<p>　　<img src="/assets/1/image-20220311173327-umwapah.png" alt="image.png"></p>
<p>c、创建测试步骤：</p>
<p><img src="/assets/1/image-20220311173350-5an5xbo.png" alt="image.png"></p>
<p>注：此处选择HTTP Test Request,目前我测试的接口是http的，接口有哪些类型可自己百度，或者不清楚所测接口是什么类型可与开发确认.</p>
<p><img src="/assets/1/image-20220311173356-8dl85hf.png" alt="image.png"></p>
<p><img src="/assets/1/image-20220311173402-dlj6sfz.png" alt="image.png"></p>
<p>点击ok进入接口运行界面：</p>
<p><img src="/assets/1/image-20220311173411-n20bz3g.png" alt="image.png"></p>
<p>注意：执行结果中提示token未找到则，此处需与开发确认，登录时需要哪些参数，再次添加参数并执行：</p>
<p><img src="/assets/1/image-20220311173418-jomh8oo.png" alt="image.png"></p>
<p>然后不断的乱点功能，乱试，同事的帮助执行成功了，如下图:</p>
<p><img src="/assets/1/image-20220311173424-n2ho330.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>03_soapUI</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>postman</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/01_postman/</url>
    <content><![CDATA[<ul>
<li><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/01_postman%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/">postman界面介绍</a></p>
</li>
<li><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/02_postman%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">postman基本操作</a></p>
<ul>
<li><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/03_Postman%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82/">Postman实现接口请求</a></p>
</li>
<li><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/04_Postman%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">Postman项目实战</a></p>
</li>
<li><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/05_Postman%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">Postman数据驱动与持续集成</a></p>
</li>
</ul>
</li>
<li><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/06_postman-%E6%96%AD%E8%A8%80%E5%8F%98%E9%87%8F/">postman-断言、变量</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>02_postman</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>postman界面介绍</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/01_postman%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="/assets/1/image-20211207104240-taz51ex.png" alt="image.png"></p>
<p><strong>1、collections：可以理解为文件夹，可以把接口项目的请求放在同一个文件夹，方便管理。</strong></p>
<p><strong>2、get：请求方式，包括HTTP的各种请求，可以下拉选择。</strong></p>
<p><strong>3、请求url</strong></p>
<p><strong>4、params：get请求的参数，以键值对的形式组成，点击后可以自己添加修改。</strong></p>
<p><strong>5、send：点击发送接口请求。</strong></p>
<p><strong>6、save：选择接口请求，存放到collections。选择下拉框，支持发送请求并下载响应结果到指定的位置</strong></p>
<p><strong>7、Authorization：授权文件。</strong></p>
<p><strong>8、headers：请求头，如果有参数需要放在头部信息，可以在这里添加。</strong></p>
<p><strong>9、Body：请求body，post请求的参数，可以在这里添加。</strong></p>
<p><strong>10、Pre-request Script发起请求之前执行的脚本，当某个接口，需要保持登录，这时候我们就可以先发起一个登录请求。</strong></p>
<p><strong>11、Tests：发起请求之后执行的脚本，比如我们要验证接口的返回接口，就可以使用这个Tests。</strong></p>
<p><strong>12、 Code：将请求生成代码脚本，支持Java，Python，js等多种编程语言。cookie就不做多介绍了</strong></p>
<p><strong>13、请求返回的数据格式。</strong></p>
<p><strong>14、可以选择相应的数据，如json，xml等。</strong></p>
<p><strong>15、Tests：查看请求之后执行脚本的结果。</strong></p>
<p><strong>16、设置，可以在这里添加全局变量，比如测试服务器和正式服务器的host。</strong></p>
<p><strong>17、可以搜索响应body的数据。比如我们想要查找token的时候。</strong></p>
<h4 id="Collections"><a href="#Collections" class="headerlink" title="**Collections"></a>**Collections</h4><p>**</p>
<hr>
<p><strong>添加一个collection，上面是名字，下面是注释</strong></p>
<p><img src="/assets/1/image-20211207104257-j0nnv6q.png" alt="image.png"></p>
<p><strong>将我们的请求保存到collection，就可以实现一次性，把用例全部跑完，很方便有木有。</strong></p>
<p><img src="/assets/1/image-20211207104301-hus7qfs.png" alt="image.png"></p>
<p><strong>选择我们的主collections，点击拓展框，再点击run就到了我们的跑用例界面了</strong></p>
<p><img src="/assets/1/image-20211207104305-5zfy0rq.png" alt="image.png"></p>
<p><strong>Environment：测试环境</strong></p>
<p><strong>Lterations：循环次数</strong></p>
<p><strong>Delay：启动时间</strong></p>
<p><strong>Log Responses：一共三种选项，记录所有的接口请求的响应信息，只记录失败的请求的响应信息，不记录请求的响应信息</strong></p>
<p><strong>Data：测试数据，支持从外部导入数据</strong></p>
<p><img src="/assets/1/image-20211207104310-icr824l.png" alt="image.png"></p>
<p>测试结果</p>
<p><strong>测试结果，记录所有请求的响应信息，所以我们可以在测试结果请求url的前面，点击查看响应信息。</strong></p>
<p><strong>断言成功，服务器返回200和OK</strong></p>
<p><strong>不知道断言怎么办？不要慌，不要急，马上就会告诉你，嘿嘿嘿。</strong></p>
<h4 id="Pre-request-Script"><a href="#Pre-request-Script" class="headerlink" title="**Pre-request Script"></a>**Pre-request Script</h4><p>**</p>
<hr>
<p><img src="/assets/1/image-20211207104313-ufjcjm6.png" alt="image.png"></p>
<p><strong>发起请求之前的脚本。使用的是JavaScript语言，支持设置全局变量，环境变量，发起请求，完全符合我们的需求。没有的还可以自己加，嘿嘿嘿</strong></p>
<h4 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a><strong>Tests</strong></h4><hr>
<p><img src="/assets/1/image-20211207104317-c9j47xb.png" alt="image.png"></p>
<p><strong>发起请求之后的脚本，同样也是用的 <strong>JavaScript语言哦。</strong> 比如我想验证一下请求有没有成功，Tests就有已经设置好的断言，点击添加就OK。加个200或者响应信息，断言一下，有木有很nice啊。当然还有更多功能，等待你的挖掘，有兴趣的可以去了解一下JavaScript语言。</strong></p>
<p><img src="/assets/1/image-20211207104321-g3d62wm.png" alt="image.png"></p>
<p><strong>断言信息</strong></p>
<h4 id="Code"><a href="#Code" class="headerlink" title="** Code**"></a>** Code**</h4><hr>
<p><strong>什么？你觉得postman逼格不够高，OK。还有code来拯救你。</strong></p>
<p><img src="/assets/1/image-20211207104325-ste7l50.png" alt="image.png"></p>
<p><strong>code</strong></p>
<p>**<strong>点击code，选择你想要的语言，马上生成相应的代码脚本，语言应有尽有有木有</strong><br>**</p>
<p><strong>最后给大家讲一下怎么设置全局变量</strong></p>
<p><img src="/assets/1/image-20211207104329-xncj4l1.png" alt="image.png"></p>
<p><strong>点击设置符号的齿轮，选择Manage Environments</strong></p>
<p><img src="/assets/1/image-20211207104335-l5d89wb.png" alt="image.png"></p>
<p><strong>点击Globals，就可以开始设置我们的需要的变量了，还支持导出为json格式的数据</strong></p>
<p><img src="/assets/1/image-20211207104342-bqietja.png" alt="image.png"></p>
<p><strong>设置好，我们的全局变量，接下来，当然是调用全局变量了。</strong></p>
<p><img src="/assets/1/image-20211207104346-fe10hwy.png" alt="image.png"></p>
<p><strong>调用全局变量的方法是key，双引号中间写key的值。这样就可以实现了，数据分离，想怎么改就怎么改</strong></p>
<p><strong>Postman+Newman+Jenkins可以做接口自动化测试。</strong></p>
<p>主要介绍Postman基本操作及设置，包括Postman设置、Postman新建请求以及Postman导入&#x2F;导出操作。</p>
<p>一</p>
<p>Postman设置</p>
<p>Postman在开发时已经基于用户体验，尽可能少的提供设置项。所以，对于大多数配置项可以不用修改，使用默认值即可。如果想要适用更多的场景，那么就需要进行适当的调整。以下，就对Postman设置中的每个设置项进行简单的说明。</p>
<p>1</p>
<p>Postman通用设置</p>
<p>打开Postman之后选择右上角的”设置”按钮，选择Settings；或在File-Setings打开General通用设置界面。可以进行SSL证书验证设置，字体大小设置。</p>
<p><img src="/assets/1/image-20211207102349-8z6sh79.png" alt="image.png"></p>
<p>具体设置项说明如下：</p>
<blockquote>
<p>Trim keys and values in request body（在请求体中删除键和值）：如果使用form-data或者url-encoded的方式向服务器发送数据；将该选项设置为“ON”，则会引起参数左右两侧的空格被删除；</p>
<p>SSL certificate verification（SSL证书验证）：防止应用程序在发出请求时检查SSL证书的有效性；</p>
<p>Always open requests in new tab（总是在新标签打开请求）：将该选项设置为“ON”时，所有新打开请求都在一个新标签中呈现。</p>
<p>Language detection（语言检测）：将此设置为JSON将强制执行JSON呈现，而不管响应Content-Type标头；</p>
<p>Request timeout in ms(0 for infinity)（请求超时时间，0代表无穷大，单位为ms）：在显示服务器没有响应之前，设置应用等待响应的时间。0表示无穷大，Postman将永远等待响应；</p>
<p>Eidtor Font Size（px）（编辑字体大小）：调整字体大小，以像素为单位。</p>
<p>Two-pane view(beta)(左右窗口视图)：默认为上下窗口视图，开启本设置后，将使用左右窗口视图。</p>
<p>Vari(变量自动完成)：变量是否自动完成转换。</p>
<p>Send no-cache header（发送无缓存Header）：发送一个no-cache标头可以确保请求从服务器获得最新的响应，而不是缓存数据；</p>
<p>Send Postman Token header(发送Postman Token header)：这主要用于绕过Chrome中的错误。如果XmlHttpRequest处于挂起状态，并且使用相同的参数发送另一个请求，则Chrome会为它们返回相同的响应。发送随机令牌可避免此问题。这也可以帮助我们在服务器端区分请求；</p>
<p>Retain headers when clicking on links（当单击链接时，保留Headers）:如果点击响应报文中的链接，Postman会使用该URL创建一个新的GET请求。如果希望该请求继续使用前一次请求中的头部信息，该选项就应该设置为ON；这个选项对于访问受保护的资源非常有用；</p>
<p>Automatically follow redirects（自动跟随重定向）：阻止返回300系列响应的请求被自动重定向；</p>
<p>Send anonymous usage data to Postman（将匿名使用数据发送给Postman）：是否同意Postman采集我们的使用信息。</p>
</blockquote>
<p>2</p>
<p>设置Postman主题</p>
<p>Themes可以修改Postman主题为白色（默认）或黑色。</p>
<p><img src="/assets/1/image-20211207102443-u5fpp2u.png" alt="image.png"></p>
<p>3</p>
<p>键盘快捷键设置</p>
<p>Shortcuts可以查看当前键盘的快捷键设置。</p>
<p><img src="/assets/1/image-20211207102517-mh6cssx.png" alt="image.png"></p>
<p>4</p>
<p>Data数据导入&#x2F;导出设置</p>
<p>Data设置可以以Json形式导入和导出当前的环境、全局变量等设置。对于团队协作来说，数据导入&#x2F;导出是经常使用的功能。但是该操作将覆盖现有当集合环境，需谨慎操作。</p>
<p><img src="/assets/1/image-20211207102530-tqc5aqi.png" alt="image.png"></p>
<p>5</p>
<p>附加组件设置</p>
<p>“Add-ons”选项卡会提示用户可以通过npm来安装Postman的Newman插件。</p>
<p><img src="/assets/1/image-20211207102618-zh87cll.png" alt="image.png"></p>
<p>6</p>
<p>证书设置</p>
<p>Certificates可以新增证书，包括Host设置和CRT file和KEY file文件导入。</p>
<p><img src="/assets/1/image-20211207102624-pxvz5xg.png" alt="image.png"></p>
<p>7</p>
<p>代理设置</p>
<p>Proxy可以进行网络代理设置，可以使用系统代理或者自定义代理。</p>
<p><img src="/assets/1/image-20211207102632-3xooj3g.png" alt="image.png"></p>
<p>8</p>
<p>更新设置</p>
<p>版本更新时以弹框形式通知用户有新版本可更新，弹框包括版本号、增加的特效、修复的漏洞。</p>
<p><img src="/assets/1/image-20211207102645-j0ohp72.png" alt="image.png"></p>
<p>9</p>
<p> 关于</p>
<p>显示Postman的版本信息及相关链接。</p>
<p><img src="/assets/1/image-20211207102652-tlqmjcw.png" alt="image.png"></p>
<p>二</p>
<p>Postman新建请求操作</p>
<p>1</p>
<p>说明</p>
<p>Postman最基本的操作是发送请求，查看响应结果，以下简单介绍新建请求相关操作。</p>
<p>2</p>
<p>介绍</p>
<p><img src="/assets/1/image-20211207102723-3s5yzml.png" alt="image.png"></p>
<p>Request快速打开新建接口请求的窗口；</p>
<p>Collection新建测试集合；</p>
<p>Environment新建环境变量的窗口；</p>
<p>Documentation，生成公有文档，可以通过网址进行查看；</p>
<p>Mock server模拟服务器进行联调和测试；</p>
<p>Monitor监控请求的状态；</p>
<p>三</p>
<p>Postman导入导出操作</p>
<p>1</p>
<p>导出</p>
<p>1.在需要导出的接口集，点击右键“Export”。</p>
<p><img src="/assets/1/image-20211207102732-ic5vde0.png" alt="image.png"></p>
<p>2.默认选择 “Collection v2.1 (recommended)”，点击“Export”执行导出。</p>
<p><img src="/assets/1/image-20211207102750-qu77qy8.png" alt="image.png"></p>
<p>3.选择保存路径，数据一般以postman_collection.json结尾。</p>
<p><img src="/assets/1/image-20211207102806-vl3jrtb.png" alt="image.png"></p>
<p>2</p>
<p>Json导入</p>
<p>1.选择“Import”。</p>
<p><img src="/assets/1/image-20211207102820-x08usim.png" alt="image.png"></p>
<p>2.点击“Choose  Files”选择文件，即可将对应的json文件导入到Postman。</p>
<p><img src="/assets/1/image-20211207102827-gv5nycj.png" alt="image.png"></p>
<p>3</p>
<p>导入cURL</p>
<p>想在Postman上模拟接口发起请求,可以通过导入cURL的方式实现。</p>
<p>1.Chrome浏览器打开开发者工具（F12），Network下选择一条需要复制的网络请求，右键Copy,Copy as cURL (bash)，注意不是copy as cURL (cmd)。</p>
<p><img src="/assets/1/image-20211207102840-r0uhsng.png" alt="image.png"></p>
<p>2.打开 Postman ， 点击左上角的 Import ， 选择Paste Raw Text ，导入后点击 Send发送请求。</p>
<p><img src="/assets/1/image-20211207102850-w0k582a.png" alt="image.png"></p>
<p>3.发送请求之后就可以查看，如下图，标箭头处可以查看更多。如可以预览web界面，查看 Headers 信息，查看状态，复制代码。</p>
<p><img src="/assets/1/image-20211207102902-domk5vd.png" alt="image.png"></p>
<p>4.同时可以打开 Headers ，用来调试，勾选或取消勾选对应的头部信息。</p>
<p><img src="/assets/1/image-20211207102908-3j40b3y.png" alt="image.png"></p>
<p>5.最方便的一点是，可以直接生成对应的编程语言并复制，例如Python的Requests方法。</p>
<p><img src="/assets/1/image-20211207102915-qorhbbm.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>02_postman</category>
        <category>999_postman文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>postman基本操作</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/02_postman%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>一、基础知识</strong></p>
<p>　　 <strong>1.HTTP的五种请求方法</strong> ：GET， POST ，HEAD，OPTIONS， PUT， DELETE， TRACE 和 CONNECT 方法。</p>
<p>　　　　 <strong>GET请求</strong> ：请求指定的页面信息，并返回实体主体。（通常用来接收数据）。</p>
<p>　　　　 <strong>POST请求</strong> ：向指定资源提交数据进行处理请求，数据被包含在请求体中。POST请求可能会导致新的资源的建立、已有资源的修改。（通常用来发送数据）。</p>
<p>　　　　 <strong>HEAD请求</strong> ：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</p>
<p>　　　　 <strong>PUT请求</strong> ：从客户端向服务器传送的数据取代指定的文档的内容。</p>
<p>　　　　 <strong>DELETE请求</strong> ：请求服务器删除指定的页面。</p>
<p>　　　　 <strong>CONNECT请求</strong> ：能够将连接改为管道方式的代理服务器。</p>
<p>　　　　 <strong>OPTIONS请求</strong> ：允许客户端查看服务器的性能。</p>
<p>　　　　 <strong>TRACE请求</strong> ：显示服务器收到的请求，主要用于测试或诊断。</p>
<p>　　 <strong>2.接口调用传参方式</strong> ：key-value参数形式，Json串传参形式。</p>
<p>　　　　key-value参数：把参数拼接在url的后面由?相连，多个参数之间用&amp;相连。</p>
<p>　　　　Json串传参：需要在请求的body写中，入Json格式参数。</p>
<p><strong>二、接口文档</strong></p>
<p>**　1.GET请求接口文档**</p>
<p>　　功能说明：用户注册</p>
<p>　　请求URL： <a href="http://demo/web-member/auth/memberRegisteredByMobile">http://demo/web-member/auth/memberRegisteredByMobile</a></p>
<p>　　请求方式：GET</p>
<p>　　参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>必选</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>mobile</td>
<td>是</td>
<td>string</td>
<td>手机号</td>
</tr>
<tr>
<td>sign</td>
<td>是</td>
<td>int</td>
<td>(0:注册发送，1，忘记密码发送)</td>
</tr>
</tbody></table>
<p>　　</p>
<p>　　</p>
<p>　　返回示例：</p>
<p>　　　　无</p>
<p>　　返回参数说明：　</p>
<table>
<thead>
<tr>
<th>数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>status</td>
<td>string</td>
<td>注册发送是否成功</td>
</tr>
<tr>
<td>message</td>
<td>string</td>
<td>注册发送详细信息</td>
</tr>
</tbody></table>
<p>　</p>
<p>　</p>
<p>　　</p>
<p><strong>2.POST请求接口文档</strong></p>
<p>　　功能说明：用户登录</p>
<p>　　请求URL： <a href="http://demo/web-member/auth/memberLogin">http://demo/web-member/auth/memberLogin</a></p>
<p>　　请求方式：POST</p>
<p>　　参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>必选</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>username</td>
<td>是</td>
<td>string</td>
<td>用户名（邮箱或电话号）</td>
</tr>
<tr>
<td>password</td>
<td>是</td>
<td>string</td>
<td>密码</td>
</tr>
<tr>
<td>deviceType</td>
<td>是</td>
<td>string</td>
<td>“ios”“android”</td>
</tr>
</tbody></table>
<p>　　返回示例：</p>
<p>　　无</p>
<p>　　返回参数说明：　　</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>status</td>
<td>string</td>
<td>操作状态</td>
</tr>
<tr>
<td>result</td>
<td>string</td>
<td>返回token</td>
</tr>
</tbody></table>
<p><strong>三、Postman接口操作</strong></p>
<p>**　　1.GET请求操作：**</p>
<p><img src="/assets/1/image-20211207104548-ek5h868.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207104552-pq7zfmx.png" alt="image.png"></p>
<p>**　　2.GET请求操作结果：**</p>
<p><img src="/assets/1/image-20211207104558-gv3jxtd.png" alt="image.png"></p>
<p>　　<strong>3.POST请求操作：</strong></p>
<p><img src="/assets/1/image-20211207104603-u69scza.png" alt="image.png"></p>
<p>　**　4.POST请求操作结果：**</p>
<p><img src="/assets/1/image-20211207104607-1qldld3.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>02_postman</category>
        <category>999_postman文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman实现接口请求</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/03_Postman%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p><strong>课程实例使用的url地址汇总：</strong></p>
<p>**开源接口部分： **<a href="https://api.apiopen.top/api.html"><strong>https://api.apiopen.top/api.html</strong></a></p>
<p>**1、获取时间get接口   **<a href="http://poetry.apiopen.top/getTime">http://poetry.apiopen.top/getTime</a></p>
<p>**2、网易新闻post接口 **<a href="https://api.apiopen.top/getWangYiNews">https://api.apiopen.top/getWangYiNews</a></p>
<p>**3、百度ip接口   **<a href="https://sp1.baidu.com/8aQDcjqpAAV3otqbppnN2DJv/api.php?query=12.12.12.12&co=&resource_id=5809&t=1636461955537&ie=utf8&oe=gbk&cb=op_aladdin_callback&format=json&tn=baidu&cb=jQuery110206769724197850711_1636461449011&_=1636461449013">https://sp1.baidu.com/8aQDcjqpAAV3otqbppnN2DJv/api.php?query=12.12.12.12&co=&resource_id&#x3D;5809&amp;t&#x3D;1636461955537&amp;ie&#x3D;utf8&amp;oe&#x3D;gbk&amp;cb&#x3D;op_aladdin_callback&amp;format&#x3D;json&amp;tn&#x3D;baidu&amp;cb&#x3D;jQuery110206769724197850711_1636461449011&amp;_&#x3D;1636461449013</a></p>
<p> <strong>电商项目部分： 电商网站：</strong> <a href="http://www.testingedu.com.cn:8000/">http://www.testingedu.com.cn:8000/</a></p>
<p><strong>4、电商登录接口：</strong><a href="http://www.testingedu.com.cn:8000/index.php?m=Home&c=User&a=do_login&t=0.9806405470978172">http://www.testingedu.com.cn:8000/index.php?m=Home&c=User&a=do_login&amp;t&#x3D;0.9806405470978172</a></p>
<p><strong>5、文件上传接口 ：</strong><a href="http://www.testingedu.com.cn:8000/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html">http://www.testingedu.com.cn:8000/index.php/home/Uploadify/imageUp/savepath/head_pic&#x2F;pictitle&#x2F;banner&#x2F;dir&#x2F;images.html</a></p>
<p> <strong>自动化平台项目：平台网站：</strong> <a href="http://39.108.55.18/mypro/#/login"><strong>http://39.108.55.18/mypro/#/login</strong></a></p>
<p><strong>6、平台登录接口：</strong><a href="http://39.108.55.18/mypro/api/user/login">http://39.108.55.18/mypro/api/user/login</a></p>
<p> <strong>Token接口项目：Token项目网站：</strong> <a href="http://www.testingedu.com.cn:8081/inter/"><strong>http://www.testingedu.com.cn:8081/inter/</strong></a></p>
<p><strong>7、Token项目 SOAP接口：</strong><a href="http://www.testingedu.com.cn:8081/inter/SOAP?wsdl">http://www.testingedu.com.cn:8081/inter/SOAP?wsdl</a></p>
<h3 id="1、-Postman-安装之后，-可以进行一下更新。"><a href="#1、-Postman-安装之后，-可以进行一下更新。" class="headerlink" title="1、 Postman 安装之后， 可以进行一下更新。"></a>1、 Postman 安装之后， 可以进行一下更新。</h3><p><strong>使用的时候最好可以注册一个账号。</strong></p>
<p><strong>先创建一个workspace，用于管理接下来使用过程中产生的内容。</strong></p>
<h3 id="2、接口测试的基本流程：-本质就是抄。"><a href="#2、接口测试的基本流程：-本质就是抄。" class="headerlink" title="2、接口测试的基本流程： 本质就是抄。"></a>2、接口测试的基本流程： 本质就是抄。</h3><p><strong>1、了解接口信息 ： 由开发提供接口文档，   或者通过抓包来获取接口报文信息。</strong></p>
<p><strong>2、 设计测试用例</strong></p>
<p><strong>3、 执行测试用例： 用postman等工具执行。 请求发包。</strong></p>
<p><strong>4、验证返回结果。</strong></p>
<h3 id="3、-HTTP协议接口报文：-理解成寄快递。"><a href="#3、-HTTP协议接口报文：-理解成寄快递。" class="headerlink" title="3、 HTTP协议接口报文：  理解成寄快递。"></a>3、 HTTP协议接口报文：  理解成寄快递。</h3><p><strong>接口报文分为请求和返回，格式其实是相同的。</strong></p>
<p><strong>请求</strong></p>
<p>**请求四要素： ** http方法 、url地址、请求头 、请求体。</p>
<p><strong>请求行</strong>： http方法（邮寄方式）  url（地址）   http协议版本</p>
<p><strong>请求头</strong>： 键值对格式 ，键：值  用换行分割的方式。 （快递单）</p>
<p><strong>除了特殊指定的要填的请求头以外，注意  post请求 需要关注content-Type请求头，表示的是请求体的编辑格式。（快递的运输方式 常温&#x2F;冷冻）</strong></p>
<p><strong>常见的content-Type类型：</strong></p>
<p><strong>application&#x2F;x-www-form-urlencoded: url编码格式： 键&#x3D;值&amp;键&#x3D;值</strong></p>
<p><strong>application&#x2F;json:    json格式字符串：  {“键”:值,”键”:值}</strong></p>
<p><strong>postman选 raw格式之后，下拉栏选择json</strong></p>
<p><strong>注意：复制json格式的请求体的时候，如果从浏览器开发者工具中复制，记得确认键必须带双引号。最好view source 之后再复制。</strong></p>
<p><strong>multipart&#x2F;form-data： 用于进行文本和文件的混合传递。 完成文件上传。</strong></p>
<p><strong>选择posmtna中的 form-data进行参数填写。</strong></p>
<p><strong>注意： Name空格中，可以选择下拉 file或者text。</strong></p>
<p><strong>文件用file上传，文本用text上传。</strong></p>
<p><strong>text&#x2F;xml: 用xml格式来进行传递。  &lt;键&gt;值&lt;&#x2F;键&gt;</strong></p>
<p><strong>选择 body中的 raw格式 ，下拉栏用xml进行填写：</strong></p>
<p><strong>注意：content-type postman会默认使用 application&#x2F;xml，需要自己确认，到底是text&#x2F;xml还是application&#x2F;xml，如果不对，进行修改，最后是直接去掉原有的，加一个新的content-type头。</strong></p>
<p><strong>请求体</strong> ： 请求头之后空一行  ，之后的就是请求体。   （寄的东西）</p>
<p><strong>返回</strong></p>
<p><strong>返回行</strong>：http协议版本  HTTP状态码（物流状态） 状态码描述</p>
<p><strong>返回头</strong>： 键值对格式 ，键：值  用换行分割的方式。 （快递单）</p>
<p><strong>返回体</strong> ：返回头之后空一行，就是返回体 （对方寄回的东西）</p>
<p><strong>返回：重点验证返回体。</strong></p>
<h3 id="4、http协议抓包："><a href="#4、http协议抓包：" class="headerlink" title="4、http协议抓包："></a>4、http协议抓包：</h3><p><strong>使用浏览器开发者工具抓包：</strong></p>
<p><strong>在网页上右键检查，或者按下F12，打开开发者工具，切换到network 界面。</strong></p>
<p><strong>注意：记得勾选 preserve log。</strong></p>
<p><strong>请求体中：request payload （json格式、xml格式和普通文本）  和form data （文件和x-www-form-urlencoded格式）</strong></p>
<p><strong>使用 fiddler &#x2F;charles 等http抓包工具抓包：</strong></p>
<p><strong>在fiddler菜单右侧，用inspector 选项进行查看，选raw（原始）格式能够直观看到报文格式。</strong></p>
<h3 id="5、用postman发送报文请求："><a href="#5、用postman发送报文请求：" class="headerlink" title="5、用postman发送报文请求："></a>5、用postman发送报文请求：</h3><p><strong>1、http 方法 和 url 进行填写。  注意 url中最后带上的空格也会有影响，所以千万注意。</strong></p>
<p><strong>2、请求头一般先不做过多关注，先用默认的，除非有明确的说明需要设置某个请求头。</strong></p>
<p><strong>3、请求体在postman 请求栏的body中进行设置。选择相应的content-type格式进行编辑，可以自动设置，不用自己设置 请求头中的 content-type。</strong></p>
<h3 id="6、unicode编码：-u-4位16进制数，用于表示某个特殊的字符。"><a href="#6、unicode编码：-u-4位16进制数，用于表示某个特殊的字符。" class="headerlink" title="6、unicode编码： \u 4位16进制数，用于表示某个特殊的字符。"></a>6、unicode编码： \u 4位16进制数，用于表示某个特殊的字符。</h3><p>**例如：\u7f8e\u56fd\u963f\u62c9\u65af\u52a0 **</p>
<h3 id="7、get和post的核心区别："><a href="#7、get和post的核心区别：" class="headerlink" title="7、get和post的核心区别："></a>7、get和post的核心区别：</h3><p>**get方法，通常不带请求体。 **</p>
<p><strong>而post方法可以携带请求体。</strong></p>
<h2 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h2><p><strong>作业提交到吴老师的qq邮箱：<a href="mailto:&#x36;&#51;&#x35;&#x39;&#x39;&#x37;&#55;&#x39;&#x33;&#64;&#x71;&#x71;&#46;&#99;&#111;&#109;">&#x36;&#51;&#x35;&#x39;&#x39;&#x37;&#55;&#x39;&#x33;&#64;&#x71;&#x71;&#46;&#99;&#111;&#109;</a>。</strong></p>
<p><strong>1、要完成文件上传请求，应该使用的content-type为？</strong></p>
<p><strong>A</strong>、<strong>application&#x2F;x-www-form-urlencoded</strong></p>
<p><strong>B</strong>、<strong>application&#x2F;json</strong></p>
<p><strong>C</strong>、<strong>multipart&#x2F;form-data</strong></p>
<p><strong>D、text&#x2F;xml</strong></p>
<p><strong>2、HTTP协议中，请求和返回报文的主体构成部分为哪几部分？</strong></p>
<p><strong>3、完成课上演示案例的Postman请求</strong></p>
<p><strong>4、在</strong><a href="https://api.apiopen.top/api.html">https://api.apiopen.top/api.html</a>网站中选择几个接口完成请求</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>02_postman</category>
        <category>999_postman文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman项目实战</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/04_Postman%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="1、postman从接口调试到自动化测试："><a href="#1、postman从接口调试到自动化测试：" class="headerlink" title="1、postman从接口调试到自动化测试："></a>1、postman从接口调试到自动化测试：</h3><p><strong>1、自动判断执行是否成功。  -通过代码 来进行结果的断言。</strong></p>
<p><strong>2、多个接口如何批量运行。  -通过 postman的 collection 进行运行。</strong></p>
<p><strong>3、测试数据管理方式</strong></p>
<p><strong>4、工作中如何定时执行或者将自动化测试结合到研发体系中。</strong></p>
<h3 id="2、Postman断言："><a href="#2、Postman断言：" class="headerlink" title="2、Postman断言："></a>2、Postman断言：</h3><p><strong>1、想清楚断言的标准是什么，断言的对象是什么。</strong></p>
<p><strong>断言什么？  返回内容</strong></p>
<p>**返回行： 状态码  **</p>
<p><strong>返回头： 可以携带某些信息    一般很少关注。</strong></p>
<p>**返回体：  验证重点是返回体。  **</p>
<p><strong>2、postman 里 怎么完成断言：</strong></p>
<p><strong>tests菜单（其实是执行请求之后，得到返回了再执行的内容）中，编写断言脚本。</strong></p>
<p><img src="/assets/1/2.jpg"></p>
<p>**1、在tests编辑中，用&#x2F;&#x2F;表示注释，是不执行的代码，说明文字。 **</p>
<p><strong>可以用 ctrl+&#x2F; 快速注释一行。</strong></p>
<p><strong>2、常用的断言模板：</strong></p>
<p><strong>Status Code：Code is 200  		断言返回状态码是200</strong></p>
<p><strong>Response Body:Contains string	断言返回体包含某个字符串</strong></p>
<p><strong>Response Headers:Content-Type header check    断言返回体中的头域信息</strong></p>
<pre><code>// 判断返回的状态码是否为200的测试
pm.test(&quot;返回的状态码是否为200&quot;, function () &#123;
    // function中的内容是真正执行的判断操作。
    pm.response.to.have.status(200);
&#125;);
// 判断返回头中的内容。
pm.test(&quot;返回头有内容&quot;, function () &#123;
    pm.response.to.have.header(&quot;Access-Control-Allow-Metho&quot;);
&#125;);
// 表示判断返回体包含一个字符串
pm.test(&quot;返回体中包含成功&quot;, function () &#123;
    //返回中的文本内容
    pm.expect(pm.response.text()).to.include(&quot;成功&quot;);
&#125;);
</code></pre>
<p><strong>最常用的：</strong></p>
<p><strong>Response Body:JSON value check  断言返回结果json中的字段值</strong></p>
<pre><code>// 判断返回体和指定内容完全相等。
//注意：使用body的时候，获取到的是原始格式字符串的内容，中文等特殊字符以unicode编码呈现，所以断言的预期结果中，也要写unicode编码，记得用\\u来转义\u，否则postman依然会认为这是中文。
pm.test(&quot;返回内容是正确的&quot;, function () &#123;
    pm.response.to.have.body(&#39;&#123;&quot;code&quot;: 1000, &quot;msg&quot;: &quot;\\u606d\\u559c\\u60a8\\u767b\\u5f55\\u6210\\u529f&quot;, &quot;data&quot;: [&#123;&quot;id&quot;: 12, &quot;username&quot;: &quot;roy&quot;, &quot;pwd&quot;: &quot;******&quot;, &quot;nickname&quot;: &quot;roy\\u8001\\u5e08&quot;, &quot;gender&quot;: &quot;\\u7537&quot;, &quot;dept&quot;: &quot;\\u6d4b\\u8bd5\\u90e8\\u95e8&quot;, &quot;position&quot;: &quot;\\u81ea\\u52a8\\u5316\\u6d4b\\u8bd5&quot;&#125;]&#125;&#39;);
&#125;);

//验证code结果为1000
pm.test(&quot;code结果为1000&quot;, function () &#123;
    //将返回结果转为json格式，赋值给变量（variable） jsonData 
    var jsonData = pm.response.json();
    // eql是equal 相等
    //jsonData.msg表示 在json根层级中，获取msg键的内容
    //1000是个数字，所以直接写。
    pm.expect(jsonData.code).to.eql(1000);
&#125;);

//验证msg结果为登录成功
pm.test(&quot;msg结果为登录成功&quot;, function () &#123;
    //将返回结果转为json格式，赋值给变量（variable） jsonData 
    var jsonData = pm.response.json();
    // eql是equal 相等
    //jsonData.msg表示 在json根层级中，获取msg键的内容
    //恭喜您登录成功是个字符串，所以用&quot;&quot;引起来
    pm.expect(jsonData.msg).to.eql(&quot;恭喜您登录成功&quot;);
&#125;);


//验证nickname是roy老师
pm.test(&quot;nickname是roy老师&quot;, function () &#123;
    var jsonData = pm.response.json();
    //将字符串进行拼接，输出到console控制台。
    console.log(&quot;data值的是：&quot;+jsonData.data)
    console.log(jsonData.data)
    console.log(&quot;data中的第一个值是：&quot;+jsonData.data[0])
    console.log(jsonData.data[0])
    console.log(&quot;data中的第一个值的nickname的值是&quot;+jsonData.data[0].nickname)
    pm.expect(jsonData.data[0].nickname).to.eql(&quot;roy老师&quot;);
&#125;);
</code></pre>
<h3 id="3、json格式：是js中用于描述对象的语言。"><a href="#3、json格式：是js中用于描述对象的语言。" class="headerlink" title="3、json格式：是js中用于描述对象的语言。"></a>3、json格式：是js中用于描述对象的语言。</h3><p><strong>有标准的格式规范：</strong>{“键”:值,”键”:值}</p>
<p><strong>json中的值的可选项是：</strong></p>
<ul>
<li><strong>数字或者布尔数true&#x2F;false： 不用带双引号</strong></li>
<li><strong>字符串：		“内容”  要被双引号括起来。</strong></li>
<li><strong>数组： 		[值，值，值]：比如：[1,2,3]  或者 [“roy”,”will”]</strong></li>
<li><strong>json子串：	{“键”:值,”键”:值}</strong></li>
</ul>
<p><strong>js中json解析核心语法符号：</strong></p>
<p><strong>.号</strong> ：表示往下进行一层选取。</p>
<p><strong>[]</strong>: 	[“键”]表示取某个键的值</p>
<p>** [数字]表示取数组中的对应下标的值**</p>
<p><strong>js里面可以用两种方式来解析json中某个键的值：</strong></p>
<p><strong>jsonData.键： 获取json根层级下的某个键的值。</strong></p>
<p><strong>jsonData[“键”]：如果键中有一些特殊字符的时候用这种方式</strong></p>
<p><strong>如果要解析数组中的第n个值：  注意编程语言中，下标从0开始计数。</strong></p>
<p><strong>jsonData.数组键[n-1]</strong></p>
<p><strong>例如：jsonData.data[0]</strong></p>
<p><strong>如果要解析一个子json中的键：</strong></p>
<p><strong>jsonData.子json键.键名</strong></p>
<p><strong>例如：jsonData.data[0].nickname</strong></p>
<h3 id="4、正则表达式解析：-通过某种规则，从字符串中获取对应的内容。"><a href="#4、正则表达式解析：-通过某种规则，从字符串中获取对应的内容。" class="headerlink" title="4、正则表达式解析： 通过某种规则，从字符串中获取对应的内容。"></a>4、正则表达式解析： 通过某种规则，从字符串中获取对应的内容。</h3><p><strong>js中的正则表达式写法是  ： &#x2F;正则表达式&#x2F;  用&#x2F;&#x2F;把正则表达式括起来。</strong></p>
<p><strong>例子：</strong></p>
<pre><code>//首先提取出来json内容
//编写正则表达式
//&lt;return&gt;(.*?)&lt;\/return&gt;  其中\/表示用\对/进行转义操作
//(.*?) 表示要获取的内容。
var regex=/&lt;return&gt;(.*?)&lt;\/return&gt;/
//用正则表达式获取返回结果中的内容
var result= regex.exec(pm.response.text())
//匹配出来包含两部分，一部分是有(.*?)以外的规则的内容
//另一部分是只有(.*?)的内容,注意这是字符串，不是json
console.log(result[1])
//将普通字符串，处理为json格式。
var jsonData=JSON.parse(result[1]);
//断言的时候要用的，是已经经过层层解析的jsonData
console.log(jsonData)

pm.test(&quot;返回结果msg是success&quot;, function () &#123;
    pm.expect(jsonData.msg).to.eql(&quot;success&quot;);
&#125;);
</code></pre>
<h3 id="5、postman中进行调试："><a href="#5、postman中进行调试：" class="headerlink" title="5、postman中进行调试："></a>5、postman中进行调试：</h3><p><strong>console.log（内容）可以将指定内容输出到console控制台。</strong></p>
<p><strong>console控制台在postman的左下角。</strong></p>
<p>**同时console中可以看到postman发出去请求的具体信息，相当于给发包过程抓了个包。  **</p>
<h3 id="6、postman-测试集collection-运行："><a href="#6、postman-测试集collection-运行：" class="headerlink" title="6、postman 测试集collection 运行："></a>6、postman 测试集collection 运行：</h3><p><strong>记得勾上 save responses ，方便查看运行的返回结果具体状态。</strong></p>
<h3 id="7、保持登录状态，进行接口的测试："><a href="#7、保持登录状态，进行接口的测试：" class="headerlink" title="7、保持登录状态，进行接口的测试："></a>7、保持登录状态，进行接口的测试：</h3><p><strong>项目中进行登录鉴权的机制：</strong></p>
<p><strong>1、cookie机制</strong></p>
<p><strong>Cookie 用于服务器对用户的状态进行记录。</strong></p>
<p>**cookie 和session ：  **</p>
<p><strong>cookie和session 都是由服务器生成的。</strong></p>
<p><strong>session（酒店入住记录）保留在服务器上，cookie（房卡）会由服务器通过返回头中的Set-Cookie返回给客户端，由客户端保存在本地。</strong></p>
<p><strong>下次进行请求的时候，客户端在请求头中通过Cookie头携带cookie去请求服务器的接口。</strong></p>
<p><strong>cookie机制保持登录状态，核心是带上cookie：</strong></p>
<p><strong>1、尝试带上已有的cookie来进行访问（把别人的房卡直接拿来用），不一定靠谱</strong></p>
<p><strong>postman中添加头域，直接在Headers中填写键值对即可。</strong></p>
<p><strong>2、借助postman自动保存cookie的机制，先去登录（自己办一张房卡），然后请求其它接口（拿自己的房卡去房间）</strong></p>
<p><strong>postman要做的事情就是，</strong></p>
<p><strong>1、先调用一下登录接口，让postman自动保存cookie</strong></p>
<p><strong>2、然后再调用其它接口。</strong></p>
<p><img src="/assets/1/image-20220324173242-h2j4mkh.png" alt="image.png"></p>
<p><strong>注意postman中cookie的管理在这里。</strong></p>
<p><strong>如果使用的是cookie机制，用postman会自动保存各种网站的cookie，和浏览器一样。</strong></p>
<p><strong>调用一下登录接口之后，就不需要额外操作就可以请求登录后的接口</strong></p>
<p><strong>2、token机制</strong></p>
<h3 id="8、postman中的环境变量-x2F-全局变量。"><a href="#8、postman中的环境变量-x2F-全局变量。" class="headerlink" title="8、postman中的环境变量&#x2F;全局变量。"></a>8、postman中的环境变量&#x2F;全局变量。</h3><p>**变量就类似于在手机通讯类 为电话号码建立一个联系人。  **</p>
<p><strong>1、方便于进行修改</strong></p>
<p><strong>2、重复使用的时候，可以更简略。</strong></p>
<p><strong>3、方便别人进行使用  参数关联。</strong></p>
<p><strong>环境变量是创建一组变量进行分组，可以有选择性地使用。</strong></p>
<p><strong>全局变量是大家都可以用的变量。</strong></p>
<p><strong>Postman中使用环境变量：</strong></p>
<p><strong>创建环境变量组：相当于创建一个通讯录。</strong></p>
<p><strong>创建一个变量：相当于加个联系人。</strong></p>
<p><img src="/assets/1/image-20220324173251-hewimyl.png" alt="image.png"></p>
<p><strong>使用变量：</strong></p>
<p><strong>选择环境变量组之后，在请求中，可以用</strong><strong>来使用组中的环境变量。</strong></p>
<p><img src="/assets/1/image-20220324173257-u4s7d2y.png" alt="image.png"></p>
<h3 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h3><p><strong>1、cookie和session机制中，以下描述正确的是：</strong></p>
<p><strong>A、cookie由客户端生成、session由服务端生成</strong></p>
<p><strong>B、cookie由服务端生成，发送给客户端保存在本地</strong></p>
<p><strong>C、cookie和session都保存在服务器端</strong></p>
<p><strong>D、session由服务端生成，并发给客户端保存在本地</strong></p>
<p><strong>2、json格式中，值的类型需要带双引号的是：</strong></p>
<p><strong>A、子Json</strong></p>
<p><strong>B、数字</strong></p>
<p><strong>C、数组</strong></p>
<p><strong>D、字符串</strong></p>
<p><strong>3、在postman中，可以在_______中查看脚本输出调试信息，以及查看postman请求的实际详情。</strong></p>
<p><strong>4、postman中，如何创建并在请求中使用环境变量？</strong></p>
<p><strong>5、实操题： 1、为百度ip接口编写断言，实现location字段的校验。</strong></p>
<p><strong>2、对自动化测试平台中的部分接口抓包进行测试，并用测试集运行。</strong></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>02_postman</category>
        <category>999_postman文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>postman-断言变量</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/06_postman-%E6%96%AD%E8%A8%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="一-基本操作"><a href="#一-基本操作" class="headerlink" title="一.基本操作"></a>一.基本操作</h2><h3 id="1、postman-gt-gt-Tests-中常用的断言"><a href="#1、postman-gt-gt-Tests-中常用的断言" class="headerlink" title="1、postman &gt;&gt; Tests 中常用的断言"></a>1、postman &gt;&gt; Tests 中常用的断言</h3><p>　　<img src="/assets/1/image-20211207103248-id024s7.png" alt="image.png"></p>
<ul>
<li><p>Get an environment variable</p>
</li>
<li><p>Get a global variable</p>
<ul>
<li>获取一个全局变量</li>
</ul>
</li>
<li><p>Get a variable</p>
<ul>
<li>获取一个变量</li>
</ul>
</li>
<li><p>Set an environment variable</p>
<ul>
<li>赋值给设置好的环境变量</li>
</ul>
</li>
<li><p>Seta global variable</p>
</li>
<li><p>Clear an environment variable</p>
<ul>
<li>删掉一个环境变量</li>
</ul>
</li>
<li><p>Clear a global variable</p>
<ul>
<li>删除一个全局变量</li>
</ul>
</li>
<li><p>Send a request</p>
</li>
<li><p>Status code: Code is 200</p>
<ul>
<li>校验状态码 Code 是否是 200</li>
</ul>
</li>
<li><p>Response body: Contains string</p>
<ul>
<li>响应体中包含了某个字符串</li>
</ul>
</li>
<li><p>Response body: JSON value check</p>
<ul>
<li>获取响应的结果</li>
</ul>
</li>
<li><p>Response body: Is equal to a string</p>
<ul>
<li>响应的结果是否和期望的结果一致，完全相等</li>
</ul>
</li>
<li><p>Response headers: Content- Type header check</p>
</li>
<li><p>Response time is less than 200ms</p>
</li>
<li><p>Status code: Successful POST request</p>
</li>
<li><p>Status code: Code name has string</p>
</li>
<li><p>Response body: Convert XML body to a JSON Object</p>
<ul>
<li>将响应的数据从 XML 格式转换成 JSON 的对象</li>
</ul>
</li>
<li><p>use Tiny Validator for jSON data</p>
</li>
</ul>
<h3 id="2-postman中设置中的意思"><a href="#2-postman中设置中的意思" class="headerlink" title="2.postman中设置中的意思"></a>2.postman中设置中的意思</h3><p>　　<img src="/assets/1/image-20211207103254-vsbm70i.png" alt="image.png"></p>
<ul>
<li><p>Globals：全局变量</p>
<ul>
<li>提取cookies, seesion， token用于下个接口</li>
</ul>
</li>
<li><p>Add：环境变量&#x3D;局部变量</p>
<ul>
<li>设置ip地址、手机号等</li>
</ul>
</li>
</ul>
<h3 id="二、常用的几个结果判断"><a href="#二、常用的几个结果判断" class="headerlink" title="二、常用的几个结果判断"></a>二、常用的几个结果判断</h3><p>APP登录操作字段验证</p>
<p><img src="/assets/1/image-20211207103258-ucirpiz.png" alt="image.png"></p>
<p>APP的关联处理，获取 token</p>
<p><img src="/assets/1/image-20211207103302-h9pzjf5.png" alt="image.png"></p>
<p>APP的环境变量配置和执行结果：执行时会自动填入token值</p>
<p><img src="/assets/1/image-20211207103308-79c6r72.png" alt="image.png"></p>
<p> 断言结果</p>
<p><img src="/assets/1/image-20211207103312-k96syih.png" alt="image.png"></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<ul>
<li><p>在 Test Results（测试的断言结果）</p>
<ul>
<li>All：所有的测试结果</li>
<li>Passed：运行通过</li>
<li>Skipped：跳过</li>
<li>Failed：失败</li>
</ul>
</li>
<li><p>名词解释：</p>
<ul>
<li><p>　postman断言是JavaScript语言编写的，在postman客户端的test区域编写即可，断言会在请求返回之后，运行，并根据断言的pass\fail情况体现在最终测试结果中。</p>
<p>具体断言如下所示：</p>
<p><strong>1.设置环境变量–Setting an environment variable</strong></p>
<p>　　postman.setEnvironmentVariable(“key”, “value”);</p>
<p><strong>2.设置全局变量–Set a global variable</strong></p>
<p>　　postman.setGlobalVariable(“key”, “value”);</p>
<p><strong>3.检查响应中包含string–Check if response body contains a string</strong></p>
<p>　　tests[“Body matches string”] &#x3D; responseBody.has(“string_you_want_to_search”);</p>
<p><strong>4.转化XML格式的响应成JSON对象—Convert XML body to a JSON object</strong></p>
<p>　　var jsonObject &#x3D; xml2Json(responseBody);</p>
<p><strong>5.检查响应body中等于指定string–Check if response body is equal to a string</strong></p>
<p>　　tests[“Body is correct”] &#x3D; responseBody &#x3D;&#x3D;&#x3D; “response_body_string”;</p>
<p><strong>6.检查JSON某字段值–Check for a JSON value</strong></p>
<p>　　var data &#x3D; JSON.parse(responseBody);</p>
<p>　　tests[“Your test name”] &#x3D; data.value &#x3D;&#x3D;&#x3D; 100;</p>
<p><strong>7.检查Content-Type是否包含在header返回（大小写不敏感） –Content-Type is</strong></p>
<p>　　present (Case-insensitive checking)</p>
<p>　　tests[“Content-Type is present”] &#x3D; postman.getResponseHeader(“Content-Type”);</p>
<p>　　&#x2F;&#x2F;Note: the getResponseHeader() method returns the header value, if it exists.</p>
<p><strong>8.检查Content-Type是否包含在header返回（大小写敏感） –Content-Type is</strong></p>
<p>　　present (Case-sensitive)</p>
<p>　　tests[“Content-Type is present”] &#x3D; responseHeaders.hasOwnProperty(“ContentType”);</p>
<p><strong>9.检查请求耗时时间小于200ms–Response time is less than 200ms</strong></p>
<p>　　tests[“Response time is less than 200ms”] &#x3D; responseTime &lt; 200;</p>
<p><strong>10.检查Status code为200–Status code is 200</strong></p>
<p>　　tests[“Status code is 200”] &#x3D; responseCode.code &#x3D;&#x3D;&#x3D; 200;</p>
<p><strong>11.检查Code name包含指定string–Code name contains a string</strong></p>
<p>　　tests[“Status code name has string”] &#x3D; responseCode.name.has(“Created”);</p>
<p><strong>12.检查成功post的请求status code–Succesful POST request status code</strong></p>
<p>　　tests[“Successful POST request”] &#x3D; responseCode.code &#x3D;&#x3D;&#x3D; 201 ||responseCode.code &#x3D;&#x3D;&#x3D; 202;</p>
</li>
</ul>
</li>
</ul>
<p>tests断言代码：</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code>// 响应状态码：Status code: Code is 200
pm.test(&quot;响应状态码是否为 200&quot;, function () &#123;
    pm.response.to.have.status(200);
&#125;);


// 响应体中是否包含某个字段：Response body: Contains string
pm.test(&quot;响应结果:登录成功&quot;, function () &#123;
    pm.expect(pm.response.text()).to.include(&quot;app登录成功&quot;);
&#125;);


// 获取返回结果转换为json格式数据，提取字段进行对比：Response body; JSON value check
pm.test(&quot;转换为json格式数据，验证返回结果中字段：&quot;, function () &#123;
    var jsonData = pm.response.json();
    pm.expect(jsonData.status).to.eql(1);
    pm.expect(jsonData.code).to.eql(&quot;1001&quot;);
    pm.expect(jsonData.data.mobilephone).to.eql(&quot;13264489754&quot;);
    pm.expect(jsonData.msg).to.eql(&quot;app登录成功&quot;);
&#125;);


// 关联处理：获取 token
// 1、从接口的响应结果中提取需要的数据
// Response body; JSON value check   获取响应的结果
// Set an environment variable       赋值给设置好的环境变量
// 2、右上角设置--添加环境变量/全局变量
// 3、写入到下个接口的请求数据中 &#123;&#123;user_token&#125;&#125; 来引用
pm.test(&quot;set_user_token&quot;, function () &#123;
    var jsonData = pm.response.json();
    pm.environment.set(&quot;user_token&quot;, jsonData.data.token);
&#125;);
</code></pre>
<p><a href="javascript:void(0);" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h2 id="三、关联处理，设置环境变量的两种方法"><a href="#三、关联处理，设置环境变量的两种方法" class="headerlink" title="三、关联处理，设置环境变量的两种方法"></a>三、关联处理，设置环境变量的两种方法</h2><p>1.为什么要设置环境变量</p>
<ul>
<li>设置环境变量：使上一个接口的返回数据要和下一个接口关联</li>
</ul>
<p>2.第一种：获取登录接口的cookies,，seesion，token，并设置为环境变量、全局变量</p>
<p>　　第一步：获取 token</p>
<p><a href="javascript:void(0);" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code>// 第一步：获取 token
//获取响应数据json对象
//把postman的json返回结果，赋值给到aaaa
//用 aaaa 这个变量来接受服务器的json返回结果

var aaaa = pm.response.json();

//从响应数据提取出token
//用bbbb 这个变量来接受json返回结果里面的token字段值

var bbbb = aaaa.token;
</code></pre>
<p><a href="javascript:void(0);" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>　　第二步：设置 token 为环境变量</p>
<pre><code>// 第二步：设置token 为环境变量
// 将token 的值bbbb 设置成环境变量，重新命名为cccc
//environment：环境变量

pm.environment.set(&quot;cccc&quot;, bbbb);
</code></pre>
<p>　　第二步：设置 token 为全局变量</p>
<pre><code>// 第二步：设置token 为全局变量
// 将token 的值bbbb 设置成全局变量，重新命名为dddd
// globals：全局变量
pm.globals.set(&quot;dddd&quot;, bbbb);
//把json的结果取出来，设置成环境变量，给到下一个接口使用
</code></pre>
<p>创建环境变量后自动记录 token 值</p>
<p><img src="/assets/1/image-20211207103319-ebg7xlw.png" alt="image.png"></p>
<h3 id="postman-中使用两个花括号-变量名-引用："><a href="#postman-中使用两个花括号-变量名-引用：" class="headerlink" title="postman 中使用两个花括号+变量名 引用："></a>postman 中使用两个花括号+变量名 引用：</h3><p><img src="/assets/1/image-20211207103323-4d0r2kg.png" alt="image.png"></p>
<p>3.第二种设置环境：</p>
<ul>
<li>1、从接口的响应结果当中提取需要的数据–postman如何提取</li>
<li>2、设置环境变量、全局变量</li>
<li>3、写入到下一个接口的请求与数据中</li>
</ul>
<p><a href="javascript:void(0);" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code>// 关联处理：获取 token
// 1、从接口的响应结果中提取需要的数据
// Response body; JSON value check   获取响应的结果
// Set an environment variable       赋值给设置好的环境变量
// 2、右上角设置--添加环境变量/全局变量
// 3、写入到下个接口的请求数据中 &#123;&#123;user_token&#125;&#125; 来引用

pm.test(&quot;set_user_token&quot;, function () &#123;
    var jsonData = pm.response.json();
    pm.environment.set(&quot;user_token&quot;, jsonData.data.token);
&#125;);
</code></pre>
<p><a href="javascript:void(0);" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>02_postman</category>
        <category>999_postman文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman数据驱动与持续集成</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/02_postman/999_postman%E6%96%87%E4%BB%B6/05_Postman%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h3 id="1、postman从接口调试到自动化测试："><a href="#1、postman从接口调试到自动化测试：" class="headerlink" title="1、postman从接口调试到自动化测试："></a>1、postman从接口调试到自动化测试：</h3><p><strong>1、自动判断执行是否成功。  -通过代码 来进行结果的断言。</strong></p>
<p><strong>2、多个接口如何批量运行。  -通过 postman的 collection 进行运行。</strong></p>
<p>**3、测试数据管理方式             -collection的run中提供了 用数据文件驱动的方式。  **</p>
<p><strong>postman支持的是 csv和json两种格式。  用csv可以用excel打开，方便管理。</strong></p>
<p><strong>4、工作中如何定时执行生成报告或者将自动化测试结合到研发体系中。  -通过命令行进行执行，加入持续集成的流程中。</strong></p>
<h3 id="2、url-中的参数："><a href="#2、url-中的参数：" class="headerlink" title="2、url 中的参数："></a>2、url 中的参数：</h3><p><strong>url的基本构成格式：</strong></p>
<p><strong>协议       域名（服务器地址:端口（默认http 端口80 https端口443可以省略）） &#x2F; 路径  ？ 键&#x3D;值&amp;键&#x3D;值</strong></p>
<p><a href="https://sp1.baidu.com/8aQDcjqpAAV3otqbppnN2DJv/api.php?query=12.12.12.12&co=&resource_id=5809&t=1636461955537&ie=utf8&oe=gbk&cb=op_aladdin_callback&format=json&tn=baidu&cb=jQuery110206769724197850711_1636461449011&_=1636461449013">https://sp1.baidu.com/8aQDcjqpAAV3otqbppnN2DJv/api.php?query=12.12.12.12&co=&resource_id&#x3D;5809&amp;t&#x3D;1636461955537&amp;ie&#x3D;utf8&amp;oe&#x3D;gbk&amp;cb&#x3D;op_aladdin_callback&amp;format&#x3D;json&amp;tn&#x3D;baidu&amp;cb&#x3D;jQuery110206769724197850711_1636461449011&amp;_&#x3D;1636461449013</a></p>
<p><strong>url中的参数，也叫做query Param查询参数。 postman和chrome开发者工具中，都用这个名字指代url中的参数。</strong></p>
<p><strong>get请求的参数，在url中填写设计。</strong></p>
<p><strong>post请求的参数，通常在对应的请求体里，有些post请求也有可能直接在url中带参数。</strong></p>
<h3 id="3、正则表达式的解析操作："><a href="#3、正则表达式的解析操作：" class="headerlink" title="3、正则表达式的解析操作："></a>3、正则表达式的解析操作：</h3><p><strong>&#x2F;<return>(.*?)&lt;/return&gt;&#x2F;</strong></p>
<p><strong>(.*?)  表示要获取的内容，可以是任意长度的文字。</strong></p>
<p><strong>语义符号：</strong></p>
<p><strong>()：表示将一系列字符组合起来作为一个整体</strong></p>
<p><strong>. :表示任意一个字符</strong></p>
<p>*<strong>：表示字符可以出现0-n次</strong></p>
<p>***?表示非贪婪匹配模式，匹配到第一个符合条件的位置，就停止匹配。**</p>
<p><strong>由于()是有特殊含义的，所以如果要表示一个普通的小括号字符，要进行转义，用\进行转义。</strong></p>
<h3 id="4、token（令牌，口令）机制鉴权："><a href="#4、token（令牌，口令）机制鉴权：" class="headerlink" title="4、token（令牌，口令）机制鉴权："></a>4、token（令牌，口令）机制鉴权：</h3><p><strong>为了减少服务器的存储session压力， 只存储校验规则。</strong></p>
<p><strong>token同样会由服务器发给客户端。   测试只需要关注从哪里可以拿到。  开发最清楚哪里拿token。</strong></p>
<p><strong>服务器返回token发送的位置可以在报文中可以携带内容的地方： 返回头 、返回体。</strong></p>
<p><strong>请求在携带token的时候： 也可以放在 请求头、请求体和请求url中。</strong></p>
<p>**具体一定找开发或者接口文档看清楚！  **</p>
<h3 id="5、变量的使用："><a href="#5、变量的使用：" class="headerlink" title="5、变量的使用："></a>5、变量的使用：</h3><p><strong>1、比如项目中多个接口都是同一个url，就可以使用变量，方便进行维护，减少输入字数。</strong></p>
<p><strong>2、项目中牵涉到参数的值传递，上一个接口拿到的结果，需要作为下一个接口的输入进行使用。</strong></p>
<p><strong>参数关联：</strong></p>
<p><strong>1、A接口获取结果，存到环境变量中</strong></p>
<p><strong>2、B接口使用环境变量。</strong></p>
<h3 id="6、-接口测试的时候要注意，接口文档也是测试对象的一部分。"><a href="#6、-接口测试的时候要注意，接口文档也是测试对象的一部分。" class="headerlink" title="6、 接口测试的时候要注意，接口文档也是测试对象的一部分。"></a>6、 接口测试的时候要注意，接口文档也是测试对象的一部分。</h3><h3 id="7、数据驱动"><a href="#7、数据驱动" class="headerlink" title="7、数据驱动"></a>7、数据驱动</h3><p>**postman中如果collection用数据驱动，已经修改了接口中原本的参数为环境变量调用，那么这个时候请求会把它当做一个普通字符串直接发送。  **</p>
<p>**1、创建excel文件，编写用例，保存为csv格式文件。 **</p>
<p><strong>2、使用的时候在collction里面 select file 选择csv文件，记得 preview。</strong></p>
<p>**3、接口中请求里面使用数据文件的内容就用 **</p>
<h3 id="8、命令行执行postman操作："><a href="#8、命令行执行postman操作：" class="headerlink" title="8、命令行执行postman操作："></a>8、命令行执行postman操作：</h3><p>**1、安装nodeJs 环境 ：  **<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p>
<p><strong>安装直接双击运行即可，安装完之后，检查一下 node环境变量。</strong></p>
<p><strong>打开cmd窗口， 运行 node -v 和 npm -v两个命令，分别你能查看到 node 和npm的版本信息即可。</strong></p>
<p><strong>2、使用npm安装newman工具，用于完成postman脚本的执行。</strong></p>
<p>**npm install newman -g  –registry **<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p>
<p><strong>使用淘宝的npm镜像下载newman工具。</strong></p>
<p>**检查newman的安装：  ** npm config ls   <strong>查看到prefix 目录，也就是npm安装内容的目录。 检查一下newman是不是已经装好了，并且将这个目录配置到环境变量PATH里，方便进行newman的使用。</strong></p>
<p><strong>最后cmd运行newman得到如下结果即安装成功：</strong></p>
<p><img src="/assets/1/image-20220324173410-0kvakk8.png" alt="image.png"></p>
<p><strong>3、通过newman执行postman的collection。</strong></p>
<p>**需要的内容：  环境变量 、 测试集collection 、测试数据csv等。 **</p>
<p><strong>需要在postman中导出 collection 和 环境变量 environments。   不仅可以用于newman执行，还可以进行导入，查看别人的测试集。</strong></p>
<p><strong>注意：在导出的时候，最好创建一个文件夹管理，不要用中文，同时，导出的文件最好也不要中文名。</strong></p>
<p><strong>执行方式 newman run xxxx.collection.json  -e xxxx.enviroments.json</strong></p>
<p><img src="/assets/1/image-20220324173415-kj253np.png" alt="image.png"></p>
<p><strong>4、newman生成 html测试报告：</strong></p>
<p><strong>1、通过以下命令先安装 newman的html报告插件。</strong></p>
<p><strong>npm install -g newman-reporter-html</strong></p>
<p><strong>2、使用的时候，先声明 -r参数带上html格式，然后使用 –reporter-html-export 参数指定html文件生成位置。</strong></p>
<p>**newman run Autoplat.postman_collection.json -e postmancampEnv.postman_environment.json **-r cli,html –reporter-html-export result.html</p>
<h3 id="9、Postman-monitor工具定时执行"><a href="#9、Postman-monitor工具定时执行" class="headerlink" title="9、Postman monitor工具定时执行"></a>9、Postman monitor工具定时执行</h3><p><strong>postman中的monitor可以创建监视器，用于定时执行某些collection。 可以在里面配置要执行的测试集，以及设置定时周期，同时可以发邮件给指定的邮箱。</strong></p>
<h3 id="10、jenkins持续集成：-将研发体系中所有的流程结合到一起，放在jenkins中完成。"><a href="#10、jenkins持续集成：-将研发体系中所有的流程结合到一起，放在jenkins中完成。" class="headerlink" title="10、jenkins持续集成： 将研发体系中所有的流程结合到一起，放在jenkins中完成。"></a>10、jenkins持续集成： 将研发体系中所有的流程结合到一起，放在jenkins中完成。</h3><p><strong>如果要将postman和jenkins结合起来，去找开发了解清楚，持续集成使用的构建任务，最后加一步执行自己的接口测试newman脚本就好了。</strong></p>
<h3 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h3><p><strong>1、实操实现token项目接口测试数据驱动，记得加上断言。</strong></p>
<p><strong>2、安装newman工具，使用newman通过命令行执行之前写好的collection测试集。</strong></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>02_postman</category>
        <category>999_postman文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter性能篇</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/19_jmeter%E6%80%A7%E8%83%BD%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter函数助手</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/11_jmeter%E5%87%BD%E6%95%B0%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<p> 在讲解函数助手之前，先讲解下jmeter的用户自定义变量</p>
<p> 用户自定义变量解决了那些问题？</p>
<p> 1.测试环境和线上环境切换，每次次都需要修改每个请求的IP地址</p>
<p> 2.请求的共用参数，每次只要修改一个地方，所有引用都被改变</p>
<p> 3.方便快捷，便于维护脚本</p>
<p> 废话不多话，下面步入正题</p>
<p> 如何添加自定义变量控件呢</p>
<p> 选中  线程组—配置元件—-用户自定义变量</p>
<p> <img src="/assets/1/image-20220326105124-7rgr85p.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220326105130-ujsj4py.png" alt="image.png"></p>
<p> 我们这里设置完了之后，我们怎么引用呢？</p>
<p> Jmeter的标准引用格式是：${IP}这种格式进行访问</p>
<p> <img src="/assets/1/image-20220326105140-vfl9a43.png" alt="image.png"></p>
<p> 接下来 咱们开始使用函数助手，重点即将开始—-点击选项—-选择 函数助手对话框</p>
<p> 文件参数化：</p>
<pre><code>                    1：函数助手

                    2：csv data set config
</code></pre>
<p> <img src="/assets/1/image-20220326105150-gafco24.png" alt="image.png"></p>
<p> 打开函数助手对话框，选择_CSVRead</p>
<p> <img src="/assets/1/image-20220326105158-04kx5nw.png" alt="image.png"></p>
<p> CSV file to get values from | * ,这个参数是 文件的路径，csv的文件分隔符是逗号，咱们使用txt文本进行逗号分隔也是可以使用的</p>
<p> CSV文件列号| next| *alias  见名知意    这里的主要意思，取列数，列入第一行是用户名，第二行是密码，一一对应</p>
<p> 注意：这里取值的时候  是从0进行开始取值，</p>
<p> <img src="/assets/1/image-20220326105211-xfyhoii.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220326105215-um5ggha.png" alt="image.png"></p>
<p> 生成之后，我们${__CSVRead(C:\Users\Administrator\Desktop\user.txt,0)}这行复制出来</p>
<p> 0代表取的文件第一列，1代表取的第二列</p>
<p> <img src="/assets/1/image-20220326105221-5me8p5z.png" alt="image.png"></p>
<p> 我们需要http请求的时候进行调用</p>
<p> 我们的参数，用户名使用${__CSVRead(C:\Users\Administrator\Desktop\user.txt,0)}</p>
<p> 密码使用。${__CSVRead(C:\Users\Administrator\Desktop\user.txt,1)}</p>
<p> <img src="/assets/1/image-20220326105229-xghzept.png" alt="image.png"></p>
<p> 然后我们设置完 就可以进行模仿不同用户进行登录</p>
<p> 我在这儿线程组，设置的为100，会一直循环进行模仿 这10个用户进行登录</p>
<p> <img src="/assets/1/image-20220326105239-wypbk2s.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220326105245-6o5iilg.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter接口自动化</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/13_Jmeter%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[<p> 目录   ：  来源：<a href="https://blog.csdn.net/weixin_46518133/article/details/121516830">(36条消息) Jmeter接口自动化_陈晴chenqing的博客-CSDN博客_jmeter自动化</a></p>
<p> 变更记录变更日期变更说明附件2021-02-26【TestReport名称优化】将html报告名称index.html 改为动态变化的（不然每次生成的报告Html报告都会把原有的报告覆盖）详细见【五-8】📎build.xml</p>
<p> 一、JMeter简介</p>
<p> 二、JMeter 基本使用</p>
<ol>
<li>启动Jmeter</li>
<li>设置为中文版(根据个人喜好)</li>
<li>配置元件-Http Cookie管理器</li>
</ol>
<p> 4.断言</p>
<p> 5.接口关联（Json提取器&amp;正则表达式提取器）</p>
<p> 6.Jmeter数据驱动</p>
<p> 7.JDBC Request</p>
<p> 8.函数助手</p>
<p> 9.BeanShell</p>
<p> 10.Jmeter事物&#x2F;模块控制器</p>
<p> 三、Ant简介</p>
<p> 四、Jenkins介绍及安装配置</p>
<p> 五、Jmeter自动化测试的配置</p>
<ol>
<li>原理</li>
<li>Jmeter.property配置</li>
<li>Ant配置</li>
<li>Jenkins 配置-相关插件安装</li>
<li>邮件通知配置</li>
<li>Ant build.xml 文件</li>
<li>运行-看结果</li>
<li>配置过程中遇到的问题总结</li>
<li>分享中提到的关于TestReport的名称优化</li>
</ol>
<blockquote>
<div class="table-box"><table id="f0sx4"><tbody><tr><td colspan="3"> <p id="cecccdb2ff1ee959ba8a5b48d7fb9a87"><strong>演示文档（2021-02-25）</strong></p> </td></tr><tr><td> <p id="40710764d5260149b37ef7014227487b">1</p> </td><td> <p id="d3ca34bca2b3d164fd4b2dd1c9747479"><a href="https://so.csdn.net/so/search?q=Jmeter&spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{"spm":"1001.2101.3001.7020","dest":"https://so.csdn.net/so/search?q=Jmeter&spm=1001.2101.3001.7020"}" data-tit="Jmeter" data-pretit="jmeter">Jmeter</a> 脚本</p> </td><td> <p id="8be3c97346a1e903bd4c391a60fd65ce"><a href="https://www.yuque.com/attachments/yuque/0/2021/jmx/136643/1614238704259-cb8bb684-4e14-4317-8337-a9edbfe9813e.jmx" id="WfbNf" title="📎testDemo.jmx">📎testDemo.jmx</a></p> </td></tr><tr><td> <p id="9f7af416c864fbbb76ef0f01e59c8949">2</p> </td><td> <p id="f625fa9f1b0d44a668793f59b9b879fd_p_0">build.xml 文件</p> </td><td> <p id="b6e722eb507baf32cac65fbe5e13b0b9"><a href="https://www.yuque.com/attachments/yuque/0/2021/xml/136643/1614238731270-c114447b-b516-4d8e-b028-210b75de56e2.xml" id="D7TVC" title="📎build.xml">📎build.xml</a></p> </td></tr><tr><td> <p id="a20d224c568e48b9d67847a2c66a8c01_p_0">3</p> </td><td> <p id="b5c06d45b8d476b78b70091a4b612fa8_p_0">PPT</p> </td><td> <p id="1e75db477fa0689b45d27536bb379750"><a href="https://www.yuque.com/attachments/yuque/0/2021/pptx/136643/1614238817575-7d736599-743a-4e13-87e7-7eb84c5d88cf.pptx" id="weRQJ" title="📎Jmeter+Ant+Jenkins接口自动化测试-20210225.pptx">📎Jmeter+Ant+Jenkins接口自动化测试-20210225.pptx</a></p> </td></tr><tr><td> <p id="u2692a67c">4</p> </td><td> <p id="28f0509faa924657fc4f6292ddb8463d_p_0">CSV文件</p> </td><td> <p id="u6b9a0b16"><a href="https://www.yuque.com/attachments/yuque/0/2021/csv/136643/1614238743200-e97b2b2c-1d22-490f-983b-1111b61db9be.csv" id="HsnWU" title="📎计数器演示.csv">📎计数器演示.csv</a><a href="https://www.yuque.com/attachments/yuque/0/2021/csv/136643/1614238743397-6115e40b-5b16-4357-b1b0-7dbe1e079d45.csv" id="Gm7Bp" title="📎jmeter数据驱动演示.csv">📎jmeter数据驱动演示.csv</a></p> </td></tr></tbody></table></div>
</blockquote>
<p> 一、JMeter简介<br> 二、JMeter 基本使用</p>
<ol>
<li>启动Jmeter<br> MAC启动Jmeter，进入到jmeter的bin目录下 ，运行以下命令</li>
</ol>
<p> sh jmeter</p>
<p> <img src="/assets/1/image-20220329110728-p8yq4py.png" alt="image.png"></p>
<ol start="2">
<li><p>设置为中文版(根据个人喜好)<br> 进入jmeter -bin目录下，找到jmeter.properties 文件，设置language&#x3D;zh_CN，设置完需要重启Jmeter</p>
<p> <img src="/assets/1/image-20220329110738-012ezuy.png" alt="image.png"></p>
</li>
<li><p>配置元件-Http Cookie管理器<br> 配置元件（Config Element）用于提供对静态数据配置的支持，Http Cookie管理器可以用来对 HTTP Request Sampler 的 cookie 进行管理</p>
</li>
</ol>
<p> 如果想要Jmeter像浏览器一样，保存cookie，那么可以借助“配置元件-Http Cookie管理器”，</p>
<p> （1）若没有 Http Cookie管理器：</p>
<p> <img src="/assets/1/image-20220329110751-cekwjn7.png" alt="image.png"></p>
<p> （2）当我们第一个请求，有了cookie之后，那么“Http Cookie管理器”就会保存这个cookie，给后面的请求用，就像在浏览器里的用法一样</p>
<p> <img src="/assets/1/image-20220329110759-9twhwms.png" alt="image.png"></p>
<p> 4.断言<br> 比较重要的断言主要有：响应断言(Response Assertion)、大小断言(Size Assertion)、持续时间断言(Duration Assertion)</p>
<p> （1）响应断言(Response Assertion)</p>
<p> ①响应文本(Test Response)断言</p>
<p> 断言内容 –相当于预期结果</p>
<p> <img src="/assets/1/image-20220329110812-jvc7c57.png" alt="image.png"></p>
<p> 响应中看到的数据 –相当于实际结果</p>
<p> <img src="/assets/1/image-20220329110844-gioik3d.png" alt="image.png"></p>
<p> 执行脚本后，若实际结果与预期结果不一致，则断言失败</p>
<p> <img src="/assets/1/image-20220329110854-hegwwd0.png" alt="image.png"></p>
<p> ②响应代码(Response Code)断言</p>
<p> 设置断言，假设Response Code预期应为500</p>
<p> <img src="/assets/1/image-20220329110900-2q9ure7.png" alt="image.png"></p>
<p> 实际运行结果，Response Code 为200</p>
<p> <img src="/assets/1/image-20220329110907-fvv6jl7.png" alt="image.png"></p>
<p> 则断言失败</p>
<p> （2）大小断言(Size Assertion)</p>
<p> 验证生成的响应的大小，以字节为单位，这也是吞吐量参数，当我们加负载的时候，若网站处理不过来时，就可能出现有的数据没有加载出来，这时的就不会返回完整的字节大小，当我们加负载时，我们也会参考这个参数，看看是否完全加载出来</p>
<p> <img src="/assets/1/image-20220329110922-z7yzpnx.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329110927-a25tlos.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329110934-qzvoi78.png" alt="image.png"></p>
<p> （3）持续时间断言(Duration Assertion)-主要用来验证性能指标</p>
<p> 当我们在断言中，设置为1000时，代表最大耗时不能超过1000ms</p>
<p> 这边为了演示断言出错，持续时间故意设置比较短，方便查看效果</p>
<p> <img src="/assets/1/image-20220329110941-xhqopv6.png" alt="image.png"></p>
<p> 断言失败，并给出提示</p>
<p> <img src="/assets/1/image-20220329110946-dpcmple.png" alt="image.png"></p>
<p> 通过“监听器-用表格查看结果”来看下这个sample的持续时间</p>
<p> <img src="/assets/1/image-20220329110954-bosq9nn.png" alt="image.png"></p>
<p> 5.接口关联（Json提取器&amp;正则表达式提取器）<br> 我们在进行接口测试时，一般会有业务场景的关联性，接口关联就是把应用中动态变化返回的数据获取到，把它保存为一个参数，提供给后面需要用到的地方进行使用。</p>
<p> 最常见的比如登录的接口会返回一个token，便于之后其他接口调用时来认证身份，那么这个时候，我们就需要通过接口关联来实现参数传递，最常用的方法有两种，一个是Json提取器，一个是正则表达式提取器</p>
<p> <img src="/assets/1/image-20220329111002-2mbz4a9.png" alt="image.png"></p>
<p> (1)Json 提取器</p>
<p> 我们先来看下登录接口返回参数中，是否能把pytoken这个值取到，其中$表示根元素，图中$.data.pyToken为Json路径表达式</p>
<p> <img src="/assets/1/image-20220329111011-dsqe93e.png" alt="image.png"></p>
<p> 然后在登录接口里添加后置处理器-json提取器，用json path表达式取到得值，放在pyToken这个变量里</p>
<p> Names of created variables ：接收值的变量名，自定义</p>
<p> JSON Path expression： json path表达式</p>
<p> Match No.(0 for Random)：1 代表匹配获取到的第一个值，我们这边只有一个值（0表示随机；n取第几个匹配值；-1匹配所有。若只要获取到匹配的第一个值，则填写1）</p>
<p> Default Values： 缺省值，匹配不到值的时候取该值，可写error也可不写</p>
<p> <img src="/assets/1/image-20220329111038-yu16ymc.png" alt="image.png"></p>
<p> 我们也可以使用调试取样器（Debug Sample）来查看pyToken取值是否正确</p>
<p> <img src="/assets/1/image-20220329111050-nndd4wc.png" alt="image.png"></p>
<p> 对json提取器取到的值，进行变量引用，格式为${变量名}，所以此处为 ${pyToken}</p>
<p> <img src="/assets/1/image-20220329111056-x39n204.png" alt="image.png"></p>
<p> (2)正则表达式提取器</p>
<p> 运行登录接口，查看响应结果，把需要提取的数据复制出来，然后用正则表达式代替即可</p>
<p> <img src="/assets/1/image-20220329111104-lutkk9n.png" alt="image.png"></p>
<p> “pyToken”:”03d8aa93-8f52-471f-8c12-f51a692ae7b5”}}</p>
<p> –&gt; 可以看到黄色部分，我们使用(.+?)进行了替代，因为黄色部分是动态变化的</p>
<p> <img src="/assets/1/image-20220329111112-z0y8vtn.png" alt="image.png"></p>
<p> 说明：</p>
<p> . 代表：匹配换行符\n之外的任何单字符</p>
<p> +代表：匹配前面的子表达式一次或多次</p>
<p> ?代表：匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</p>
<p> 关于正则表达式的语法可参考：正则表达式 – 语法 | 菜鸟教程</p>
<p> 模板(Template)–&gt; $0$ 代表取正则表达式输入项内输入的值，$1$指取第一个括号内的内容，此处即为.+?</p>
<p> 匹配数字(Match No.) –&gt;若jmeter在匹配Regular Expression中的值时，匹配出了多项，那么Jmeter是不知道要取哪个值的，所以可以用来指定，比如输入1，即匹配查到的第一个值</p>
<p> 缺省值（Default Value） –&gt;默认值，设置默认值，若匹配不到，则使用默认值</p>
<p> 6.Jmeter数据驱动<br> Jmeter里参数化一般分为①从文件里读数据，②从数据库里读数据，③用后置处理器从响应里读数据(第五节中就是从后置处理器中进行数据读取)</p>
<p> 数据驱动的目标就是，我们在单独的一个Execl里来维护数据，而不是在请求里面硬编码</p>
<p> (1)添加配置元素-CSV Data Set Config</p>
<p> 数据驱动csv文件：<img src="/assets/1/image-20220329111123-8vn9dch.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111128-3vksb6n.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111133-0wri3fv.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111137-y9f44d1.png" alt="image.png"></p>
<p> 设置线程数2，运行后结果查看：</p>
<p> <img src="/assets/1/image-20220329111145-dbl0nse.png" alt="image.png"></p>
<p> CSV数据文件设置字段说明：</p>
<p> ① 变量名称(Variable Names)：需要输入文本里各列都叫什么名字</p>
<p> ② 分隔符(Delimiter)：用英文的逗号隔开</p>
<p> ③遇到文件结束符再次循环？(Recycle on EOF？)：数据再循环，例如设置为True，我们的CSV中共有7条数据，但是我们有10个用户，那么第8个用户就会就会从第一条数据开始，再次循环取值</p>
<p> ④遇到文件结束符停止线程？(Stop thread on EOF?)：例如是true，执行了文件，则停止运行，如果是False，执行了文件，不停止线程，当Recycle on EOF设置为True时，此项设置无效。</p>
<p> 注意点：</p>
<p> ①文件一定要保存.csv格式</p>
<p> ②当csv文件在jmeter的bin目录或脚本目录时，只需给出文件名即可</p>
<p> (2)用函数助手参数化-从csv文件取数据</p>
<p> 依然使用（1）中的csv文件</p>
<p> <img src="/assets/1/image-20220329111154-cxrpva0.png" alt="image.png"></p>
<p> 点击生成后，就拷贝到粘贴板上，直接去粘贴就可以了</p>
<p> <img src="/assets/1/image-20220329111203-88y4cc4.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111208-rez34ee.png" alt="image.png"></p>
<p> (3)计数器</p>
<p> 在CSV里读数据，不管是用CSV Date Set Config还是用函数助手，那些数据都可能重复，我们都是手动的把它设置成不一样，如果我们不想一直去修改csv的数据，那么可以使用计数器，这样我们只需要修改计数器的起始点，最大值等，就能通过csv里的测试数据和计数器使得测试数据不重复</p>
<p> 来看下计数器的定义：允许用户在线程组中任何位置创建引用的计数器。 计数器配置允许用户配置起始点，最大值和增量。 计数器将从开始循环到最大，然后从开始重新开始，继续进行，直到测试结束。</p>
<p> 我们以函数助手参数化为实例（CSV Data Set Config同理）来实战一下</p>
<p> ①设置计数器</p>
<p> <img src="/assets/1/image-20220329111219-o15996z.png" alt="image.png"></p>
<p> a. Staring value：开始值，比如设置为1</p>
<p> b. 递增(Increment) ：递增值，比如设置为2，那么从1开始，下一个数就是3，是两个两个递增的</p>
<p> c. Maximum value： 最大值，比如设置10，就是涨到10就不涨了</p>
<p> d. 数字格式(Number format)： 什么格式的，比如我写00，则是01，02，03一直到10，如果写的是000，则是001，002，003这种</p>
<p> e. 引用名称(Exported Variable Name)：变量名，比如就叫num</p>
<p> ②设置csv文件</p>
<p> <img src="/assets/1/image-20220329111228-6rorvdl.png" alt="image.png"></p>
<p> ③函数助手设置</p>
<p> <img src="/assets/1/image-20220329111234-gepxtrv.png" alt="image.png"></p>
<p> ④根据计数器和函数助手设置接口变量</p>
<p> <img src="/assets/1/image-20220329111239-xibw7da.png" alt="image.png"></p>
<p> ⑤运行查看结果（此处实例中用了循环控制器，一个线程，但设置新增项目进度接口循环五次），查看结果</p>
<p> <img src="/assets/1/image-20220329111246-r6y3m5l.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111256-fby96lv.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111301-9n038tm.png" alt="image.png"></p>
<p> ⑥计数器的定义中提到： 计数器将从开始循环到最大，然后从开始重新开始，继续进行，直到测试结束</p>
<p> 这个是指，如果我循环的次数（或者是线程数）多于开始到最大的总数，那么会从开始的值继续执行，知道我们设置的循环次数（或者是线程数）执行完毕，例如设置开始数字1，递增是2，最大值是10，而我们设置的循环次数或者是线程数是 7，则num 分别为1，3，5，7，9，1</p>
<p> ⑦与每个用户独立的跟踪计数器(Track counter independently for each user)：若勾选这一项，则代表每个用户（线程）是独立计数的，我们可以设置线程数是2，循环次数是3，来看下效果</p>
<p> <img src="/assets/1/image-20220329111309-5qtrwom.png" alt="image.png"></p>
<p> 7.JDBC Request<br> 要用这个JDBC Request，需要配置下数据库链接 添加(Add)–&gt;配置与案件(Config Element) –&gt;JDBC链接配置(JDBC Connection Configuration)</p>
<p> 网站：JDBC Driver List | SoapUI 可以下载JDBC的Driver，还可以找到不同数据库的链接地址，不同的数据库，有不同的链接地址和数据库驱动</p>
<p> (1)配置</p>
<p> ①下载数据库驱动</p>
<p> <img src="/assets/1/image-20220329111322-ii079cw.png" alt="image.png"></p>
<p> 按照提示进行下载，下载解压后，将文件夹中的两个jar包中的一个，拷贝到Jmeter的lib目录下</p>
<p> <img src="/assets/1/image-20220329111328-7074j17.png" alt="image.png"></p>
<p> 为了方便大家下载，此处提供mysql driver的网盘下载地址：<a href="https://pan.baidu.com/s/1rSz0cEvAhAElPC9WPO44mw">https://pan.baidu.com/s/1rSz0cEvAhAElPC9WPO44mw</a>  密码:pxuv</p>
<p> ②复制数据库连接地址(这个也可以直接问开发要)</p>
<p> <img src="/assets/1/image-20220329111335-mr908un.png" alt="image.png"></p>
<p> 复制链接地址到 Database URL里，并在图中红框之后维护你的数据库的地址和端口号，后面的用户名和密码可以删除，因为Jmeter后面可以直接维护</p>
<p> <img src="/assets/1/image-20220329111343-9722roi.png" alt="image.png"></p>
<p> ③JDBC Driver class(mysql的固定写法是 com.mysql.jdbc.Driver)</p>
<p> <img src="/assets/1/image-20220329111353-tac4hzb.png" alt="image.png"></p>
<p> 完成数据库链接配置，并设置Variable Name for created pool（为了在JDBC Request中被引用）</p>
<p> <img src="/assets/1/image-20220329111401-97jv5xr.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111408-zh7shdh.png" alt="image.png"></p>
<p> (2)Jmeter中数据库操作</p>
<p> ①Query Type ：Select Statement (查询)</p>
<p> <img src="/assets/1/image-20220329111415-olsxb61.png" alt="image.png"></p>
<p> 察看结果树：</p>
<p> <img src="/assets/1/image-20220329111422-3wrcdep.png" alt="image.png"></p>
<p> 来验证下，看看数据库里数据是否和查出来的一致</p>
<p> <img src="/assets/1/image-20220329111428-v2k1fad.png" alt="image.png"></p>
<p> ②Query Type ：Update Statement (更新)</p>
<p> <img src="/assets/1/image-20220329111434-p1rxzak.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111440-cnw602a.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111445-kcjou9i.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111454-ohlu7qg.png" alt="image.png"></p>
<p> 大家可以在尝试下delete</p>
<p> <img src="/assets/1/image-20220329111505-8ues2ze.png" alt="image.png"></p>
<p> 数据已被删除</p>
<p> <img src="/assets/1/image-20220329111513-4tk2gk2.png" alt="image.png"></p>
<p> ③按照以上的测试配置，仅能执行一条sql语句，若想执行多条，需在 JDBC Connection Configuration中设置的Database URL中设置allowMultiQueries&#x3D;true</p>
<p> <img src="/assets/1/image-20220329111525-8vg2o1g.png" alt="image.png"></p>
<p> 5种Query Type 总结（以是否设置allowMultiQueries&#x3D;true来分类）：</p>
<table>
<thead>
<tr>
<th>Query Type</th>
<th>已设置(基本前提为语句正确)</th>
<th>未设置<br /></th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>Select Statement<br />或<br />Prepared Select Statement<br /></th>
<th>不管填写1条还是多条，仅执行第1条语句，且第1条语句必须为select，否则会报错</th>
<th>仅能填写1条sql语句，且必须为select语句，否则会报错</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>Update Statement或Prepared Update Statement</th>
<th>不管设置1条还是多条，只要第一条为非select语句，则能正确运行，且会忽略所有select语句，若第一条是select语句，则会报错</th>
<th>仅能填写1条sql语句，且必须为非select语句，否则会报错</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>Callable Statement</th>
<th>可执行多条sql语句</th>
<th>仅能填写一条sql语句，否则会报错</th>
</tr>
</thead>
</table>
<p> ④若在测试过程中，执行成功，却未得到对应的结果，可能是因为编码的问题，jmeter识别不了，那么此时，我们需要在 JDBC Connection Configuration的Database URL加上useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8来对他进行编码</p>
<p> <img src="/assets/1/image-20220329111935-jhhvptk.png" alt="image.png"></p>
<p> ⑤接下来我们来看下Select Statement与Prepared Select Statement，Update Statement与Prepared Update Statement的区别</p>
<p> Select Statement：静态select语句</p>
<p> Update Statement： 静态DML(insert、update、delete)</p>
<p> Prepared Select Statement：动态select语句，参数化select语句</p>
<p> Prepared Update Statement：动态DML语句，参数化DML语句</p>
<p> Prepared Select Statement和Prepared Update Statement是可以防sql注入的</p>
<p> 一般我们测试insert的时候会使用Prepared Update Statement而不是Update Statement</p>
<p> <img src="/assets/1/image-20220329111946-xoiet3s.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111951-7k7l3a3.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329111956-qvucil1.png" alt="image.png"></p>
<p> 上一次安全培训的时候，有提到关于防止sql注入的问题，一个很有效的方式，就是采用预编译的方式组装sql， “？”就是占位符，我们温习下：</p>
<p> 【预编译占位符为什么能防止sql注入】</p>
<p> a. 使用占位符：select * from table where name &#x3D; ？</p>
<p> b. 那么你传进来的参数 sql会解析成 select * from table where name &#x3D; ‘张三 or  1&#x3D;1’</p>
<p> 这个就不会有注入的风险了，sql会把传进来的是一个参数字符串，而不是语法</p>
<p> ⑥JDBC Request本身也是可以将返回值取出给到定义好的变量</p>
<p> 我们以select查询返回后的结果为例</p>
<p> <img src="/assets/1/image-20220329112005-fzzjkw2.png" alt="image.png"></p>
<p> 运行后的结果</p>
<p> <img src="/assets/1/image-20220329112011-qmlr3wq.png" alt="image.png"></p>
<p> 调试取样器查看取值情况</p>
<p> <img src="/assets/1/image-20220329112017-ngokexr.png" alt="image.png"></p>
<p> (3)JDBC Request 结合后置处理器-正则表达式提取器</p>
<p> 通过JDBC Request获取数据库的数据，用正则表达式提取器进行提取后，给到其他接口使用</p>
<p> 假设此处我们需要取出这边的登录账号 admin</p>
<p> <img src="/assets/1/image-20220329112029-kppl3ot.png" alt="image.png"></p>
<p> 添加调试取样器，我们来查看结果（调试取样器直接用${username}命名），可以看到是可以正确取到值的</p>
<p> <img src="/assets/1/image-20220329112035-rgmtssu.png" alt="image.png"></p>
<p> 注意：正则表达式中 空白用\s ，换行用 \n</p>
<p> 8.函数助手<br> 在第6节中，我们有简单讲到过一个函数助手，用CSVRead实现数据驱动，不管是使用什么函数，使用方法都是类似的，就是我们选择某个函数，并且按要求为其参数设定值，不同的函数要求的参数也不同，然后生成函数字符串，供脚本使用，后续时间充裕会将常用的Jmeter函数做下总结，这边我们就先拿__Random函数取了例子，主要演示下函数生成和使用</p>
<p> __Random函数：返回指定最大值和最小值之间的随机数</p>
<p> <img src="/assets/1/image-20220329112044-fce51qc.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112050-gfunnb2.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112053-25pe9vq.png" alt="image.png"></p>
<p> 9.BeanShell<br> 10.Jmeter事物&#x2F;模块控制器<br> 三、Ant简介<br> 下载地址：Apache Ant - Binary Distributions</p>
<p> windows下载zip包，mac下载tar包</p>
<p> <img src="/assets/1/image-20220329112105-ywqkh6w.png" alt="image.png"></p>
<p> 下载后解压，配置环境变量（同java的配置方式，可百度）</p>
<p> 配置环境变量后，在命令行运行如下命令，查看ant是否生效</p>
<p> ant -version</p>
<p> <img src="/assets/1/image-20220329112110-j041oem.png" alt="image.png"></p>
<p> 四、Jenkins介绍及安装配置<br> Jenkins官网下载地址（选择稳定的版本进行下载）：Jenkins download and deployment</p>
<p> MAC版本下载：链接:<a href="https://pan.baidu.com/s/19OpTt5aQhAhmXx4oeW4JeA">https://pan.baidu.com/s/19OpTt5aQhAhmXx4oeW4JeA</a>  密码:hltv</p>
<p> 下载后按照提示安装即可</p>
<p> mac版本获取密码时，可以在iterm里 输入：sudo less 提示的地址 ，来获取登录的初始密码</p>
<p> 登录后记得及时修改密码！！！</p>
<p> <img src="/assets/1/image-20220329112121-uxlruia.png" alt="image.png"></p>
<p> 五、Jmeter自动化测试的配置</p>
<ol>
<li><p>原理</p>
<p> <img src="/assets/1/image-20220329112127-di6hlur.png" alt="image.png"></p>
</li>
<li><p>Jmeter.property配置<br> Jmeter配置文件中，默认的报告是csv格式的，因为csv的报告不是很好看，达不到想要的效果，所以要改成xml，改成xml后，生成的报告，就能生成html的格式（注：修改后要重启Jmeter才能生效）</p>
<p> <img src="/assets/1/image-20220329112147-6zucq8s.png" alt="image.png"></p>
</li>
<li><p>Ant配置<br> 需要把Jmeter下面的一个Jar包（ant-jmeter-x.x.x.jar），复制到ant的安装目录lib目录下面，这样Ant就能使用Jmeter</p>
<p> <img src="/assets/1/image-20220329112156-i9aqdla.png" alt="image.png"></p>
</li>
<li><p>Jenkins 配置-相关插件安装<br> （1）安装Ant插件：安装后，我们才能用Jenkins结合Ant去运行build.xml文件</p>
<p> <img src="/assets/1/image-20220329112206-3gxcbrc.png" alt="image.png"></p>
</li>
</ol>
<p> （2）安装完成后，还需要配置Java 和Ant的环境变量</p>
<p> <img src="/assets/1/image-20220329112213-ma31b32.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112222-n7v1zno.png" alt="image.png"></p>
<p> （3）安装jtl和html报告插件：HTML Publisher</p>
<p> <img src="/assets/1/image-20220329112228-r3fsf4q.png" alt="image.png"></p>
<ol start="5">
<li><p>邮件通知配置<br> （1）安装插件：Email Extension Template、Email Ext Recipients Column</p>
<p> <img src="/assets/1/image-20220329112245-qcg5tbq.png" alt="image.png"></p>
</li>
</ol>
<p> （2）以QQ邮箱为例，配置发送邮箱，QQ邮箱-设置-账户-SMTP服务必须是开启的，才能发送邮件，需要获得授权码</p>
<p> <img src="/assets/1/image-20220329112252-o5tjbi8.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112256-x9sb5he.png" alt="image.png"></p>
<p> （3）进入Jenkins - Manage Jenkins - Configure System，找到邮件服务器，进行配置</p>
<p> <img src="/assets/1/image-20220329112303-e39zlrr.png" alt="image.png"></p>
<p> （4）将Jmeter里的两个Jar包（javax.activation-1.2.0.jar，mail-1.5.0-b01.jar）拷贝到Ant的lib目录下 ，否则进行ant build的时候会报错</p>
<p> <img src="/assets/1/image-20220329112311-hdods8i.png" alt="image.png"></p>
<ol start="6">
<li><p>Ant build.xml 文件</p>
<p> <img src="/assets/1/image-20220329112318-iyd1ewj.png" alt="image.png"></p>
</li>
</ol>
<p> Jenkins 新建Job<br> （1）构建触发器，此处设置一个定时任务，为了演示，假设每1分钟执行一次</p>
<p> <img src="/assets/1/image-20220329112331-yde7206.png" alt="image.png"></p>
<p> （2）安装过Ant插件后，此处构建时下拉列表就会有“Invoke Ant”选项，如图进行配置</p>
<p> <img src="/assets/1/image-20220329112338-j7w1mjz.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112342-4uwc06v.png" alt="image.png"></p>
<p> （3）构建后操作里下拉选择 “Publish HTML reports”，HTML文件的路径为jenkins workspace中html报告 的存放路径，报告名称为 index.html(可自定义，但需和xml文件中一致)</p>
<p> <img src="/assets/1/image-20220329112350-obucsvl.png" alt="image.png"></p>
<ol start="6">
<li><p>运行-看结果</p>
<p> <img src="/assets/1/image-20220329112403-ywffi1t.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112413-n3ak8ol.png" alt="image.png"></p>
</li>
</ol>
<p> 查看邮件</p>
<p> <img src="/assets/1/image-20220329112422-uw4xrm4.png" alt="image.png"></p>
<ol start="7">
<li><p>配置过程中遇到的问题总结<br> （1）jenkins html 报告格式丢失</p>
<p> <img src="/assets/1/image-20220329112437-3kg61n8.png" alt="image.png"></p>
</li>
</ol>
<p> 解决方法参考：jenkins使用HTML Publisher Plugin插件 拉取报告样式缺失问题解决 - 凯宾斯基 - 博客园</p>
<p> ①安装插件：Groovy，startup Trigger</p>
<p> ②配置方法</p>
<p> 新建一个job，该job专门用于Jenkins启动时执行的配置命令；<br> 在Build Triggers模块下，勾选Build when job nodes start；<br> 在Build模块下，Add build step-&gt; Execute system Groovy script，在Groovy Script中输入配置命令，System.setProperty(“hudson.model.DirectoryBrowserSupport.CSP”, “”)<br> 解决后，报告显示正常</p>
<p> <img src="/assets/1/image-20220329112446-58a067u.png" alt="image.png"></p>
<p> （2）Html报告中，MinTime和 Max Time 显示为NaN</p>
<p> <img src="/assets/1/image-20220329112453-clzth2w.png" alt="image.png"></p>
<p> 解决方法一：</p>
<p> jmete-lib目录下这两个jar包，复制到ant的lib目录下即可</p>
<p> <img src="/assets/1/image-20220329112459-dvivbp0.png" alt="image.png"></p>
<p> 解决方法二：在xml文档中引用这两个jar包即可</p>
<p> <img src="/assets/1/image-20220329112505-9soji57.png" alt="image.png"></p>
<p> （3）Jenkins构建时遇到SSL警告</p>
<p> <img src="/assets/1/image-20220329112511-2lexqq6.png" alt="image.png"></p>
<p> 解决方法，需要在JDBC Connection Configuration的Database URL中，增加三个参数：useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false</p>
<p> <img src="/assets/1/image-20220329112520-arj1oaf.png" alt="image.png"></p>
<p> （4）Jenkins构建时 控制台提示jmeter.log 权限不足</p>
<p> <img src="/assets/1/image-20220329112527-4vj8e1v.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112531-z2s6btq.png" alt="image.png"></p>
<p> 解决方法：进入到jmeter.log的目录下，对该文件的权限进行变更</p>
<p> <img src="/assets/1/image-20220329112540-11x47zt.png" alt="image.png"></p>
<ol start="8">
<li>分享中提到的关于TestReport的名称优化<br> 目标：使展示的TestReport展示成变化的值(本身展示的是index.html)</li>
</ol>
<p> （1）在Jenkins中安装插件</p>
<p> <img src="/assets/1/image-20220329112551-bu7qznm.png" alt="image.png"></p>
<p> （2）进入系统配置</p>
<p> <img src="/assets/1/image-20220329112557-ocebez9.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112604-ihl79vz.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112610-s1tpg83.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112615-zcy27c2.png" alt="image.png"></p>
<p> 进入jenkins 对应的jmeter自动化的Job中，点击Configure，我们去修改一下当时的配置，</p>
<p> <img src="/assets/1/image-20220329112622-vfi5b12.png" alt="image.png"></p>
<p> 修改构建后操作（Post-build Actions），将原先设置的index.html改成和 TestReport${time}.html，点击save</p>
<p> <img src="/assets/1/image-20220329112719-4kwtn2h.png" alt="image.png"></p>
<p> 我们来构建并查看报告，看下是否达到我们想要的效果</p>
<p> <img src="/assets/1/image-20220329112645-2czf07j.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220329112654-zcqagi3.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter 连接 MySQL数据库测试</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/12_jmeter%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p> 1、下载安装mysql驱动包<br> 提供下载地址：<a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a></p>
<p> <img src="/assets/1/image-20220326104628-z3y3izm.png" alt="image.png"></p>
<p> 也可以自行百度搜索下载。</p>
<p> 下载完成之后，将mysql驱动放置到…\apache-jmeter-3.2\lib目录下。</p>
<p> <img src="/assets/1/image-20220326104637-3hy3v7z.png" alt="image.png"></p>
<p> 然后重新启动JMeter。</p>
<p> 2、测试计划添加mysql驱动</p>
<p> <img src="/assets/1/image-20220326104648-8ad0kyu.png" alt="image.png"></p>
<p> 3、配置JDBC<br> 给线程组添加配置原件&gt;JDBC Connection Configuration。</p>
<p> 1)Varible Name: 这个是变量的名字，具有唯一性，不能重复</p>
<ol start="2">
<li>Database URL: jdbc:mysql:&#x2F;&#x2F;数据库地址:数据库端口号&#x2F;数据库名</li>
<li>JDBC Driver Class ：org.gjt.mm.mysql.Driver  或者 com.mysql.jdbc.Driver   这是固定值</li>
<li>Username：这个数据库的登录名</li>
<li>Password： 这个是数据库的登录密码</li>
<li><img src="/assets/1/image-20220326104701-ypfc3ln.png" alt="image.png"></li>
<li><img src="/assets/1/image-20220326104737-abfdea1.png" alt="image.png"></li>
</ol>
<p> 4、添加JDBC Request<br> 给线程组添加Sampler&gt;JDBC Request。</p>
<p> Variable Name：<br> 数据库连接池的名字，需要与上面配置的JDBC Connection Configuration中Variable Name Bound Pool的Variable Name相同<br> Query：填写的sql语句未尾不要加“;”<br> Parameter valus：参数值<br> Parameter types：参数类型，可参考：Javadoc for java.sql.Types<br> Variable names：保存sql语句返回结果的变量名<br> Result variable name：创建一个对象变量，保存所有返回的结果<br> Query timeout：查询超时时间<br> Handle result set：定义如何处理由callable statements语句返回的结果</p>
<p> <img src="/assets/1/image-20220326104745-60ube5i.png" alt="image.png"></p>
<p> 5、添加查看结果树，运行线程组，查看结果</p>
<p> <img src="/assets/1/image-20220326104754-janco21.png" alt="image.png"></p>
<p> 6、其他地方引用查询结果作为参数<br> 我们需要在JDBC Request中设置Variable names作为参数名，该参数名也具有唯一性，必须不与其他变量名重复。</p>
<p> 上图中我们已经设置了Variable names&#x3D;UserName。</p>
<p> 我们的SQL语句只查询了UserName这一个字段，那么我们想要引用第1个UserName，可以如下书写：${UserName_1}；第2个可以如下书写：${UserName_2}，依次类推。</p>
<p> <img src="/assets/1/image-20220326104807-cnwxb7i.png" alt="image.png"></p>
<p> 以下是JMeter帮助文档中的介绍：</p>
<p> <img src="/assets/1/image-20220326104814-x9ytcpj.png" alt="image.png"></p>
<h1 id="jmeter使用beanshell和jdbc-将sql查询出来的数据写入文件中"><a href="#jmeter使用beanshell和jdbc-将sql查询出来的数据写入文件中" class="headerlink" title="jmeter使用beanshell和jdbc 将sql查询出来的数据写入文件中"></a>jmeter使用beanshell和jdbc 将sql查询出来的数据写入文件中</h1><p> 需求<br> 通过sql查询结果，将结果写入scv文件中。<br> 1<br> 思路<br> 1、使用jdbc取样器获取sql查询结果<br> 2、使用beanshell将查询结果写入指定的文件中。</p>
<p> 操作步骤<br> 1、创建一个配置原件JDBC Connection Configuration，如下图</p>
<p> <img src="/assets/1/image-20220326150842-uw0e7l1.png" alt="image.png"></p>
<p> 2、创建一个jdbc request 请求，如下图：</p>
<p> <img src="/assets/1/image-20220326150851-j6kt7mi.png" alt="image.png"></p>
<p> 3、创建一个beanshell取样器，如下图</p>
<p> <img src="/assets/1/image-20220326150857-sv6vur8.png" alt="image.png"></p>
<blockquote>
<p>&#x2F;&#x2F;创建文件对象<br>FileWriter fw &#x3D;new FileWriter(“d:\deviceNum.csv”,true);</p>
<p>&#x2F;&#x2F;创建一个字符缓存输出流<br>BufferedWriter bufw&#x3D;new BufferedWriter (fw);<br>&#x2F;&#x2F;获取sql查询结果的行数<br>String num&#x3D;vars.get(“deviceNum_#”);<br>&#x2F;&#x2F;字符串转换成int<br>int count &#x3D; Integer.parseInt(num);<br>&#x2F;&#x2F;控制循环次数，写入count行文件<br>for(int i&#x3D;1;i&lt;&#x3D;count;i++){<br>    &#x2F;&#x2F;获取sql查询结果第i行的数据<br>    str&#x3D;vars.get(“deviceNum_”+i);<br>    &#x2F;&#x2F;将数据写入磁盘文件中<br>    bufw.write(str);<br>    &#x2F;&#x2F;换行<br>    bufw.write(“\r\n”);<br>}<br>&#x2F;&#x2F;文件写入结束后，关闭流<br>bufw.close();<br>fw.close();<br><br /></p>
</blockquote>
<p> 4、执行，查看结果，生成了文件，并查看文件内容。</p>
<p> <img src="/assets/1/image-20220326151132-f02glae.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220326151136-6ejnxww.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>blazemeter</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/14_blazemeter(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/</url>
    <content><![CDATA[<p> blazemeter 插件：<a href="assets/1/BlazeMeter-20211210140654-8y5ux10.zip">BlazeMeter.zip</a></p>
<p> <strong>一、下载安装Chrome浏览器</strong></p>
<p> 　　地址：<a href="http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html%EF%BC%9B">http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html；</a></p>
<p> <strong>二、离线安装BLazeMeter插件</strong></p>
<p> 　　1、下载BlazeMeter插件，地址：<a href="https://www.chromefor.com/down/?wp_file=mbopgmdnpcbohhpnfglgohlbhfongabi/blazemeter-the-continuous_v3.2.2.crx&amp;tdd=1526367875">https://www.chromefor.com/down/?wp_file=mbopgmdnpcbohhpnfglgohlbhfongabi/blazemeter-the-continuous_v3.2.2.crx&amp;tdd=1526367875</a></p>
<p> 　　2、打开Chrome浏览器，按如下步骤操作</p>
<p> <a href="http://www.51testing.com/batch.download.php?aid=79445"><img src="/assets/1/image-20211210141231-08a4h1s.png" alt="image.png"></a></p>
<p> <a href="http://www.51testing.com/batch.download.php?aid=79446"><img src="/assets/1/image-20211210141236-o7wjrgi.png" alt="image.png"></a></p>
<p> 　　3、安装成功的标志：Chrome浏览器右上角出现如下标志，证明安装BlazeMeter成功了。</p>
<p> <a href="http://www.51testing.com/batch.download.php?aid=79447"><img src="/assets/1/image-20211210141241-4xws5a2.png" alt="image.png"></a></p>
<p> <strong>三、使用BlazeMeter录制，并导出.jmx文件</strong></p>
<p> 　<strong>1、用Chrome浏览器打开要<a href=""><strong>测试</strong></a>的网页，打开BlazeMeter界面，如下：</strong></p>
<p> <a href="http://www.51testing.com/batch.download.php?aid=79448"><img src="/assets/1/image-20211210141245-av7walp.png" alt="image.png"></a></p>
<p> <img src="/assets/1/image-20211210141249-5m0b3le.png" alt="image.png"></p>
<p> 　　注意，该界面前四个按钮在非登陆的状态下都可使用，但是.jmx按钮是录制完成后导出.jmx文件，只有在登录BlazeMeter状态下才可以使用。</p>
<p> 四、脚本录制过程</p>
<h3 id="1-2-插件介绍"><a href="#1-2-插件介绍" class="headerlink" title="1.2 插件介绍"></a>1.2 插件介绍</h3><h4 id="1-2-1-登录注册"><a href="#1-2-1-登录注册" class="headerlink" title="1.2.1 登录注册"></a>1.2.1 登录注册</h4><p> 点击右上角图标，等待几分钟左右进入注册界面，根据相关提示填入用户名和邮箱信息，保存即可进入BlazeMeter界面。此时，再进入插件界面用户已自动登录，参见图1-3。</p>
<p> <img src="/assets/1/image-20211210144911-ozdafn1.png" alt="image.png"></p>
<p> 图1-3 用户登录</p>
<h4 id="1-2-2-基本设置工程命名"><a href="#1-2-2-基本设置工程命名" class="headerlink" title="1.2.2 基本设置工程命名"></a>1.2.2 基本设置工程命名</h4><p> 在<img src="/assets/1/image-20211210144917-arhdvjw.png" alt="image.png">输入测试任务名称，录制完成后以此作为名字导出脚本。</p>
<p> 停止录制</p>
<p> 点击<img src="/assets/1/image-20211210144924-79zvbqp.png" alt="image.png">按钮，停止录制。</p>
<p> 开始录制</p>
<p> 点击<img src="/assets/1/image-20211210144929-oue8lzl.png" alt="image.png">按钮，开始页面录制。</p>
<p> 恢复默认值</p>
<p> 点击<img src="/assets/1/image-20211210144934-3ypmr68.png" alt="image.png">按钮，恢复默认值。</p>
<p> 使用场景</p>
<p> Perfornamce（Jmeter）：性能测试；</p>
<p> API Functional（Jmeter）：API功能测试；</p>
<p> GUI Functional（Selenium）：API功能测试；</p>
<p> End User Experence Monitoring（JMeter &amp; Selenium）：联合测试；</p>
<p> 更多细节，参见<a href="https://www.blazemeter.com/product/">https://www.blazemeter.com/product/</a></p>
<p> 编辑</p>
<p> JMeter Script：编辑Jmeter录制脚本后进行上传，参见图1-4；</p>
<p> <img src="/assets/1/image-20211210144938-4ny6cwk.png" alt="image.png"></p>
<p> 图1-4 编辑Jmeter录制脚本</p>
<p> Selenium：编辑Jmeter录制脚本后进行上传；</p>
<p> <img src="/assets/1/image-20211210144942-4z1huxi.png" alt="image.png"></p>
<p> 图1-5 编辑Selenium录制脚本</p>
<p> l 保存</p>
<p> 点击，选择保存类型JMeter（JMX）、Selenium only、JMeter &amp; Selenium combined（YAML）。</p>
<p> <img src="/assets/1/image-20211210144948-4evg0aq.png" alt="image.png"> <img src="/assets/1/image-20211210144951-cfmivha.png" alt="image.png"> <img src="/assets/1/image-20211210144955-evf4d5r.png" alt="image.png"></p>
<p> 图1-6 脚本保存类型</p>
<h4 id="1-2-3-高级设置"><a href="#1-2-3-高级设置" class="headerlink" title="1.2.3 高级设置"></a>1.2.3 高级设置</h4><p> 不再详细介绍。</p>
<h4 id="1-2-4-保存项目"><a href="#1-2-4-保存项目" class="headerlink" title="1.2.4 保存项目"></a>1.2.4 保存项目</h4><p> 在保存项目选项中，配置好账号、工作空间、项目，不填按照默认值填写，参见图1-7。</p>
<p> <img src="/assets/1/image-20211210145002-u47qpvl.png" alt="image.png"></p>
<p> 图1-7 保存选项</p>
<h3 id="1-3-Web录制"><a href="#1-3-Web录制" class="headerlink" title="1.3 Web录制"></a>1.3 Web录制</h3><p> 打开录制的网页，点击图标，开始页面录制，参见图1-8。</p>
<p> <img src="/assets/1/image-20211210145006-a8mqxb4.png" alt="image.png"></p>
<p> 图1-8 blazeMeter界面</p>
<p> 开始录制前在输入框中工程名称，点击开始录制按钮，可以观察到<img src="/assets/1/image-20211210145016-8g51qlz.png" alt="image.png">下数字一直在变化，说明界面操作事件被录制到，参见图1-9。</p>
<p> <img src="/assets/1/image-20211210145011-g0jdql8.png" alt="image.png"></p>
<p> 图1-9 BlazeMeter录制</p>
<p> 录制完成后点击图标，停止录制；点击<img src="/assets/1/image-20211210145021-1s5hw6m.png" alt="image.png">图标，选择导出脚本类型JMeter、Selenium only、Jmeter &amp; Selenium combined，直接导出录制脚本，参见图1-10。</p>
<p> 注意：JMeter需要先注册登录才能导出使用。勾选JMeter（JMX）生成Jmeter脚本并下载，参见图1-11。</p>
<p> <img src="/assets/1/image-20211210145025-hsmkj6c.png" alt="image.png"></p>
<p> 图1-10 直接导出JMX脚本</p>
<p> 或者点击<img src="/assets/1/image-20211210145030-tt1flfw.png" alt="image.png">编辑按钮，选择JMeter Script、Selenium一种类型，进入编辑界面，可以对脚本进行编辑，被选中编辑的内容高亮显示，参见图1-11，编辑完成后点击页面右上角<img src="https://img.jbzj.com/file_images/article/202112/2021120109093129.png">，选择一种保存类型后浏览器直接开始下载脚本到本地默认路径下。</p>
<p> <img src="/assets/1/image-20211210145035-g9uzrpm.png" alt="image.png"></p>
<p> 图1-11 编辑脚本后下载</p>
<p> 打开Jmeter界面，将下载到本地的JMX录制脚本直接拖到Jmeter窗口，BlazeMeter自动填充全局配置信息（Http信息头，抽取出接口环境变量），参见图1-11。</p>
<p> <img src="/assets/1/image-20211210145040-cpwrq55.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20211210145044-f65h5ne.png" alt="image.png"></p>
<p> 图1-11 环境参数</p>
<p> 到此这篇关于Jmeter BlazeMeter实现web录制的文章就介绍到这了,</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>badboy</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/15_badboy(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/</url>
    <content><![CDATA[<p> <strong>Badboy工具介绍</strong></p>
<p> Badboy是一个强大的工具，被设计用于测试和开发复杂的动态应用。Badboy功能丰富（包括一个捕获&#x2F;重播接口，强大的压力测试支持，详细的报告、图形）使得测试和开发更加容易。bodbay 是一个录制脚本的工具，主要是搭配jmeter工具进行搭配。bodbay 适合小白使用，录制比较方便。</p>
<p> <strong>安装</strong><br> 下载地址：<a href="https://badboy.en.softonic.com/">https://badboy.en.softonic.com/</a>下载完成后进行安装，完毕。</p>
<p> 安装包：<a href="assets/1/badboy2.2.5-20211210150333-3tfp0p3.zip">badboy2.2.5.zip</a><br> <img src="/assets/1/image-20211210145212-qhs98i9.png" alt="image.png"></p>
<p> <strong>使用方法：</strong><br> 打开软件，可以看到如下操作界面<br> <img src="/assets/1/image-20211210145216-gwand93.png" alt="image.png"></p>
<p> 这里使用<a href="http://www.so.com进行演示,如下/">www.so.com进行演示，如下</a>:<br> <img src="/assets/1/image-20211210145221-4tattt4.png" alt="image.png"></p>
<p> 然后进行搜索Badboy关键字进行搜索<br> <img src="/assets/1/image-20211210145225-qy3jasq.png" alt="image.png"><br> 最后按暂停，进行回放，就可以看到刚刚的操作<br> <img src="/assets/1/image-20211210145241-95231ej.png" alt="image.png"></p>
<p> <strong>检查点的使用</strong><br> 停止录制后，添加检查点；选中搜索框中的关键词，点击工具栏中Tools→Add Assertion for selection<br> <img src="/assets/1/image-20211210145246-etw732c.png" alt="image.png"></p>
<p> 选择variables,右键选择Add Variable…<br> <img src="/assets/1/image-20211210145250-wolo6pw.png" alt="image.png"><br> <img src="/assets/1/image-20211210145254-wsh96bs.png" alt="image.png"><br> 最后进行检查点的替换，如下图：<br> <img src="/assets/1/image-20211210145259-eiyws6h.png" alt="image.png"><br> <img src="/assets/1/image-20211210145304-b6otgt6.png" alt="image.png"><br> <img src="/assets/1/image-20211210145308-wyfjqmc.png" alt="image.png"><br> <img src="/assets/1/image-20211210145312-8r05e4c.png" alt="image.png"></p>
<p> 最后选择回放：</p>
<p> 并发使用<br> <img src="/assets/1/image-20211210145317-hq1n6w8.png" alt="image.png"><br> <img src="/assets/1/image-20211210145322-9pgbji8.png" alt="image.png"><br> 测试报告<br> <img src="/assets/1/image-20211210145643-o87elku.png" alt="image.png"><br> <img src="/assets/1/image-20211210145647-384qtj6.png" alt="image.png"><br> <strong>其他说明</strong><br> <strong>其他相关配置说明</strong><br> Windows10+IE11+Badboy2.2.5</p>
<p> 提示：提示Badboy为201602版本，已经停止维护；</p>
<p> <strong>问题汇总</strong><br> 1)Badboy.exe，一运行就提示Badboy Script File 停止运行问题；</p>
<p> 处理方式：换电脑，运行没问题；检查端口占用、没占用；考虑软件冲突，卸载360、可能影响的软件，没解决；<br> 解决方式：重装系统。</p>
<p> 2)录制问题，用baidu，输入搜索条件，录制的url有问题； taobao，录制有问题，无法加载完成；<br> 解决方式：用<a href="https://www.jd.com/">https://www.jd.com</a></p>
<p> 3)参数化回放时，只回放一遍<br> 解决方式：重新设置录入参数，再回放，就ok了。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter简单的性能测试</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/16_jmeter%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="什么是压力测试"><a href="#什么是压力测试" class="headerlink" title="什么是压力测试"></a>什么是压力测试</h1><p>顾名思义：压力测试，就是  被测试的系统，在一定的访问压力下，看程序运行是否稳定&#x2F;服务器运行是否稳定（资源占用情况）</p>
<p>比如： 2000个用户同时到一个购物网站购物，这些用户打开页面的速度是否会变慢，或者网站是否会奔溃</p>
<h1 id="做压力测试的常用工具"><a href="#做压力测试的常用工具" class="headerlink" title="做压力测试的常用工具"></a><strong>做压力测试的常用工具</strong></h1><p>做压力测试，一般要使用工具， 人工是没办法做的。   最常用的工具是LoadRunner, 但是LoadRunner毕竟是收费软件，而且使用上也比较复杂。 现在越来越多的人开始使用Jmeter来做压力测试。 免费， 而且使用上非常简单。</p>
<h1 id="做压力测试的步骤如下"><a href="#做压力测试的步骤如下" class="headerlink" title="做压力测试的步骤如下:"></a><strong>做压力测试的步骤如下:</strong></h1><ol>
<li>写脚本 或者录制脚本</li>
<li>使用用户自定义参数</li>
<li>场景设计</li>
<li>使用控制器，来控制 模拟多少用户。</li>
<li>使用监听器， 查看测试结果</li>
</ol>
<h1 id="本文做压力测试的例子"><a href="#本文做压力测试的例子" class="headerlink" title="本文做压力测试的例子"></a><strong>本文做压力测试的例子</strong></h1><p>本文举的实例是： 在一台电脑用Jmeter模拟200个用户，同时去使用bing搜索不同的关键字， 查看页面返回的时间是否在正常范围内。</p>
<h1 id="第一步：-使用CSV-Data-Set-Config-来参数化"><a href="#第一步：-使用CSV-Data-Set-Config-来参数化" class="headerlink" title="第一步： 使用CSV Data Set Config 来参数化"></a><strong>第一步： 使用CSV Data Set Config 来参数化</strong></h1><p>首先我们把测试需要用到的2个参数放在txt文件中，</p>
<p>新建一个data.txt文件，输入些数据， 一行有两个数据，用逗号分隔。</p>
<p><img src="/assets/1/wpsA389.tmp-20211222151639-v1yct5t.png"><img src="/assets/1/wpsA38A.tmp-20211222151639-jjq1wud.jpg"></p>
<p>启动Jmeter, 先添加一个Thread Group, 然后添加一个CSV Data Set Config (Add -&gt; Config Element -&gt; CSV Data Set Config)</p>
<p><img src="/assets/1/wpsA38B.tmp-20211222151639-2pu141a.png"><img src="/assets/1/wpsA38C.tmp-20211222151639-pau65wi.jpg"></p>
<h1 id="第二步：添加HTTP-Request"><a href="#第二步：添加HTTP-Request" class="headerlink" title="第二步：添加HTTP Request."></a><strong>第二步：添加HTTP Request.</strong></h1><p>我们添加http 请求，发送get 到 <a href="http://cn.bing.com/search?q=testteststtssdfds">http://cn.bing.com/search?q=</a>博客园+小坦克</p>
<p>选择Thread Group 右键 (Add -&gt;Sampler -&gt; HTTP Request)，  需要填的数据如下：</p>
<p><img src="/assets/1/wpsA38D.tmp-20211222151639-lnmmrhi.png"> <img src="/assets/1/wpsA38E.tmp-20211222151639-xufwtlv.jpg"></p>
<h1 id="第三步：-使用Thread-Group，-控制模拟多少用户"><a href="#第三步：-使用Thread-Group，-控制模拟多少用户" class="headerlink" title="第三步： 使用Thread Group， 控制模拟多少用户"></a><strong>第三步： 使用Thread Group， 控制模拟多少用户</strong></h1><p>选中Thread Group</p>
<p><img src="/assets/1/wpsA38F.tmp-20211222151639-q49txfd.png"> <img src="/assets/1/wpsA390.tmp-20211222151639-pzriw4y.jpg"></p>
<p>Number of Threads(users):     一个用户占一个线程，  200个线程就是模拟200个用户</p>
<p>Ramp-Up Period(in seconds):   设置线程需要多长时间全部启动。如果线程数为200 ，准备时长为10 ，那么需要1秒钟启动20个线程。也就是每秒钟启动20个线程。</p>
<p>Loop Count: 每个线程发送请求的次数。如果线程数为200 ，循环次数为10 ，那么每个线程发送10次请求。总请求数为200*10&#x3D;2000 。如果勾选了“永远”，那么所有线程会一直发送请求，直到选择停止运行脚本。</p>
<h1 id="第四步：-添加Summary-Report-用来查看测试结果"><a href="#第四步：-添加Summary-Report-用来查看测试结果" class="headerlink" title="第四步：  添加Summary Report 用来查看测试结果"></a><strong>第四步：  添加Summary Report 用来查看测试结果</strong></h1><p>选中Thread Group 右键(Add -&gt; Listener -&gt; Summary Report)</p>
<h1 id="第五步：-运行一下"><a href="#第五步：-运行一下" class="headerlink" title="第五步： 运行一下"></a><strong>第五步： 运行一下</strong></h1><p>到目前为止， 脚本就全写好了， 我们来运行下， 如何看下测试的结果</p>
<p><img src="/assets/1/wpsA391.tmp-20211222151639-p939i7p.png"><img src="/assets/1/wpsA392.tmp-20211222151639-w2xoqt3.jpg"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter监控服务器性能</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/17_Jmeter%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h3 id="jmeter也可以像loadrunner一样监控服务器CPU、内存等性能参数，不过需要安装一些插件"><a href="#jmeter也可以像loadrunner一样监控服务器CPU、内存等性能参数，不过需要安装一些插件" class="headerlink" title="jmeter也可以像loadrunner一样监控服务器CPU、内存等性能参数，不过需要安装一些插件"></a>jmeter也可以像loadrunner一样监控服务器CPU、内存等性能参数，不过需要安装一些插件</h3><h3 id="1、下载需要的jmeter插件"><a href="#1、下载需要的jmeter插件" class="headerlink" title="** 1、下载需要的jmeter插件**"></a>** 1、下载需要的jmeter插件**</h3><p><img src="/assets/1/image-20220326104327-nzp9r33.png" alt="image.png"></p>
<pre><code>   如图上面两个是jmeter插件，可以再下面的链接中下载：
</code></pre>
<p><a href="https://jmeter-plugins.org/downloads/old">https://jmeter-plugins.org/downloads/old</a></p>
<p> 第三个是放在服务器中的，可在下面的度盘中下载：</p>
<p><a href="http://pan.baidu.com/share/link?shareid=2974853586&amp;uk=1528396991&amp;fid=512652594025385">http://pan.baidu.com/share/link?shareid=2974853586&amp;uk=1528396991&amp;fid=512652594025385</a></p>
<h3 id="2、解压压缩包"><a href="#2、解压压缩包" class="headerlink" title="2、解压压缩包"></a>2、解压压缩包</h3><p>参见包里面的说明文档：”Just copy the JAR file into JMeter’s lib&#x2F;ext directory.Then you can start JMeter and add additional items to your Test Plan.Java version 1.6 and JMeter 2.4 are required.”</p>
<p>所以我们需要找到解压包中的JAR文件，并拷贝到jmeter的lib&#x2F;ext目录下，这里下载的1.4版本的插件需要在jdk1.6及jmeter2.4以上的版本使用</p>
<p><img src="/assets/1/image-20220326104336-mnxzztx.png" alt="image.png"></p>
<p>   如上图，把的两个jar包放到JMeter的 lib&#x2F;ext目录下，重启jmeter，出现如下新增的组件，则说明启动成功</p>
<p><img src="/assets/1/image-20220326104342-izjjvmn.png" alt="image.png"></p>
<h3 id="3、-常用组件简要介绍："><a href="#3、-常用组件简要介绍：" class="headerlink" title="** 3、 常用组件简要介绍：**"></a>** 3、 常用组件简要介绍：**</h3><ol>
<li><strong>jp@gc - Bytes Throughput Over Time:</strong> 不同时间吞吐量展示（图表）<br> 聚合报告里，Throughput是按请求个数来展示的，比如说1.9&#x2F;sec，就是每s发送1.9个请求；而这里的展示是按字节Bytes来展示的图表</li>
<li>**jp@gc - Composite Graph： **混合图表<br> 在它的Graphs里面可以设置多少个图表一起展示，它可以同时展示多个图表</li>
<li><strong>jp@gc - Hits per Second：</strong> 每秒点击量</li>
<li><strong>jp@gc - PerfMon Metrics Collector</strong> <strong>：</strong>服务器性能监测控件，包括CPU，Memory，Network，I&#x2F;O等等</li>
<li><strong>jp@gc - Reponse Latencies Over Time：</strong> 记录客户端发送请求完成后，服务器端返回请求之前这段时间</li>
<li><strong>jp@gc - Reponse Times Distribution：</strong> 显示测试的响应时间分布，X轴显示由时间间隔分组的响应时间，Y轴包含每个区间的样本数</li>
<li><strong>jp@gc - Transactions per Second：</strong> 每秒事务数，服务器每秒处理的事务数</li>
</ol>
<p> 4、将监控服务器的serverAgent拷贝到需监测的服务器</p>
<p><img src="/assets/1/image-20220326104350-fmnkbou.png" alt="image.png"></p>
<pre><code>   windows服务器中启动startAgent.bat，Linux服务器启动startAgent.sh即可

   在linux中启动 ./startAgent.sh 是，可能会提示：“-bash: ./startAgent.sh: 权限不够”，那么我们需要执行命令：

   chmod +x startAgent.sh
</code></pre>
<p><img src="/assets/1/image-20220326104359-7bjy6ks.png" alt="image.png"></p>
<h3 id="5、准备测试脚本"><a href="#5、准备测试脚本" class="headerlink" title="** 5、准备测试脚本**"></a>** 5、准备测试脚本**</h3><pre><code>    这里用到一个登陆测试系统的简单脚本做压力测试demo
</code></pre>
<p><img src="/assets/1/image-20220326104405-5wtfz9j.png" alt="image.png"></p>
<h3 id="6、配置监控服务器性能参数的组件"><a href="#6、配置监控服务器性能参数的组件" class="headerlink" title="**  6、配置监控服务器性能参数的组件**"></a>**  6、配置监控服务器性能参数的组件**</h3><pre><code>    主要用到这个组件：jp@gc - PerfMon Metrics Collector，配置如下：
</code></pre>
<p><img src="/assets/1/image-20220326104411-n8o04th.png" alt="image.png"></p>
<h3 id="7、设置负载，执行脚本，查看监控结果"><a href="#7、设置负载，执行脚本，查看监控结果" class="headerlink" title="7、设置负载，执行脚本，查看监控结果"></a>7、设置负载，执行脚本，查看监控结果</h3><p><img src="/assets/1/image-20220326104416-6yys6lr.png" alt="image.png"></p>
<h3 id="8、图表可导出成csv文件，配合聚合报告，分析服务器性能状况"><a href="#8、图表可导出成csv文件，配合聚合报告，分析服务器性能状况" class="headerlink" title="8、图表可导出成csv文件，配合聚合报告，分析服务器性能状况"></a>8、图表可导出成csv文件，配合聚合报告，分析服务器性能状况</h3>]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter插件</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/18_jmeter%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter远程启动</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/10_jmeter%E8%BF%9C%E7%A8%8B%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p> 使用JMeter，来完成一台机器控制，多台远程机器，即实现1主多从来进行压测脚本。</p>
<p> 过程：</p>
<p> 1、主从机器上均安装相同版本的JMeter 和JDK。</p>
<p> 2、配置主从机器，详见步骤：</p>
<p> a、将主机器的JMeter&#x2F;bin中的jmeter.properties文件，修改如下2处信息，</p>
<p> <img src="/assets/1/image-20220324113829-81yj5kl.png" alt="image.png"></p>
<p> 切记要修改：server.rmi.ssl.disable&#x3D;true，否则会报如下的错误</p>
<p> <img src="/assets/1/image-20220324113835-1lawuv2.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220324113840-ln4o8lp.png" alt="image.png"></p>
<p> b、从机器也做类似的配置</p>
<p> <img src="/assets/1/image-20220324113846-8jdlhfd.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220324113850-k8890gu.png" alt="image.png"></p>
<p> 3、启动从主机器</p>
<p> 启动机器前，一定要先启动 jmeter-server，否则会报 如下错</p>
<p> <img src="/assets/1/image-20220324113856-rvktg8z.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220324113901-miz90ql.png" alt="image.png"></p>
<p> 4、启动jmeter.sh(mac)，jmeter.bat（window），执行脚本，运行—远程启动<br> <br /></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter json提取器详解</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/08_jmeterjson%E6%8F%90%E5%8F%96%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>一、JSON提取器</p>
<ol>
<li><p>JSON提取器是专门用来对返回的响应结果是application&#x2F;json格式的报文进行提取，如下所示</p>
<p> <img src="/assets/1/image-20220310180655-r4lg5zc.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220310180707-9lamju0.png" alt="image.png"></p>
</li>
<li><p>首先在需要提前变量的HTTP请求点击右键》添加》后置处理器》JSON提取器</p>
<p> <img src="/assets/1/image-20220310180717-swpsysb.png" alt="image.png"></p>
</li>
<li><p>JSON提取器，变量应用范围，默认选择Main sample only即可</p>
<p> <img src="/assets/1/image-20220310180725-zrdedue.png" alt="image.png"></p>
</li>
<li><p>下面给大家讲解写怎么写JSON PATH，只有写出正确的JSON PATH，才能获取到我们需要的变量值，默认我们jmeter的察看结果树显示的结果是Text文本格式，这样我们就不能快速的看出变量的层级，所以需要把查看结果树的显示格式改成JSON Path Tester，该查看结果树还支持直接对结果进行调试，这是很多刚入门的小伙伴不知道的一个功能，很方便，如下所示</p>
<p> <img src="/assets/1/image-20220310180734-7sd2ozo.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220310180740-17p7iyw.png" alt="image.png"></p>
</li>
<li><p>JSON的基本语法就是$.然后后面跟要取字段名，比如要取data，就直接写$.data，如果要取msg，就直接写$.msg如下所示</p>
<p> <img src="/assets/1/image-20220310180747-b5py5r7.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220310180752-9c6i5jn.png" alt="image.png"></p>
</li>
<li><p>如果还要往下取值，就像文中的token，就需要继续在后面加”.”，(.代表子元素)，然后跟字段名，如$.data.token</p>
<p> <img src="/assets/1/image-20220310180740-17p7iyw.png" alt="image.png"></p>
</li>
<li><p>在给大家介绍一种结果为数组格式的怎么取值，如下图所示，results保存了数组格式的值，先要知道数组索引，然后才能继续读取数组下的值，学过python的应该就清楚，只要从0依次递增就能取到需要的值，如resulst[0]，resulst[1]，比如我想取第一个数组中的name值，只需要填写$.data.results[0].name</p>
<p> <img src="/assets/1/image-20220310180813-2eois8o.png" alt="image.png"></p>
</li>
<li><p>实际工作中，可能返回的查询结果经常会变化，这时候如果在写死数组索引的位置，比如上面给大家介绍的，写成$.data.results[0].name，如果系统新增了项目，可能就会导致取的值不正确，这时候就需要用到另外一种取值方式，$…results[?(@.name&#x3D;&#x3D;‘function’)].id，该json path可以通过一个变量定位到自己所在的数组的索引，然后在去取需要的id，比如automation这个值是唯一值，就可以通过该值取到需要的值，语法如下$…然后后面跟数组名称，本文为results，然后跟[?(@.name&#x3D;&#x3D;‘function’)]，其中name是序列中的一个唯一值，可以根据需要修改，function是name实际为什么值就填什么，最后在加”.”后面跟你需要取的字段名如id，pah都行，只要在这个数组中存在</p>
<p> <img src="/assets/1/image-20220310180848-jkna4en.png" alt="image.png"></p>
</li>
<li><p>在给大家介绍一个经常用到的json 转换网站， <a href="https://www.json.cn/">https://www.json.cn/</a> 打开该网站，拷贝json格式响应结果到该网站，系统就会帮你自动转换成json层级格式，方便调试，如下所示</p>
<p> <img src="/assets/1/image-20220310180912-yqckvy7.png" alt="image.png"></p>
</li>
<li><p>我们之前通过json path取到的变量token，现在需要写入到信息头管理器，这样下面的请求才会被调用到，格式为${token}</p>
<p> <img src="/assets/1/image-20220310180927-3dcmt7l.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20220310180934-cetu5ts.png" alt="image.png"></p>
</li>
<li><p>JSON PATH语法如下列表，具体语法使用规则，还需要大家多多尝试，可以在察看结果树中切换成JSON Path Tester模式进行测试</p>
<p> <img src="/assets/1/image-20220310181008-e6gbt4g.png" alt="image.png"></p>
</li>
<li><p>末尾在给大家介绍JSON怎么通过一个提取器提取多个变量，多个变量时则每个变量用“；”间隔开，正则表达式、匹配序列、默认值也一样，需要用“；”隔开，下面先介绍当正则表达式取固定的序列的时候，填写的规则如下图</p>
<p> <img src="/assets/1/image-20220310181022-g26pabm.png" alt="image.png"></p>
</li>
<li><p>当表达式取任意序列时(匹配所有符合的值)，填写规则如下图</p>
<p> <img src="/assets/1/image-20220310181035-d7kaned.png" alt="image.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter脚本录制</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/09_jmeter%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6/</url>
    <content><![CDATA[<h2 id="配置JMeter"><a href="#配置JMeter" class="headerlink" title="配置JMeter"></a>配置JMeter</h2><ol>
<li><p>打开JMeter，并新增一个线程组（选中“测试计划”，右键选择“添加” -&gt; “Threads (Users)” -&gt; “线程组”），如下图所示：</p>
<p> <a href=""><img src="/assets/1/image-20211210100851-rgrip8q.png" alt="image.png"></a></p>
</li>
<li><p>添加“HTTP代理服务器”</p>
<p> 选中“工作台”，右键选择“添加” -&gt; “非测试元件” -&gt; “HTTP代理服务器”，如下图所示：</p>
<p> <img src="/assets/1/image-20211210100858-3hys0sy.png" alt="image.png"></p>
</li>
<li><p>配置HTTP代理服务器，如下图所示：</p>
<ol>
<li>打开新增的HTTP代理服务器，修改目标控制器为”测试计划 &gt; 线程组“</li>
<li>修改分组为“每个组放入一个新的控制器”</li>
<li>还根据需要可以修改代理端口号（默认8888）等配置</li>
</ol>
<p> <a href=""><img src="/assets/1/image-20211210100903-lbzw22o.png" alt="image.png"></a></p>
</li>
<li><ol start="4">
<li>选择“Requests Filtering”，在“包含模式”中填入“.+(baidu.com).+”用以过滤非baidu.com的请求</li>
<li>同时在“排除模式”中填入“(?i).*.(bmp|css|js|gif|ico|jpe?g|png|swf|woff|woff2|htm|html).”用以过滤js、图片、html等资源文件请求</li>
<li>最后点击“启动”按钮启动HTTP代理，如下图所示：</li>
</ol>
<p> <a href=""><img src="/assets/1/image-20211210100907-xhe41n6.png" alt="image.png"></a></p>
<p> <strong>END</strong></p>
</li>
</ol>
<h2 id="录制脚本"><a href="#录制脚本" class="headerlink" title="录制脚本"></a>录制脚本</h2><ol>
<li><p>配置代理</p>
<p> 打开IE浏览器，点击右上方工具按钮，依次选择“Internet选项” -&gt; “连接” -&gt; “局域网设置” -&gt; “代理服务器”，勾选“为LAN使用代理服务器”，输入本地IP地址127.0.0.1及端口号8888，点击确定保存，如下图所示：</p>
<p> <a href=""><img src="/assets/1/image-20211210100912-26k2b0p.png" alt="image.png"></a></p>
</li>
<li><p>访问页面</p>
<p> 使用IE浏览器打开百度首页，并进行一次搜索（如搜索lovesoo）；若页面提示“此网站的安全证书存在问题”，点击“继续浏览此网站(不推荐) ”即可，如下图所示：</p>
<p> <a href=""><img src="/assets/1/image-20211210100917-yn5vsdk.png" alt="image.png"></a></p>
<p> <strong>END</strong></p>
</li>
</ol>
<h2 id="脚本处理"><a href="#脚本处理" class="headerlink" title="脚本处理"></a>脚本处理</h2><ol>
<li><p>现在我们打开JMeter查看我们刚才录制的脚本，可以看到JMeter录制了整个流程的请求，包括开始的搜索建议，访问首页请求，获取搜索历史及搜索等请求，如下图所示：</p>
<p> <a href=""><img src="/assets/1/image-20211210100921-lj9tq23.png" alt="image.png"></a></p>
</li>
<li><p>此时，我们需要对这些HTTP请求做一些删除操作，只保留访问首页及搜索的请求，如下图所示：</p>
<p> <a href=""><img src="/assets/1/image-20211210100926-hyot478.png" alt="image.png"></a></p>
</li>
<li><p>然后，我们添加“查看结果树”及“聚合报告”，点击运行即可查询相应的搜索结果，如下图所示：</p>
<p> <a href=""><img src="/assets/1/image-20211210100930-qn83bfp.png" alt="image.png"></a></p>
</li>
<li><p>最后，我们还可以对接口进行响应的参数化及断言，用以校验HTTP请求返回值是否正确，如下图所示：</p>
<p> <a href=""><img src="/assets/1/image-20211210100934-4sxodie.png" alt="image.png"></a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter正则表达式详解</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/07_jmeter%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>二、正则表达式提取器</p>
<ol>
<li><p>正则表达式也是我们在开发案例过程中用的最多的一种提取器，他支持对各种格式的响应结果进行提取，比如application&#x2F;json、HTML格式等等</p>
<p> <img src="/assets/1/image-20220310181104-6c4x6qh.png" alt="image.png"></p>
</li>
<li><p>首先在需要提前变量的HTTP请求点击右键》添加》后置处理器》正则表达式提取器</p>
<p> <img src="/assets/1/image-20220310181111-jer2dz0.png" alt="image.png"></p>
</li>
<li><p>正则表达式提取器，变量应用范围，默认选择Main sample only即可，要检查的响应字段选择主体</p>
<p> <img src="/assets/1/image-20220310181118-854pmzh.png" alt="image.png"></p>
</li>
<li><p>下面给大家讲解写怎么写正则表达式，只有写出正确的正则表达式，才能获取到我们需要的变量值，默认我们jmeter的察看结果树显示的结果是Text文本格式，所以需要把查看结果树的显示格式改成RegExp Tester，上面已经介绍了，这种可以支持写出正则，然后进行调试，看取值是否正确</p>
<p> <img src="/assets/1/image-20220310181126-moq19ue.png" alt="image.png"></p>
</li>
<li><p>我们写正则，只需要拷贝变量所在的左右边界，data”:“c7a86d03-4684-4302-9456-e4f15e849368”, 然后把需要取的变量替换成(.)即可，“data”:”(.)”, 该表达式即是我们需要的效果，当然如果返回的响应结果有很多相同的左右边界，这时候还需要细化正则(本人经验，返回结果为application&#x2F;json格式的都用json path取值，不用正则)</p>
</li>
<li><p>正则表达式，具体语法使用规则参考<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a> ，还需要大家多多尝试，可以在察看结果树中切换成RegExp Tester模式进行测试</p>
 <br /></li>
</ol>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter简单操作(四)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/06_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E5%9B%9B)/</url>
    <content><![CDATA[<p>使用cookie来请求网页：</p>
<p><img src="/assets/1/image-20211207112735-xvj9yck.png" alt="image.png"></p>
<p>假设我需要在登录后的某个页面进行下发请求操作</p>
<p><img src="/assets/1/image-20211207112743-ngk2o9t.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112750-tk57rd2.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112757-slim33r.png" alt="image.png"></p>
<p>我直接在jmeter中使用请求下发</p>
<p><img src="/assets/1/image-20211207112807-b1gz6i3.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112815-5vuwvkh.png" alt="image.png"></p>
<p>此时需要用到cookie来通过认证</p>
<p><img src="/assets/1/image-20211207112821-9nkyp6u.png" alt="image.png"></p>
<p>此时我们添加一个Http Cookie管理器，来管理cookie值</p>
<p><img src="/assets/1/image-20211207112829-fekt06f.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112838-xxl71hr.png" alt="image.png"></p>
<p>再次点击执行，观察结果</p>
<p><img src="/assets/1/image-20211207112844-cwoz4ef.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter简单操作(三)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/05_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%89)/</url>
    <content><![CDATA[<p>Jmeter参数化方法：</p>
<ol>
<li>直接自定义入参<br> 举例：当前需要实现5个请求，请求中包含一个参数输入，需要分别读取5个不同值进行请求<br> 步骤1：设置一个线程组，在线程组下添加一个用户定义变量的配置元件；</li>
<li><img src="/assets/1/image-20211207112358-g2u7b44.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211207112408-11olk9s.png" alt="image.png"></li>
</ol>
<p>步骤2：添加5个请求，每个请求中参数通过${用户定义的变量名}的方式读取值；</p>
<p><img src="/assets/1/image-20211207112415-t1zp0q5.png" alt="image.png"></p>
<p>步骤3：点击执行，并观察执行结果；</p>
<p><img src="/assets/1/image-20211207112421-6vqwrb2.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112427-3i28sdh.png" alt="image.png"></p>
<ol start="2">
<li>使用CSV Data Set Config的设置，从csv文件导入<br> 举例：当前需要实现一个请求，请求中包含一个参数输入，需要分别读取5个不同值进行请求<br> 步骤1：设置一个线程组，假设需要包含一共有5个参数入参，则设置循环次数为5次；</li>
<li><img src="/assets/1/image-20211207112434-dk9k02r.png" alt="image.png"></li>
</ol>
<p>步骤2：在一个目录中创建一个CSV文件，变量名写在第一行（也可以不写变量名，当不写变量名时，添加CSV数据文件配置中需要设置一下指定读取参数是否忽略首行），当然此处不仅仅可以读取csv文件，也可以读取txt文件之类的，此处我们用csv文件作为例子；</p>
<p><img src="/assets/1/image-20211207112441-h3u0ge2.png" alt="image.png"></p>
<p>步骤3：在线程组下添加一个CSV数据文件配置的配置元件，根据实际需要来进行配置；</p>
<p><img src="/assets/1/image-20211207112447-ta1gwgb.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112452-kto9lah.png" alt="image.png"></p>
<p>步骤4：添加察看结果树，并将结果保存到一个指定文件；</p>
<p><img src="/assets/1/image-20211207112459-ymiepcc.png" alt="image.png"></p>
<p>步骤5：点击执行，并观察执行结果；</p>
<p><img src="/assets/1/image-20211207112505-ochla6s.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112510-jn8tkga.png" alt="image.png"></p>
<ol start="3">
<li>使用计数器，来输入<br> 举例：当前需要实现一个请求，请求中包含一个参数输入，这5个参数可以是前缀+数值递增的格式，需要分别读取5个不同值进行请求<br> 步骤1：设置一个线程组，假设需要包含一共有5个参数入参，则设置循环次数为5次；</li>
<li><img src="/assets/1/image-20211207112518-2c7xdd8.png" alt="image.png"></li>
</ol>
<p>步骤2：添加一个计数器，并设置输出的格式和参数变量名，我们此处举例是需要输入的参数为maowei-001、maowei-002、maowei-003、maowei-004、maowei-005，具体配置如下图所示；</p>
<p><img src="/assets/1/image-20211207112526-x0cpevn.png" alt="image.png"></p>
<p>步骤3：添加请求和查看结果树，具体操作如上一种方法所示；</p>
<p><img src="/assets/1/image-20211207112531-d8yjv77.png" alt="image.png"></p>
<p>步骤4：点击执行并查看执行结果；</p>
<p><img src="/assets/1/image-20211207112539-khj9gmq.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112544-pca74ss.png" alt="image.png"></p>
<ol start="4">
<li>使用随机函数来生成随机值</li>
<li><img src="/assets/1/image-20211207112549-byih28h.png" alt="image.png"></li>
</ol>
<p>4.1使用__Random函数来实现随机生成数值</p>
<p><img src="/assets/1/image-20211207112556-8vljx1e.png" alt="image.png"></p>
<p>将函数式复制到请求页面的变量值输入框中，可以在函数式前面加想要输入的字符串前缀，例如maowei-，后面接随机值</p>
<p><img src="/assets/1/image-20211207112605-d8lpmd3.png" alt="image.png"></p>
<p>点击执行，可以查看结果，【注意】此随机值函数，可以产生入值参数重复的情况，假如不想入参出现重复，建议不要使用这种方式</p>
<p><img src="/assets/1/image-20211207112611-9z64wa2.png" alt="image.png"></p>
<p>4.2使用__RandomDate函数来实现随机生成数值</p>
<p><img src="/assets/1/image-20211207112618-z7bjnzp.png" alt="image.png"></p>
<p>点击执行，可以查看结果，【注意】此随机值函数，可以产生入值参数重复的情况，假如不想入参出现重复，建议不要使用这种方式</p>
<p><img src="/assets/1/image-20211207112625-0je5puy.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112631-g8flyis.png" alt="image.png"></p>
<p>4.3使用__RandomString函数来实现随机生成数值</p>
<p><img src="/assets/1/image-20211207112638-t4nxhld.png" alt="image.png"></p>
<p>点击执行，可以查看结果，【注意】此随机值函数，概率性产生入值参数重复的情况，假如不想入参出现重复，建议不要使用这种方式</p>
<p><img src="/assets/1/image-20211207112645-l8ytl87.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112658-y6oy4lk.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter简单操作(二)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/04_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%BA%8C)/</url>
    <content><![CDATA[<p>基础界面配置：<br>配置日志：</p>
<p><img src="/assets/1/image-20211207112138-drx2f7r.png" alt="image.png"></p>
<p>选择界面的显示语言：</p>
<p><img src="/assets/1/image-20211207112147-bxkf3xx.png" alt="image.png"></p>
<p>配置界面字体大小：<br>修改Body体内的字体大小<br>修改Jmeter文件目录中&#x2F;bin&#x2F;jmeter.properties文件中的font相关参数<br>jsyntaxtextarea.font.family&#x3D;Hack 和 jsyntaxtextarea.font.size&#x3D;20 ,将#去掉，修改完成之后，重启jmeter生效</p>
<p><img src="/assets/1/image-20211207112201-qtpz1co.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112206-kvvl5as.png" alt="image.png"></p>
<p>配置界字体大小<br>修改Jmeter文件目录中&#x2F;bin&#x2F;jmeter.properties文件中的hidpi相关参数<br>jmeter.hidpi.mode&#x3D;true 和 jmeter.hidpi.scale.factor&#x3D;2.0 ,将#去掉，修改完成之后，重启jmeter生效</p>
<p><img src="/assets/1/image-20211207112215-y94l0vc.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207112220-29jond2.png" alt="image.png"></p>
<p>自定义字体大小<br>临时使用时，可以使用一直按着“Ctrl”键，上下滚动鼠标，来自定义字体大小，哪种大小字体舒服就可以自己调节选择，但是这种和以上2种方式不同之处在于，这个不能保存配置，重启Jmeter之后会还原到默认配置大小，但是这种修改方式比较人性化，而且很容易操作。</p>
<p><img src="/assets/1/20191031102614715-20211207112241-mqxwvh4.gif" alt="20191031102614715.gif"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter简单操作(一)</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/03_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%80)/</url>
    <content><![CDATA[<p>线程组：<br>线程组相当于有多个用户,同时去执行相同的任务。每个线程之间都互不影响</p>
<p><img src="/assets/1/image-20211207111207-cgulay1.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111221-u033b3i.png" alt="image.png"></p>
<p>新建一个HTTP请求：<br>服务器名称或IP、端口号 ：配置目标服务器名称或者IP地址，端口号默认情况下为80，也可以指定其它端口号。<br>方法：发送请求的具体方法，可以是GET、POST等。路径：配置路径，注意在填写路径时服务器地址、端口及参数不需要，只需要填写剩余后的部分。<br>Content encoding ：编码方式。此处采用utf-8，如果为空，则表示采用ISO-8859-1编码。<br>参数配置：表中每行表示一个参数（与URL中的 name&#x3D;value相对应）</p>
<p><img src="/assets/1/image-20211207111232-3t1zd5x.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111239-9qwa1pt.png" alt="image.png"></p>
<p>常用监听器：</p>
<p><img src="/assets/1/image-20211207111245-txqh89u.png" alt="image.png"></p>
<p>聚合报告：<br>与Summary Report类似，但是表格中的内容有些许区别。聚合报告：记录这次却被行测试总请求数、错误率、用户响应时间（中间值、90%、最少、最大）、吞吐量等，用以帮助分析被测试系统的性能。</p>
<p><img src="/assets/1/image-20211207111253-vs9pyi1.png" alt="image.png"></p>
<p>查看结果树:<br>调试利器。想必大家也都经常用，不做介绍。有点类似我们的抓包，可以看到request以及response信息。</p>
<p><img src="/assets/1/image-20211207111302-fp1kwwa.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111312-9ir0et8.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111321-893xldm.png" alt="image.png"></p>
<p>图形结果:<br>样本数目：是总共发送到服务器的请求数。<br>最新样本：表示服务器相应最后一个请求的响应时间。<br>吞吐量：服务器每分钟处理的请求数。<br>平均值：是总运行时间除以发送到服务器的请求数（平均响应时间）。<br>中间值：一半的响应时间请求高于该值。<br>偏离：代表服务器相应时间变化的数据的分布</p>
<p><img src="/assets/1/image-20211207111328-i3hsb3g.png" alt="image.png"></p>
<p>用表格查看结果：<br>Sample：每个请求的序号<br>Start Time：每个请求开始时间<br>Thread Name：每个线程的名称<br>Label：Http请求名称<br>Sample Time：每个请求所花时间，单位毫秒<br>Status：请求状态，如果为勾则表示成功，如果为叉表示失败。<br>Bytes：请求的字节数<br>样本数目：也就是上面所说的请求个数，成功的情况下等于你设定的并发数目乘以循环次数<br>平均：每个线程请求的平均时间<br>最新样本：表示服务器响应最后一个请求的时间<br>偏离：服务器响应时间变化、离散程度测量值的大小，或者，换句话说，就是数据的分布。</p>
<p><img src="/assets/1/image-20211207111336-8h91k3w.png" alt="image.png"></p>
<p>常用工具栏图标：</p>
<p><img src="/assets/1/image-20211207111401-w2pchol.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111407-tpdyjyy.png" alt="image.png"></p>
<p>断言：</p>
<p><img src="/assets/1/image-20211207111648-1v3brno.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111655-h9ytrp1.png" alt="image.png"></p>
<p>响应断言</p>
<p><img src="/assets/1/image-20211207111701-hpna2yu.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111707-e81ybg5.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111717-knn6per.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111729-g4sghej.png" alt="image.png"></p>
<p>持续时间断言</p>
<p><img src="/assets/1/image-20211207111735-f8nugga.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111740-e1wtvwy.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111745-vs7931a.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111758-nwm8m8o.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111803-q0flrz5.png" alt="image.png"></p>
<p>字节断言</p>
<p><img src="/assets/1/image-20211207111809-5z3mecx.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111814-758zhjf.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111820-getemqo.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111826-x2umgq5.png" alt="image.png"></p>
<p>输出性能报告：</p>
<p><img src="/assets/1/image-20211207111153-gy9athg.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111147-u7lzeyv.png" alt="image.png"></p>
<p>输入以下命令，进行性能测试并输出CSV执行结果文件和HTML报告<br>jmeter -n -t C:\temp\jmeter.jmx -l C:\temp\jmeterfile\test.csv -e -o C:\temp\jmetertest<br>三个路径依次是：xxx.jmx文件路径，输出xxx.csv文件路径，要保存的http report的文件路径<br>[注意]当这个两个目录已经生成了文件时，请先清除或者备份，保持目录为空时，在执行以下操作</p>
<p><img src="/assets/1/image-20211207111139-v05fczw.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111128-9f04e1l.png" alt="image.png"></p>
<p><img src="/assets/1/image-20211207111120-of6rwip.png" alt="image.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20191030172706725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA0Njk3NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter界面介绍</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/02_jmeter%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p> JMeter主界面主要分为 标题栏、菜单栏、工具栏、测试计划树形目录、内容展示区</p>
<p> <img src="/assets/1/image-20211207110936-8xa0kh8.png" alt="image.png"></p>
<p> 标题栏：主要展示JMeter的程序版本、当前脚本的名称、脚本的储存路径</p>
<p> 菜单栏：程序基本上所有功能的所属分类目录，基本上可以通过菜单栏对程序进行所有的操作</p>
<p> 工具栏：可以理解为菜单栏中某些功能的快捷按钮</p>
<p> 测试计划树形目录：以树形结构展示测试计划的内容标签，可以理解为用例名称，通过点击标签查看任意标签的内容</p>
<p> 内容展示区：对当前所选树形目录的标签内容进行展示，当日志输出框显示时，还可以看到程序的运行日志记录</p>
<h2 id="菜单详解"><a href="#菜单详解" class="headerlink" title="菜单详解"></a>菜单详解</h2><h3 id="文件："><a href="#文件：" class="headerlink" title="文件："></a>文件：</h3><p> 　　　　新建：新建一个空白的测试计划</p>
<p> 　　　　Templates&lt;模板&gt;：对于一些常用功能的示例模板，点击模板中的链接可跳转到官方的介绍页面</p>
<p> 　　　　打开：弹出路径选择框，可选择并打开一个新的JMX格式的脚本文件</p>
<p> 　　　　Open Recent&lt;最近打开&gt;:显示最近打开过的脚本记录，选择后可打开对应的脚本</p>
<p> 　　　　合并：将多个JMX文件合并成一个文件，指将所选文件的内容合并到当前文件中来</p>
<p> 　　　　保存测试计划：就字面意思，保存整个测试计划</p>
<p> 　　　　保存测试计划为：类似于文本编辑器中的另存为，保存的是整个测试计划</p>
<p> 　　　　选中部分保存为：仅保存选择部分，类似于选中部分另存为XXX</p>
<p> 　　　　save as Test fragment：保存为测试片段，其中测试计划、测试组是不能被保存为测试片段的&lt;4.0之前的版本工作台也是不能保存的,4.0开始工作台被去掉了&gt;。</p>
<p> 　　　　Revert：还原,还原到上次保存时的状态</p>
<p> 　　　　退出：关闭程序</p>
<h3 id="编辑："><a href="#编辑：" class="headerlink" title="编辑："></a>编辑：</h3><p> 　　　　添加：根据当前再树形标签页中所选中的标签，来显示不同的添加内容</p>
<p> 　　　　粘贴：就是粘贴，将复制的部分粘贴过来</p>
<p> 　　　　打开：等同于文件—打开</p>
<p> 　　　　合并：等同于文件—合并</p>
<p> 　　　　选中部分另存为：等同于文件—选中部分保存为</p>
<p> 　　　　Save Node As Image:保存节点为图片，只会截取并保存右侧内容显示区域</p>
<p> 　　　　Save Screen As Image:保存屏幕为图片，会保存整个jmeter程序的界面</p>
<p> 　　　　启用：对当前选中的标签进行启用操作</p>
<p> 　　　　禁用：对当前选中的标签进行禁用操作</p>
<p> 　　　　Toggle：切换，对当前选中的标签进行禁用&#x2F;启用切换操作，禁用变启用、启用变禁用</p>
<p> 　　　　帮助：跳到官方帮助文档页面</p>
<h3 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a>搜索：</h3><p> 　　　　Search：查询功能，查找到的内容会在树形结构中框红显示</p>
<p> 　　　　Reset Search：重置查询，对前面框红的内容进行清除</p>
<h3 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h3><p> 　　　　启动：运行测试计划</p>
<p> 　　　　Start no pauses:不停顿启动，运行测试计划，但会忽略测试计划中的定时器等待</p>
<p> 　　　　远程启动：分布式测试时使用，指定启动一个远程agent运行。</p>
<p> 　　　　远程全部启动：分布式测试时使用，启动所有的远程agent运行。</p>
<p> 　　　　停止：停止执行测试计划。</p>
<p> 　　　　关闭：没发现于停止有啥区别，但肯定有区别，哈哈。</p>
<p> 　　　　远程停止：分布式测试时使用，指定停止一个远程agent运行。</p>
<p> 　　　　远程全部停止：分布式测试时使用，停止所有的远程agent运行。</p>
<p> 　　　　远程关闭：类似于远程停止。</p>
<p> 　　　　远程全部关闭：类似于远程全部停止。</p>
<p> 　　　　远程退出：</p>
<p> 　　　　远程全部退出：</p>
<p> 　　　　清除：清除当前所选标签的执行结果，貌似只对监听器有用。</p>
<p> 　　　　清除全部：清除当前计划中的所有监听器的执行结果。</p>
<h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><p> 　　　　函数助手对话框：弹出函数助手弹窗，可快速生成需要的代码</p>
<p> 　　　　外观：可用改变jmeter的界面风格主题。</p>
<p> 　　　　Log Viewer：打开\关闭日志输出框</p>
<p> 　　　　Log Level：设定运行输出日期的等级</p>
<p> 　　　　SSL管理器：导入外置的SSL管理器，用于更好的管理证书。</p>
<p> 　　　　选择语言：改变界面的语言种类，适配不完善的地方依旧使用的英语。</p>
<p> 　　　　Collapse All：展开所有的菜单</p>
<p> 　　　　Expand All: 折叠所有的菜单</p>
<p> 　　　　Zoom In：放大，页面中的文字整体放大</p>
<p> 　　　　Zoom Out：缩小，页面中的文字整体缩小</p>
<p> 　　　　Save automatically before run：翻译过来是保存之前自动运行，但没发现实际意义</p>
<p> 　　　　Plugins Manager：插件管理器</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git篇</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/09_git%E7%AF%87/01_git%E7%AF%87/</url>
    <content><![CDATA[<p>文章目录<br>转载地址<br>Git简介<br>Git安装（仅列出在Windows系统下的安装过程）<br>Git本地仓库操作<br>创建版本库<br>修改文件<br>版本回退<br>工作区和暂存区<br>管理修改<br>撤销修改<br>删除文件&#96;<br>Git与远程仓库交互<br>远程仓库准备工作<br>添加远程库<br>从远程库克隆<br>创建与合并分支<br>bug分支<br>多人协作</p>
<ol>
<li>推送分支：</li>
<li>抓取分支：<br> 工作使用Git<br> 如何在Windows的cmd 中使用linux的命令<br> 思维导图<br> 转载地址<br> <a href="https://blog.csdn.net/weixin_42152081/article/details/80558282?utm_source=app&app_version=4.7.0&code=app_1562916241&uLinkId=usr1mkqgl919blen">Git教程（完整）</a><br> <a href="https://blog.csdn.net/u011535541/article/details/83379151?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-12.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-12.control">Git使用教程</a><br> <a href="https://pypypy.blog.csdn.net/article/details/104551896">git使用教程</a></li>
</ol>
<p>Git简介<br>Git是目前世界上最先进的分布式版本控制系统，在处理各种项目时都十分高效，而且非常的高大上。</p>
<p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。而且集中式版本控制系统是必须联网才能工作。</p>
<p>Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。</p>
<p>Git安装（仅列出在Windows系统下的安装过程）<br>打开Git官网下载安装程序，然后按照默认选项安装即可。</p>
<p>安装完成后，打开Git bash软件，弹出一个类似cmd的命令行窗口，证明安装成功。</p>
<p><img src="/assets/2/image-20220507195916-hlisywu.png" alt="image.png"></p>
<p>安装完成后，需要进行设置，在命令行输入以下代码：</p>
<blockquote>
<p>$ git config –global user.name “Your Name”<br>$ git config –global user.email “<a href="mailto:&#101;&#109;&#97;&#x69;&#108;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#109;">&#101;&#109;&#97;&#x69;&#108;&#64;&#101;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#109;</a>“</p>
</blockquote>
<p>顾名思义，这是设置你的名字和Email地址。</p>
<p>我们可以查看一下用户名和密码：</p>
<p>$ git config user.name<br>$ git config user.email<br>1<br>2<br>假如我们这时候报错，证明Git的用户名和密码没有配置成功，我们还可以这样做：</p>
<p>在用户主目录下找到 .git 文件夹：</p>
<p><img src="/assets/2/image-20220507200013-kkruo86.png" alt="image.png"></p>
<p>然后打开 config 文件，这是专门用来配置和读取相应的工作环境变量的，在里面加上如图所示内容：</p>
<p>这样也就完成了对Git用户名和邮箱的配置。</p>
<p>Git本地仓库操作<br>创建版本库<br>版本库(repository)也叫仓库，可以看做一个目录，这个目录里的所以文件都由Git进行管理，每个文件的修改、删除，Git都能跟踪。</p>
<p>1.选择一个合适的地方，创建一个空目录：</p>
<p>$ mkdir learngit &#x2F;&#x2F;创建一个名叫learngit的空目录<br>$ cd learngit &#x2F;&#x2F;把learngit设置为当前目录<br>$ pwd &#x2F;&#x2F;查看当前目录<br>&#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;learngit<br>1<br>2<br>3<br>4<br>如果使用Windows系统，要保证目录名不包含中文。</p>
<p>2.通过如下命令把这个目录变成Git可以管理的仓库：</p>
<p>$ git init<br>Initialized empty Git repository in &#x2F;Users&#x2F;Administrator&#x2F;learngit&#x2F;.git&#x2F;<br>1<br>2<br>这样Git就把仓库建好啦，我们可以看到在当前目录下多了一个 .git 的目录，这个目录是Git来跟踪管理版本库的。<br>3.把文件添加到版本库</p>
<p>我们在 learngit 目录下编写一个 readme.txt 文件，内容如下：</p>
<p>Git is a version control system.<br>Git is free software.<br>1<br>2<br>(1) 用 git add 命令，把文件添加到仓库：</p>
<p>$ git add readme.txt<br>1<br>执行以上命令，没有任何显示。</p>
<p>(2) 用 git commit 命令，把文件提交到仓库：</p>
<p>$ git commit -m “wrote a readme file” &#x2F;&#x2F;-m后面输入的是本次提交的说明，可以输入任意内容。<br>[master (root-commit) eaadf4e] wrote a readme file<br> 1 file changed, 2 insertions(+) &#x2F;&#x2F;1 file changed：1个文件被改动（新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt内有两行内容）<br> create mode 100644 readme.txt<br>1<br>2<br>3<br>4<br>修改文件<br>我们已经成功添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容：</p>
<p>Git is a distributed version control system.<br>Git is free software.<br>1<br>2<br>运行 git status 命令：</p>
<p>$ git status &#x2F;&#x2F;查看仓库当前的状态<br>On branch master<br>Changes not staged for commit: &#x2F;&#x2F;没有文件将要被提交<br>  (use “git add <file>…” to update what will be committed)<br>  (use “git checkout – <file>…” to discard changes in working directory)</p>
<pre><code>modified:   readme.txt
</code></pre>
<p>no changes added to commit (use “git add” and&#x2F;or “git commit -a”)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>上面的命令告诉我们，readme.txt 文件被修改过了，但还没有准备提交的修改。</p>
<p>如果我们想知道上次是怎么修改readme.txt 文件的，需要用 git diff 命令：</p>
<p>$ git diff readme.txt<br>diff –git a&#x2F;readme.txt b&#x2F;readme.txt<br>index 46d49bf..9247db6 100644<br>— a&#x2F;readme.txt<br>+++ b&#x2F;readme.txt<br>@@ -1,2 +1,2 @@<br>-Git is a version control system. &#x2F;&#x2F;这一句是被删掉的<br>+Git is a distributed version control system. &#x2F;&#x2F;这一句是新添加的<br> Git is free software.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>接下来还是那两步：</p>
<p>(1) git add</p>
<p>$ git add readme.txt<br>1<br>没有任何输出，这时候可以用 git status 查看一下当前仓库状态：</p>
<p>$ git status<br>On branch master<br>Changes to be committed: &#x2F;&#x2F;将要被提交的文件包括 readme.txt<br>  (use “git reset HEAD <file>…” to unstage)</p>
<pre><code>modified:   readme.txt
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>(2) git commit</p>
<p>$ git commit -m “add distributed”<br>[master e475afc] add distributed<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br>1<br>2<br>3<br>再用 git status 查看一下当前仓库状态：</p>
<p>$ git status<br>On branch master<br>nothing to commit, working tree clean &#x2F;&#x2F;当前没有需要提交的修改，而且，工作目录是干净的。<br>1<br>2<br>3<br>版本回退<br>如果我们继续对 readme.txt 文件进行修改，改成如下内容：</p>
<p>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>1<br>2<br>然后添加并提交：</p>
<p>$ git add readme.txt<br>$ git commit -m “append GPL”<br>[master 1094adb] append GPL<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br>1<br>2<br>3<br>4<br>到目前为止，readme.txt 文件一共有三个版本被提交到了 Git 仓库里，我们可以用 git log 命令进行查看：</p>
<p>$ git log &#x2F;&#x2F;查看历史记录<br>commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)<br>Author: Michael Liao <a href="mailto:&#97;&#x73;&#x6b;&#120;&#117;&#101;&#102;&#x65;&#110;&#103;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;">&#97;&#x73;&#x6b;&#120;&#117;&#101;&#102;&#x65;&#110;&#103;&#64;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;</a><br>Date:   Fri May 18 21:06:15 2018 +0800</p>
<pre><code>append GPL
</code></pre>
<p>commit e475afc93c209a690c39c13a46716e8fa000c366<br>Author: Michael Liao <a href="mailto:&#x61;&#115;&#107;&#x78;&#117;&#101;&#102;&#101;&#x6e;&#103;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;">&#x61;&#115;&#107;&#x78;&#117;&#101;&#102;&#101;&#x6e;&#103;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;</a><br>Date:   Fri May 18 21:03:36 2018 +0800</p>
<pre><code>add distributed
</code></pre>
<p>commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0<br>Author: Michael Liao <a href="mailto:&#x61;&#x73;&#107;&#120;&#x75;&#x65;&#x66;&#101;&#x6e;&#103;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;">&#x61;&#x73;&#107;&#120;&#x75;&#x65;&#x66;&#101;&#x6e;&#103;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a><br>Date:   Fri May 18 20:59:18 2018 +0800</p>
<pre><code>wrote a readme file
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>我们还可以加上 –pretty&#x3D;oneline 参数：</p>
<p>$ git log –pretty&#x3D;oneline<br>1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL<br>e475afc93c209a690c39c13a46716e8fa000c366 add distributed<br>eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file &#x2F;&#x2F;一大串数字是 commit id ，而且每个人的都不一样。<br>1<br>2<br>3<br>4<br>好了，现在如果我们想把 readme.txt 文件退回到上一个版本，就可以使用 git reset 命令：</p>
<p>$ git reset –hard HEAD^ &#x2F;&#x2F;HEAD表示当前版本，则HEAD^表示上一个版本，那么上上版本就是HEAD^^<br>HEAD is now at e475afc add distributed<br>1<br>2<br>这时候用 cat 命令查看一下 readme.txt 的内容：</p>
<p>$ cat readme.txt &#x2F;&#x2F;查看 readme.txt 文件的内容<br>Git is a distributed version control system.<br>Git is free software.<br>1<br>2<br>3<br>果然 readme.txt 文件返回到了上一个版本。</p>
<p>我们现在想要回到最新的版本，还是使用 git reset 命令：</p>
<p>$ git reset –hard 1094a &#x2F;&#x2F;这里不能用HEAD而必须使用 commit id ，因为最新版本在之前返回时已经被删除了，1094a就是最新版本的 commit id，可以在之前的代码中查到<br>HEAD is now at 83b0afe append GPL<br>1<br>2<br>这时再查看一下 readme.txt 文件内容：</p>
<p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>1<br>2<br>3<br>果然，又回到了最新的版本</p>
<p>工作区和暂存区<br>工作区（Working Directory）</p>
<p>learngit 文件夹就是一个工作区。</p>
<p>版本库（Repository）</p>
<p>工作区有个隐藏目录 .git ，这个不算工作区，而是 Git 的版本库。</p>
<p>版本库里面的 index(stage) 文件叫暂存区，还有Git为我们自动创建的第一个分支 master ，以及指向 master 的一个指针叫做 HEAD。</p>
<p><img src="/assets/2/image-20220507200142-lfxgbjm.png" alt="image.png"></p>
<p>前面我们提到过，如果我们想把文件添加到Git里面时，需要分两步：</p>
<p>第一步是用 git add 把文件添加进去，实际上就是把文件修改添加到暂存区。</p>
<p>第二步是用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支。（我们现在只有唯一一个分支 master，所以现在就是往 master 分支上提交更改）</p>
<p>我们可以实践一下：</p>
<p>在 readme.txt 文件中加上一行内容：</p>
<p>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>1<br>2<br>3<br>然后在工作区新建一个 LICENSE 文本文档（任意内容）</p>
<p>使用两次 git add 命令分别把 readme.txt 和 LICENSE 都添加后，可以用 git status 命令查看一下：</p>
<p>$ git status<br>On branch master<br>Changes to be committed:<br>  (use “git reset HEAD <file>…” to unstage)</p>
<pre><code>new file:   LICENSE
modified:   readme.txt
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>现在，暂存区的状态就变成这样了：</p>
<p><img src="/assets/2/image-20220507200154-0zls1qv.png" alt="image.png"></p>
<p>再使用 git commit 命令把暂存区的所有修改提交到分支：</p>
<p>$ git commit -m “understand how stage works”<br>[master e43a48b] understand how stage works<br> 2 files changed, 2 insertions(+)<br> create mode 100644 LICENSE<br>1<br>2<br>3<br>4<br>这时候的工作区就是干净的：</p>
<p>$ git status<br>On branch master<br>nothing to commit, working tree clean<br>1<br>2<br>3<br>这时候版本库就变成了这样：</p>
<p><img src="/assets/2/image-20220507200206-crz6ggh.png" alt="image.png"></p>
<p>管理修改<br>Git 如此的优秀是因为，Git 跟踪并管理的不是文件，而是修改。</p>
<p>我们对 readme.txt 文件进行修改：</p>
<p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes.<br>1<br>2<br>3<br>4<br>5<br>然后，添加：</p>
<p>$ git add readme.txt<br>$ git status</p>
<h1 id="On-branch-master"><a href="#On-branch-master" class="headerlink" title="On branch master"></a>On branch master</h1><h1 id="Changes-to-be-committed"><a href="#Changes-to-be-committed" class="headerlink" title="Changes to be committed:"></a>Changes to be committed:</h1><h1 id="use-“git-reset-HEAD-…”-to-unstage"><a href="#use-“git-reset-HEAD-…”-to-unstage" class="headerlink" title="(use “git reset HEAD …” to unstage)"></a>(use “git reset HEAD <file>…” to unstage)</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="modified-readme-txt"><a href="#modified-readme-txt" class="headerlink" title="modified:   readme.txt"></a>modified:   readme.txt</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>然后再修改 readme.txt 文件：</p>
<p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes of files.&#96;&#96;&#96;<br>1<br>2<br>3<br>4<br>5<br>提交：</p>
<p>$ git commit -m “git tracks changes”<br>[master 519219b] git tracks changes<br> 1 file changed, 1 insertion(+)<br>1<br>2<br>3<br>这时候我们查看一下状态：</p>
<p>$ git status<br>On branch master<br>Changes not staged for commit:<br>  (use “git add <file>…” to update what will be committed)<br>  (use “git checkout – <file>…” to discard changes in working directory)</p>
<pre><code>modified:   readme.txt
</code></pre>
<p>no changes added to commit (use “git add” and&#x2F;or “git commit -a”)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>我们可以发现，第二次修改并没有被提交。</p>
<p>因为在工作区的第一次修改被放入暂存区，准备提交；而在工作区的第二次修改并没有被放入暂存区，所以， git commit 命令只负责把暂存区的修改提交了。</p>
<p>提交后，我们可以用 git diff HEAD – readme.txt 命令去查看工作区和版本库里面最新版本的区别：</p>
<p>$ git diff HEAD – readme.txt<br>diff –git a&#x2F;readme.txt b&#x2F;readme.txt<br>index 76d770f..a9c5755 100644<br>— a&#x2F;readme.txt<br>+++ b&#x2F;readme.txt<br>@@ -1,4 +1,4 @@<br> Git is a distributed version control system.<br> Git is free software distributed under the GPL.<br> Git has a mutable index called stage.<br>-Git tracks changes.<br>+Git tracks changes of files.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>撤销修改<br>假如说你在 readme.txt 文件中添加了一行内容如下：</p>
<p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes of files.<br>My stupid boss still prefers SVN.<br>1<br>2<br>3<br>4<br>5<br>6<br>最后一行是万万不能让BOSS看到的，应该怎么撤销呢？</p>
<p>(1) 没有 git add 之前</p>
<p>可以手动删除最后一行，手动把文件恢复到上一个版本的状态。然后再用 git checkout – file 命令丢弃工作区的修改</p>
<p>$ git checkout – readme.txt &#x2F;&#x2F;把readme.txt文件在工作区的修改全部撤销。<br>1<br>现在看一下 readme.txt 文件内容：</p>
<p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes of files.<br>1<br>2<br>3<br>4<br>5<br>果然复原了。</p>
<p>(2) git add了，但没有git commit</p>
<p>这时候的修改添加到了暂存区，但没有提交到分支，用git status查看一下：</p>
<p>$ git status<br>On branch master<br>Changes to be committed:<br>  (use “git reset HEAD <file>…” to unstage)</p>
<pre><code>modified:   readme.txt
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>这时候我们可以使用 git reset HEAD file 命令把把暂存区的修改撤销掉，重新放回工作区：</p>
<p>$ git reset HEAD readme.txt &#x2F;&#x2F;git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区，HEAD表示最新版本。<br>Unstaged changes after reset:<br>M    readme.txt<br>1<br>2<br>3<br>现在再用 git status 查看一下：</p>
<p>$ git status<br>On branch master<br>Changes not staged for commit:<br>  (use “git add <file>…” to update what will be committed)<br>  (use “git checkout – <file>…” to discard changes in working directory)</p>
<pre><code>modified:   readme.txt //暂存区是干净的，工作区有修改。
</code></pre>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>这时候再丢弃工作区的修改就OK了：</p>
<p>$ git checkout – readme.txt &#x2F;&#x2F;丢弃工作区的修改。</p>
<p>$ git status<br>On branch master<br>nothing to commit, working tree clean<br>1<br>2<br>3<br>4<br>5<br>终于大功告成了。</p>
<p>(3) 既 git add 了，也 git commit 了</p>
<p>可以回退到上一个版本，见回退版本内容。</p>
<p>删除文件&#96;<br>在工作区即 learngit 文件夹下新建一个 test.txt 文件，并添加和提交到Git：</p>
<p>$ git add test.txt</p>
<p>$ git commit -m “add test.txt”<br>[master b84166e] add test.txt<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test.txt<br>1<br>2<br>3<br>4<br>5<br>6<br>这时候可用 rm 命令删除：</p>
<p>$ rm test.txt<br>1<br>这时工作区和版本库就不一样了。</p>
<p>现在又分两种情况：</p>
<p>(1) 确实要从版本库中删除该文件，那就用 git rm 命令删除，并且 git commit：</p>
<p>$ git rm test.txt<br>rm ‘test.txt’</p>
<p>$ git commit -m “remove test.txt”<br>[master d46f35e] remove test.txt<br> 1 file changed, 1 deletion(-)<br> delete mode 100644 test.txt<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>这时候文件就从版本库被删除了。<br>(2) 文件被删错了。因为版本库里有，所以很好恢复：</p>
<p>$ git checkout – test.txt &#x2F;&#x2F;用版本库里的版本替换工作区的版本。<br>1<br>Git与远程仓库交互<br>远程仓库准备工作<br>在开始这部分之前，我们需要自行注册GitHub账号。而且，因为你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要设置：</p>
<p>(1) 创建SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有的话，看此目录下</p>
<p><img src="/assets/2/image-20220507200333-vwye9mw.png" alt="image.png"></p>
<p>有没有 id_rsa 和 id_rsa.pub 这两个文件，如果有，直接跳到下一步。如果没有，打开Git Bash，创建SSH</p>
<p>(2) 登陆GitHub，打开”Account settings”</p>
<p><img src="/assets/2/image-20220507200343-sclrfq2.png" alt="image.png"></p>
<p>然后点击”Add SSH and GPG Keys”，再点击”New SSH Key”进行SSH Key 的创建，填上任意 Title ，把 id_rsa.pub 中的内容复制到Key文本框内：</p>
<p><img src="/assets/2/image-20220507200352-c38yp2i.png" alt="image.png"></p>
<p>添加远程库<br>现在我们已经在本地创建了一个Git仓库了，又想在GitHub上创建一个Git仓库，然后让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。那么我们应该怎么做呢？</p>
<p>首先，登陆GitHub，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>
<p><img src="/assets/2/image-20220507200401-gerwzac.png" alt="image.png"></p>
<p>在Repository name填入 learngit （因为我已经创建完成了，所以提示此用户名存在）其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="/assets/2/image-20220507200409-ueso7yv.png" alt="image.png"></p>
<p>如上图所示我已经把本地仓库的内容推送到了GitHub上了，大家创建完以后应该是一个空的仓库。这时候我们可以在本地learngit仓库下运行命令：</p>
<p>$ git remote add origin <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:RFHzhj&#x2F;learngit.git &#x2F;&#x2F;“RFHzhj”是我的GitHub的账户名，你需要填写你自己的账户名<br>1<br>添加后，远程库的名字就是 origin ，这是Git默认的叫法。</p>
<p>然后，我们就可以把本地库的所有内容推送到远程库上：</p>
<p>$ git push -u origin master<br>Counting objects: 20, done.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (15&#x2F;15), done.<br>Writing objects: 100% (20&#x2F;20), 1.64 KiB | 560.00 KiB&#x2F;s, done.<br>Total 20 (delta 5), reused 0 (delta 0)<br>remote: Resolving deltas: 100% (5&#x2F;5), done.<br>To github.com:RFHzhj&#x2F;learngit.git</p>
<ul>
<li>[new branch]      master -&gt; master<br>Branch ‘master’ set up to track remote branch ‘master’ from ‘origin’.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>使用 git push 命令，就是把当前分支 master 推送到远程。</li>
</ul>
<p>因为远程库是空的，所以我们在第一次推送 master 分支时，要加上 -u 参数，Git不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>
<p><img src="/assets/2/image-20220507200422-9h9jrnv.png" alt="image.png"></p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<p>$ git push origin master<br>1<br>把本地 master 分支的最新修改推送至GitHub。现在，我们拥有了真正的分布式版本库。</p>
<p>从远程库克隆<br>我们的学习过程是先有了本地库，后有了远程库，然后再对远程库进行关联。</p>
<p>其实，我们大部分时候是先创建远程库，然后再从远程库克隆。<br>（截取从第二个转载连接的远程仓库部分进行转载）<br>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p>
<p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p>
<p>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p>
<p><img src="/assets/2/image-20220507200435-r2bolam.png" alt="image.png"></p>
<p>如下，我们看到：</p>
<p><img src="/assets/2/image-20220507200444-lf8dy3d.png" alt="image.png"></p>
<p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p>
<p><img src="/assets/2/image-20220507200452-8d1eoig.png" alt="image.png"></p>
<p>接着在我本地目录下 生成testgit2目录了，如下所示：</p>
<p><img src="/assets/2/image-20220507200459-6grha7b.png" alt="image.png"></p>
<p>创建与合并分支<br>在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p>
<p><img src="/assets/2/image-20220507200506-arsjbya.png" alt="image.png"></p>
<p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p>
<p>git branch dev</p>
<p>git checkout dev</p>
<p>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p>
<p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p>
<p><img src="/assets/2/image-20220507200513-hzo4stk.png" alt="image.png"></p>
<p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p>
<p><img src="/assets/2/image-20220507200520-53i1n9y.png" alt="image.png"></p>
<p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p>
<p><img src="/assets/2/image-20220507200529-2g2fj46.png" alt="image.png"></p>
<p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p>
<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>合并完成后，我们可以接着删除dev分支了，操作如下：</p>
<p><img src="/assets/2/image-20220507200550-r1l4a5j.png" alt="image.png"></p>
<p>总结创建与合并分支命令如下：</p>
<p>查看分支：git branch</p>
<p>创建分支：git branch name</p>
<p>切换分支：git checkout name</p>
<p>创建+切换分支：git checkout –b name</p>
<p>合并某分支到当前分支：git merge name</p>
<p>删除分支：git branch –d name</p>
<p>如何解决冲突？<br>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p>
<p><img src="/assets/2/image-20220507200602-9pmx2mb.png" alt="image.png"></p>
<p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p>
<p><img src="/assets/2/image-20220507200609-l8r3v1e.png" alt="image.png"></p>
<p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p>
<p><img src="/assets/2/image-20220507200618-g0t0yzf.png" alt="image.png"></p>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p>
<p><img src="/assets/2/image-20220507200625-itwxuwe.png" alt="image.png"></p>
<p>如果我想查看分支合并的情况的话，需要使用命令 git log 命令行演示如下：</p>
<p><img src="/assets/2/image-20220507200633-3zgtf4c.png" alt="image.png"></p>
<p>3.分支管理策略。 通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff 来禁用”Fast forward”模式。首先我们来做demo演示下：</p>
<p>创建一个dev分支。<br>修改readme.txt内容。<br>添加到暂存区。<br>切换回主分支(master)。<br>合并dev分支，使用命令 git merge –no-ff -m “注释” dev<br>查看历史记录<br>截图如下：</p>
<p><img src="/assets/2/image-20220507200642-xurq5wg.png" alt="image.png"></p>
<p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
<p>bug分支<br>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>
<p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p>
<p><img src="/assets/2/image-20220507200656-upvowcm.png" alt="image.png"></p>
<p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p>
<p><img src="/assets/2/image-20220507200705-gv9i4f0.png" alt="image.png"></p>
<p>所以现在我可以通过创建issue-404分支来修复bug了。</p>
<p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p>
<p><img src="/assets/2/image-20220507200713-cobq3ek.png" alt="image.png"></p>
<p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p>
<p><img src="/assets/2/image-20220507200720-t5kjmxl.png" alt="image.png"></p>
<p>现在，我们回到dev分支上干活了。</p>
<p><img src="/assets/2/image-20220507200730-cu0s1ef.png" alt="image.png"></p>
<p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list 来查看下。如下：</p>
<p><img src="/assets/2/image-20220507200738-uk13e10.png" alt="image.png"></p>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p>
<p>1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。<br>2.另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。<br>演示如下</p>
<p><img src="/assets/2/image-20220507200747-zfv1sag.png" alt="image.png"></p>
<p>多人协作<br>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p>
<p>要查看远程库的信息 使用 git remote</p>
<p>要查看远程库的详细信息 使用 git remote –v<br>如下演示：</p>
<p><img src="/assets/2/image-20220507200754-jm65prs.png" alt="image.png"></p>
<ol>
<li>推送分支：<br> 推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 使用命令 git push origin master</li>
</ol>
<p>比如我现在的github上的readme.txt代码如下：</p>
<p><img src="/assets/2/image-20220507200806-ou2rdju.png" alt="image.png"></p>
<p>本地的readme.txt代码如下：</p>
<p><img src="/assets/2/image-20220507200813-u2izoh6.png" alt="image.png"></p>
<p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p>
<p><img src="/assets/2/image-20220507200841-in0bcfd.png" alt="image.png"></p>
<p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p>
<p><img src="/assets/2/image-20220507200852-hyor60m.png" alt="image.png"></p>
<p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev</p>
<p>那么一般情况下，那些分支要推送呢？</p>
<p>master分支是主分支，因此要时刻与远程同步。<br>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</p>
<ol start="2">
<li>抓取分支：<br> 多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2</li>
</ol>
<p>但是我首先要把dev分支也要推送到远程去，如下</p>
<p><img src="/assets/2/image-20220507200905-bq9eypq.png" alt="image.png"></p>
<p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p>
<p><img src="/assets/2/image-20220507200913-7z5adse.png" alt="image.png"></p>
<p>现在目录下生成有如下所示：</p>
<p><img src="/assets/2/image-20220507200921-k7xy767.png" alt="image.png"></p>
<p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：</p>
<p>git checkout –b dev origin&#x2F;dev</p>
<p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p>
<p>如下：</p>
<p><img src="/assets/2/image-20220507200930-1mx9vw9.png" alt="image.png"></p>
<p>小伙伴们已经向origin&#x2F;dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p>
<p><img src="/assets/2/image-20220507200940-n959oa8.png" alt="image.png"></p>
<p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin&#x2F;dev抓下来，然后在本地合并，解决冲突，再推送。</p>
<p><img src="/assets/2/image-20220507200949-49am5ce.png" alt="image.png"></p>
<p>git pull也失败了，原因是没有指定本地dev分支与远程origin&#x2F;dev分支的链接，根据提示，设置dev和origin&#x2F;dev的链接：如下：</p>
<p><img src="/assets/2/image-20220507200957-wjs4io8.png" alt="image.png"></p>
<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：<br>我们可以先来看看readme.txt内容了。</p>
<p><img src="/assets/2/image-20220507201022-2visnno.png" alt="image.png"></p>
<p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</p>
<p><img src="/assets/2/image-20220507201029-vzd554q.png" alt="image.png"></p>
<p>因此：多人协作工作模式一般是这样的：</p>
<p>首先，可以试图用git push origin branch-name推送自己的修改.<br>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。<br>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送</p>
<p>工作使用Git<br>不墨迹直接上代码：<br>知道如何生成SSH KEY<br>知道know_hosts文件路径在哪儿<br>loading…<br>项目经理：<br>(1)项目经理搭建项目的框架。<br>(2)搭建完项目框架之后，项目经理把项目框架代码放到服务器。</p>
<p>普通员工：<br>(1)在自己的电脑上，生成ssh公钥，然后把公钥给项目经理，项目经理把它添加的服务器上面。<br>(2)项目经理会给每个组员的项目代码的地址，组员把代码下载到自己的电脑上。<br>(3)创建本地的分支dev,在dev分支中进行每天的开发。<br>(4)每一个员工开发完自己的代码之后，都需要将代码发布远程的dev分支上。</p>
<p>项目里一般会有两个分支，如：<br>Master:用于保存发布的项目代码。<br>Dev:用于保存开发过程中的代码。所有的组员开发完自己的代码提交到该分支上。<br>补充小技巧：<br>首先，整体认知一下工作中git常用的就这么几个命令：<br>步骤1.创建项目目录，如git_test【强烈建议返回到2.安装配置一节，学一学在windows中用mkdir git_test。工作中点来点去，文件夹一多就不爽了，学会在windows上用linux命令，工作效率谁用谁知道<del>】<br>步骤2.git init【如果你考皮github上别人的代码，必须将别人的.git文件删掉。步骤：进入项目目录，如git_test，cd git_test，ls -al，rm -rf .git】【工作中linux必会的，赶快回到2.安装配置一节，学一学在windows使用linux命令，这样就不用装linux环境了，简单胜于复杂</del>】<br>步骤3.git add .<br>步骤4.git commit -m “整体提交”<br>步骤5.git remote add origin&#x2F;github URL<br>add 后面的名字可以是【origin&#x2F;github】<br>URL是【你的github&#x2F;gitlab仓库地址】<br>步骤6.git checkout -b dev<br>步骤7.git push origin&#x2F;github dev<br>步骤8：权限控制允许了吗？</p>
<p>如何在Windows的cmd 中使用linux的命令<br>cmd的命令功能肯定没有linux的命令功能好用，这点毋庸置疑。<br>现在装好了Git，就可以在Windows的cmd中使用linux命令了。<br>记住关键词：环境变量 Git命令<br>怎么玩？如下2步操作：<br>假如你按照上述步骤将Git装在C盘，那么做如下操作：<br>操作1：找Git命令的【.exe文件】。如图：</p>
<p><img src="/assets/2/image-20220507201104-w87yt8a.png" alt="image.png"></p>
<p>操作2：添加到环境变量，就可以在cmd里使用linux命令了。如图：</p>
<p><img src="/assets/2/image-20220507201114-c6q4afi.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507201127-6qij2o1.png" alt="image.png"></p>
<p>最终效果：</p>
<p><img src="/assets/2/image-20220507201135-jzwr6gr.png" alt="image.png"></p>
<p>PyCharm也可以使用linux命令。【环境变量–全局—使用】</p>
<p><img src="/assets/2/image-20220507201143-a0dbf4m.png" alt="image.png"></p>
<p>备注：你可能需要关闭之前打开的cmd窗口&#x2F;PyCharm窗口，重新打开新的cmd窗口&#x2F;&#x2F;PyCharm窗口，使用命令才可能生效。<br>恭喜你已经掌握在Windows环境下使用linux命令了【效率会提高一点点】</p>
<p>思维导图</p>
<p><img src="/assets/2/image-20220507201150-2rk7yjo.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>09_git篇</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>TestDirector</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/10_TestDirector/01_TestDirector/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>10_TestDirector</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>tapd</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/11_TAPD/01_Tapd/</url>
    <content><![CDATA[<p>目录</p>
<p>什么是TAPD</p>
<p>为什么使用TAPD</p>
<p>如何使用TAPD</p>
<p>工作台</p>
<p>需求——分类管理用户故事</p>
<p>迭代——敏捷研发，小步快跑</p>
<p>故事墙——直观展示需求状态</p>
<p>缺陷——快速跟进产品缺陷</p>
<p>报表——高效完成数据分析</p>
<p>文档—— 轻松在线协作编辑</p>
<p>什么是TAPD<br>TAPD（Tencent Agile Product Development）全名为腾讯敏捷产品研发平台，行业领先的敏捷协作方案，贯穿敏捷产品研发生命周期的一站式服务。</p>
<p>为什么使用TAPD</p>
<p><img src="/assets/2/image-20220507201912-vn6iu34.png" alt="image.png"></p>
<p>如何使用TAPD<br>可以通过他人邀请，也可以自己注册，登录进入工作区。</p>
<p><img src="/assets/2/image-20220507201919-zql934y.png" alt="image.png"></p>
<p>TAPD一共提供以下几种功能件：</p>
<p><img src="/assets/2/image-20220507201927-u1yx4sz.png" alt="image.png"></p>
<p>使用TAPD 可 以 管理整个研发生命周期，使用需求承载需求的设计规划，利用迭代 进行迭代的规划跟踪，通过缺陷保证Bug流程可追溯。</p>
<p>迭代发布后，及时收集用户反馈进入下个迭代的研发，实现快速迭代，小步快跑。</p>
<p>工作台<br>提供与当前用户相关的工作事项概览：</p>
<p>快速查看各项目的待办工作<br>快速查看已完成工作<br>快速查看自己创建的工作<br>快捷修改&#x2F;流转相关工作项</p>
<p><img src="/assets/2/image-20220507201937-wim7exy.png" alt="image.png"></p>
<p>需求——分类管理用户故事<br>创建团队项目需求<br>修改完善需求内容<br>对需求进行分配与流转<br>分级分类管理项目需求</p>
<p><img src="/assets/2/image-20220507201946-mrzqowq.png" alt="image.png"></p>
<p>那么如何创建一个需求呢？三种方式如下：</p>
<p>1、点击【创建需求】，输入需求名称、详细描述、选择关联属性，完成需求的创建；</p>
<p>2、点击【快速创建需求】，输入需求名称，完成对需求的快速创建；</p>
<p>3、点击【更多操作】——【导入需求】可以实现将创建 好的需求直接导入至TAPD。</p>
<p><img src="/assets/2/image-20220507201954-q9h1dz3.png" alt="image.png"></p>
<p>此外还可以对已经创建了的需求进行更改，有两种种方式：</p>
<p>1、点击需求列表上的相关信息可以实现快速修改需求属性；</p>
<p>2、进入需求详情页，点击【编辑】【更多】对需 求进行修改、删除等；</p>
<p>注：点击【附件】【评论】实现对需求作补充说明。</p>
<p><img src="/assets/2/image-20220507202002-5r35pyr.png" alt="image.png"></p>
<p>需求还可以随着项目进展进行流转：</p>
<p>1、选中状态流中对应状态即可完成对需求的流转；</p>
<p>2、输入对应处理人即可为需求添加下一负责人；</p>
<p>3、输入评论，补充需求流转意见。</p>
<p><img src="/assets/2/image-20220507202011-fpmyfhu.png" alt="image.png"></p>
<p>还可以通过配置个人视图和过滤查看自己需要的信息：</p>
<p>1、点击【当前视图】，选择需要的视图模式，点击 【新建视图】可以实现自定义需求视图；</p>
<p>2、点击【过滤】，实现快速查找对应需求。</p>
<p><img src="/assets/2/image-20220507202019-fstdew6.png" alt="image.png"></p>
<p>迭代——敏捷研发，小步快跑<br>创建项目迭代<br>规划迭代内容<br>工作量评估与任务分配<br>跟踪迭代进度</p>
<p><img src="/assets/2/image-20220507202027-gqfg8b9.png" alt="image.png"></p>
<p>创建迭代</p>
<p>1、点击【创建迭代】，进入迭代创建页面；</p>
<p>2、输入迭代名称、迭代内容、起止时间完成创建。</p>
<p><img src="/assets/2/image-20220507202036-o6cxpzp.png" alt="image.png"></p>
<p>规划迭代内容</p>
<p>• 点击【规划迭代】，进入迭代规划详情页, 你可以通过两种方式将需求规划到迭代中：</p>
<pre><code>  1、选中需求前方的选框，点击【规划到迭代】；

  2、鼠标移至需求列表前方将需求拖动至左侧迭代卡片。
</code></pre>
<p>• 点击【过滤】可以实现查找具体的需求 ，缺陷也可以通过相同的方式纳入迭代中</p>
<p><img src="/assets/2/image-20220507202045-ocj1lql.png" alt="image.png"></p>
<p>故事墙——直观展示需求状态<br>由不同的故事卡组成，相当于敏捷研发的白板，直观展现项目进度。</p>
<p>查看迭代进度<br>修改故事卡片内容<br>快速流转需求状态</p>
<p><img src="/assets/2/image-20220507202106-5rh2mse.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507202113-5skx1a8.png" alt="image.png"></p>
<p>查看迭代进度</p>
<p>1、点击左上角迭代栏，可以切换不同迭代下的 故事墙；</p>
<p>2、TAPD提供了资源故事墙和状态故事墙两种展示方式切换故事墙视图。</p>
<p><img src="/assets/2/image-20220507202121-fjaectd.png" alt="image.png"></p>
<p>卡片内容修改与状态流转</p>
<p>• 状态流转</p>
<pre><code>  鼠标直接拖动故事卡片，添加当前处理人并补充流转

 意见即可完成对需求的快速流转。
</code></pre>
<p>• 卡片内容修改</p>
<pre><code> 点击故事卡片，你可以在右侧弹框内修改需求信息
</code></pre>
<p><img src="/assets/2/image-20220507202132-36y3g0u.png" alt="image.png"></p>
<p>缺陷——快速跟进产品缺陷<br>管理产品缺陷，跟进迭代质量 ：</p>
<p>创建产品缺陷<br>修改完善缺陷内容<br>对缺陷进行分配与流转<br>统计分析缺陷数据<br>缺陷的操作和需求的操作类似，这里就不一一赘述了。</p>
<p>报表——高效完成数据分析<br>统计缺陷情况，控制项目质量<br>统计需求情况，了解需求状态<br>设置邮件报告，实现信息共享</p>
<p><img src="/assets/2/image-20220507202144-ijss0mw.png" alt="image.png"></p>
<p>文档—— 轻松在线协作编辑<br>提供三种文档，通过在线文档、思维导图、文件管理功能 ，可以：</p>
<p>与团队成员快速脑暴，碰撞创意<br>利用文档完成方案策划与输出<br>关联看板任务进行落地与跟进</p>
<p><img src="/assets/2/image-20220507202152-3jlejq0.png" alt="image.png"></p>
<p>可以对文档进行一下操作：</p>
<p>创建与编辑<br>在线文档的编辑与协作<br>思维导图的编辑与协作<br>文档管理与关联</p>
<p>这里只对思维导图的编辑与协作和文档管理与关联简单介绍一下</p>
<p>思维导图的编辑与协作</p>
<p>1、打开思维导图，可以对导图节点进行编辑， 并插入链接、图标、备注等内容；</p>
<p>2、将思维导图链接分享给团队成员，可以与 他们同时对导图进行编辑。</p>
<p><img src="/assets/2/image-20220507202205-cp31dwm.png" alt="image.png"></p>
<p>文档管理与关联（好像没找到这个功能）</p>
<p>通过文件夹分类，对团队文件进行管理；<br>文挡中的内容可以与看板工作项进行关联， 实现对于工作文件的一站式管理。</p>
<p>此外还有甘特图，测试用例这些功能，TAPD每个功能都有引导的这里就不一一赘述了。</p>
<p>参考：</p>
<p><a href="https://www.bilibili.com/video/av35215548%EF%BC%88%E5%BF%85%E7%9C%8B%EF%BC%89">https://www.bilibili.com/video/av35215548（必看）</a><br><a href="https://blog.csdn.net/qq_33189961/article/details/98633304">https://blog.csdn.net/qq_33189961/article/details/98633304</a><br><a href="https://blog.csdn.net/qq_33189961/article/details/98640464">https://blog.csdn.net/qq_33189961/article/details/98640464</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/11_TAPD/02_xmind%E8%BD%ACExcel/">xmind转Excel教程</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>11_TAPD</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>xmind转Excel</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/11_TAPD/02_xmind%E8%BD%ACExcel/</url>
    <content><![CDATA[<h3 id="xmind转Excel测试用例"><a href="#xmind转Excel测试用例" class="headerlink" title="xmind转Excel测试用例"></a>xmind转Excel测试用例</h3><ul>
<li>一、引言</li>
<li>二、环境准备</li>
<li>三、脚本编写</li>
<li><ul>
<li>1、读取xmind文件</li>
<li>2、根据读取数据，解析数据</li>
<li>3、定义测试用例标题</li>
<li>4、数据写入Excel中</li>
<li>5、运行入口</li>
</ul>
</li>
<li>四、总结</li>
</ul>
<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>作为一名测试点工，我们是需要经常写测试用例的，一般我们都会使用xmind或者freemain先写出导图，然后根据导图再编写我们的测试用例。那我们能不能直接把导图中的内容直接转成Excel测试用例呢，…有了想法，开始行动起来，测试人不要怂，开始干。</p>
<h1 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h1><p>点工一般都使用python居多，本次我们也是用python来写脚本实现本次需求，从网上了解到xmindparser库可以解析xmind文件数据，支持将xmind文件解析为dict、json、xml数据类型。数据解析完成后，还需要把解析的数据存在Excel中，python处理Excel库很多，在这边我使用的是openpyxl库。</p>
<pre><code class="python">python 3.7.1
xmindparser 1.0.9
openpyxl 3.0.9
</code></pre>
<p>上面介绍完本次使用的库，还有一个重点就是，xmind的导图如何每个人写法都不一样，我们该如何解析形成统一标准呢，所以我们应该制定一个写导图的规则，下方是我制定的一个规则，后面都以此规则讲解。规则不是唯一，可根据实际情况自行制定。</p>
<p>中心主题：项目标题<br>二级标题：模块标题<br>三级标题：用例正标题<br>四级标题：操作步骤<br>五级标题：预期结果<br><img src="/assets/2/image-20220507202514-i7vov3m.png" alt="image.png"></p>
<h1 id="三、脚本编写"><a href="#三、脚本编写" class="headerlink" title="三、脚本编写"></a>三、脚本编写</h1><h2 id="1、读取xmind文件"><a href="#1、读取xmind文件" class="headerlink" title="1、读取xmind文件"></a>1、读取xmind文件</h2><p>读取xmind文件数据，xmind_to_dict(xmind_file_path)[0][“topic”] 返回数据如图所示，我们读取文件时把中心主题和二级目录下分支数据取出，用于后续处理。<br><img src="/assets/2/image-20220507202505-y0no9di.png" alt="image.png"><br>代码如下：</p>
<pre><code class="python">from xmindparser import xmind_to_dict
def read_xmind_data(xmind_file_path):
    &quot;&quot;&quot;
    读取xmind文件，返回中心主题标题和其他分支list数据
    :param xmind_file: xmind文件路径
    :return:
    &quot;&quot;&quot;
    case_data_dict=xmind_to_dict(xmind_file_path)[0][&quot;topic&quot;]
    title = case_data_dict[&quot;title&quot;]
    data_list=case_data_dict[&quot;topics&quot;]
    return title,data_list
</code></pre>
<h2 id="2、根据读取数据，解析数据"><a href="#2、根据读取数据，解析数据" class="headerlink" title="2、根据读取数据，解析数据"></a>2、根据读取数据，解析数据</h2><p>上面我们已经读取出数据，先分析下数据构成，我们发现每一个topics下面都有下一级的list，我们可以使用循环或者递归来提取出数据，并形成类似：登录-输入正确账号密码登录-进入登录页面-成功进入登录页面 这种结构的数据。<br>返回数据如下：<br><img src="/assets/2/image-20220507202458-j2pgajd.png" alt="image.png"></p>
<p>代码如下：</p>
<pre><code class="python">def xmind_to_caselist(data_list,title,listcase,strcase=&#39;&#39;):
    &quot;&quot;&quot;
    根据传入的list数据，递归解析出数据，形成以：
    登录-输入正确账号密码登录-进入登录页面-成功进入登录页面 的数据
    :param data_list: 传入解析后list
    :param strcase: 初始字符串，默认为空
    :param listcase: 存用例数据的list
    :return: 返回以每条用例数据的list
    &quot;&quot;&quot;
    for branch_one in data_list:
        strcase_one = strcase + branch_one[&#39;title&#39;] + &#39;_&#39;
        if &#39;topics&#39; not in branch_one:
            # 分支中不存在topics时，把数据添加到listcase中
            strcase_one=title+&#39;_&#39;+ strcase_one
            listcase.append(strcase_one)
            continue
        branch = branch_one[&#39;topics&#39;]
        # 递归，遍历所有分支
        xmind_to_caselist(branch,title,listcase,strcase=strcase_one)

    return listcase
</code></pre>
<h2 id="3、定义测试用例标题"><a href="#3、定义测试用例标题" class="headerlink" title="3、定义测试用例标题"></a>3、定义测试用例标题</h2><p>目前我所在的公司使用tapd，tapd中所用的测试用例模板标标题为：ID 用例目录 用例名称 前置条件 用例步骤 预期结果 用例类型 用例状态 用例等级。其中一些标题一般都没什么变化，我这边使用默认值。由上面返回的listcase数据，把数据拆分后重新组成一条用例，一条用例为一个list，方便后续写入Excel中。<br>返回数据如下：<br><img src="/assets/2/image-20220507202451-wovoyq6.png" alt="image.png"></p>
<p>代码如下：</p>
<pre><code class="python">def change_case(listcase,top_term=&#39;&#39;,case_type=&#39;功能测试&#39;,case_state=&#39;待更新&#39;,case_grade=&#39;中&#39;):
    &quot;&quot;&quot;
    Excel中用例标题分为如下9个（tapd上的上传标准）：
    ID	用例目录	用例名称	前置条件	用例步骤	预期结果	用例类型	用例状态	用例等级

    ID：自增
    用例目录：项目名称-模块名称 例如：某某某项目-登录模块
    用例名称：提取传入数据的三级标题+四级标题+五级标题
    前置条件：默认为空，可自己填写通用数据
    用例步骤：提取数据的四级标题
    预期结果：提取数据的五级标题
    用例类型：默认值为功能测试，可填其他值为：性能测试，安全性测试
    用例状态：默认值为待更新，可填其他值为：正常，已废弃
    用例登记：默认值为中，可填其他值为：高，低
    :param data_list: 传入已从xmind分解成的list数据
    :param top_term: 前置条件
    :param case_type: 用例类型
    :param case_state: 用例状态
    :param case_grade: 用例等级
    :return: 返回以一条用例为一个list的数据，例如[[用例1],[用例2],[用例3]]
    &quot;&quot;&quot;
    total_case=[]#总的用例格式的list
    case_id=1
    for data in listcase:
        case_list=[]#每一条用例的list
        data_sp=data.split(&#39;_&#39;)
        case_list.append(case_id)
        case_list.append(data_sp[0]+&quot;-&quot;+data_sp[1])
        case_list.append(data_sp[2]+&#39;，&#39;+data_sp[3]+&#39;，&#39;+data_sp[4])
        case_list.append(top_term)
        case_list.append(data_sp[3])
        case_list.append(data_sp[4])
        case_list.append(case_type)
        case_list.append(case_state)
        case_list.append(case_grade)
        total_case.append(case_list)
        case_id+=1
    return total_case
</code></pre>
<h2 id="4、数据写入Excel中"><a href="#4、数据写入Excel中" class="headerlink" title="4、数据写入Excel中"></a>4、数据写入Excel中</h2><p>在上面步骤中，已经完成对数据的梳理，下面使用openpyxl库完成对数据的写入并相应的调整样式。<br>代码如下：</p>
<pre><code class="python">def write_excel_case(total_case,save_path):
    &quot;&quot;&quot;
    把解析的数据写入Excel中
    :param total_case: 解析完成的数据
    :param save_path: 文件保存路径
    :return: 
    &quot;&quot;&quot;
    wb=Workbook()
    ws=wb.active
    ws[&#39;A1&#39;]=&#39;ID&#39;
    ws[&#39;B1&#39;]=&#39;用例目录&#39;
    ws[&#39;C1&#39;]=&#39;用例名称&#39;
    ws[&#39;D1&#39;]=&#39;前置条件&#39;
    ws[&#39;E1&#39;]=&#39;用例步骤&#39;
    ws[&#39;F1&#39;]=&#39;预期结果&#39;
    ws[&#39;G1&#39;]=&#39;用例类型&#39;
    ws[&#39;H1&#39;]=&#39;用例状态&#39;
    ws[&#39;I1&#39;]=&#39;用例等级&#39;
    i=1
    for case in total_case:
        ws[&#39;A&#123;&#125;&#39;.format(i + 1)] = case[0]
        ws[&#39;B&#123;&#125;&#39;.format(i + 1)] = case[1]
        ws[&#39;C&#123;&#125;&#39;.format(i + 1)] = case[2]
        ws[&#39;D&#123;&#125;&#39;.format(i + 1)] = case[3]
        ws[&#39;E&#123;&#125;&#39;.format(i + 1)] = case[4]
        ws[&#39;F&#123;&#125;&#39;.format(i + 1)] = case[5]
        ws[&#39;G&#123;&#125;&#39;.format(i + 1)] = case[6]
        ws[&#39;H&#123;&#125;&#39;.format(i + 1)] = case[7]
        ws[&#39;I&#123;&#125;&#39;.format(i + 1)] = case[8]
        i+=1
    column_list = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;]
    cell_list = [&#39;A1&#39;, &#39;B1&#39;, &#39;C1&#39;, &#39;D1&#39;, &#39;E1&#39;, &#39;F1&#39;, &#39;G1&#39;, &#39;H1&#39;, &#39;I1&#39;]
    #设置表头字体
    font=Font(name=&#39;宋体&#39;,bold=True)
    for cel in cell_list:
        cell=ws[cel]
        cell.font=font
    # 设置列的表格居中
    alignment = Alignment(horizontal=&#39;center&#39;,wrapText=True)
    for col_name in column_list:
        col_list = ws[col_name]
        for col in col_list:
            col.alignment = alignment
    #设置列的宽度
    ws.column_dimensions[&#39;B&#39;].width = 20
    ws.column_dimensions[&#39;C&#39;].width = 60
    ws.column_dimensions[&#39;D&#39;].width = 30
    ws.column_dimensions[&#39;E&#39;].width = 30
    ws.column_dimensions[&#39;F&#39;].width = 30
    ws.column_dimensions[&#39;G&#39;].width = 15
    ws.column_dimensions[&#39;H&#39;].width = 15
    ws.column_dimensions[&#39;I&#39;].width = 15
    #设置行的高度
    for x in range(2,ws.max_row+1):
        ws.row_dimensions[x].height = 40
    wb.save(save_path)
</code></pre>
<h2 id="5、运行入口"><a href="#5、运行入口" class="headerlink" title="5、运行入口"></a>5、运行入口</h2><p>上述步骤中已经把脚本所需函数完成，下面写下运行脚本函数：<br>代码如下：</p>
<pre><code class="python">def run_main(xmind_file_path,save_path,top_term=&#39;&#39;,case_type=&#39;功能测试&#39;,case_state=&#39;待更新&#39;,case_grade=&#39;中&#39;):
    &quot;&quot;&quot;

    :param xmind_file_path: xmind文件路径
    :param save_path: 文件保存路径
    :param top_term: 前置条件
    :param case_type: 用例类型
    :param case_state: 用例状态
    :param case_grade: 用例等级
    :return:
    &quot;&quot;&quot;
    title,data_list=read_xmind_data(xmind_file_path)
    listcase=xmind_to_caselist(data_list,title,[])
    total_case = change_case(listcase, top_term=top_term,case_type=case_type,case_state=case_state,case_grade=case_grade)
    write_excel_case(total_case,save_path)
</code></pre>
<p>运行结果图如下：<br><img src="/assets/2/image-20220507202439-2jl83d6.png" alt="image.png"></p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>实现该需求并不是很难，主要是使用对应库解析数据并保存，目前只是实现了脚本，后续继续学习，希望把脚本转换成Tkinter桌面应用，使用更方便。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>11_TAPD</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/01_jmeter/</url>
    <content><![CDATA[<h2 id="jmeter操作"><a href="#jmeter操作" class="headerlink" title="jmeter操作"></a>jmeter操作</h2><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/01_jmeter%E5%AE%89%E8%A3%85/">jmeter安装</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/02_jmeter%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D/">jmeter界面介绍</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/03_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%80)/">jmeter简单操作(一)</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/04_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%BA%8C)/">jmeter简单操作(二)</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/05_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E4%B8%89)/">jmeter简单操作(三)</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/06_jmeter%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C(%E5%9B%9B)/">jmeter简单操作(四)</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/07_jmeter%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/">jmeter正则表达式详解</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/08_jmeterjson%E6%8F%90%E5%8F%96%E5%99%A8%E8%AF%A6%E8%A7%A3/">jmeterjson提取器详解</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/09_jmeter%E8%84%9A%E6%9C%AC%E5%BD%95%E5%88%B6/">jmeter脚本录制</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/10_jmeter%E8%BF%9C%E7%A8%8B%E5%90%AF%E5%8A%A8/">jmeter远程启动</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/11_jmeter%E5%87%BD%E6%95%B0%E5%8A%A9%E6%89%8B/">jmeter函数助手</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/12_jmeter%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/">jmeter连接数据库操作</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/13_Jmeter%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/">Jmeter接口自动化</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/16_jmeter%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">jmeter简单的性能测试</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/18_jmeter%E6%8F%92%E4%BB%B6/">jmeter插件篇</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/04_%E5%B7%A5%E5%85%B7/01_jmeter/999_%E5%B7%A5%E5%85%B7/19_jmeter%E6%80%A7%E8%83%BD%E7%AF%87/">jmeter性能篇</a></p>
<h2 id="第三方脚本录制"><a href="#第三方脚本录制" class="headerlink" title="第三方脚本录制"></a>第三方脚本录制</h2><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/14_blazemeter(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/">blazemeter(第三方录制脚本)</a></p>
<p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/15_badboy(%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BD%95%E5%88%B6%E8%84%9A%E6%9C%AC)/">badboy(第三方录制脚本)</a></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/01_jmeter%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p> <strong>特别需要注意的时，</strong> <strong>jdk版本和jmeter版本匹配问题。</strong><br><strong>Jdk1.8对应apache-jmeter-3.3</strong><br><strong>Jmeter下载及安装配置</strong><br>本文是在win7环境下安装使用jmeter，jmeter可以运行在多平台上Windows和Linux。<br>前提：使用jmeter工具之前需要安装java.并配置好java的环境变量。（备注：java下载和环境配置参考java下载安装）<br>下载地址<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a><br>（Windows版本下载zip，Linux版本下载tgz）<br> <strong>附录</strong> <strong>：java下载和环境配置参考java下载安装</strong><br>1、官网下载链接：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>2、选择accept，之后才能下载对应的版本；这里我选择的是Windows x86版本；<br><img src="/assets/1/image-20211204000805-eyza1hc.png" alt="image.png"><br>3、下载完后，找到下载后的这文件，双击运行。点击下一步，出现如下图一内容，这里是设置安装路径，可以默认，用户可自行选择，这里我安装在D:\JAVA\JDK，如下图二。这路径记好，一会设置环境变量需要用到，设置好后点击下一步，过一会会出现安装Jre路径，如下图三，用户自行选择，点击下一步等待安转完毕即可。<br><img src="/assets/1/image-20211204000813-ecja7mn.png" alt="image.png"><br><img src="/assets/1/image-20211204000819-zupyhze.png" alt="image.png"><br><img src="/assets/1/image-20211204000827-tfqdqnr.png" alt="image.png"><br>4、到了这，离成功又近了一步，开始设置环境变量。我的电脑是win7,这里主要以win7为例，其他系统可自行查阅资料，在桌面找到计算机图标右键选择属性，出现如下图一所示内容，点击高级系统设置，出现下图二内容，点击环境变量。<br><img src="/assets/1/image-20211204000834-lruterg.png" alt="image.png"><br><img src="/assets/1/image-20211204000839-2rca6yt.png" alt="image.png"><br>5、点击环境变量后出现如下图一所示，在系统变量下面点击新建,然后在下图二弹窗中输入以下内容，变量值就是在步骤4里设置的路径，我的是D:\JAVA\JDK，所以就设置成这个。设置完后再重复刚才步骤新建一个系统变量如下图三，这个可以和我设置一样，变量值为“%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”。设置好后别忘了确定呀，如下图四。<br><img src="/assets/1/image-20211204000846-cb27j2t.png" alt="image.png"><br><img src="/assets/1/image-20211204000856-xfwkx75.png" alt="image.png"><br>6、一切大功告成。但怎么样才能确定安装成功了呢？点击windows图标，在命令行中输入cmd，如下图一，按回车键。就会出现一个命令窗口（一个黑色的框框），再输入“javac”按回车键，如果出现如下图二就真的大功告成了，如果没有就重温下以上的步骤。<br><img src="/assets/1/image-20211204000905-bluwpbb.png" alt="image.png"><br><strong>JMETER下载及安装配置</strong><br>1、打开下载地址<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a><br>2、（Windows版本下载zip，Linux版本下载tgz）一般下载Binaries，Source含有源码；<br><img src="/assets/1/image-20211204000912-j11sxx2.png" alt="image.png"><br>3、下载后无需安装，解压后即可使用。下图为解压后的目录。<br><img src="/assets/1/image-20211204000918-11fk6vd.png" alt="image.png"><br>4、完成以上操作后，需要进行配置jmeter的环境变量。<br>jmeter环境变量配置如下：<br>（1）新增JMETER_HOME变量，注意：变量值为你下载后解压的路径。<br><img src="/assets/1/image-20211204000925-ts7ok5b.png" alt="image.png"><br>（2）编辑CLASSPATH变量，加上%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar;注：如果电脑重没找到CLASSPATH，添加在PATH也可以；<br><img src="/assets/1/image-20211204000930-31qpx0p.png" alt="image.png"><br>5、操作完上面的步骤，我们就可以点击Jmeter中bin目录下面的jmeter.bat文件即可打开Jmeter了。<br>注意：打开的时候会有两个窗口，Jmeter的命令窗口和Jmeter的图形操作界面，不可以关闭命令窗口。<br>注：打开如果提示“findstr不是内部或外部命令”， 这是PATH环境变量的问题，将windows命令的目录添加到PATH中就over了。即：在path中追加：%SystemRoot%&#x2F;system32;%SystemRoot%;<br><img src="/assets/1/image-20211204000935-jcinai9.png" alt="image.png"><br>6、进入JMeter界面。<br><img src="/assets/1/image-20211204000941-230j3vm.png" alt="image.png"><br>7、 备注：也可以通过ApacheJMeter.jar打开。<br><img src="/assets/1/image-20211204000949-k1rry3j.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>02_接口测试篇</category>
        <category>01_jmeter</category>
        <category>999_工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>bugzilla</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/04_bugzilla/01_bugzilla/</url>
    <content><![CDATA[<p>Bugzilla 是一个开源的缺陷跟踪系统（Bug-Tracking System），它可以管理软件开发中缺陷的提交（new），修复（resolve），关闭（close）等整个生命周期。</p>
<p>　　Bugzilla是一个搜集缺陷的数据库。它让用户报告软件的缺陷从而把它们转给合适的开发者。开发者能使用bugzilla保持一个要做事情的优先表，还有时间表和跟踪相关性。不是所有的”bugs”都是软件缺陷。一些数据库中的内容是作为增强的请求(RFE)。一个RFE是一个严重级别字段被设为”enhancement”的”Bug”.人们常说”bug”,实际上意思是Bugzilla中的记录,所以RFEs经常被称作bug。</p>
<p>它能够为你建立一个完善的 Bug 跟踪体系, 包括报告 Bug, 查询 Bug 记录并产生报表,处理解决,管理员系统初始化和设置四部分</p>
<p><a href="https://www.bugzilla.org/">bugzilla官网</a></p>
<!-- [bugzilla安装](/05_测试工具/01_测试管理工具/04_bugzilla/02_bugzilla安装/)	 -->
<p><a href="/05_测试工具/01_测试管理工具/04_bugzilla/02_bugzilla安装/" target="_blank">bugzilla安装</a> <br/></p>
<p>功能表现</p>
<p>　　1. 强大的检索功能</p>
<p>　　2. 用户可配置的通过Email公布Bug变更</p>
<p>　　3. 历史变更记录</p>
<p>　　4. 通过跟踪和描述处理Bug</p>
<p>　　5. 附件管理</p>
<p>　　6. 完备的产品分类方案和细致的安全策略</p>
<p>　　7. 安全的审核机制</p>
<p>　　8. 强大的后端数据库支持</p>
<p>　　9. Web，Xml，Email和控制界面</p>
<p>　　10.友好的网络用户界面</p>
<p>　　11.丰富多样的配置设定</p>
<p>　　12.版本间向下兼容</p>
<p>为什么使用Bugzilla</p>
<p>Bugzilla是一个拥有强大功能的错误跟踪系统。它可以使我们更好的在软件开发过程中跟踪软件错误的处理过程，为开发和测试工作以及产品质量的度量提供数据支持，从而有效的保证软件产品的质量。</p>
<h2 id="问题的处理"><a href="#问题的处理" class="headerlink" title="问题的处理"></a>问题的处理</h2><h3 id="Bug报告状态分类（Status）"><a href="#Bug报告状态分类（Status）" class="headerlink" title="Bug报告状态分类（Status）"></a>Bug报告状态分类（Status）</h3><p>　　待确认的（Unconfirmed）</p>
<p>　　新提交的（New）</p>
<p>　　已分配的（Assigned）</p>
<p>　　问题未解决的（Reopened）</p>
<p>　　待返测的（Resolved）</p>
<p>　　待归档的（Verified）</p>
<p>　　已归档的（Closed）</p>
<h3 id="Bug处理意见（Resolution）"><a href="#Bug处理意见（Resolution）" class="headerlink" title="Bug处理意见（Resolution）"></a>Bug处理意见（Resolution）</h3><p>　　已修改的（Fixed）</p>
<p>　　不是问题（Nvalid）</p>
<p>　　无法修改（Wontfix）</p>
<p>　　以后版本解决（Later）</p>
<p>　　保留（Remind）</p>
<p>　　重复（Duplicate）</p>
<p>　　无法重现（Worksforme）</p>
<h3 id="指定处理人（Assigned-To）"><a href="#指定处理人（Assigned-To）" class="headerlink" title="指定处理人（Assigned To）"></a>指定处理人（Assigned To）</h3><p>　　可以指定一个处理人</p>
<p>　　如不指定处理人，则系统指定管理员为默认处理人</p>
<h3 id="新建一个Bugzilla账号"><a href="#新建一个Bugzilla账号" class="headerlink" title="新建一个Bugzilla账号"></a>新建一个Bugzilla账号</h3><p>　　1.当以个人身份需要访问登陆系统时需要 点击“New Account”链接，输入你的Email地址（如：<a href="mailto:&#x78;&#x78;&#120;&#x40;&#x78;&#120;&#46;&#99;&#111;&#x6d;">&#x78;&#x78;&#120;&#x40;&#x78;&#120;&#46;&#99;&#111;&#x6d;</a>）然后点击“send”。</p>
<p> 要创建一个Bugzilla帐号，所有你需要做的就是输入合法的电子邮件地址。在这个地址，您将收到一封电子邮件，以确认您的帐户的创建。您将无法登录，直到你收到的电子邮件。如果没有一个合理的时间内抵达，您可以联系这个Bugzilla安装在管理员维护者。</p>
<p>　　2. 稍候，你会收到一封邮件。邮件中包含你的登录账号（与你的Email相同）和口令，这个口令时Bugzilla系统随机生成的，你可以根据你的需要进行变更。</p>
<p>　　3. 在页面的黄色页角中点击“Log In”链接，而后输入你的账号和口令。最后点击“Log in”</p>
<p>There was an error sending mail from ‘bugzilla-daemon@’ to ‘<a href="mailto:&#x31;&#50;&#51;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;">&#x31;&#50;&#51;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;</a>‘: Couldn’t connect to 10.175.75.250</p>
<p> 遇到这样问题首先要看服务器的邮件服务开启没，smtp若没启动请启动</p>
<p>There was an error sending mail from ‘bugzilla-daemon@’ to ‘<a href="mailto:&#x31;&#x32;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#x32;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a>‘: Can’t call method “address” on an undefined value at C:&#x2F;Perl&#x2F;site&#x2F;lib&#x2F;Email&#x2F;Send&#x2F;SMTP.pm line 25.</p>
<p>Email::MIME::CreatorBUGZILLA里自带的有SMTP，只要SMTP能够通过认证就可以了，所以第三方，以及代码什么都不用修改，只要设置params里面的参数就可以了！<br>在..\data\params设置如下参数：<br>maintainer :                  <a href="mailto:&#49;&#x32;&#51;&#64;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;">&#49;&#x32;&#51;&#64;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;</a><br>mail_delivery_method :         SMTP<br>mailfrom :                     <a href="mailto:&#x31;&#50;&#x33;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;">&#x31;&#50;&#x33;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a><br>sendmailnow:                   on<br>smtpserver :                   smtp.163.com<br>smtp_username:                 <a href="mailto:&#x31;&#x32;&#51;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;">&#x31;&#x32;&#51;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;</a><br>smtp_password :                **********<br>注意：maintainer、mailfrom必须相同！smtp_username邮箱必须是存在的真实的邮箱，smtp_password必须是你真实邮箱的真实密码（要与你所登陆邮箱时的密码相同）！邮件已经发送成功！如果还有不能连接等问题，只能说明你的邮箱和密码有问题！</p>
<h3 id="产品和结构"><a href="#产品和结构" class="headerlink" title="产品和结构"></a>产品和结构</h3><p>　　Bug记录按产品分类，每种产品按功能拆分成几类。以Bugzilla产品为例，它由以下几部分构成：</p>
<p>　　Administration</p>
<p>　　Bugzilla-General</p>
<p>　　Creating&#x2F;Changing Bug</p>
<p>　　Documentation</p>
<p>　　Email</p>
<p>　　Installation</p>
<p>　　Query&#x2F;Buglist</p>
<p>　　Reporting&#x2F;Charting</p>
<p>　　User Accounts</p>
<p>　　Changing Passwords</p>
<p>　　User Interface</p>
<p>一个Bug的生存周期</p>
<p><img src="/assets/2/image-20220507181955-zh66vht.png" alt="image.png"></p>
<ol>
<li><ol>
<li>用户登录及设置流程：</li>
</ol>
</li>
</ol>
<p>打开浏览器，输入Bugzilla服务器地址：<a href="http://server/bugzilla/">http://server/bugzilla/</a></p>
<p><img src="/assets/2/image-20220507182005-aa08gpt.png" alt="image.png"></p>
<p>进入主页面后，点击【新建帐号】New Account，进入注册页面。</p>
<p>　　在注册页面中输入E-Mail地址和用户代号，然后，点击【New Account】，随后，你将收到一封包含初始密码的E-Mail。</p>
<p>如图所示：</p>
<p><img src="/assets/2/image-20220507182014-izw36bx.png" alt="image.png"></p>
<p>　在收到E-Mail之后，点击【登录】，在帐号栏输入注册时使用的E-Mail地址，在密码栏输入邮件里通知的初始密码，然后，点击【Log In】。</p>
<p>　　如忘记密码，在登陆页面中点击Forgot PassWord，点击【Reset PassWord】,根据收到的邮件进行重新设置密码。</p>
<p>(1)File a Bug (2)Search （3）Open a New Account</p>
<p>一、File a Bug 里面。首先选中一个产品后点击New时增加新的Bug</p>
<p>二、在Search 里面<br>Simple Search (简单搜索)选择Product的产品比如testproduct在点Search后可以快速定位到某一个产品的所有的Bug如图所示。</p>
<p><img src="/assets/2/image-20220507182022-yp6yd3w.png" alt="image.png"></p>
<p>还可以高级搜索Advanced Search 如图所示：</p>
<p><img src="/assets/2/image-20220507182032-h0cwmzv.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507182043-2gpu9js.png" alt="image.png"></p>
<p>一：首先有管理员登录系统 进入系统后进行系统配置</p>
<p>Administrator进入如下图所示</p>
<p><img src="/assets/2/image-20220507182052-n5mf3sv.png" alt="image.png"></p>
<p>点击各个配置如参数配置Parameters 进入页面后进行配置</p>
<p>1若增加用户则点击Users创建新User 如图所示</p>
<p><img src="/assets/2/image-20220507182101-pjalpms.png" alt="image.png"></p>
<p>在点击Add a New User</p>
<p>如图所示：</p>
<p><img src="/assets/2/image-20220507182121-wyeofsn.png" alt="image.png"></p>
<p>禁止一个用户:填写Disabled text 输入框即可</p>
<p>输入用户名和密码后点击保存会进入另一个页面设置一下</p>
<p>Login name:必须是用户的邮箱地址<br>Password是修改密码，<br>Bugmail Disabled:表示如果有人提交了新Bug后是否自动向我们的邮箱发送信息<br>设置一下是否有这些问题的权限。</p>
<p>Disable text：禁用文本<br>之后再点击保存ADD。</p>
<p>要创建一个Bugzilla帐号，所有你需要做的就是输入一个合法的地址。在这个地址，您将收到一封电子邮件，以确认您的帐户的创建。您将无法登录，直到您收到。如果没有一个合理的时间内抵达，您可以联系这个Bugzilla安装的维护者</p>
<p>创建成功后页面如图所示：</p>
<p><img src="/assets/2/image-20220507182137-e95kmhs.png" alt="image.png"></p>
<p>除了第一个admin之外其他的最好全部选中 然后点击save changes</p>
<p>最后出现如图所示界面：</p>
<p><img src="/assets/2/image-20220507182146-fq31kv3.png" alt="image.png"></p>
<p>① 如果要删除一个账户请在参数配置里面 点击【Index】进入界面后如图所示</p>
<p><img src="/assets/2/image-20220507182154-mq2qcce.png" alt="image.png"></p>
<p>然后点击【allowuserdeletion】或者直接点击左侧列表菜单【Administrative Policies】进入页面如图所示：选择ON 后然后点击Save Changes 保存更改。</p>
<p><img src="/assets/2/image-20220507182208-taa5jre.png" alt="image.png"></p>
<p>②    在初次设置时一只设置不成功会出现报错之类的信息：Can’t rename data\params.nhYFB to .&#x2F;data&#x2F;params: Permission denied at Bugzilla&#x2F;Config.pm line 301</p>
<p>③    这时就需要添加你登陆web server 用户对bugzilla文件夹的所有权限，如果用的是administrator登陆：右键c:\bugzilla—&gt;共享和安全—&gt;安全中勾选administrator的所有权限。如果你设置的超级管理员权限用户登录的而在服务器没有超级管理员权限必须设置users完全控制权限 然后在设置系统参数配置就会成功。</p>
<p>④    这样你在对users用户管理一项时进入设置页面有个search按钮全部查询或者根据条件查询显示出users群组这样后面就会有删除【delete】按钮的权限如图所示：</p>
<p><img src="/assets/2/image-20220507182219-vl1oi2p.png" alt="image.png"></p>
<p>对超级管理员的切记不要随意删除，对已不存在项目组的普通用户可以删除修改。</p>
<p>点击yes delete 删除用户成功。</p>
<p>2、创建项目</p>
<p>Administrator进入后点击Products创建新Products<br>如图所示：</p>
<p><img src="/assets/2/image-20220507182227-cizj0qt.png" alt="image.png"></p>
<p>点击Add a Product</p>
<p>—输入产品名称和描述后点击Add 进入详细页面</p>
<p><img src="/assets/2/image-20220507182237-rm16sml.png" alt="image.png"></p>
<p>3、当管理员将所有的配置项目都设置好后就可以发Bug了<br>发Bug的流程为：<br>点击首页后—&gt;NEW –&gt;File a Bug–&gt;点击某一个产品比如Test，如图所示</p>
<p><img src="/assets/2/image-20220507182245-3urkmt5.png" alt="image.png"></p>
<p>其中Component:为哪一个模块组建。</p>
<p>Component Description：组建描述</p>
<p>Version：为版本。</p>
<p>Product: 产品</p>
<p>Reporter：报告者<br>serverity代表问题的严重程度</p>
<p>Blocker为最严重的。</p>
<p>Critical严重 死机，丢失数据，内存溢出</p>
<p>Major    较大的功能缺陷</p>
<p>Normal   正常</p>
<p>Minor    较小的功能缺陷</p>
<p>Trivial  细小 拼写、对齐类的错误</p>
<p>enhancement为最轻微的需要改进的。<br>Hardware硬件。</p>
<p>Os代表操作系统。</p>
<p>输入Summary 摘要和Description 描述后</p>
<p>还可以添加Attachment写上附件的描述后点击提交。一个Bug即提交了。<br>同时。在我们的邮件里面会马上收到一封邮件。</p>
<p>确定保存后进入下一页面如图所示：</p>
<p><img src="/assets/2/image-20220507182255-8j36gld.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>04_bugzilla</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>bugzilla安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/04_bugzilla/02_bugzilla%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>安装bugzilla<br>安装bugzilla有两种方式，一种是利用Git克隆源码，这样有利于以后更新。<br>第二种方式是直接到官网下载源码。我采用的是第二种，以为是外网，没有翻墙工具网速很慢我怕Git失败会出现很多问题就直接去下载源码。下载之后放在自己喜欢的磁盘中就可以。但是一般存放路径不用出现中文。Bugzilla安装可以说是很简单了。最重要的还是配置。<br>下载地址：<a href="https://www.bugzilla.org/">https://www.bugzilla.org/</a></p>
<p>安装ActivePerl<br>ActivePerl也是一样到官网下载，但是官网只能下载5.26和5.28的版本这两个版本太高了有一些插件无法安装。因此我在网上找了一些资源下载的5.20的版本：ActivePerl-5.20.2.2002-MSWin32-x64-299195.msi。下载好之后直接点击运行就可以。</p>
<p><img src="/assets/2/image-20220507183216-c1cjmcg.png" alt="image.png"></p>
<p>选择同意：</p>
<p><img src="/assets/2/image-20220507183225-5opabz0.png" alt="image.png"></p>
<p>选择第一个：</p>
<p><img src="/assets/2/image-20220507183232-8xox7er.png" alt="image.png"></p>
<p>可以根据自己的情况选择文件安装，默认是安装在c盘下的Perl64文件：</p>
<p><img src="/assets/2/image-20220507183240-2jpt9kq.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507183251-87d36kf.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507183257-t9m6mdq.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507183303-0ht4i4o.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507183310-irxh0iw.png" alt="image.png"></p>
<p>安装好之后将bin文件添加到系统环境变量。Win+R键打开cmd输入ppm version出现以下内容就表示安装成功以及环境变量配置成功。</p>
<p><img src="/assets/2/image-20220507183318-q20jbf2.png" alt="image.png"></p>
<p>配置bugzilla<br>进入bugzilla安装文件按住shift+鼠标右键进去cmd命令窗口</p>
<p><img src="/assets/2/image-20220507183327-e1rfnuk.png" alt="image.png"></p>
<p>输入checksetup.pl运行checksetup.pl文件</p>
<p><img src="/assets/2/image-20220507183335-wizp4a2.png" alt="image.png"></p>
<p>可以看到bugzilla缺少的插件有可选的，有必选的，必选的就必须安装。</p>
<p><img src="/assets/2/image-20220507183342-sa8mwkl.png" alt="image.png"></p>
<p>将安装命令复制到命令行按下回车就可以安装，从上往下依次安装。如果安装失败可以先跳过，最后再来安装，有些插件有依赖关系。安装命令如：ppm install DateTime</p>
<p>安装完之后重新输入checksetup.pl会是这样</p>
<p><img src="/assets/2/image-20220507183350-pfaoz9w.png" alt="image.png"></p>
<p>接下来就是会在bufzilla目录下生成一个localconfig的文件，我们需要进去配置一下才能连接我们的数据库。</p>
<p><img src="/assets/2/image-20220507183357-l1xp9cp.png" alt="image.png"></p>
<p>由于我是在本地做配置，所以就只需要改这些地方就可以了，如果需要连接远程数据库还需要修改$db_host的值。配置完之后再执行checksetup.pl就会自动创建数据库。</p>
<p><img src="/assets/2/image-20220507183404-rvmp4o5.png" alt="image.png"></p>
<p>但是呢，在这个过程中我遇到了一些挫折，首先是数据库连接失败，原因是我没有启动本地数据库。手动启动数据库之后又出现的问题是数据库版本太低，又将我5.5版本的数据库升级到了5.7版本。这里提醒一下啊，不要直接将数据库版本升级太高，可能Navicat工具不支持那么高版本的数据库还得升级Navicat工具。<br>输入管理员名字和账号（该账号是一个email地址）以及管理员登陆的密码.和确认密码</p>
<p><img src="/assets/2/image-20220507183413-mgzryyf.png" alt="image.png"></p>
<p>到这里bugzilla就配置好了。</p>
<p>安装mysql数据库<br>安装数据库其实很简单，我安装的是mysql数据库，去mysql官网下载自己需要的mysql安装包，运行程序根据提示就可以了。如果是第一次安装mysql的可以去网上看看安装教程，我就不做详细介绍了。我重点来讲一下本地数据库升级应该注意什么。<br>首先升级本地数据库我们就得先备份数据库的数据。不然就会发现数据库一片空白，以前的数据全没了。<br>第一步：找到数据库安装路径C:\ProgramData\MySQL，将Mysql server5.5备份到别的地方。<br>第二步：到任务管理器将MySQL服务关闭。<br>第三步：通过控制面板的程序卸载将数据库卸载即可。<br>第四步：安装提前下好的数据库，我安装的是MySQL5.7.20版本。注重要的一步是取消“Development Components”的勾选（因为我们只需要安装mysql server）</p>
<p><img src="/assets/2/image-20220507183424-qm55dtu.png" alt="image.png"></p>
<p>第五步：我们将备份的Mysql server5.5下的data复制到C:\ProgramData\MySQL\ Mysql server5.7文件夹下，直接替换掉就可以。这样我们启动数据库还是能看到以前的数据。如果替换不掉就需要去任务管理器去将MySQL服务关掉。</p>
<p>配置IIS<br>IIS作为web服务器是非常好用的，一般Windows系统都会自带。想了解更多可以去网上查查资料，这里只讲如何配置。<br>第一步：需要先开启这些服务。WIn+R，输入OptionalFeatures，打开Windows功能，选上如下的功能。</p>
<p><img src="/assets/2/image-20220507183436-3zhpfk8.png" alt="image.png"></p>
<p>第二步：继续Win+R，输入inetmgr，打开Windows IIS配置管理工具。鼠标右键选择添加网站。</p>
<p><img src="/assets/2/image-20220507183443-nu7r0za.png" alt="image.png"></p>
<p>第三步：如下图。端口号为了避免影响以后的开发，可以选择一个不常用的端口。</p>
<p><img src="/assets/2/image-20220507183453-tpa89jp.png" alt="image.png"></p>
<p>双击默认文档，添加一个index.cgi</p>
<p><img src="/assets/2/image-20220507183500-cko5dnc.png" alt="image.png"></p>
<p>双击处理程序映射，添加脚本映射，perl.exe的路径根据实际情况来。</p>
<p><img src="/assets/2/image-20220507183507-wo91et0.png" alt="image.png"></p>
<p>然后预览一下，出现这个界面就算完成啦。</p>
<p><img src="/assets/2/image-20220507183514-6l4zmva.png" alt="image.png"></p>
<p>最后如果喜欢中文的可以将汉语包放大bugzilla&#x2F;template下就可以了。</p>
<p><img src="/assets/2/image-20220507183519-272bbih.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>04_bugzilla</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>vss</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/05_vss/01_vss/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>05_vss</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>note</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/06_note/01_note/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>06_note</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CQ</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/07_CQ/01_CQ/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>07_CQ</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>svn篇</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/08_svn%E7%AF%87/01_svn%E7%AF%87/</url>
    <content><![CDATA[<p>文章目录</p>
<ol>
<li><p>什么是SVN？<br> 版本控制：<br> 常用的版本控制工具：<br> SVN的优势</p>
</li>
<li><p>搭建VisualSVN Server服务器</p>
</li>
<li><p>SVN服务器创建仓库与用户<br> 3.1 创建仓库<br> 3.2 SVN标准目录结构<br> 3.3 创建用户<br> 3.4 修改仓库权限</p>
</li>
<li><p>安装TortoiseSVN客户端</p>
</li>
<li><p>使用Checkout检出仓库代码</p>
</li>
<li><p>添加文件、修改文件<br> 6.1 添加文件<br> 6.2 查看日志<br> 6.3 修改文件</p>
</li>
<li><p>版本回滚</p>
</li>
<li><p>删除文件</p>
</li>
<li><p>解决冲突<br> 9.1 产生冲突的情况？<br> 9.2 解决冲突</p>
</li>
<li><p>创建分支<br> 10.1 创建分支<br> 10.2 合并分支<br> GO GO GO~<br> 感谢大家，关注点一波~</p>
</li>
<li><p>什么是SVN？<br> 版本控制：<br> 它可以记录每一次文件和目录的修改情况，这样就可以借此将数据恢复到以前的版本，并可以查看数据的更改细节！</p>
<p> <img src="/assets/2/image-20220507193512-9d4nlms.png" alt="image.png"></p>
</li>
</ol>
<p>Subversion（简称SVN）是一个自由开源的版本控制系统。在Subversion管理下，文件和目录可以超越时空。</p>
<p>常用的版本控制工具：</p>
<p><img src="/assets/2/image-20220507193524-u136u49.png" alt="image.png"></p>
<p><a href="http://subversion.apache.org/">http://subversion.apache.org/</a></p>
<p><img src="/assets/2/image-20220507193535-3r4qtfh.png" alt="image.png"></p>
<p>SVN的优势<br>统一的版本号</p>
<p>Subversion下，任何一次提交都会对所有文件增加到同一个新版本号，即使是提交并不涉及的文件，版本号相同的文件构成软件的一个版本。</p>
<p>原子提交</p>
<p>一次提交不管是单个还是多个文件，都是作为一个整体提交的。在这当中发生的意外例如传输中断，不会引起数据库的不完整和数据损坏。</p>
<p>多级管理系统</p>
<p>超级管理员：对所有配置库具有完全权限。</p>
<p>目录管理员：目录管理员可对指定的目录&#x2F;SVN库进行权限管理。</p>
<p>普通用户：可以查看用户名、查看权限设置、修改自己密码。</p>
<p>一致的数据操作</p>
<p>Subversion用一个二进制差异算法描述文件的变化，对于文本（可读）和二进制（不可读）文件其操作方式是一致的。这两种类型的文件压缩存储在版本库中，而差异信息则在网络上双向传递。</p>
<p>简单、易操作</p>
<p>SVN对中文支持好，操作简单，使用没有难度，使用界面统一，功能完善，操作方便。</p>
<ol start="2">
<li><p>搭建VisualSVN Server服务器<br> 集中式代码管理的核心是SVN服务器：</p>
<p> <img src="/assets/2/image-20220507193548-nr6owm4.png" alt="image.png"></p>
</li>
</ol>
<p>SVN服务端：Subversion和VisualSVN Server</p>
<p>因为如果直接使用Subversion，那么在Windows系统上，要想让它随系统启动，就要封装SVN Server为windws service，还要通过修改配置文件来控制用户权限，另外如果要想以Web方式htp协议访问，一般还要安装配置Apache，如果是新手，岂不是很头痛？</p>
<p>而VisualSVN Serve集成了Subversion和Apache，省去了以上所有的麻烦。</p>
<p>下载地址：</p>
<p><a href="https://www.visualsvn.com/server/">https://www.visualsvn.com/server/</a></p>
<p><img src="/assets/2/image-20220507193559-xkku5fm.png" alt="image.png"></p>
<p>安装图解：</p>
<p>下载</p>
<p><img src="/assets/2/image-20220507193609-a0ku9i3.png" alt="image.png"></p>
<p>双击安装：</p>
<p><img src="/assets/2/image-20220507193616-n3k92fk.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507193628-69cqo42.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507193636-chtdmyr.png" alt="image.png"></p>
<p>设置仓库地址、端口</p>
<p><img src="/assets/2/image-20220507193643-iw6lvl1.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507193650-if5vo0t.png" alt="image.png"></p>
<p>安装完成</p>
<p><img src="/assets/2/image-20220507193657-vc922wo.png" alt="image.png"></p>
<ol start="3">
<li><p>SVN服务器创建仓库与用户<br> VisualSVN Server Manager 主界面</p>
<p> <img src="/assets/2/image-20220507193705-l0oypbd.png" alt="image.png"></p>
</li>
</ol>
<p>3.1 创建仓库</p>
<p><img src="/assets/2/image-20220507193722-nu8qixt.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507193729-ch0evsy.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507193735-1lnq20r.png" alt="image.png"></p>
<p>这里选择仓库类型</p>
<p>类型1：空仓库</p>
<p><img src="/assets/2/image-20220507193745-kbkndrn.png" alt="image.png"></p>
<p>类型2：主分支-分支-标签</p>
<p><img src="/assets/2/image-20220507193752-xlu7oha.png" alt="image.png"></p>
<p>访问权限设置</p>
<p><img src="/assets/2/image-20220507193800-kwhciab.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507193809-zvxo8e7.png" alt="image.png"></p>
<p>创建完成</p>
<p><img src="/assets/2/image-20220507193817-fzb2cpo.png" alt="image.png"></p>
<p>3.2 SVN标准目录结构<br>trunk是主分支，是日常开发进行的地方。<br>branches是分支。一些阶段性的release版本，这些版本是可以继续进行开发和维护的，则放在branches目录中。又比如为不同用户客制化的版本，也可以放在分支中进行开发。<br>tags目录一般是只读的，这里存储阶段性的发布版本，只是作为一个里程碑的版本进行存档。<br>3.3 创建用户<br>创建user1、user2两个用户</p>
<p>创建user1（密码123456）</p>
<p><img src="/assets/2/image-20220507193834-3bytm2c.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507193840-nud08nr.png" alt="image.png"></p>
<p>创建user2（密码123456）</p>
<p><img src="/assets/2/image-20220507193846-j2660j7.png" alt="image.png"></p>
<p>重设密码</p>
<p><img src="/assets/2/image-20220507193853-2q1gexn.png" alt="image.png"></p>
<p>3.4 修改仓库权限<br>右键仓库，属性</p>
<p><img src="/assets/2/image-20220507193904-rq54wno.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507193912-9rzbghw.png" alt="image.png"></p>
<ol start="4">
<li><p>安装TortoiseSVN客户端</p>
<p> <img src="/assets/2/image-20220507193921-wgojj4v.png" alt="image.png"></p>
</li>
</ol>
<p>TortoiseSVN是Subversion版本控制系统的一个优秀的免费开源客户端。</p>
<p>官方网址： Home · TortoiseSVN</p>
<p><img src="/assets/2/image-20220507193930-h1jfa5n.png" alt="image.png"></p>
<p>下载地址：</p>
<p><a href="https://tortoisesvn.net/downloads.html">Downloads · TortoiseSVN</a></p>
<p><img src="/assets/2/image-20220507194004-jcgbkru.png" alt="image.png"></p>
<p>安装图解：</p>
<p><img src="/assets/2/image-20220507194012-cew8bzm.png" alt="image.png"></p>
<p>一路next：</p>
<p><img src="/assets/2/image-20220507194019-jkvzgj6.png" alt="image.png"></p>
<p>安装成功后、右键单击、可出现SVN菜单：</p>
<p><img src="/assets/2/image-20220507194027-sr06dxl.png" alt="image.png"></p>
<p>汉化：</p>
<p><img src="/assets/2/image-20220507194036-aw2uaqh.png" alt="image.png"></p>
<ol start="5">
<li><p>使用Checkout检出仓库代码<br> 查看仓库地址：</p>
<p> <img src="/assets/2/image-20220507194043-vy4fx91.png" alt="image.png"></p>
</li>
</ol>
<p>右键 -&gt; SVN Checkout…</p>
<p><img src="/assets/2/image-20220507194053-njpqdhl.png" alt="image.png"></p>
<p>查看本机IP：</p>
<p><img src="/assets/2/image-20220507194059-cay0k8k.png" alt="image.png"></p>
<p>检出rep1仓库：</p>
<p><img src="/assets/2/image-20220507194106-kizum1r.png" alt="image.png"></p>
<p>接受证书：</p>
<p><img src="/assets/2/image-20220507194114-b9vksi2.png" alt="image.png"></p>
<p>输入用户名和密码，并保存认证：</p>
<p><img src="/assets/2/image-20220507194120-7708ar8.png" alt="image.png"></p>
<p>成功检出到本地：</p>
<p><img src="/assets/2/image-20220507194126-sa2t3c5.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194141-q5dpkqt.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194150-u28meae.png" alt="image.png"></p>
<ol start="6">
<li><p>添加文件、修改文件<br> 6.1 添加文件<br> 在rep1文件夹下新建1.txt并保存</p>
<p> <img src="/assets/2/image-20220507194200-vjfcwnu.png" alt="image.png"></p>
</li>
</ol>
<p>右键 -&gt; 增加 ：将文件加入版本管理</p>
<p><img src="/assets/2/image-20220507194207-3xyjbuf.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194213-3wju7cr.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194234-0weu0ji.png" alt="image.png"></p>
<p>增加成功后，文件上面多了一个 ＋ 号</p>
<p><img src="/assets/2/image-20220507194241-dw2xzcq.png" alt="image.png"></p>
<p>右键 -&gt; 提交，写上备注</p>
<p><img src="/assets/2/image-20220507194250-vzi1z3m.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194255-r7unfvx.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194302-yr9rxug.png" alt="image.png"></p>
<p>提交成功后，文件上多了一个 “✓” 号</p>
<p><img src="/assets/2/image-20220507194310-cx73sbp.png" alt="image.png"></p>
<p>6.2 查看日志<br>TortoiseSVN -&gt; 显示日志</p>
<p><img src="/assets/2/image-20220507194317-w2k0x42.png" alt="image.png"></p>
<p>可以看到新增日志：</p>
<p><img src="/assets/2/image-20220507194327-sb7nf8m.png" alt="image.png"></p>
<p>服务器上可以看到文件：</p>
<p><img src="/assets/2/image-20220507194336-rc63iov.png" alt="image.png"></p>
<p>在新的地方更新目录：</p>
<p><img src="/assets/2/image-20220507194343-5e6qwpy.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194352-nvs0pqe.png" alt="image.png"></p>
<p>6.3 修改文件<br>修改文件并保存，文件图标变为红色感叹号</p>
<p><img src="/assets/2/image-20220507194400-gzjstyg.png" alt="image.png"></p>
<p>提交修改：</p>
<p><img src="/assets/2/image-20220507194408-v9acz3u.png" alt="image.png"></p>
<p>填写备注：</p>
<p><img src="/assets/2/image-20220507194415-fej0fy5.png" alt="image.png"></p>
<p>提交完成：</p>
<p><img src="/assets/2/image-20220507194422-59kpcfr.png" alt="image.png"></p>
<p>查看日志</p>
<p><img src="/assets/2/image-20220507194429-hzcki47.png" alt="image.png"></p>
<p>双击日志，可以显示出和上个版本的区别：</p>
<p><img src="/assets/2/image-20220507194437-p87juim.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194445-zo28y49.png" alt="image.png"></p>
<p>去查看另一个仓库，发现没有更新</p>
<p><img src="/assets/2/image-20220507194457-tl9zfqj.png" alt="image.png"></p>
<p>更新：</p>
<p><img src="/assets/2/image-20220507194504-2z7ioom.png" alt="image.png"></p>
<p>打开，发现已经同步：</p>
<p><img src="/assets/2/image-20220507194511-kdrua7q.png" alt="image.png"></p>
<ol start="7">
<li><p>版本回滚<br> 在rep1文件夹下打开1.txt，修改如下，此刻文件出现“！”号</p>
<p> <img src="/assets/2/image-20220507194519-js3uomp.png" alt="image.png"></p>
</li>
</ol>
<p>如果你没有提交，那么直接删除此文件，然后 更新 即可， 发现文件回复了，并且为“✓”号。</p>
<p><img src="/assets/2/image-20220507194526-xm7oudz.png" alt="image.png"></p>
<p>如果你已经提交了，且有日志记录</p>
<p><img src="/assets/2/image-20220507194535-l37d67y.png" alt="image.png"></p>
<p>那么就使用回滚</p>
<p><img src="/assets/2/image-20220507194542-2hogi2v.png" alt="image.png"></p>
<p>1.查看版本 2.选择版本 3.确定</p>
<p><img src="/assets/2/image-20220507194551-kig86ob.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194600-whnhwyb.png" alt="image.png"></p>
<p>注意：再次更新，会恢复到最新，提交的记录无法删除！！！</p>
<p><img src="/assets/2/image-20220507194609-47wdqmg.png" alt="image.png"></p>
<p>这样才能表示历史记录可追溯：</p>
<p><img src="/assets/2/image-20220507194617-4km3ud1.png" alt="image.png"></p>
<ol start="8">
<li><p>删除文件<br> 新建2.txt，并提交</p>
<p> <img src="/assets/2/image-20220507194624-m8zyocv.png" alt="image.png"></p>
<p> <img src="/assets/2/image-20220507194638-hifg5e8.png" alt="image.png"></p>
</li>
</ol>
<p>TortoiseSVN -&gt; 删除，此时文件会消失</p>
<p><img src="/assets/2/image-20220507194646-jf6kh2q.png" alt="image.png"></p>
<p>提交删除：</p>
<p><img src="/assets/2/image-20220507194653-hk6t6ap.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194659-9mvtcvs.png" alt="image.png"></p>
<ol start="9">
<li><p>解决冲突<br> 9.1 产生冲突的情况？<br> 当开发人员A和开发人员B从版本库同时检出文档1.txt，而A和B同事修改了1.txt的同一个地方，先提交的不会有任何问题，后提交的一方会在提交的时候产生冲突。</p>
<p> <img src="/assets/2/image-20220507194708-dr8mn9d.png" alt="image.png"></p>
</li>
</ol>
<p>A修改并提交：</p>
<p><img src="/assets/2/image-20220507194721-frknmle.png" alt="image.png"></p>
<p>B 修改并提交：</p>
<p><img src="/assets/2/image-20220507194728-73ek59w.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194738-4dirh5y.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194745-pdn64zz.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194750-8ll7trg.png" alt="image.png"></p>
<p>冲突会导致提交失败，并自动返回：</p>
<p><img src="/assets/2/image-20220507194756-z04d1vz.png" alt="image.png"></p>
<p>9.2 解决冲突<br>产生冲突的目录编程这样了，文件出现黄色的感叹号：</p>
<p><img src="/assets/2/image-20220507194803-tnh19uy.png" alt="image.png"></p>
<p>右键 -&gt; TortoiseSVN -&gt; 编辑冲突</p>
<p><img src="/assets/2/image-20220507194809-2ynjjzq.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194820-ri6d3gb.png" alt="image.png"></p>
<p>先删除掉问号：</p>
<p><img src="/assets/2/image-20220507194829-rffiwjp.png" alt="image.png"></p>
<p>拷贝到合并后的文件：</p>
<p><img src="/assets/2/image-20220507194837-yf9atqi.png" alt="image.png"></p>
<p>保存：</p>
<p><img src="/assets/2/image-20220507194844-k2o48ri.png" alt="image.png"></p>
<p>黄色的感叹号消失：</p>
<p><img src="/assets/2/image-20220507194851-ip6lujk.png" alt="image.png"></p>
<p>文件修改已经合并：</p>
<p><img src="/assets/2/image-20220507194858-m03fhi6.png" alt="image.png"></p>
<p>重新提交：</p>
<p><img src="/assets/2/image-20220507194905-g883x2y.png" alt="image.png"></p>
<ol start="10">
<li>创建分支<br> 什么是分支？</li>
</ol>
<p>在版本控制的系统中，我们经常需要对开发周期中的单独生命线作单独的修改，这条单独的开发生命线就可以称为Branches即分支。分支经常用于添加新的功能以及产品发布后的bug修复等，这样可以不影响主要的产品开发线以及避免编译错误等。当我们添加的新功能完成后可以将其合并到主干中。</p>
<p>10.1 创建分支<br>TortoiseSVN -&gt; 分支&#x2F;标记</p>
<p><img src="/assets/2/image-20220507194914-xklwrh0.png" alt="image.png"></p>
<p>创建分支：</p>
<p>1.源路径<br>2.分支路径<br>3.备注<br>4.版本</p>
<p><img src="/assets/2/image-20220507194923-0ep1rsy.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507194930-zsl5zhb.png" alt="image.png"></p>
<p>创建成功：</p>
<p><img src="/assets/2/image-20220507194936-8dj5hwv.png" alt="image.png"></p>
<p>服务器上也出现了：</p>
<p><img src="/assets/2/image-20220507194942-7hhnlta.png" alt="image.png"></p>
<p>在分支中添加文件：</p>
<p><img src="/assets/2/image-20220507194949-cdqoe91.png" alt="image.png"></p>
<p>10.2 合并分支<br>TortoiseSVN -&gt; 合并</p>
<p><img src="/assets/2/image-20220507194955-wqm3bci.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507195006-87kyiej.png" alt="image.png"></p>
<p>选择合并源：</p>
<p><img src="/assets/2/image-20220507195013-51ij04d.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507195019-rcff0e2.png" alt="image.png"></p>
<p>合并完成：</p>
<p><img src="/assets/2/image-20220507195025-y7va5xf.png" alt="image.png"></p>
<p>文件被合并到了trunk中</p>
<p><img src="/assets/2/image-20220507195031-rrnp20o.png" alt="image.png"></p>
<p>提交分支点合并到主分支</p>
<p><img src="/assets/2/image-20220507195031-rrnp20o.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507195045-klu1846.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220507195053-t87jv8j.png" alt="image.png"></p>
<p>查看日志：</p>
<p><img src="/assets/2/image-20220507195100-jhj6rsg.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>08_svn篇</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>QualityCenter</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/02_QualityCenter/01_QualityCenter/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>02_QualityCenter</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>禅道</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/03_%E7%A6%85%E9%81%93/01_%E7%A6%85%E9%81%93/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.zentao.net/book/zentaopmshelp/40.html" target="_blank">禅道使用帮助</a> <br/></li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>03_禅道</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>22_Jira报告</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/22_Jira%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>报告用于跟踪和分析整个项目中团队的绩效。Jira有一系列报告，显示有关您的项目，版本，冲刺，史诗和问题的信息。<br>以下是报告生成的报告：</p>
<h4 id="平均时长报告"><a href="#平均时长报告" class="headerlink" title="平均时长报告"></a>平均时长报告</h4><p>平均时长报告显示项目或过滤器未解决问题的平均时长。它可以帮助您显示积压是否保持最新。</p>
<p>基本上，它找到问题未解决的平均天数。</p>
<p>生成平均时长告，该报告取决于所选项目，过滤器中选择的问题类型以及时间(小时&#x2F;天&#x2F;周&#x2F;月)。</p>
<p>平均时长报告如下所示：</p>
<p><img src="/assets/2/image-20220503123842-sp2l09c.png" alt="image.png"><br>上面的屏幕显示了过去30天内所有未解决问题的平均时长。</p>
<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>饼图显示从指定项目或问题过滤器返回的问题。我们可以创建一个问题过滤器，用于检索属于特定项目特定版本的所有问题。创建饼图以对属于特定统计类型的所有问题进行分组，统计类型可以是受理人，项目等。</p>
<p>假设选择统计类型作为受让人。</p>
<p><img src="/assets/2/image-20220503123846-ga9c7vn.png" alt="image.png"></p>
<p>上面的屏幕显示了基于“受让人”类型的饼图。上图显示一个问题分配给 <strong>Akshita Gupta</strong> ，其他四个问题未分配。</p>
<h4 id="已创建与已解决的问题"><a href="#已创建与已解决的问题" class="headerlink" title="已创建与已解决的问题"></a>已创建与已解决的问题</h4><p>已创建与已解决的问题是一个报告，显示在给定时间段内创建和解决的问题数。<br>此报告是基于用户选择的项目和问题过滤器创建的，图表可以是累积的，也可以是累积的。</p>
<p><img src="/assets/2/image-20220503123851-xolknwz.png" alt="image.png"></p>
<h4 id="最近创建的问题报告"><a href="#最近创建的问题报告" class="headerlink" title="最近创建的问题报告"></a>最近创建的问题报告</h4><p>最近创建的问题报告显示了已创建的问题数，并解决了一些问题。<br><img src="/assets/2/image-20220503123856-2682c9c.png" alt="image.png"></p>
<p>在上面的屏幕中，红色部分显示问题已创建且未解决，而绿色显示问题已创建，但已解决。</p>
<h4 id="解决时间报告"><a href="#解决时间报告" class="headerlink" title="解决时间报告"></a>解决时间报告</h4><p>解决时间报告确定解决项目&#x2F;过滤器问题所用时间的长度。</p>
<h4 id="按报告单级组"><a href="#按报告单级组" class="headerlink" title="按报告单级组"></a>按报告单级组</h4><p>按报告的单级组按问题过滤器的特定字段对问题进行分类，但不显示图表。</p>
<p><img src="/assets/2/image-20220503123901-q4dgspj.png" alt="image.png"></p>
<p>上面的屏幕显示分配了一个问题，即HEL-1，而其他四个问题，即HEL-5，HEL-3，HEL-2，HEL-4，是未分配的。“按级别分组报告”显示已分配和未分配问题的进度。</p>
<h4 id="自问题报告以来的时间"><a href="#自问题报告以来的时间" class="headerlink" title="自问题报告以来的时间"></a>自问题报告以来的时间</h4><p>自问题报告以来的时间生成报告，该报告显示所选数据字段的问题数，并且数据字段可以是创建，更新，到期，已解决。</p>
<p><img src="/assets/2/image-20220503123905-bv2urpp.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>21_Jira版本</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/21_Jira%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>版本用于组织和计划发布。如果创建了版本并在版本上分配了问题，那么我们可以使用该版本来过滤各种报告中的信息。</p>
<p>可以将问题分配给特定版本，并可以组织该版本中的sprint。</p>
<h4 id="创建版本"><a href="#创建版本" class="headerlink" title="创建版本"></a>创建版本</h4><p> <strong>第1步：</strong> 进入到您的项目。<br> <strong>第2步：</strong> 单击面板左侧显示的版本( <em>Releases</em> )。</p>
<p><img src="/assets/2/image-20220503123653-71s5ctt.png" alt="image.png"></p>
<p> <strong>第3步：</strong> 点击<strong>Releases</strong>链接后，屏幕出现，如下所示：</p>
<p><img src="/assets/2/image-20220503123658-adcyssn.png" alt="image.png"></p>
<p> <strong>第4步：</strong> 单击“创建版本”按钮。<br> <strong>第5步：</strong> 单击“创建版本”按钮，将出现弹出窗口，询问版本名称及其描述。</p>
<p><img src="/assets/2/image-20220503123703-1bxxc58.png" alt="image.png"></p>
<h4 id="向版本添加问题"><a href="#向版本添加问题" class="headerlink" title="向版本添加问题"></a>向版本添加问题</h4><p> <strong>第1步：</strong> 进入到您的项目。<br> <strong>第2步：</strong> 单击面板左侧显示的Backlog。<br> <strong>第3步：</strong> 单击“版本”面板。</p>
<p><img src="/assets/2/image-20220503123708-ee2ni5s.png" alt="image.png"></p>
<p> <strong>第4步：</strong> 将问题拖到要在版本中添加的版本。</p>
<h4 id="完成一个版本"><a href="#完成一个版本" class="headerlink" title="完成一个版本"></a>完成一个版本</h4><p>可以在准备好发布版本时完成版本。当问题完成时，版本已准备好发布，并且会检查和检查代码。</p>
<p> <strong>第1步：</strong> 导航到您的项目。<br> <strong>第2步：</strong> 单击面板左侧显示的“版本”链接。</p>
<p><img src="/assets/2/image-20220503123713-rppzmpe.png" alt="image.png"></p>
<p> <strong>第3步：</strong> 要发布版本，请转到省略号**(…)** -&gt; <strong>发布</strong> 。</p>
<p><img src="/assets/2/image-20220503123718-3k8h61k.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>20_Jira史诗（Epic）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/20_Jira%E5%8F%B2%E8%AF%97%EF%BC%88Epic%EF%BC%89/</url>
    <content><![CDATA[<p>Jira史诗(Epic)是一个大型用户故事，根据客户或最终用户需求分解为较小的任务(用户故事)。</p>
<ul>
<li>根据客户需求，根据需要在史诗中添加或删除任务。</li>
<li>Epic用于组织工作和创建层次结构。</li>
<li>Epic通过将更大的任务组织成更小的任务来保持敏捷性。</li>
<li>Epic是工作层次结构的顶层，开发人员使用它。</li>
<li>Epic是更大的故事，具有明显的开始和结束。</li>
<li>Epic可以跨越多个冲刺，即，史诗是通过多个冲刺传递的。</li>
<li>Epic可以包含故事，错误和任务，并将它们分组成一个大故事。</li>
<li>当Epic包含故事，错误或任务时，所有这些问题类型都表示在Jira的层次结构中的同一级别。</li>
<li>故事，错误，任务代表单件作品，而史诗则是一组相关问题。</li>
</ul>
<p><strong>下面我们来理解史诗的结构流程：</strong></p>
<p>史诗由多个故事组成，而初步行动由Epics组成。因此，我们可以说这些初步行动举措超越了史诗。初步行动从多个团队中获取Epics，以实现比任何Epics都能实现的目标更大的目标。</p>
<p><img src="https://www.yiibai.com/uploads/article/2019/08/27/075442_67722.png" alt="史诗的结构流程" title="史诗的结构流程"></p>
<h2 id="史诗的工作"><a href="#史诗的工作" class="headerlink" title="史诗的工作"></a>史诗的工作</h2><h4 id="创造一个史诗"><a href="#创造一个史诗" class="headerlink" title="创造一个史诗"></a>创造一个史诗</h4><p>创建史诗有两种方法：</p>
<ul>
<li>从新问题创建史诗</li>
</ul>
<p><strong>第1步：</strong> 单击面板左侧显示的“+”图标。</p>
<p><img src="/assets/2/image-20220503123338-eyvewfq.png" alt="image.png"></p>
<p> <strong>第2步：</strong> 单击 <strong>+</strong> 图标，屏幕出现，如下所示：</p>
<p><img src="/assets/2/image-20220503123343-f9dv2d0.png" alt="image.png"></p>
<p> <strong>第3步：</strong> 选择问题类型为Epic。</p>
<ul>
<li>从Epics面板创建一个史诗</li>
</ul>
<p> <strong>第1步：</strong> 单击面板左侧显示的Backlog。<br><img src="/assets/2/image-20220503123348-d21m1uo.png" alt="image.png"></p>
<p><strong>第2步：</strong> 单击史诗面板中显示的Epics。</p>
<p><img src="/assets/2/image-20220503123405-vigcbeo.png" alt="image.png"></p>
<p> <strong>第3步：</strong> 单击<strong>Create Epic</strong>链接。</p>
<p>在上述两种情况下，需要输入以下详细信息才能创建史诗：</p>
<ul>
<li>史诗名称：它是史诗的简短唯一标识符。</li>
<li>史诗摘要：它提供了史诗的简短描述。</li>
</ul>
<h4 id="添加和删除故事"><a href="#添加和删除故事" class="headerlink" title="添加和删除故事"></a>添加和删除故事</h4><p>在史诗中添加故事的方法有两种：</p>
<ul>
<li>从问题创建屏幕添加问题</li>
</ul>
<p> <strong>第1步：</strong> 单击面板左侧出现的 <strong>+</strong> 图标。</p>
<p><img src="/assets/2/image-20220503123410-vsf5uob.png" alt="image.png"></p>
<p><strong>第2步：</strong> 单击问题类型的下拉列表，然后选择史诗以外的问题类型。<br><img src="/assets/2/image-20220503123410-vsf5uob.png" alt="image.png"></p>
<p>上面的屏幕显示我们已经创建了Bug类型的问题，在史诗“摘要”中添加了这个问题。我们在史诗链接字段中添加史诗。</p>
<ul>
<li><strong>从Epics面板添加问题</strong></li>
</ul>
<p> <strong>第1步：</strong> 单击面板左侧显示的Backlog。<br> <strong>第2步：</strong> 点击Epics面板中的Epics。<br> <strong>第3步：</strong> 单击史诗链接中的创建问题。<br><img src="/assets/2/image-20220503123420-45g6iym.png" alt="image.png"></p>
<ul>
<li><strong>从史诗中删除一个问题</strong></li>
</ul>
<p>要从Epic中删除问题，请按照以下步骤操作：</p>
<p> <strong>第1步：</strong> 移至Backlog页面。<br> <strong>第2步：</strong> 将问题拖放到没有史诗的问题。</p>
<p><img src="/assets/2/image-20220503123425-mbhqqsl.png" alt="image.png"></p>
<h4 id="查看所有的Epics"><a href="#查看所有的Epics" class="headerlink" title="查看所有的Epics"></a>查看所有的Epics</h4><p>可以在Backlog中看到与史诗相关的信息。</p>
<p><img src="/assets/2/image-20220503123431-k4usd83.png" alt="image.png"></p>
<ul>
<li><strong>Epics面板：</strong> 导航到Backlog，然后单击Epics面板以查看和管理epics。</li>
<li><strong>Epics列表：</strong> Epics面板显示项目中所有史诗的列表。</li>
<li><strong>查看史诗中的问题：</strong> 单击史诗的名称可查看所有史诗冲刺中的所有问题。</li>
</ul>
<h4 id="完成史诗"><a href="#完成史诗" class="headerlink" title="完成史诗"></a>完成史诗</h4><p>一旦完成了与史诗相关的所有工作，那么史诗就会被标记为完整。</p>
<p>以下是完成史诗所需的步骤：</p>
<ul>
<li>单击面板左侧显示的Backlog。</li>
<li>点击Epics面板中的Epics。</li>
<li>选择要将其标记为“完成”的史诗。</li>
<li>单击下拉列表并选择“标记为完成”选项。<br><img src="/assets/2/image-20220503123437-z76lk5b.png" alt="image.png"></li>
</ul>
<p>将史诗标记为“完成”时，将出现确认完成对话框。</p>
<p><img src="/assets/2/image-20220503123442-z74tugo.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>19_Jira与Bugzilla</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/19_Jira%E4%B8%8EBugzilla/</url>
    <content><![CDATA[<p>Jira和Bugzilla是大型组织广泛使用的bug跟踪工具。如今这两种工具都需求巨大，但这两种工具的性能各不相同。让我们首先看看这两个工具的关键点，然后再看看这两个工具之间的区别。</p>
<h2 id="Jira"><a href="#Jira" class="headerlink" title="Jira"></a>Jira</h2><p>Jira是一家由澳大利亚Atlassian公司于2002年开发的错误跟踪工具。它用于项目管理，问题跟踪和错误跟踪。Jira不是一个开源工具，即Jira软件不是免费提供的; 这是一项付费服务。</p>
<p><strong>Jira软件的优点</strong></p>
<ul>
<li>Jira工具对于功能测试很有用。</li>
<li>它用于确定任务的优先级。</li>
<li>随着Jira工具提供更好的可见性，人们可以轻松了解构建的下一个版本。</li>
<li>它提供了更好的灵活性工作流程，以便团队可以相应调整。</li>
</ul>
<h2 id="Bugzilla"><a href="#Bugzilla" class="headerlink" title="Bugzilla"></a>Bugzilla</h2><p>Bugzilla也是一个由Mozilla Foundation于1998年开发的bug跟踪工具。它是一个非常流行的报告工具，具有简单的用户界面。由于其简单的界面，初学者不会花时间了解其工作流程。</p>
<p><strong>Bugzilla的优点</strong></p>
<ul>
<li>它提高了产品的质量。</li>
<li>它增强了开发团队和测试团队之间的沟通。</li>
<li>它具有适应多种情况的能力。</li>
</ul>
<h2 id="Jira和Bugzilla区别"><a href="#Jira和Bugzilla区别" class="headerlink" title="Jira和Bugzilla区别"></a>Jira和Bugzilla区别</h2><p><img src="/assets/2/image-20220503123207-dbym8wh.png" alt="image.png"></p>
<p>以下是Jira和Bugzilla之间的区别是：</p>
<ul>
<li><strong>许可证</strong><br>Jira软件仅适用于商业许可证所有者，而Bugzilla软件是一种开源工具，即无需任何许可即可使用。</li>
<li><strong>服务器端架构</strong><br>Jira软件的服务器端架构基于MySQL，Oracle，PostgreSQL，Perl构建，而Bugzilla软件的服务器端架构构建于J2EE，Tomcat，Lucene，MySQL，Oracle，PostgreSQL之上。</li>
<li><strong>服务器负载</strong><br>与Jira软件相比，Bugzilla中的服务器负载相当低。在Bugzilla中，多个实例可以在一台服务器上运行而没有太多开销，而Jira是一个复杂的系统，每个Web请求执行大多数服务器端代码，因为服务器负载要高得多。建议为Jira提供强大的硬件，即现代CPU和1 GB内存。根据Atlassian社区的说法，不要在单个JIRA实例上存储超过200,000个问题。</li>
<li><strong>拖放问题优先级</strong><br>拖放问题优先级功能在Jira中可用，但在Bugzilla中不可用。在Jira中，您可以根据问题的优先级轻松拖放问题，但这在Bugzilla中是不可能的。</li>
<li><strong>带有自定义小工具的仪表板</strong><br>小工具提供所有详细信息的摘要，例如团队的进度，报告等。Jira提供“带有自定义小工具的仪表板”功能，您可以根据需要自定义小工具，但Bugzilla中不提供此功能。</li>
<li><strong>实时发布跟踪</strong><br>软件开发过程中最重要的一点是可见性。Jira通过提供开发团队和测试团队之间的沟通来克服这个问题，团队成员可以通过该沟通了解“任务何时开始”和“任务何时完成”。Bugzilla不提供此功能。</li>
<li><strong>附件</strong><br>在Jira中，一次可以附加多个文件，而在Bugzilla中，一次只能添加一个文件。</li>
<li><strong>文件附件的大小限制</strong><br>Jira中文件的大小限制为10 MB，而Bugzilla中文件附件的大小限制为1mb。</li>
<li><strong>看板支持</strong><br>Jira支持看板项目，但Bugzilla不支持看板项目。</li>
<li><strong>用户界面</strong><br>Jira用户界面比Bugzilla的用户界面要好得多。在Jira中，已经做了很多努力来改进用户界面，但在Bugzilla中，界面多年来没有太大变化。</li>
<li><strong>自定义字段类型</strong><br>Bugzilla中提供的自定义字段类型包括文本字段，多选，下拉列表，错误ID。Jira中有太多可用的字段类型，插件中提供了更多自定义字段类型。</li>
<li><strong>工作流程</strong><br>在Bugzilla中，管理员通过编辑转换矩阵来定义所有产品的全局工作流，而Jira允许用户根据问题和项目的类型定义多个工作流，并且问题经历多个状态。</li>
<li><strong>搜索</strong><br>Bugzilla提供了一种高级搜索功能，但Jira具有更灵活的Jira查询语言，可提供更强大的搜索功能，用于创建项目状态和监控项目进度。</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>18_JIRA缺陷生命周期</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/18_JIRA%E7%BC%BA%E9%99%B7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>JIRA bug生命周期也称为缺陷生命周期。错误生命周期由一组错误通过的状态组成。错误经历的状态数因项目而异。我们可以将Bug定义为错误，缺陷或者我们可以说当实际输出与预期输出不匹配时，它被称为错误或缺陷。这两个术语，即bug和缺陷都是常用的，但最流行的是一个bug。可以在SDLC(软件开发生命周期)的任何阶段生成错误，它可以存在于需求收集，设计SRS文档的设计阶段，开发阶段，测试阶段或最终用户在 使用申请的时间。</p>
<p>从错误登录到错误关闭点的角度来看，错误的生命周期。Bug经历以下状态：</p>
<ul>
<li>新建(New)</li>
<li>分配(Assigned)</li>
<li>打开(Open)</li>
<li>确定(Fixed)</li>
<li>复验(Retesting)</li>
<li>重打开(Reopen)</li>
<li>已验证(Verified)</li>
<li>关闭(Closed)</li>
</ul>
<p><img src="/assets/2/image-20220503123024-e1ie1uc.png" alt="image.png"></p>
<h4 id="新建-New"><a href="#新建-New" class="headerlink" title="新建(New)"></a>新建(New)</h4><p>在测试阶段，测试人员会识别错误或缺陷，并登录到Jira，Bugzilla等错误跟踪工具中。测试人员检测到的错误将首次发布在错误跟踪工具中。此状态被指定为新状态。</p>
<h4 id="分配-Assigned"><a href="#分配-Assigned" class="headerlink" title="分配(Assigned)"></a>分配(Assigned)</h4><p>将新状态的错误分配给软件开发人员，他们将查看错误以检查错误是有效还是无效。如果错误无效，则他们将状态更改为无效。如果错误有效，则状态将更改为已分配，然后软件开发人员开始处理缺陷以获得修复。</p>
<h4 id="打开-Open"><a href="#打开-Open" class="headerlink" title="打开(Open)"></a>打开(Open)</h4><p>当错误被分配给软件开发人员时，他们就开始对其进行分析并处理缺陷修复。错误或缺陷可以分三个阶段打开：</p>
<h4 id="确定-Fixed"><a href="#确定-Fixed" class="headerlink" title="确定(Fixed)"></a>确定(Fixed)</h4><ul>
<li><strong>重复</strong><br>如果缺陷重复两次或缺陷对应于前一个bug的相同概念，则它将状态更改为Duplicate。</li>
<li><strong>被拒绝</strong><br>如果开发人员认为缺陷不是真正的缺陷，那么它会将状态更改为“已拒绝”。</li>
<li><strong>递延</strong><br>如果错误的优先级不高并且可以在下一个版本中解决，则状态将更改为Deferred。延迟状态也称为推迟状态。</li>
</ul>
<h4 id="复验-Retesting"><a href="#复验-Retesting" class="headerlink" title="复验(Retesting)"></a>复验(Retesting)</h4><p>当开发人员进行必要的代码更改并验证更改时，他&#x2F;她可以将错误状态设置为已修复。当开发人员修复错误后，状态将更改为“重新打开”或“已验证”。</p>
<h4 id="重打开-Reopen"><a href="#重打开-Reopen" class="headerlink" title="重打开(Reopen)"></a>重打开(Reopen)</h4><p>如果在开发人员修复了bug之后bug仍然存在，那么测试人员将状态更改为Reopen，并且bug再次通过整个bug生命周期。</p>
<h4 id="已验证-Verified"><a href="#已验证-Verified" class="headerlink" title="已验证(Verified)"></a>已验证(Verified)</h4><p>如果没有发现错误，测试人员在开发人员修复错误后重新测试该错误，然后将状态更改为已验证。</p>
<h4 id="关闭-Closed"><a href="#关闭-Closed" class="headerlink" title="关闭(Closed)"></a>关闭(Closed)</h4><p>如果错误不再存在，则会将状态更改为“已关闭”。</p>
<p>Bug生命周期的参与者 -</p>
<ul>
<li><strong>Bug报告者</strong><br>识别错误的人称为 <strong>Bug Reporter</strong> 。Bug报告者验证错误并将所有与bug相关的详细信息输入到错误跟踪工具中，例如正确的主题，错误优先级，应用程序组件，测试环境，错误受理人，错误描述。如果需要，测试人员需要发送附加的屏幕截图以澄清错误详细信息。</li>
<li><strong>错误跟踪工具</strong><br>可以将错误记录到错误跟踪工具中，错误跟踪工具可以是Jira，Bugzilla，Assembla等。</li>
<li><strong>Bug小组</strong><br>Bug小组是一组可以查看错误详细信息的人。Bug小组可以包括报告错误的测试人员或最终用户，分配错误的开发人员，项目经理，QA经理。</li>
<li><strong>Bug所有者</strong><br>错误所有者是审核并拥有该错误的人。错误所有者检查错误信息是否足够，如果没有，则将错误分配给错误报告者以提供更多信息。根据bug的优先级，Bug所有者获取bug的所有权并在截止日期内修复它。</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>17_Jira控制面板</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/17_Jira%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<p>控制面板显示项目中发生的所有问题，为您提供查看，管理和报告工作进度的灵活方式。</p>
<p>Jira中存在三种类型的控制面板：</p>
<p><img src="/assets/2/image-20220503122700-julhaka.png" alt="image.png"></p>
<ul>
<li><strong>下一代板</strong><br>这个板对那些刚接触敏捷的人很有用。它是一个非常简化，直接和流线型的板。</li>
<li><strong>Scrum板</strong><br>当团队处理包含待办事项的冲刺时，此板很有用。</li>
<li><strong>看板</strong><br>看板是一种灵活的项目管理工具，专为工作可视化，限制在制品和最大化效率而设计。</li>
</ul>
<h4 id="Scrum板"><a href="#Scrum板" class="headerlink" title="Scrum板"></a>Scrum板</h4><p>Scrum板分为三个部分：</p>
<ul>
<li><strong>积压</strong><br>积压( <em>backlog</em> )是项目中可用的一组活动或问题。所有问题都分为积压和冲刺。在scrum backlog中，可以创建和更新问题，拖放问题并将其分配给sprint，拖放问题以对其进行排名。</li>
</ul>
<p><img src="/assets/2/image-20220503122706-3bggp2f.png" alt="image.png"><br>上面的屏幕显示了包含问题<strong>TP-1</strong>的积压，它的描述是登录按钮不起作用。</p>
<ul>
<li>活动冲刺<br><strong>Active sprint</strong>是一个包含团队当前正在处理的问题。也可以拖放问题并将其分配回待办事项。</li>
</ul>
<p><strong>创建活动sprint的步骤：</strong></p>
<p>单击Backlog。点击Backlog后，屏幕出现，如下所示：<br><img src="/assets/2/image-20220503122712-qs7ord4.png" alt="image.png"></p>
<p>上面的屏幕显示Backlog，其中包含“登录按钮无法正常工作”的问题。</p>
<ul>
<li>单击<strong>Create sprint</strong>按钮创建sprint。单击<strong>Create sprint</strong>按钮，将出现如下屏幕所示的屏幕：</li>
</ul>
<p><img src="/assets/2/image-20220503122717-snhqs6x.png" alt="image.png"></p>
<p>上面的屏幕显示的sprint是 <strong>Sprint 1</strong> 。</p>
<ul>
<li>将问题从积压拖放到 <strong>Sprint 1</strong> ，如下图所示 -<br><img src="/assets/2/image-20220503122722-rux1bm0.png" alt="image.png"></li>
</ul>
<p>在上面的屏幕中，我们观察到问题已从积压拖到 <strong>Sprint 1</strong> ，并且问题已从积压中删除。</p>
<ul>
<li>单击开始冲刺按钮以进行活动冲刺。</li>
<li>单击面板左侧显示的Active sprint。</li>
</ul>
<p><img src="/assets/2/image-20220503122728-j30xmvk.png" alt="image.png"></p>
<p>上面的屏幕显示<strong>Sprint 1</strong>是团队目前正在进行的活跃冲刺。</p>
<ul>
<li><strong>报告</strong></li>
</ul>
<p>报告是将在整个项目中执行的活动。制作报告，用于显示有关项目，版本，史诗，冲刺和问题的信息。</p>
<h4 id="看板"><a href="#看板" class="headerlink" title="看板"></a>看板</h4><p>看板是一个过程，它提供您今天所做的所有工作的可视化。</p>
<p>看板由三部分组成：</p>
<ul>
<li><strong>积压</strong><br>看板有一个单独的Backlog列，我们为团队计划工作。在一个小栏目中规划工作变得非常困难，因此通过使用看板积压为处理问题提供了更大的空间。</li>
</ul>
<p><strong>在看板框架中创建待办事项的步骤：</strong></p>
<p>创建一个问题。当创建一个问题时，它会自动添加到Backlog中。<br><img src="/assets/2/image-20220503122734-fafagt1.png" alt="image.png"><br>上面的屏幕显示我们创建的<strong>HEL-1</strong>问题已添加到待办事项中。</p>
<ul>
<li><p><strong>看板控制面板</strong> - 看板是一个基于持续交付工作的过程。在看板框架中，不是计划迭代，而是连续监视工作流当任务完成时，新任务被添加到进行中状态。看板控制面板由三种状态组成：</p>
<ul>
<li>入选开发</li>
<li>进行中</li>
<li>完成</li>
</ul>
</li>
<li><p><strong>报告</strong><br>报告是将在整个项目中执行的活动。制作报告，用于显示有关项目，版本，史诗，冲刺和问题的信息。</p>
</li>
</ul>
<h4 id="下一代控制面板"><a href="#下一代控制面板" class="headerlink" title="下一代控制面板"></a>下一代控制面板</h4><p>下一代(next-gen)控制面板与经典的scrum和看板相同。但是，next-gen控制面板在开始时并未提供所有功能，它仅在您需要时提供该功能。Next-gen项目可以在两个模板中完成，即<strong>Next-gen Scrum</strong>和 <strong>Next-gen Kanban</strong> 。</p>
<p>如何创建下一代项目？</p>
<p><strong>可以通过以下步骤创建下一代项目：</strong></p>
<p>单击<strong>Create project</strong>下拉菜单，然后选择<strong>Try next-gen project</strong>选项。</p>
<p><img src="/assets/2/image-20220503122741-wwfxa3y.png" alt="image.png"></p>
<ul>
<li>单击<strong>Try next-gen</strong>项目后，屏幕出现，如下所示：</li>
</ul>
<p><img src="/assets/2/image-20220503122748-tqceb3a.png" alt="image.png"></p>
<p>上面的屏幕显示选择了Scrum模板，也可以通过点击链接更改模板来更改模板。选择模板后，输入项目名称，我们将<em>Test Project</em> 作为项目名称。单击“创建”按钮。</p>
<p>单击创建按钮后，将创建<strong>Next-gen Scrum</strong>项目，如下所示：</p>
<p><img src="/assets/2/image-20220503122754-rfrmfb7.png" alt="image.png"></p>
<blockquote>
<p><strong>注意：</strong> Next-Gen Scrum和Next-Gen Kanban项目都有一个路线图功能，可以显示团队的进度，还可以定义项目的截止日期。</p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>09_JIRA问题</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/09_JIRA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>JIRA Issue用于跟踪已完成或未完成的各项工作。JIRA问题可能是软件错误或任何其他问题。在Jira中导入项目后，可以创建问题。</p>
<h4 id="问题类型"><a href="#问题类型" class="headerlink" title="问题类型"></a>问题类型</h4><p>团队共同努力将工作分解为问题。问题可能代表软件错误，项目任务，子任务或任何其他项目工作。Jira项目附带默认问题类型，还可以创建自己的问题类型。</p>
<p>问题类型是工作单元的通用名称。在Jira中，我们在项目中有不同的工作单元，而问题类型字段区分了这一点。</p>
<p>创建问题时，您需要指定问题类型。甚至可以在创建问题后更改问题类型。</p>
<p>每个问题都有一个与之关联的图标，用于标识问题类型。</p>
<p> <strong>自定义问题类型：</strong> 它还用于创建自定义问题类型，为团队提供根据其项目创建自己的问题类型的灵活性</p>
<p>以下屏幕显示问题类型列表：<br><img src="/assets/2/image-20220503111822-8t5nmhy.png" alt="image.png"></p>
<p><strong>问题类型有三种类型：</strong></p>
<ul>
<li><p><strong>JIRA核心默认问题类型</strong></p>
<ul>
<li>任务：任务是团队完成的工作项，但不直接与用户的要求相关联。例如，升级团队使用的产品版本。</li>
<li>子任务：这是另一个问题的一部分。它用于将问题分解为不同的工作。在创建问题时，问题类型字段下拉列表中未提供子任务问题，因为它包含一些父问题，因此可以说无法单独创建子任务问题。</li>
</ul>
</li>
<li><p><strong>JIRA软件默认问题类型</strong></p>
<ul>
<li>故事：从用户的角度来看，这是一个要求。</li>
<li>错误：这是产品中的缺陷，需要由开发人员修复。可以使用自己的问题类型跟踪它，以区别于其他类型的工作。</li>
<li>史诗：史诗是一个包含其他问题的大问题。</li>
</ul>
</li>
<li><p><strong>JIRA服务台默认问题类型</strong></p>
<ul>
<li>事件</li>
<li>服务请求</li>
<li>更改</li>
<li>问题</li>
</ul>
</li>
</ul>
<h4 id="为什么要使用问题类型？"><a href="#为什么要使用问题类型？" class="headerlink" title="为什么要使用问题类型？"></a>为什么要使用问题类型？</h4><p><strong>使用问题类型的原因如下：</strong></p>
<ul>
<li>它们支持多个工作项。通常，团队包含多个工作项，而问题类型用于区分这些工作项。</li>
<li>每种问题类型可以具有不同的字段，屏幕和工作流程。例如，错误出现在项目板的顶部。</li>
<li>可以单独报告问题类型。问题按问题类型分类; 例如，要报告上周工作的进度。</li>
</ul>
<p><strong>子任务</strong></p>
<ul>
<li>子任务是一种必须具有父问题的问题类型。</li>
<li>要创建子任务，请单击父问题的创建子任务图标。<br><img src="/assets/2/image-20220503111828-gjmlb0a.png" alt="image.png"></li>
<li>它将问题转换为单独的可管理任务，并将每个任务分配给团队成员。</li>
<li>子任务比父母问题更具技术性。例如，问题的类型是故事，然后故事中写的行将是非技术性的，以便团队成员和利益相关者可以理解。但是子任务是用技术方式编写实现子任务的。</li>
</ul>
<p><strong>子任务特征</strong></p>
<ul>
<li>子任务有自己的问题关键字和字段。</li>
<li>子任务具有独立的工作流程状态</li>
<li>子任务问题类型可以转换为另一个问题。</li>
</ul>
<h4 id="将子任务转换为发布"><a href="#将子任务转换为发布" class="headerlink" title="将子任务转换为发布"></a>将子任务转换为发布</h4><p>转到子任务的详细信息，然后单击 <strong>更多(…)</strong> 按钮，然后单击 <strong>转换为问题(Convert to Issue)</strong> 。<br><img src="/assets/2/image-20220503111833-o4qck15.png" alt="image.png"></p>
<p>单击转换为问题时，将出现如下所示的屏幕。可以选择所选的问题类型。<br><img src="/assets/2/image-20220503111839-nqgskhm.png" alt="image.png"></p>
<h4 id="将问题转换为子任务"><a href="#将问题转换为子任务" class="headerlink" title="将问题转换为子任务"></a>将问题转换为子任务</h4><p>打开要转换为子任务的问题。单击 <strong>on (…)</strong> 按钮，然后将打开下拉菜单。<br><img src="/assets/2/image-20220503111844-dt5kktt.png" alt="image.png"><br>单击<em>Convert to Subtask</em> 菜单项。单击转换为子任务，将出现如下所示的屏幕：</p>
<p><img src="/assets/2/image-20220503111849-ct0fc4l.png" alt="image.png"></p>
<p>在上面的屏幕中，选择父问题，然后单击<em>Next &gt;&gt;</em> 。以下屏幕显示不需要 <strong>步骤2</strong> 。单击 <em>Next &gt;&gt;</em> 。</p>
<p><img src="/assets/2/image-20220503111855-7mt49kr.png" alt="image.png"></p>
<p>以下屏幕是确认，单击“完成”按钮。</p>
<p><img src="/assets/2/image-20220503111900-inryrti.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>11_JIRA登录</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/11_JIRA%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>以下是登录Jira的步骤：</p>
<ul>
<li>要登录Jira，请转到我们在Jira中创建的网站。出现登录页面，然后您需要填写用户名和密码等凭据。单击继续按钮。<br><img src="/assets/2/image-20220503120850-xjv99s2.png" alt="image.png"></li>
<li>输入密码，然后单击“登录”按钮。<br><img src="/assets/2/image-20220503120858-r3yruj5.png" alt="image.png"></li>
<li>如果密码不正确，则会显示验证消息“不正确的电子邮件地址或密码”。这显示在下面的屏幕截图中：</li>
</ul>
<p><img src="/assets/2/image-20220503120905-bvwcebu.png" alt="image.png"></p>
<ul>
<li>要解决上述错误，请单击“无法登录”？链接。点击链接，我们将看到如下所示的屏幕：<br><img src="/assets/2/image-20220503120911-xt71qda.png" alt="image.png"></li>
<li>单击“发送恢复链接”按钮。单击“发送恢复链接”按钮后，邮件将发送到已注册的电子邮件ID，并要求您重置密码。当您单击<strong>重置我的密码</strong>按钮时，将显示如下所示的屏幕：</li>
</ul>
<p><img src="/assets/2/image-20220503120917-avhqbw3.png" alt="image.png"></p>
<ul>
<li>输入新密码，然后单击“继续”按钮。</li>
<li>当我们提供错误的用户名或密码时，会出现上述情况。成功登录后，您的jira帐户将会打开，并出现如下所示的屏幕：</li>
</ul>
<p><img src="/assets/2/image-20220503120923-1jt0lmc.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>12_JIRA仪表盘</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/12_JIRA%E4%BB%AA%E8%A1%A8%E7%9B%98/</url>
    <content><![CDATA[<p>登录Jira时，将出现的第一个屏幕是仪表盘。仪表盘只能由管理员自定义，管理员可以根据角色访问Jira。</p>
<p>管理员甚至可以更改颜色和Jira徽标。</p>
<p>您可以创建多个仪表盘，帮助您在不同的图表中组织项目，分配和成果。</p>
<h2 id="默认仪表盘"><a href="#默认仪表盘" class="headerlink" title="默认仪表盘"></a>默认仪表盘</h2><p>可以在默认仪表板中添加小工具，也可以配置默认仪表板。还可以配置仪表板的布局，例如多个列。对默认仪表板所做的所有更改也将反映当前使用默认仪表板的用户的仪表板中的更改。例如，“管理”小工具存在于“默认”仪表板中，但仅对管理员可见。</p>
<p>以下是可用于在默认仪表板中添加小工具的步骤：</p>
<ul>
<li>登录Jira网站。</li>
</ul>
<p><img src="/assets/2/image-20220503121148-vub82jm.png" alt="image.png"></p>
<ul>
<li>单击“添加小工具”链接。<br><img src="/assets/2/image-20220503121154-igzwmsp.png" alt="image.png"></li>
<li>添加小工具后，小工具将添加到信息中心，然后点击“保存”按钮。</li>
</ul>
<p><img src="/assets/2/image-20220503121205-lz5vi68.png" alt="image.png"></p>
<ul>
<li>保存小工具后，将创建气泡图，如下所示：</li>
</ul>
<p><img src="/assets/2/image-20220503121211-h0ixm8b.png" alt="image.png"></p>
<h3 id="创建仪表板"><a href="#创建仪表板" class="headerlink" title="创建仪表板"></a>创建仪表板</h3><p>以下是创建仪表板的步骤：</p>
<ul>
<li>单击“…”按钮。</li>
</ul>
<p><img src="/assets/2/image-20220503121219-7af7cml.png" alt="image.png"></p>
<p>单击“…”下拉菜单中的“创建仪表板”。单击“创建”仪表板后，将出现屏幕，如下所示：</p>
<p><img src="/assets/2/image-20220503121224-tlj5dg6.png" alt="image.png"></p>
<ul>
<li>输入仪表板的详细信息，例如仪表板的名称，描述等，然后单击“创建”按钮。假设要将仪表板的名称提供为 <strong>Job Portal</strong> 。以下屏幕显示已创建仪表板：</li>
</ul>
<p><img src="/assets/2/image-20220503121230-dzd53xf.png" alt="image.png"></p>
<blockquote>
<p>注意：还可以通过单击“…”按钮编辑仪表板，然后单击“编辑仪表板”。</p>
</blockquote>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>10_JIRA工作流</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/10_JIRA%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<p>工作流是一组活动，用于跟踪问题生命周期中问题的状态和转换。<br>当问题从一种状态转移到另一种状态时，转换代表两种状态之间的链接形式的一些工作。<br><strong>状态：</strong> 状态确定工作对测试人员提交的问题的影响。</p>
<p>在Jira工具中，以下是工作流中发生的阶段(状态)：</p>
<ul>
<li>待办状态</li>
<li>进行中状态</li>
<li>完成状态</li>
</ul>
<p><img src="/assets/2/image-20220503120444-qhcluzd.png" alt="image.png"></p>
<p>在TODO状态下执行了两项活动：</p>
<ul>
<li>问题创建<br>当测试人员发现缺陷时，在Jira工具中记录缺陷。在Jira工具中记录缺陷后，Jira工具会生成唯一的故障单标识号。此过程称为问题创建。</li>
<li>摘要和其他详细信息<br>问题创建需要一些额外的信息，这些信息将被添加或更新到问题，例如问题描述，优先级，严重性，受影响的组件，子任务，上传屏幕截图，电子邮件历史记录等。在将所有详细信息添加到问题后，Jira工具分配 作为TODO状态的状态。</li>
</ul>
<p>在进行中状态中执行了三项活动：</p>
<ul>
<li>问题分配<br>创建问题后，会将其分配给某个人或团队。将问题分配给某人后，状态将更改为“进行中”状态。</li>
<li>工作回顾<br>有关该问题的工作首先由问题记录者，受让人和其他项目的管理人员进行审查和监督。当开发人员删除问题时，它首先由开发人员进行单元测试，然后代码审查团队对其进行审核。在工作审核活动期间，状态仍处于“进行中”状态。</li>
<li>质量分析<br>代码审核后，质量分析团队会对更改进行验证，其中包括回归测试。如果QA团队发现更改中存在任何问题，则问题将重新分配给开发人员，否则QA团队将关闭该问题，该问题表明问题已得到解决。在质量分析期间，状态仍处于“进行中”状态。</li>
</ul>
<p>一个活动在完成状态下执行：</p>
<ul>
<li>发布到生产，一旦产品开发和测试，产品就会在市场上发布。当产品在市场上发布时，状态将更改为“完成”状态。</li>
</ul>
<p><strong>JIRA工作流也可以称为缺陷生命周期。缺陷生命周期如下所示：</strong></p>
<p><img src="/assets/2/image-20220503120452-o89zxis.png" alt="image.png"></p>
<ul>
<li><strong>打开问题：</strong> 创建问题后，问题将分配给软件开发人员，然后他们就开始研究它。</li>
<li><strong>进行中问题：</strong> 软件开发人员开始研究该问题。</li>
<li><strong>已解决的问题：</strong> 问题由软件开发人员解决，但等待测试人员进行验证。如果验证成功，则问题结束; 否则，问题将重新开启。</li>
<li><strong>重新打开的问题：</strong> 当软件开发人员未按要求解决问题时，问题将以重新打开的状态进行。</li>
<li><strong>关闭问题：</strong> 当软件开发人员正确解决问题并由软件测试人员验证时，问题将被关闭。</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>13_Jira问题类型</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/13_Jira%E9%97%AE%E9%A2%98%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>JIRA应用程序可用于将工作分解为问题。问题可以表示为任务，子任务，bud，epic，功能请求或其他工作。每个Jira软件都附带一些适合您的项目和团队的默认问题类型。</p>
<p>JIRA软件附带有三种类型的默认Jira问题类型：</p>
<p><img src="/assets/2/image-20220503121515-n325nyi.png" alt="image.png"></p>
<ul>
<li>Jira Core(业务项目)问题类型</li>
<li>Jira Software(软件项目)问题类型</li>
<li>Jira服务台(服务台项目)问题类型</li>
</ul>
<h4 id="Jira-Core问题类型"><a href="#Jira-Core问题类型" class="headerlink" title="Jira Core问题类型"></a>Jira Core问题类型</h4><ul>
<li>任务 - 任务是为完成团队目标而完成或完成的工作。</li>
<li>子任务 - 这是一个问题的子任务。记录在案的问题下的所有任务都称为子任务。</li>
</ul>
<h4 id="Jira软件问题类型"><a href="#Jira软件问题类型" class="headerlink" title="Jira软件问题类型"></a>Jira软件问题类型</h4><ul>
<li><p>Bug - 错误是产品功能中出现的问题或缺陷。</p>
</li>
<li><p>Epic - <img src="/assets/2/image-20220503121523-lxwtiu9.png" alt="image.png"></p>
<ul>
<li>Epic是一个庞大的用户故事，可以分解成更小的故事</li>
<li>它无法在单个sprint中实现。</li>
<li>整个Epic已在几个月内完成。</li>
<li>Epic指的是一组尚未转换为用户故事的活动。</li>
<li>首先，将Epics转换为用户故事，然后将用户故事转换为敏捷团队工作的几个任务。</li>
<li>Epic的范围很广，缺乏细节，它们分为敏捷团队工作的小型和多个故事。</li>
<li>Epic被称为工作层次结构中的顶层。</li>
</ul>
</li>
<li><p><strong>Subtask</strong> - 子任务是完成整个工作的一项工作。</p>
</li>
<li><p><strong>Task</strong> - 任务是为完成团队目标而完成或完成的工作。</p>
</li>
<li><p><strong>Story</strong></p>
<ul>
<li>story是需要在项目中完成的任务列表。</li>
<li>它定义了项目要求的高级设计。</li>
<li>它定义了整个项目的简短描述。</li>
<li>它由公司的产品所有者拥有，但任何人都可以编写用户故事。</li>
<li>它用简单的语言编写，以便客户了解最终产品。</li>
<li>用户故事可以被视为“败类的核心”，因为它充当了冲刺的基石。</li>
</ul>
</li>
<li><p><strong>Jira服务台问题类型</strong></p>
<ul>
<li><strong>更改</strong> - 它要求更改当前的IT配置文件。</li>
<li><strong>IT帮助</strong> - 它用于请求IT相关问题的帮助。</li>
<li><strong>事件</strong> - 它报告事件或服务IT中断。</li>
<li><strong>新功能</strong> - 它要求添加新功能或软件功能。</li>
<li><strong>问题</strong> - 它用于报告多个事件的原因。</li>
<li><strong>服务请求</strong> - 它用于从内部或客户服务台请求帮助。</li>
<li><strong>服务请求获得批准</strong> - 它用于请求需要经理或董事会批准的帮助。</li>
<li><strong>支持</strong> - 它用于请求客户支持问题的帮助。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>14_Jira积压（待办事项）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/14_Jira%E7%A7%AF%E5%8E%8B%EF%BC%88%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%EF%BC%89/</url>
    <content><![CDATA[<p>积压(待办事项&#x2F;backlog)是团队需要在特定迭代中解决的一组活动或问题。您的项目的所有问题都分组在积压和冲刺(sprint)中。</p>
<p>在scrum backlog中，可以执行多个活动，例如创建和更新问题，拖放问题以确定优先级，将它们分配给sprint，epics，版本，管理epics等。</p>
<p>以下是可以在scrum backlog中执行的活动：</p>
<ul>
<li><strong>将问题添加到待办事项中</strong> - 要在待办事项中添加问题，需要创建一个问题。单击全局侧栏中的 <strong>+</strong> 图标以创建问题。填写与问题相关的所有详细信息，然后单击“创建”按钮。创建的问题将添加到待办事项中。</li>
<li><strong>优先处理积压</strong> - 还可以拖放问题，以便在待办事项中确定问题的优先级。还可以右键单击该问题以打开菜单，此菜单可将问题移至待办事项的顶部或底部。</li>
<li><strong>查看和编辑问题的详细信息</strong> - 单击电路板上的问题以查看问题的所有详细信息。如果要在单独的窗口中查看问题，请右键单击问题键。</li>
<li><strong>确定用户的工作量</strong> - 分配到的工作的用户显示在sprint的顶部。单击“…”选项以查看受理人的工作量。</li>
<li><strong>创建子任务</strong> - 单击一个问题，然后单击Jira Backlog图标以创建子任务。子任务对于将故事分解为可实现的部分非常有用。</li>
<li><strong>转换问题</strong> - 可以将问题从Backlog部分拖放到相关的sprint，或者可以说将问题从Backlog部分移动到相关的sprint。</li>
<li><strong>拆分问题</strong> - 右键单击该问题，然后选择拆分问题。它可以在Backlog以及sprint部分中分割问题。当您想要将大任务分解为两个或更多问题以使工作更易于管理时，拆分非常有用。</li>
<li><strong>删除问题</strong> - 也可以通过选择问题来删除问题，然后选择 <strong>…</strong> -&gt; <strong>删除</strong> 。</li>
<li><strong>查找问题</strong> - 可以创建自己的快速筛选器以仅查看所需的问题。</li>
</ul>
<h4 id="创建待办事项的步骤"><a href="#创建待办事项的步骤" class="headerlink" title="创建待办事项的步骤"></a>创建待办事项的步骤</h4><ul>
<li>单击窗格最左侧的 <strong>+</strong> 。</li>
</ul>
<p><img src="/assets/2/image-20220503121742-yml67po.png" alt="image.png"></p>
<ul>
<li>填写所有详细信息以创建问题。</li>
</ul>
<p><img src="/assets/2/image-20220503121748-g9p2u8c.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220503121754-xf7ukpc.png" alt="image.png"></p>
<p>在上面的表单中，填写所有必填详细信息，并保留其他字段的空白或默认值。</p>
<p><strong>必填字段是：</strong></p>
<ul>
<li><strong>项目</strong> - 它定义项目的名称。假设已将项目名称命名为“测试项目”。</li>
<li><strong>问题类型</strong> - 它定义了问题的类型。它可以是一个bug，epic，故事等。</li>
<li><strong>摘要</strong> - 它告诉了问题的整体描述。</li>
<li><strong>优先</strong> - 它定义了问题的优先级。它可以是中等，低或高。</li>
</ul>
<p>假设创建了一个类型为Bug的问题，描述是“登录按钮不起作用”，问题的优先级很高。<br><img src="/assets/2/image-20220503121801-dzm43i5.png" alt="image.png"></p>
<p>在上面的屏幕中，可以看到问题已创建并存放在Backlog中。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>15_Jira Scrum板</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/15_JiraScrum%E6%9D%BF/</url>
    <content><![CDATA[<p>Jira Scrum Board是一个用于团结团队以实现单一目标和增量迭代交付的工具。</p>
<h4 id="Scrum-Board的功能"><a href="#Scrum-Board的功能" class="headerlink" title="Scrum Board的功能"></a>Scrum Board的功能</h4><ul>
<li>增加沟通和透明度<br>Jira Scrum板是团队成员随时可以访问团队所有工作的唯一来源。这增加了团队成员之间的沟通和透明度。</li>
<li>促进sprint计划和迭代开发<br>Scrum框架的核心是sprint，这是团队建立可释放产品增量的固定时间。Jira scrum board主要是为了让团队能够在sprint时间范围内组织他们的工作。</li>
<li>改善团队关注和组织<br>有时团队忘记了项目的最后期限，他们对工作量的承诺过度。Jira Scrum Boards通过将工作分成多个阶段并提供燃尽和速度报告，为团队的工作提供透明度。</li>
</ul>
<h4 id="以下是与Scrum-Board相关的重要术语："><a href="#以下是与Scrum-Board相关的重要术语：" class="headerlink" title="以下是与Scrum Board相关的重要术语："></a>以下是与Scrum Board相关的重要术语：</h4><ul>
<li><p><strong>冲刺(Sprint)</strong><br>冲刺是一个时间框的时间迭代，主要时间是2周。当冲刺完成后，它就会产生市场上最有价值，最实用，最可释放的产品。</p>
</li>
<li><p><strong>积压(Backlog)</strong><br>Backlog由产品所有者拥有。产品待办事项列表是产品中要考虑的功能，缺陷，增强功能和实验的列表。</p>
</li>
<li><p><strong>用户故事</strong></p>
<ul>
<li>用户故事是敏捷框架中最小的工作单元。用户故事是一个目标，而不是根据用户的观点表达的功能。</li>
<li>用户故事的目的是展示一件作品如何将特定价值回馈给客户。</li>
<li>用户故事是用简单语言编写的句子，以提供所需的结果。</li>
<li>它应该采用粒度格式，以便可以在sprint中传递。Sprint只是一个有时间限制的迭代来提供工作软件。</li>
<li>用户故事来自史诗，史诗是一大块工作，用户故事来自史诗。一些用户故事来自史诗并被放置在特定的冲刺中。这个循环一直持续到除非sprint中的所有用户故事都完成。</li>
</ul>
</li>
<li><p><strong>问题</strong><br>一个问题也称为用户故事。在scrum board中，一个问题包含执行单个工作所需的所有任务，依赖关系和其他相关信息。</p>
</li>
<li><p><strong>史诗</strong><br>史诗是一大块工作。它基本上是一个庞大的用户故事，可以分解成许多小故事。史诗中的所有用户故事可能需要多次冲刺才能完成。</p>
</li>
<li><p><strong>Swimlane</strong><br>Swimlane是一种在scrum board或kanban board的活跃冲刺中对问题进行分类的方法。它可以帮助您区分不同类别的任务，例如用户，工作流等。</p>
</li>
</ul>
<h4 id="Scrum-Board布局"><a href="#Scrum-Board布局" class="headerlink" title="Scrum Board布局"></a>Scrum Board布局</h4><p>Scrum Board是一个物理板，用于显示当前sprint backlog中的用户故事。</p>
<p><img src="/assets/2/image-20220503122015-p19ylml.png" alt="image.png"></p>
<p>Scrum board分为以下列：</p>
<ul>
<li><strong>故事(Stories)</strong> ：此列包含当前sprint backlog中可用的所有用户故事。</li>
<li><strong>待办(TODO)</strong> ：此状态包含尚未开始工作的故事的子任务。</li>
<li><strong>处理中(In Progress)</strong> ：此状态包含工作已开始的所有任务。</li>
<li><strong>完成(Done)</strong> ：此状态包含已完成工作的所有任务。</li>
</ul>
<h4 id="创建Scrum项目的步骤"><a href="#创建Scrum项目的步骤" class="headerlink" title="创建Scrum项目的步骤"></a>创建Scrum项目的步骤</h4><ul>
<li>单击页面左侧显示的项目。</li>
</ul>
<p><img src="/assets/2/image-20220503122019-ta9y6rk.png" alt="image.png"></p>
<ul>
<li>单击“创建项目”按钮以创建出现在页面右上角的新项目。</li>
<li>单击模板链接。</li>
</ul>
<p><img src="/assets/2/image-20220503122025-smumc1l.png" alt="image.png"></p>
<ul>
<li>从模板中选择scrum项目。<br><img src="/assets/2/image-20220503122030-nal44cl.png" alt="image.png"></li>
<li>输入项目名称。<br><img src="/assets/2/image-20220503122035-w1tgzki.png" alt="image.png"></li>
<li>在下图中，创建了TP Board，它是名为“Test project”的项目的简称。</li>
</ul>
<p><img src="/assets/2/image-20220503122040-v9gvfcr.png" alt="image.png"></p>
<p>上图中显示的白板是Jira板，它包含与特定项目相关的问题。在Scrum板上显示问题可以灵活地查看，管理和跟踪问题的进度。对于新创建的项目，积压是空的。只有在Backlog中添加任务或问题时才会填充它。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>16_Jira创建冲刺（Sprint）</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/16_Jira%E5%88%9B%E5%BB%BA%E5%86%B2%E5%88%BA%EF%BC%88Sprint%EF%BC%89/</url>
    <content><![CDATA[<p>团队需要在指定的时间段内完成一系列问题称为sprint。冲刺的持续时间由团队和产品所有者决定。</p>
<h4 id="创建Sprint"><a href="#创建Sprint" class="headerlink" title="创建Sprint"></a>创建Sprint</h4><p>以下是创建sprint的步骤：</p>
<ul>
<li>点击左侧出现的Backlog，如下图所示：</li>
</ul>
<p><img src="/assets/2/image-20220503122325-hc37vwk.png" alt="image.png"></p>
<ul>
<li>单击右下角出现的<strong>Create sprint</strong>按钮，如下面的屏幕截图所示：</li>
</ul>
<p><img src="/assets/2/image-20220503122330-wxxneyf.png" alt="image.png"></p>
<ul>
<li>单击<strong>Create sprint</strong>按钮后，将出现如下屏幕所示的屏幕：<br><img src="/assets/2/image-20220503122336-9h0prjr.png" alt="image.png"></li>
</ul>
<p>上面的屏幕显示sprint已创建名称为“Sprint 1”，现在可以将问题添加到此sprint中。</p>
<h4 id="向sprint添加问题"><a href="#向sprint添加问题" class="headerlink" title="向sprint添加问题"></a>向sprint添加问题</h4><p>以下是将问题添加到sprint所需的步骤：</p>
<ul>
<li>点击积压(Backlog)。</li>
<li>在“积压”列表中，右键单击该问题，然后选择要在其中添加问题的sprint。我们刚刚创建了名为<strong>Sprint 1</strong>的sprint，选择 <strong>Sprint 1</strong> 。<br><img src="/assets/2/image-20220503122342-a8sjdfm.png" alt="image.png"></li>
<li>问题<strong>TP-1</strong>被添加到sprint，即 <strong>Sprint 1</strong> 。<br><img src="/assets/2/image-20220503122347-2fbg1eh.png" alt="image.png"></li>
</ul>
<p>从上面的屏幕中，我们观察到<strong>TP-1</strong>问题被添加到<strong>Sprint 1</strong>中。</p>
<h4 id="从sprint中删除问题"><a href="#从sprint中删除问题" class="headerlink" title="从sprint中删除问题"></a>从sprint中删除问题</h4><p>从sprint中删除问题所遵循的步骤：</p>
<ul>
<li>单击Backlog。</li>
<li>将要从<strong>Sprint 1</strong>移动的问题拖放回Backlog列表。</li>
</ul>
<p><img src="/assets/2/image-20220503122352-1y9hbb7.png" alt="image.png"></p>
<p>上面的屏幕显示问题TP-1从Sprint 1移动到Backlog。</p>
<h4 id="开始冲刺"><a href="#开始冲刺" class="headerlink" title="开始冲刺"></a>开始冲刺</h4><p>开始一个冲刺的步骤：</p>
<ul>
<li>单击Backlog。</li>
<li>单击开始冲刺( <em>start sprint</em> )按钮开始冲刺。<br><img src="/assets/2/image-20220503122358-e851ht1.png" alt="image.png"></li>
</ul>
<p>填写以下详细信息以开始冲刺，例如冲刺名称，冲刺持续时间，结束日期，开始日期，冲刺目标。</p>
<p><img src="/assets/2/image-20220503122407-4txg2c7.png" alt="image.png"></p>
<p>现在，<strong>Sprint 1</strong>已经启动。最初，问题属于<strong>TO DO</strong>状态。</p>
<p><img src="/assets/2/image-20220503122413-422npat.png" alt="image.png"></p>
<h4 id="结束冲刺"><a href="#结束冲刺" class="headerlink" title="结束冲刺"></a>结束冲刺</h4><p>结束冲刺的步骤如下：</p>
<ul>
<li>单击Backlog。</li>
<li>单击项目左侧显示的活动冲刺。</li>
<li>选择要完成的sprint或结束sprint。</li>
<li>所有问题都完成后，点击右上角出现的完整冲刺按钮。</li>
</ul>
<p><img src="/assets/2/image-20220503122418-ptnmgap.png" alt="image.png"></p>
<ul>
<li>它将显示所有问题是否已完成，如果没有，则它会要求您将问题移至另一个尚未完成的sprint。</li>
</ul>
<p><img src="/assets/2/image-20220503122423-hd2jgct.png" alt="image.png"></p>
<h4 id="删除冲刺"><a href="#删除冲刺" class="headerlink" title="删除冲刺"></a>删除冲刺</h4><p>删除sprint要遵循的步骤：</p>
<ul>
<li>单击Backlog。</li>
<li>选择要删除的sprint，然后单击“…”图标。出现下拉列表，然后选择“删除sprint”选项。</li>
</ul>
<p><img src="/assets/2/image-20220503122429-4d0jq8k.png" alt="image.png"></p>
<ul>
<li>单击“删除冲刺( <em>Delete sprint</em> )”选项，单击“确认”按钮。</li>
</ul>
<p><img src="/assets/2/image-20220503122435-mjt7ncv.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>08_看板（Kanban）与Scrum区别</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/08_%E7%9C%8B%E6%9D%BF%EF%BC%88Kanban%EF%BC%89%E4%B8%8EScrum%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>看板和Scrum之间有很多不同之处。下面列出了看板和Scrum之间的区别：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Scrum</th>
<th>看板</th>
</tr>
</thead>
<tbody><tr>
<td>计划</td>
<td>它有固定的计划，它专注于规划。它从sprint计划开始，以sprint审查结束，回顾性。举行日常会议，以便团队了解后续步骤，优先事项以及之前步骤的经验。</td>
<td>它没有固定的计划，也没有每日会议。在看板中，可以随时发生变化，即频繁发生变化。</td>
</tr>
<tr>
<td>时间线</td>
<td>在scrum中，处理具有固定时间持续时间的sprint意味着在一段固定时间之后，要向客户端提供一些东西。</td>
<td>看板没有sprint的概念，因此没有固定的时间表来将产品交付给客户端。</td>
</tr>
<tr>
<td>任务估算</td>
<td>在sprint计划期间，决定从产品待办事项中提取多少活动并添加sprint backlog。例如，如果sprint持续两周，则以这样的方式选择活动的数量，使得它们可以在冲刺内完成，即在两周内完成。</td>
<td>它不估计任务。</td>
</tr>
<tr>
<td>适应性</td>
<td>此方法适用于大型项目，因为大型项目可以分为多个sprint。</td>
<td>它主要适用于小型项目。</td>
</tr>
<tr>
<td>不断变化</td>
<td>在Scrum中，可以在较短的sprint中轻松调整不断变化。</td>
<td>如果发生任何重大变化，则看板方法失败。</td>
</tr>
<tr>
<td>成本</td>
<td>在Scrum中，估计任务，即在sprint中采取固定数量的活动，因此项目的总成本是最小的。</td>
<td>在看板中，不会估算任务，因此项目的总成本不准确。</td>
</tr>
<tr>
<td>角色和责任</td>
<td>在Scrum中，Scrum Master将特定角色分配给团队成员，而产品所有者则告知团队成员必须工作的产品目标。</td>
<td>没有为团队成员分配预定义角色。所有团队成员都有责任合作提供有价值的产品。</td>
</tr>
<tr>
<td>生产力的测量</td>
<td>通过使用循环时间或从开始到结束完成整个项目所花费的时间来衡量生产率。</td>
<td>通过sprint使用速度来衡量生产率。</td>
</tr>
<tr>
<td>发布方法</td>
<td>每次sprint结束后发布小版本。</td>
<td>它提供持续交付。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>07_看板方法</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/07_%E7%9C%8B%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>看板是Scrum之后用于软件开发的最流行的敏捷框架。它提供了工作的实时性和透明性。在看板中，所有任务都是可见的，允许团队成员随时查看每项任务的状态。</p>
<h4 id="看板方法的特点"><a href="#看板方法的特点" class="headerlink" title="看板方法的特点"></a>看板方法的特点</h4><ul>
<li><strong>灵活性</strong><br>在看板方法中，团队专注于“进行中”状态的工作。一旦团队完成任务，它就会完成产品待办事项的下一个第一项任务。产品负责人会重新确定任务的优先级，或者对团队外部的产品待办事项进行更改，这样就不会破坏或影响团队。产品所有者将最重要的任务放在产品待办事项的顶部，因此开发团队确保他们将产生最有价值的输出。在看板中，我们不需要像在scrum中那样进行固定长度的迭代。</li>
<li><strong>最大限度地缩短时间周期</strong><br>工作周期是工作从开始到运送到客户的那一刻所花费的时间。重叠的技能组可以最小化循环时间。在这种情况下，开发人员不仅可以编写代码，还可以在需要时测试代码。这种类型的共享技能意味着团队成员可以进行异构工作，从而优化周期时间。</li>
<li><strong>可视指标</strong><br>可视指标是提高团队效率和团队效率的一种方式。可视化指标通过图表显示，团队成员可以查看图表中的数据，并可以发现其流程中出现的问题。可视指标的主要目标是减少问题在整个过程中移动所花费的时间。<br>看板团队使用两种类型的图表：<br>控制图：显示每个问题所花费的周期时间。<br>累积流程图：显示每个州存在的问题数量。</li>
<li><strong>持续交付</strong><br>持续交付的主要目标是快速交付低风险产品。从敏捷方法到持续交付的过渡将两到三周的冲刺转变为看板方法。看板方法和持续交付都通过更快地向客户交付产品而相互补充。软件开发团队用于以连续的方式开发，测试和审查新功能。因此，我们可以说看板是一种连续流方法。</li>
</ul>
<h4 id="看板主面板"><a href="#看板主面板" class="headerlink" title="看板主面板"></a>看板主面板</h4><p><img src="/assets/2/image-20220503111314-f82ra76.png" alt="image.png"></p>
<p>看板是一种用于可视化工作并限制在制品工作的工具。</p>
<p>与scrum一样，我们正在从产品待办事项中添加一些活动并添加sprint backlog。但是，在看板中没有sprint，因此不会执行sprint backlog活动。这是scrum和Kanban之间的主要区别，scrum包含sprint backlog，而kanban不包含sprint backlog。</p>
<p>看板由三种状态组成：</p>
<ul>
<li>待办事项</li>
<li>正在做</li>
<li>已完成</li>
</ul>
<p>项目启动后，我们将产品待办事项中的所有活动都置于“待办事项”状态。当团队成员开始处理某个活动时，该活动将处于“正在”状态，并且在放置活动时，它将处于“完成”状态。</p>
<p>从Kanban主面板，人们可以了解已经完成了哪些活动以及他们需要开展哪些活动。</p>
<p>看板板最重要的功能之一是限制选项。在上图中，我们在产品待办事项中有八个任务，限制集为4。一次只有四个任务处于“待办事项”状态，并且如果任何任务处于“正在”状态 然后，产品待办事项中的另外一项任务将被置于“待办事项”状态。通过这种方式，我们可以根据资源的可用性设置限制。</p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jira</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/01_jira/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.atlassian.com/zh/software/jira/features">jira官网：https://www.atlassian.com/zh/software/jira/features</a><!-- * [jira教程](https://www.yiibai.com/jira/jira-installation.html) -->
<!-- * [jira简介](/05_测试工具/01_测试管理工具/01_jirajira文件/01_jira简介)--></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/01_jira简介" target="_blank">jira简介</a> <br/><!-- * [JIRA安装](/05_测试工具/01_测试管理工具/01_jirajira文件/02_JIRA安装/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jiraj/ira文件/02_JIRA安装/" target="_blank">JIRA安装</a> <br/><!-- * [JIRA瀑布模型](/05_测试工具/01_测试管理工具/01_jirajira文件/03_JIRA瀑布模型/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/03_JIRA瀑布模型/" target="_blank">JIRA瀑布模型</a> <br/><!-- * [JIRA敏捷](/05_测试工具/01_测试管理工具/01_jirajira文件/04_JIRA敏捷/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/04_JIRA敏捷/" target="_blank">JIRA敏捷</a> <br/><!-- * [JIRA Scrum](/05_测试工具/01_测试管理工具/01_jirajira文件/05_JIRAScrum/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/05_JIRAScrum/" target="_blank">JIRAScrum</a> <br/><!-- * [Sprint的工作](/05_测试工具/01_测试管理工具/01_jirajira文件/06_Sprint的工作/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/06_Sprint的工作/" target="_blank">Sprint的工作</a> <br/><!-- * [看板方法](/05_测试工具/01_测试管理工具/01_jirajira文件/07_看板方法/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/07_看板方法/" target="_blank">jira看板方法</a> <br/><!-- * [看板（Kanban）与Scrum区别](/05_测试工具/01_测试管理工具/01_jirajira文件/08_看板（Kanban）与Scrum区别/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/08_看板（Kanban）与Scrum区别/" target="_blank">看板（Kanban）与Scrum区别</a> <br/><!-- * [JIRA问题](/05_测试工具/01_测试管理工具/01_jirajira文件/09_JIRA问题/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/09_JIRA问题/" target="_blank">JIRA问题</a> <br/><!-- * [JIRA工作流](/05_测试工具/01_测试管理工具/01_jirajira文件/10_JIRA工作流/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/10_JIRA工作流/" target="_blank">JIRA工作流</a> <br/><!-- * [JIRA登录](/05_测试工具/01_测试管理工具/01_jirajira文件/11_JIRA登录/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/11_JIRA登录/" target="_blank">JIRA登录</a> <br/><!-- * [JIRA仪表盘](/05_测试工具/01_测试管理工具/01_jirajira文件/12_JIRA仪表盘/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/12_JIRA仪表盘/" target="_blank">JIRA仪表盘</a> <br/><!-- * [Jira问题类型](/05_测试工具/01_测试管理工具/01_jirajira文件/13_Jira问题类型/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/13_Jira问题类型/" target="_blank">Jira问题类型</a> <br/><!-- * [Jira积压（待办事项）](/05_测试工具/01_测试管理工具/01_jirajira文件/14_Jira积压（待办事项）/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/14_Jira积压（待办事项）/" target="_blank">Jira积压（待办事项）</a> <br/><!-- * [Jira Scrum板](/05_测试工具/01_测试管理工具/01_jirajira文件/15_JiraScrum板/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/15_JiraScrum板/" target="_blank">JiraScrum板</a> <br/><!-- * [Jira创建冲刺（Sprint）](/05_测试工具/01_测试管理工具/01_jirajira文件/16_Jira创建冲刺（Sprint）/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/16_Jira创建冲刺（Sprint）/" target="_blank">Jira创建冲刺（Sprint）</a> <br/><!-- * [Jira控制面板](/05_测试工具/01_测试管理工具/01_jirajira文件/17_Jira控制面板/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/17_Jira控制面板/" target="_blank">Jira控制面板</a> <br/><!-- * [JIRA缺陷生命周期](/05_测试工具/01_测试管理工具/01_jirajira文件/18_JIRA缺陷生命周期/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/18_JIRA缺陷生命周期/" target="_blank">JIRA缺陷生命周期</a> <br/><!-- * [Jira与Bugzilla](/05_测试工具/01_测试管理工具/01_jirajira文件/19_Jira与Bugzilla/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/19_Jira与Bugzilla/" target="_blank">Jira与Bugzilla</a> <br/><!-- * [Jira史诗（Epic）](/05_测试工具/01_测试管理工具/01_jirajira文件/20_Jira史诗（Epic）/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/20_Jira史诗（Epic）/" target="_blank">Jira史诗（Epic）</a> <br/><!-- * [Jira版本](/05_测试工具/01_测试管理工具/01_jirajira文件/21_Jira版本/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/21_Jira版本/" target="_blank">Jira版本</a> <br/><!-- * [Jira报告](/05_测试工具/01_测试管理工具/01_jirajira文件/22_Jira报告/) --></li>
<li><a href="/05_测试工具/01_测试管理工具/01_jira/jira文件/22_Jira报告/" target="_blank">Jira报告</a> <br/></li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>01_jira简介</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/01_jira%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h4 id="1-JIRA是由澳大利亚公司Atlassian开发的软件测试工具。-它是一个错误跟踪工具，可报告软件或移动应用程序相关的所有问题。JIRA这个词来自日语单词，即“Gojira”，意思是哥斯拉。"><a href="#1-JIRA是由澳大利亚公司Atlassian开发的软件测试工具。-它是一个错误跟踪工具，可报告软件或移动应用程序相关的所有问题。JIRA这个词来自日语单词，即“Gojira”，意思是哥斯拉。" class="headerlink" title="1. JIRA是由澳大利亚公司Atlassian开发的软件测试工具。 它是一个错误跟踪工具，可报告软件或移动应用程序相关的所有问题。JIRA这个词来自日语单词，即“Gojira”，意思是哥斯拉。"></a>1. JIRA是由澳大利亚公司Atlassian开发的软件测试工具。 它是一个错误跟踪工具，可报告软件或移动应用程序相关的所有问题。JIRA这个词来自日语单词，即“Gojira”，意思是哥斯拉。</h4><h4 id="2-JIRA基于敏捷方法，目前的Jira版本为6。"><a href="#2-JIRA基于敏捷方法，目前的Jira版本为6。" class="headerlink" title="2. JIRA基于敏捷方法，目前的Jira版本为6。"></a>2. JIRA基于敏捷方法，目前的Jira版本为6。</h4><h4 id="3-以下是Jira提供的有用方面："><a href="#3-以下是Jira提供的有用方面：" class="headerlink" title="3. 以下是Jira提供的有用方面："></a>3. 以下是Jira提供的有用方面：</h4><ul>
<li>项目：用于非常有效地管理缺陷。</li>
<li>问题：它用于跟踪和管理缺陷&#x2F;问题。</li>
<li>工作流程：处理问题&#x2F;缺陷生命周期。假设我们有业务需求，我们创建技术设计，并从技术设计中创建测试用例。创建测试用例后，完成编码，然后对项目执行测试。使用Jira可以实现此设计工作流程。</li>
<li>搜索：轻松查找。假设在12月初完成了一个项目，其版本是1.0。现在，我们转到1.1版并在12月底完成，需要做的是添加新版本。通过Jira，我们可以了解早期版本中发生的事情，早期项目中发生了多少缺陷以及我们从早期项目中获得的学习。</li>
<li>仪表板：仪表板是在登录Jira时看到的显示。可以为多个项目创建多个仪表板。可以创建个人仪表板，并可以在仪表板中添加小工具，以便可以跟踪正在处理的分配和问题。<h2 id="1-为什么选择JIRA？"><a href="#1-为什么选择JIRA？" class="headerlink" title="1.为什么选择JIRA？"></a>1.为什么选择JIRA？</h2><h4 id="使用JIRA工具是由于以下原因："><a href="#使用JIRA工具是由于以下原因：" class="headerlink" title="使用JIRA工具是由于以下原因："></a>使用JIRA工具是由于以下原因：</h4></li>
<li><ol>
<li>计划，跟踪和工作更快JIRA是一种错误跟踪工具，主要用于跟踪，组织错误并确定其优先级，新增功能以及某些软件版本的改进。 项目细分为问题，问题可以是多种类型，例如错误，新功能，改进和文档任务。当软件的发布日期临近时，软件开发人员需要关注在指定日期之前要修复的剩余问题。 质量保证也很难维持文件的状态，即有时候很难跟踪所有内容。JIRA是处理上述问题的不错选择。 它使软件开发人员能够跟踪问题和改进。 它管理项目以及维护技术文档。</li>
</ol>
</li>
<li><ol start="2">
<li>信息的主要来源JIRA是下一个软件版本的主要信息来源。 在JIRA上，软件开发人员的整个团队可以计划要添加的新功能以及在下一版本中修复的错误。它还有助于QA团队编写技术文档。 通过JIRA，QA团队可以检查软件开发人员新添加的每个功能的状态，并根据这些功能，他们可以计划如何记录新版本。</li>
</ol>
</li>
<li><ol start="3">
<li>组织文档任务JIRA工具用于组织文档任务。 通过使用组件功能对多个任务进行分组非常有用，甚至可以创建自己的文档。 通过这种方式，您可以创建结构化的文档方式。</li>
</ol>
</li>
<li><ol start="4">
<li>跟踪我们文档的进度它是跟踪文档进度的非常有用的工具。 JIRA工具提供了一个非常重要的功能，即饼图宏。 在饼图宏中可以查看打开任务，已关闭任务，已解决任务等任务。</li>
</ol>
</li>
<li><ol start="5">
<li>帮助满足文档发布的截止日期<br>   可以定义文档发布的特定截止日期或截止日期，甚至可以使用通知配置JIRA工具，以便可以及时完成文档。</li>
</ol>
</li>
<li><ol start="6">
<li>衡量文档所花费的时间<br>   JIRA工具没有用于衡量文档花费时间的默认功能。 JIRA工具与Tempo Timesheets捆绑在一起，可以测量文档花费的时间。</li>
</ol>
</li>
<li><ol start="7">
<li>更快地提供反馈<br>   JIRA工具提供Confluence页面，只需单击几下即可连接到问题。 如果需要更新某些内容，则可以直接从Confluence页面创建问题。&#x2F;&#x2F;原文出自【易百教程】，商业转载请联系作者获得授权，非商业请保留原文链接：<a href="https://www.yiibai.com/jira/jira-introduction.html">https://www.yiibai.com/jira/jira-introduction.html</a></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>03_JIRA瀑布模型</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/03_JIRA%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在了解敏捷和JIRA之前，需要了解瀑布模型。</p>
<h2 id="什么是瀑布模型？"><a href="#什么是瀑布模型？" class="headerlink" title="什么是瀑布模型？"></a>什么是瀑布模型？</h2><p>瀑布模型是IT行业用于开发软件的最古老的模型。不同公司使用不同模型和流程，但瀑布模型是IT行业中最古老，最安全，最简单的模型。</p>
<p>它是构建代表现实生活的软件的最简单模型。下面我们来了解瀑布模型。瀑布模型分为多个阶段：<br><img src="/assets/2/image-20220503104035-tukzgc5.png" alt="image.png"></p>
<h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>假设有客户想要开发软件，然后客户联系到一家软件公司。假设客户联系了这家服务型公司并要求该公司为他们构建软件。</p>
<p><strong>公司做什么？</strong></p>
<p>公司将收集客户的所有需求，知识或客户希望拥有的软件，公司将从客户收集所有信息并准备文档。执行此活动后，设计阶段即开始。</p>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>在此阶段，我们准备高级和低级设计。在开发软件之前，需要设计软件。假设客户想要与亚马逊类似的电子商务网站，那么网站的UI(用户界面)将由设计者制作，数据流也在这个阶段设计，数据将如何流动。完成此阶段后，开发阶段即可开始。</p>
<h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>在开发阶段，软件开发团队开始编写和开发软件。这是瀑布模型的最长阶段，因为开发人员需要更多时间来构建软件。一旦软件开发完成，项目就会交给测试人员。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>测试团队将测试软件，如果发现有错误，他们会通知开发人员他们发现的问题并确保错误得到修复。测试团队确保完成端到端软件。</p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>测试项目后，将部署项目，以使其成为实时用户的实时用户。</p>
<h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p>最后，项目已部署并可供客户使用。客户希望维护期为一年或两年，因为如果发现错误或想要在项目中稍微增强功能，那么需要一些团队来处理这些问题。由于这个原因，需要一个维护期。</p>
<h2 id="瀑布模型的例子"><a href="#瀑布模型的例子" class="headerlink" title="瀑布模型的例子"></a>瀑布模型的例子</h2><p><img src="/assets/2/image-20220503104045-srhqwy5.png" alt="image.png"></p>
<p>假设客户想要一个像WhatsApp这样的应用程序，那么客户就会找到一个软件开发公司并讨论2个月。软件开发公司在2个月内完成了所有要求的记录。软件开发公司的开发团队开始开发软件，并假设开发软件花了大约10个月的时间。这意味着已经使用了12个月，即需求阶段为2个月，开发阶段为10个月，但客户仍然不了解内部阶段。开发完成后，测试完成，软件质量测试大约需要2个月。一旦测试完成，它将进入集成并启动，以便WhatsApp进入交付试用。然而，当它到达客户端时，客户说它花了一年多的时间，收到的软件却不是他所期望的。之所以发生这种情况，是因为客户只与软件团队进行了口头沟通。如果客户想要对软件进行一些更改，那么整个过程将再次执行。</p>
<h4 id="瀑布模型的优点"><a href="#瀑布模型的优点" class="headerlink" title="瀑布模型的优点"></a>瀑布模型的优点</h4><ul>
<li>简单易懂，易于使用</li>
<li>它代表了您想要在现实生活中完成的所有任务。例如，您需要客户端的需求。它包含不同的阶段，每个阶段仅在前一阶段完成时启动。</li>
<li>具体的可交付成果和审核流程。</li>
<li>每个阶段都有一个特定的可交付和审核流程。在需求阶段之后，我们满足客户需求的所有要求。软件开发完成后，我们就可以交付。</li>
<li>阶段不重叠。</li>
<li>在该模型中，相位不重叠，即，它们一次完成一次。上一阶段完成后，只有下一阶段开始。例如，开发阶段将仅在设计阶段完成时开始。</li>
</ul>
<h4 id="瀑布模型的缺点"><a href="#瀑布模型的缺点" class="headerlink" title="瀑布模型的缺点"></a>瀑布模型的缺点</h4><ul>
<li>产品上线时间很长。</li>
<li>只有在完成所有阶段后才会发布产品。因此，此模型需要很长时间才能发布产品。</li>
<li>出乎意料的结果。</li>
<li>期望和收到的内容大多不同，因为客户根据文档仅了解产品。客户只有一个想法，这是一个有记录的想法。</li>
<li>不适合改变需求。</li>
<li>瀑布模型不适用于需求处于中度到高度变化风险的项目。如果要求发生变化，则不建议使用此模型，因为所有要求都是在需求阶段完成的，这是一个非常耗时的过程。</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>04_JIRA敏捷</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/04_JIRA%E6%95%8F%E6%8D%B7/</url>
    <content><![CDATA[<p>敏捷是一种时间盒式的迭代方法，可以逐步构建项目，而不是一次性构建项目。敏捷是一种在整个软件中促进开发和测试的连续迭代的实践。</p>
<h2 id="什么不需要敏捷"><a href="#什么不需要敏捷" class="headerlink" title="什么不需要敏捷?"></a>什么不需要敏捷?</h2><ul>
<li>主持会议<br>团队每天进行10-15分钟的频繁会议，他们认为频繁的会议将是敏捷的。但是，只有以下会议才会敏捷。</li>
<li>需求随时变化<br>需求可以随时更改，那不需要敏捷。例如，客户想要添加一些新功能并希望同时更新更改，那么这将不是敏捷。</li>
<li>非结构化发展<br>假设您没有遵循任何计划并且您正在开发Adhoc，那么它不是敏捷的，其中Adhoc测试，测试人员随机测试应用程序而不遵循任何文档和测试设计技术。</li>
<li>没有文档<br>如果公司没有制作文档，那么它不是敏捷的。</li>
</ul>
<h2 id="什么是敏捷？"><a href="#什么是敏捷？" class="headerlink" title="什么是敏捷？"></a>什么是敏捷？</h2><p>敏捷是一种哲学，即一套决定开发软件的价值观和原则。<br>敏捷基于迭代增量模型。在增量模型中，我们以增量方式创建系统，其中每个增量都是单独开发和测试的。</p>
<p>下图显示了敏捷模型如何逐步工作 -</p>
<p><img src="/assets/2/image-20220503105548-8gl6vza.png" alt="image.png"></p>
<h2 id="什么是价值？"><a href="#什么是价值？" class="headerlink" title="什么是价值？"></a>什么是价值？</h2><p>在敏捷中，需要执行下表中提到的所有八个任务。但是，我们必须确保左侧任务的优先级应该高于右侧任务。</p>
<table>
<thead>
<tr>
<th>个人和互动</th>
<th>过程和工具</th>
</tr>
</thead>
<tbody><tr>
<td>工作软件</td>
<td>综合文档</td>
</tr>
<tr>
<td>客户协作</td>
<td>合同谈判</td>
</tr>
<tr>
<td>回应变化</td>
<td>遵循计划</td>
</tr>
</tbody></table>
<ul>
<li><strong>个人和互动，优先于过程和工具</strong><br>假设团队在软件中发现任何问题，然后他们搜索另一个流程或工具来解决问题。但是，在敏捷中，最好与客户，经理或团队就问题进行互动，并确保问题得到解决。</li>
<li><strong>工作软件，优先于文档</strong><br>需要文档，但是非常需要工作软件。敏捷并不是说不需要文档，但是非常需要工作软件。例如，您有20页的文档，但您没有软件的一个原型。在这种情况下，客户端将不满意，因为最终客户端需要一个文档。</li>
<li><strong>客户协作，优先于合同谈判</strong><br>合同谈判在制定软件预算时很重要，但客户协作比合同谈判更重要。例如，如果您坚持要求或流程，那么就不要签订我们已经协商的合同。您需要与客户互动，收集他们的需求。</li>
<li><strong>遵循变更，优先于遵循计划</strong><br>在瀑布模型中，一切都是有计划的，即，在什么时间，每个阶段都将完成。有时您需要在软件中间实现新要求，因此您需要具备多种功能才能对软件进行更改。</li>
</ul>
<blockquote>
<p>注意：根据敏捷方法，左侧任务应优先于右侧任务。</p>
</blockquote>
<h2 id="敏捷原则"><a href="#敏捷原则" class="headerlink" title="敏捷原则"></a>敏捷原则</h2><ul>
<li>首要任务是通过尽早和持续交付有价值的软件来满足客户。根据敏捷原则，客户就是他们的一切。无论客户需要什么，他们都有任何问题或想要添加新的要求，他们总是优先考虑客户。倾听客户的意见，并为客户提供高质量的软件。</li>
<li>它欢迎不断变化的要求，甚至在开发的后期。敏捷流程利用变革为客户带来竞争优势。在瀑布模型中，如果要在软件中间进行任何新的更改，则整个过程将再次完成。因此，瀑布模型是刚性的而不是通用的。敏捷可将这样的工作可以很容易地将新的变化整合到软件中。</li>
<li>经常提供工作软件，从几周到几个月，优先考虑更短的时间尺度。在瀑布模型中，当整个系统开发出来时，只有它被传递给客户，而敏捷说不要等待太久，等待几周或几个月。无论您开发了什么都要向客户端演示，这样就可以向客户提供您在初始阶段正在开发的软件的每个功能。</li>
<li>业务人员和开发人员必须在整个项目中每天一起工作。这意味着客户，客户和团队应该每天进行交互。</li>
<li>围绕有动力的个人建立项目，为他们提供所需的环境和支持，并信任他们完成工作。敏捷相信你的团队，客户和公司。假设给团队成员一个任务，然后提供他需要的所有资源，如文档，系统，信息研究等。</li>
<li>向开发团队内部和内部传达信息的最有效和最有效的方法是面对面交谈。假设有些情况需要与客户进行交互，开发团队通常通过邮件或电话进行，但最好进行面对面交谈。</li>
<li>工作软件是进步的主要衡量标准。敏捷无论是通过文档还是项目经理所说的内容，开发或工作的软件数量都是进度的衡量标准。</li>
<li>敏捷过程促进可持续发展。赞助商，开发者和用户应该能够无限期地保持稳定的步伐。敏捷说，让你的团队在交付时保持不变，这样团队应该有固定的工作时间意味着如果公司的工作时间是8小时，那么团队应该在一天工作8小时。</li>
<li>持续关注技术卓越和良好的设计提高灵活性意味着团队成员在技术上应该是合理的，以便他们可以做出好的设计，如果做出任何改变，那么它们可以很容易地融入软件中。</li>
<li>最好的架构，需求和设计来自自组织团队。无论架构团队进行何种设计，他们都确保他们与开发团队坐在一起并讨论软件的架构。</li>
<li>团队定期反思如何变得更有效，然后调整并相应地调整其行为。这个原则说团队应该经常见面，以便他们可以讨论他们面临的问题，并且可以有效地解决。</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>02_jira安装</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/02_JIRA%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>JIRA是一个集中式软件，其中所有项目都登录到中央数据库并完成工作流程。工作流程控制项目的状态。</p>
<h4 id="如何下载和安装JIRA软件"><a href="#如何下载和安装JIRA软件" class="headerlink" title="如何下载和安装JIRA软件"></a>如何下载和安装JIRA软件</h4><p>以下是下载和安装JIRA软件的步骤：</p>
<p><strong>第1步：</strong> 在Google&#x2F;百度搜索引擎框中输入“Download JIRA software”。屏幕显示如下：</p>
<p><img src="/assets/2/image-20220430225238-7u6rd5e.png" alt="image.png"></p>
<p><strong>第2步：</strong> 单击“Download Jira Software Server”。点击后，屏幕显示如下：</p>
<p><img src="/assets/2/image-20220430225249-zsyrfbq.png" alt="image.png"></p>
<p>在上面的屏幕中，选择操作系统环境类型，然后单击“下载”按钮。假设，我在Windows上工作，然后选择“Windows 64 Bit”。单击“下载”按钮，将出现如下对话框：</p>
<p><img src="/assets/2/image-20220430225256-aqbwzh8.png" alt="image.png"></p>
<p>在上面的对话框中，单击复选框，然后单击“Get started”按钮。单击“Get started”按钮，屏幕显示如下：</p>
<p><img src="/assets/2/image-20220430225304-shes10s.png" alt="image.png"></p>
<p>现在，找到已下载的<code>.exe</code>文件，然后单击下载的<code>.exe</code>文件。单击下载的文件，安装将开始。<br>安装向导将显示如下：<br><img src="/assets/2/image-20220430225310-k3kx9zb.png" alt="image.png"></p>
<p>单击“下一步”按钮。选择适当的安装类型，然后单击“下一步”按钮。</p>
<p><img src="/assets/2/image-20220430225316-1i6h4hu.png" alt="image.png"></p>
<p>以下是JIRA软件的详细信息，单击“安装”按钮。</p>
<p><img src="/assets/2/image-20220430225323-10mekus.png" alt="image.png"></p>
<p>以下屏幕显示安装已启动。</p>
<p><img src="/assets/2/image-20220430225330-7kzhxu9.png" alt="image.png"></p>
<p>安装完成后，屏幕显示如下：</p>
<p><img src="/assets/2/image-20220430225337-l1xk6hs.png" alt="image.png"></p>
<p>单击“完成”按钮。<br><img src="/assets/2/image-20220430225344-ix71og0.png" alt="image.png"></p>
<p>现在，JIRA已在Web浏览器中启动，必须在Jira中注册该帐户。必须选择许可证类型并输入组织的名称。</p>
<p><img src="/assets/2/image-20220430225351-idrm48k.png" alt="image.png"></p>
<p>单击 <strong>Generate License(生成许可证)</strong> 按钮后，将出现一个弹出框，该弹出框是一个确认框，询问您是否要在服务器上安装许可证密钥。单击“是”按钮。</p>
<p><img src="/assets/2/image-20220430225356-ggs2bb2.png" alt="image.png"></p>
<p>填写登录Jira所需的管理员详细信息。单击“下一步”按钮。</p>
<p><img src="/assets/2/image-20220430225402-42c0eza.png" alt="image.png"></p>
<p>Jira将开始完成您的设置。</p>
<p><img src="/assets/2/image-20220430225408-hcu09nu.png" alt="image.png"></p>
<p>当设置了Jira，就可以自由使用Jira软件。如下界面所示 -</p>
<p><img src="/assets/2/image-20220430225414-q8v9c1k.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>05_JIRA Scrum</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/05_JIRAScrum/</url>
    <content><![CDATA[<p>在前面我们学习了敏捷方法，其中敏捷是一组信念，应该遵循这些信念来开发软件开发项目。在这些信念或价值观上，已经开发了许多模型，其中一个模型是Scrum。</p>
<p>在深入Scrum之前，您应该知道一些基本术语的含义：</p>
<ul>
<li>Scrum：Scrum是一个敏捷框架，可以帮助您组织，迭代和继续您正在处理的同一个项目。在scrum中，产品是在一系列迭代中构建的，称为sprint或part。</li>
<li>Sprint：Sprint是一个时间限制的时期，scrum团队需要完成一定数量的工作。每个sprint都有一个指定的时间线，即2周到1个月。scrum团队在sprint计划会议期间同意此时间表。</li>
<li>Scrum Master：Scrum Master被定义为Scrum开发团队的推动者或仆人领导者。Scrum Master必须确保遵循Scrum原则。</li>
<li>Scrum开发团队：Scrum开发团队是包含开发人员，QA和Scrum master的个人成员的集合。它决定并提供努力估计，Scrum团队的建议规模为5到9名成员。</li>
</ul>
<h4 id="Scrum是如何工作的？"><a href="#Scrum是如何工作的？" class="headerlink" title="Scrum是如何工作的？"></a>Scrum是如何工作的？</h4><p><img src="/assets/2/image-20220503110640-hmog1be.png" alt="image.png"></p>
<p><img src="/assets/2/image-20220503110649-uxwe8j7.png" alt="image.png"></p>
<p>在瀑布模型中，我们已经读到完成了第一个完整的需求，然后完成整个设计，然后完成整个开发，然后完成整个测试和部署。此模型占用产品的整个生命周期，然后唯一的产品可供客户查看。虽然Scrum说要考虑软件的一小部分，然后对其进行规划，构建，测试并最终进行审核。已经开发的这个小模块将向客户展示。例如，我们需要开发电子商务网站，可以分为多个sprints或模块，如登录页面，支付页面，购物车页面等。然后，每个模块单独开发并同时向客户展示。因此，我们可以说，在每个sprint完成后，将产品发送到客户端，但不是完整的产品，而是功能的一部分。</p>
<h4 id="Scrum的Artifact"><a href="#Scrum的Artifact" class="headerlink" title="Scrum的Artifact"></a>Scrum的Artifact</h4><p>在Scrum中准备的文档和内容称为Artifacts。</p>
<p>以下是Scrum的Artifact：</p>
<p><img src="/assets/2/image-20220503110654-tjgng4c.png" alt="image.png"></p>
<ul>
<li><strong>产品待办事项</strong><br>产品待办事项(Product Backlog)是需要在项目中完成的活动的集合。当我们想要开发软件时，需要执行’n’个活动。例如，我们需要开发电子商务网站，然后必须进行’n’个活动，例如我们需要创建登录页面，支付系统，购物车系统等以及这些’n’个活动。需要开发的软件称为产品待办事项。</li>
<li><strong>Sprint待办事项</strong><br>我们知道，在一个scrum中，我们将scrum分解为’n’个sprint，而sprint的目标是将软件的小功能带到客户端进行演示。在产品待办事项中，我们必须完成开发软件所需的所有活动，而在sprint待办事项中，在该sprint中执行一小组产品待办事项活动。’n’个sprint待办事项等于1个产品待办事项。</li>
<li><strong>Burndown图表</strong><br>Burndown图表是sprint的结果，它显示了sprint的进展。在每个sprint之后，我们需要检查每个sprint的进度。Burndown图表告诉您如何处理sprint。在Burndown图表中，图表从一段时间开始，即活动开始的地方，并且在sprint结束时，图表在活动结束时达到零。它通常是从上到下的倾斜线。</li>
</ul>
<h4 id="Scrum角色"><a href="#Scrum角色" class="headerlink" title="Scrum角色"></a>Scrum角色</h4><p>有三个scrum角色：</p>
<ul>
<li><strong>产品拥有者</strong><br>有一个客户想要开发他的软件，所以他接近可以开发他的软件的公司。公司做什么？ 公司指定一个角色，即产品负责人。产品负责人是与客户沟通的人了解他们的要求。产品负责人是公司负责软件开发的人员。</li>
<li><strong>Scrum Master</strong><br>在冲刺期间，敏捷说团队应该每天聚会一次。当团队遵循scrum意味着他们每天开会10到15分钟。这次会议被称为scrum会议。Scrum Master是处理Scrum会议的人。</li>
<li><strong>团队</strong><br>该团队由从事该项目的人员组成。它可以是开发人员，测试人员或设计人员。当我们谈论敏捷或Scrum时，我们谈论团队，不讨论开发人员或测试人员作为个人。敏捷让开发人员可以作为测试人员工作，或者测试人员可以在需要时以开发人员的身份工作。</li>
</ul>
<h4 id="Scrum的仪式"><a href="#Scrum的仪式" class="headerlink" title="Scrum的仪式"></a>Scrum的仪式</h4><p>看看下面的Scrum仪式：</p>
<ul>
<li><strong>Sprint计划</strong><br>Scrum由许多sprint组成，这些sprint具有用于交付软件的不同模块集。在开始sprint计划之前，召开一次名为sprint计划的会议，在sprint计划中，我们讨论了sprint将要做什么。在sprint计划中，产品所有者讨论产品的每个功能并估计开发团队所涉及的工作量。</li>
<li><strong>每日Scrum</strong><br>在Scrum中，Scrum Master每天召开15分钟的会议，Scrum Master是管理会议的人。会议由scrum master，开发人员，测试人员，设计人员，产品所有者，产品所有者和客户端都是可选的客户端组成。</li>
<li><strong>Sprint复审</strong><br>在每个sprint完成之后，会议将与客户进行，其中向客户展示产品以进行演示，团队讨论他们在项目中添加的功能。</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>06_Sprint的工作</title>
    <url>/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/01_%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/01_jira/jira%E6%96%87%E4%BB%B6/06_Sprint%E7%9A%84%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>Sprint的工作如下图所示 -</p>
<p><img src="/assets/2/image-20220503111035-31ipoaz.png" alt="image.png"></p>
<h4 id="客户，利益相关者"><a href="#客户，利益相关者" class="headerlink" title="客户，利益相关者"></a>客户，利益相关者</h4><p>假设有一个客户想要开发他们的软件，他们找到一个基于服务的公司来开发他们的软件。</p>
<h4 id="产品拥有者"><a href="#产品拥有者" class="headerlink" title="产品拥有者"></a>产品拥有者</h4><p><strong>该公司将做什么？</strong></p>
<p>公司将指定称为产品所有者的人。客户端与产品所有者进行沟通，产品所有者将捕获客户端的所有需求或用户故事，并将其命名为产品待办事项。</p>
<h4 id="产品待办事项"><a href="#产品待办事项" class="headerlink" title="产品待办事项"></a>产品待办事项</h4><p>产品待办事项(Backlog)是开发软件时需要完成的一系列活动。</p>
<h4 id="Sprint计划"><a href="#Sprint计划" class="headerlink" title="Sprint计划"></a>Sprint计划</h4><p>现在，我们将开始sprint。我们不会像在瀑布模型中那样一次性开发产品。我们将考虑产品待办事项的某些部分，并且将首先开发优先的那一部分。要开发这个特定的部分，需要考虑一些因素，例如什么是优先级，哪些组件可以组合在一起，客户需要什么功能等等。在开始sprint之前，会议被称为sprint规划，我们将在哪里讨论所有功能。在sprint计划中，我们还选择将在此sprint中开发的活动或待办事项，所选的待办事项被称为sprint待办事项。</p>
<h4 id="Sprint-Backlog"><a href="#Sprint-Backlog" class="headerlink" title="Sprint Backlog"></a>Sprint Backlog</h4><p>Sprint Backlog是一组需要在此sprint中执行的活动。在产品Backlog中，在sprint backlog中捕获一组活动，并将sprint backlog的每个活动分配给特定的人。完成sprint的最短时间是4天，但可以延长到2-3周。</p>
<h4 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h4><p>在Sprint Backlog之后，团队开始进行Sprint，完成Sprint可能需要大约1到3周的时间。sprint的完成因项目而异。当sprint开始时，每日会议被称为 <strong>Daily Scrum</strong> ，Scrum Master会召开这次会议。在Daily Scrum中，每天都会举行一次会议，会议可以延长到10-15次会议。会议有一种预定义的格式，即团队成员必须告诉他昨天做了什么，今天他将做什么，以及妨碍他完成工作的事情是什么？Scrum主管负责解决团队成员面临的问题。</p>
<h4 id="Sprint交付"><a href="#Sprint交付" class="headerlink" title="Sprint交付"></a>Sprint交付</h4><p>当sprint完成时，sprint将被传递给客户端。产品交付给客户意味着完成了称为sprint backlog的最小产品待办事项。sprint交付完成后，客户端可以查看产品，这不是我们已经开发了一些东西而客户端无法查看。</p>
<h4 id="Sprint评论和回顾"><a href="#Sprint评论和回顾" class="headerlink" title="Sprint评论和回顾"></a>Sprint评论和回顾</h4><p>一旦sprint交付结束，就会举行两种类型的会议，即Sprint审查和回顾。Sprint审查是团队成员坐在一起的会议，他们向客户提供有关他们在此sprint中开发的产品的演示。</p>
<p>回顾会是团队成员之间的另一次会议。在这次会议中，他们讨论了这个sprint中的正确内容以及这个sprint中出了什么问题，比如妨碍他们工作的问题。</p>
<p>在sprint审核之后，回到产品Backlog，然后进行sprint计划以选择sprint backlog，即sprint2，这样，这个周期一直持续到除非整个产品被开发并运送到客户端。</p>
<h2 id="Scrum主面板"><a href="#Scrum主面板" class="headerlink" title="Scrum主面板"></a>Scrum主面板</h2><p> <strong>产品待办事项：</strong> Product Backlog是开发软件时需要完成的一系列活动。<br> <strong>Sprint待办事项：</strong> Sprint Backlog是一个积压，它已经从产品积压中采取了一些需要在此sprint中完成的活动。<br> <strong>Scrum主面板：</strong> Scrum Board是一个主面板，它显示了在此sprint中需要完成的所有活动的状态。</p>
<p>Scrum主面板包含四种状态：</p>
<ul>
<li><strong>打开</strong> - “打开”状态表示“打开”中可用的任务尚未启动。</li>
<li><strong>进行中</strong> - “进行中”状态意味着开发人员完成了他们的任务。</li>
<li><strong>测试</strong> - “测试”意味着任务处于测试阶段。</li>
<li><strong>关闭</strong> - ‘关闭’表示任务已完成。</li>
</ul>
]]></content>
      <categories>
        <category>05_测试工具</category>
        <category>01_测试管理工具</category>
        <category>01_jira</category>
        <category>jira文件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>测试专家</title>
    <url>/04_%E6%B5%8B%E8%AF%95%E4%B8%93%E5%AE%B6/01_%E6%B5%8B%E8%AF%95%E4%B8%93%E5%AE%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>04_测试专家</category>
      </categories>
      <tags>
        <tag>测试专家</tag>
      </tags>
  </entry>
  <entry>
    <title>测试中阶</title>
    <url>/02_%E6%B5%8B%E8%AF%95%E4%B8%AD%E9%98%B6/01_%E6%B5%8B%E8%AF%95%E4%B8%AD%E9%98%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>02_测试中阶</category>
      </categories>
      <tags>
        <tag>测试中阶</tag>
      </tags>
  </entry>
  <entry>
    <title>04_测试高阶</title>
    <url>/03_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/</url>
    <content><![CDATA[<p><a href="/05_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/">python爬虫技术</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/01_%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/02_python%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/">python常用编码</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/02_python_tkinter/01_tkinter/">python_tkinter_图形界面编程</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E9%AB%98%E9%98%B6/03_python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/01_pandas_matplotlib/">python数据分析入门实例-pandas_matplotlib</a></p>
]]></content>
      <categories>
        <category>03_测试高阶</category>
      </categories>
      <tags>
        <tag>测试高阶</tag>
      </tags>
  </entry>
  <entry>
    <title>个人问题</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/05_%E4%B8%AA%E4%BA%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li><h2 id="未来发展的职业规划："><a href="#未来发展的职业规划：" class="headerlink" title="未来发展的职业规划："></a><strong>未来发展的职业规划：</strong></h2><ol>
<li>做好目前的本质工作，更多的充实自己的技术，学习一些相关的内容，如果有机会想往管理成发展</li>
</ol>
</li>
<li><strong>对测试的看法</strong><ol>
<li>首先是必须对业务熟悉，要多分析，对自己的技术方面要不断的提升</li>
</ol>
</li>
<li><strong>什么时候查询数据库</strong><ol>
<li>在数据校验的时候</li>
</ol>
</li>
<li><strong>你们公司版本怎么发布的</strong><ol>
<li>UAT环境产品用户验收完成后，由我们项目经理进行签报，审批通过就可以发布了</li>
</ol>
</li>
<li><strong>回归测试的好处</strong><ol>
<li>确认BUG的修复情况，检查测试修复的BUG是否引起了新的BUG，检查新的版本是否保留了旧版的成熟的功能</li>
</ol>
</li>
<li><strong>项目结束的标准</strong><ol>
<li>修复了所有的BUG，控制在接受范围，通过了客户验收，到了项目的终止时间</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
        <category>999_面试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>开放性问题</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/06_%E5%BC%80%E6%94%BE%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li><h3 id="对测试的看法"><a href="#对测试的看法" class="headerlink" title="对测试的看法"></a>对测试的看法</h3><ol>
<li>首先必须对业务熟悉，要多分析，对自己的技术方面要不断的提升</li>
</ol>
</li>
<li><h3 id="作为组长你的队员不愿意加班怎么办？"><a href="#作为组长你的队员不愿意加班怎么办？" class="headerlink" title="作为组长你的队员不愿意加班怎么办？"></a>作为组长你的队员不愿意加班怎么办？</h3><ol>
<li>首先找他沟通一下，了解下详细情况，再针对相应的情况进行处理</li>
</ol>
</li>
<li><h3 id="给你个新人你怎么带？"><a href="#给你个新人你怎么带？" class="headerlink" title="给你个新人你怎么带？"></a>给你个新人你怎么带？</h3><ol>
<li>首先带领他熟悉一下我们的项目组的人员，让他熟悉一下平时工作的内容，告诉他我们工作中所用到的系统</li>
</ol>
</li>
<li><h3 id="给你一个30人的团队你怎么带领？"><a href="#给你一个30人的团队你怎么带领？" class="headerlink" title="给你一个30人的团队你怎么带领？"></a>给你一个30人的团队你怎么带领？</h3><ol>
<li>首先我会跟我的下层打成一片，在这里面了解他们的强项以及弱项，再根据我们的项目去合理分配工作，项目不紧张的时候让工作能力强的人带领弱的人，项目紧张的时候把比较难搞得事情交给能力强的人，容易的交给能力弱的人，以提高工作效率</li>
</ol>
</li>
<li><h3 id="功能测试与接口测试的区别"><a href="#功能测试与接口测试的区别" class="headerlink" title="功能测试与接口测试的区别"></a>功能测试与接口测试的区别</h3><ol>
<li>功能测试是手工测试，接口测试是借助工具进行的测试</li>
</ol>
</li>
<li><h3 id="数据库后台数据重复怎么办？"><a href="#数据库后台数据重复怎么办？" class="headerlink" title="数据库后台数据重复怎么办？"></a>数据库后台数据重复怎么办？</h3><ol>
<li>首先重复就是一个bug，记录它哪个地方出现的问题逐一解决</li>
</ol>
</li>
<li><h3 id="为什么抓包"><a href="#为什么抓包" class="headerlink" title="为什么抓包"></a>为什么抓包</h3><ol>
<li>抓包是抓取数据，帮开发定位问题的</li>
</ol>
</li>
<li><h3 id="项目结束的标准"><a href="#项目结束的标准" class="headerlink" title="项目结束的标准"></a>项目结束的标准</h3><ol>
<li>修复了所有的bug，控制在可接受的范围内，通过了客户验收，到了项目的终止时间</li>
</ol>
</li>
<li><h3 id="你们公司版本是怎么发布的"><a href="#你们公司版本是怎么发布的" class="headerlink" title="你们公司版本是怎么发布的"></a>你们公司版本是怎么发布的</h3><ol>
<li>UAT环境 产品验收完成后，由我们项目经理进行签报，审批通过后就可以发布了</li>
</ol>
</li>
<li><h3 id="回归测试的好处"><a href="#回归测试的好处" class="headerlink" title="回归测试的好处"></a>回归测试的好处</h3><ol>
<li>确认bug的球服情况，检测修复的bug是否引入新的bug，检测新版本是否保留了旧版本遗留的成熟的功能</li>
</ol>
</li>
<li><h3 id="未来发展的职业规划"><a href="#未来发展的职业规划" class="headerlink" title="未来发展的职业规划"></a>未来发展的职业规划</h3><ol>
<li>做好目前的本职工作，更多的充实自己的技术，学习一些相关内容 除此以外如果有机会想往管理层发展</li>
</ol>
</li>
<li><h3 id="有没有抓过包，为什么要抓包，具体怎么做的？"><a href="#有没有抓过包，为什么要抓包，具体怎么做的？" class="headerlink" title="有没有抓过包，为什么要抓包，具体怎么做的？"></a>有没有抓过包，为什么要抓包，具体怎么做的？</h3><ol>
<li>抓包这块，其实我们在工作用得是比较多的。一般我们都在测试过程碰到问题，我们有时候通过抓包去看一下前端与后台的数据交互，通过分析这个数据，来定位到底是前端问题，还是后台问题。</li>
<li>要用的就是 fiddler工具，如果只是抓取 Web端数据的话，只要在浏览器上设置代理服务器，指定代理服务器为本地的fiddler 这个工具，设置好端口：8888就可以了。如果要抓取手机端的包，首先需要保证手机与电脑（安装了 fiddler 的这个电脑）在同一个网络，在手机上要设置 http代理服务器为手动， 然后服务器指定为电脑的 ip地址，端口设置为 8888</li>
<li>另外，如果要抓取 https 包，可能还需要在电脑上安装证书，手机端这边也要安装证书。差不多这样就可以。</li>
</ol>
</li>
<li><h3 id="为什么要进行抓包？具体怎么分析的？"><a href="#为什么要进行抓包？具体怎么分析的？" class="headerlink" title="为什么要进行抓包？具体怎么分析的？"></a>为什么要进行抓包？具体怎么分析的？</h3><ol>
<li>主要是我们在测试过程中，出现 Bug 的时候，为了定位问题，分析问题，需要抓取前台后台的数据交互过程，通过看数据，从而来分析到底是前端问题还是后台问题。</li>
<li>分析这块的话：<ol>
<li>首先看发的请求是否有问题，请求的接口 url 是否有错误，参数是否有错误，如果 url 或传参有问题那就是前端 Bug</li>
<li>如果请求没有问题，看下后台返回的数据是否有问题，状态码5 开头的基本都是后台问题，状态码为200，响应数据与预期不一致，那也是后台 Bug，不过这里有可能是数据库问题，也有可以是后台代码问题，这里首先我一般会查看下数据库的数据，如果数据库没有问题，那就需要查看下后台的日志文件，具体分析下看是后台代码哪里出问题了，然后把日志信息信息截图给开发。</li>
<li>返回的数据没有问题，请求参数，url 也没有问题，那可能是前端代码是否转换有问题，那就是前端 Bug。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="给你一个需求，你具体讲下，你怎么测试"><a href="#给你一个需求，你具体讲下，你怎么测试" class="headerlink" title="给你一个需求，你具体讲下，你怎么测试"></a>给你一个需求，你具体讲下，你怎么测试</h3><ol>
<li>第一点：首先我要熟悉这个需求的背景，这个需要功能，我至少要知道这个需求做的是什么吧，做的是一个什么样的解决方法这个要搞清楚</li>
<li>第二点：这些搞清楚，看这个需要和其他模块有哪些交互，需不需要关联起来分析，有没有影响到其他模块，或者数据有没有流向其他模块</li>
<li>第三点：这些都清楚了，那么我会根据熟悉的情况看下工作量，哪个时间点交付，在这个时间点我需要做一个计划给老大说下，如果时间充分，一个人能搞定，那么就一个人搞定，搞不定，我会向老大申请人力</li>
<li>其实接下来也差不多了，分析需求，尽量要评审，在前期就保证好质量，如果没有问题，其他也就是用例实例化，执行啊，bug跟踪啊等，最后出个报告就好了</li>
<li>基本我做的话，会这么做主要看你在最短时间把需求吃透，做好计划，展开工作</li>
</ol>
</li>
<li><h3 id="给你一个项目，你怎么展开工作，请详细说一下，你具体怎么做的"><a href="#给你一个项目，你怎么展开工作，请详细说一下，你具体怎么做的" class="headerlink" title="给你一个项目，你怎么展开工作，请详细说一下，你具体怎么做的"></a>给你一个项目，你怎么展开工作，请详细说一下，你具体怎么做的</h3><ol>
<li>面试官考的点：进我公司，给你一个项目，你怎么做，看你有没有独立做项目能力<ol>
<li>第一点：首先我要熟悉这个项目的背景，我至少要知道这个项目做的是什么吧，做的是一个什么样的解决方法这个要搞清楚</li>
<li>第二点：这些搞清楚，那么必须要清楚这个项目的核心模块和业务，我们给这个模块做一个优先级，先测试哪些核心模块，再做哪些模块</li>
<li>第三点：根据刚刚信息，我会熟悉这个业务，这个业务相关模块，以及写数据前后台交互等</li>
<li>第四点：这些都熟悉了，那么我会根据熟悉的情况看下工作量，哪个时间点交付，在这个时间点我需要做一个测试计划,一般需求分析的话，根据我的经验基本 2天差不多了，编写用例时间，执行时间，bug修复时间，我会做一个工作量评估，如果还有其他测试，我会把这个计划发给大家，让大家评审这个计划和安排，看安排是否合理，大家能不能在这个计划时间段完成，基本需求分析等多给个 2天左右，那么大家要再这个时间段完成，完成后我会安排大家讲解需求，做需求评审和需要讲解，前期时间多投入点，后面风险小一点，这个我主要跟进下进度就行</li>
<li>第五点：那么接下来，大家按照计划去编写用例，用例在时间点完成后，我会组织大家评审，这个两个我必须把控，减少后面测试风险，前面分析和用例把握到位，后续执行和 bug 这块不会有太多问题,后续的话，那么大家执行就行，我主要跟进这个进度，每天大家 bug 解决情况，以及测试进度，做成日报，像些问题不好解决的，有问题的，我去协助那么测试完成后，我会收集大家测试数据，做一份测试报告，这个我会评估这个测试有没有风险，没有的话，发送给开发老大，开发所有人，测试所有人这块评审下，后续组织测试人员安排上线，我基本是这么做的</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="项目快上线因为开发延迟，测试时间被压缩怎么做"><a href="#项目快上线因为开发延迟，测试时间被压缩怎么做" class="headerlink" title="项目快上线因为开发延迟，测试时间被压缩怎么做"></a>项目快上线因为开发延迟，测试时间被压缩怎么做</h3><ol>
<li>【开发延期完成，产品还需如期上线，测试需怎么办】</li>
<li>首先看下自己还剩下多少时间，然后要评估工作量，评估下风险，比如说，可能我根本做不完，风险太大，那么这个我首先要把风险提出来，给对应的领导，那么我会要求有人协助我完成，需要多少人力来完成，如果只是说，正常时间完不成，那么我可以提下加班，看加班这个时间段能否完成，如果可以，我会和老大商量，提出加班计划。如果是其他的，先跟领导确认，比如说我只需要把优先级高的工作完成，其他工作可以安排到下一个版本去做，那么我就做个计划，把计划个老大说下</li>
</ol>
</li>
<li><h3 id="如果时间比较紧的话，你怎么安排你的工作"><a href="#如果时间比较紧的话，你怎么安排你的工作" class="headerlink" title="如果时间比较紧的话，你怎么安排你的工作"></a>如果时间比较紧的话，你怎么安排你的工作</h3><ol>
<li>首先要评估下风险，比如说，可能我根本做不完，风险太大，那么这个我首先要把风险提出来，给对应的领导，那么我会要求有人协助我完成，需要多少人力来完成，如果只是说，正常时间完不成，那么我可以提下加班，看加班这个时间段能否完成，如果可以，我会和老大商量，提出加班计划如果是其他的，比如说我只需要把优先级高的工作完成，其他工作可以安排到下一个版本去做，那么我就做个计划，把计划个老大说下这个可能需要抓包，首先抓包看下前后台的数据交互情况，确认下是不是前端请求发送有问题导致返回数据有问题。如果是请求有问题，那提 Bug 给前端，让前端修复。</li>
<li>如果请求没有问题，与接口文档对比，查看下返回数据具体是哪里出问题了，这里还得首先查看下数据库，看是不是数据库中本身数据就有问题，如果数据库数据没有问题，那可能是后台代码问题，这个时候可以查看下后台的日志文件，通过分析日志文件的错误信息排查具体什么原因导致问题出现。</li>
</ol>
</li>
<li><h3 id="返回数据现在有问题，怎么排查问题？"><a href="#返回数据现在有问题，怎么排查问题？" class="headerlink" title="返回数据现在有问题，怎么排查问题？"></a>返回数据现在有问题，怎么排查问题？</h3></li>
<li><h3 id="APP出现崩溃时怎么抓取日志"><a href="#APP出现崩溃时怎么抓取日志" class="headerlink" title="APP出现崩溃时怎么抓取日志"></a>APP出现崩溃时怎么抓取日志</h3><ol>
<li>#adb logcat android studiologcat</li>
<li>这种情况我肯定要去看手机端的日志，去分析崩溃日志，通过 adblogcat 去查看日志，根据崩溃时间段去查找这个时间段日志，去查看是否有 Error,Exception,Crash,OOM等显现，分析日志，不懂的可以百度查看下原因，然后发给开发处理。<br>首先带领他熟悉一下我们的项目组的人员，让他熟悉一下平时工作的内容，告诉他我们工作中所用到的系统</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
        <category>999_面试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库相关</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/07_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
        <category>999_面试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑性问题</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/04_%E9%80%BB%E8%BE%91%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li><p>你让工人为你工作7天，回报是一根金条，这个金条平分成相连的7段，你必须在每天结束的时候 给他们一段。如果只允许你两次把金条弄断，你如何给你的工人付费？</p>
<ol>
<li><p>解题思路：</p>
<ol>
<li><strong>本题实质问题是数字表示问题。由1、2两个数字可表示1-3三个数字。由1、2、4三个数字可表示1-7七个数字（即1，2，1+2，4，4+1，4+2，4+2+1）。由1、2、4、8四个数字可表示1-15十五个数字。依此类推。</strong></li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li>把金条分成1&#x2F;7、2&#x2F;7和4&#x2F;7三份。这样，第1天我就可以给他1&#x2F;7；第2天我给他2&#x2F;7，让他找回我1&#x2F;7；第3天我就再给他1&#x2F;7，加上原先的2&#x2F;7就是3&#x2F;7；第4天我给他那块4&#x2F;7，让他找回那两块1&#x2F;7和2&#x2F;7的金条；第5天，再给他1&#x2F;7；第6天和第2天一样；第7天给他找回的那个1&#x2F;7</li>
</ol>
</li>
<li><p><strong>试题拓展：</strong></p>
<ol>
<li><strong>你让工人为你工作15天，给工人的回报是一根金条。金条平分成相连的15段，你必须在每天结束时给他们一段金条，如果只许你三次把金条弄断，你如何给你的工人付费？（1&#x2F;15，2&#x2F;15，4&#x2F;15，8&#x2F;15）</strong></li>
<li><strong>你让工人为你工作31天，给工人的回报是一根金条。金条平分成相连的31段，你必须在每天结束时给他们一段金条，如果只许你四次把金条弄断，你如何给你的工人付费？（1&#x2F;31，2&#x2F;31，4&#x2F;31，8&#x2F;31，16&#x2F;31）</strong></li>
<li><strong>你让工人为你工作（2^n）-1天，给工人的回报是一根金条。金条平分成相连的（2^n）-1段，你必须在每天结束时给他们一段金条，如果只许你n-1次把金条弄断，你如何给你的工人付费？（1&#x2F;（（2^n）-1），2&#x2F;（（2^n）-1），4&#x2F;（（2^n）-1），…）</strong></li>
<li><strong>人民币为什么只有1、2、5、10的面值？（便于找零钱。理想状态下应是1、2、4、8，在现实生活中常用10进制，故将4、8变为5、10。只要2有两个，1、2、2、5、10五个数字可表示1-20。）</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>5 个强盗分 100 个金币，如果第一个人提出的分配方案得到半数以上（含半数）的人同意则执行，否则处死第一个人，再由第二个人提出方案，直到分配完成。第一个人提出怎样的方案才能既获得最大利益又没有杀身之祸？</p>
<ol>
<li><p>方案一：</p>
<ol>
<li><p>这里假设每个人都是理性的且追求最大的利益。</p>
</li>
<li><p>第 1 个人提出的分配方案要满足两个条件，一是得到半数以上的人支持。二是使自己获得最大的利益。为了取得别人的支持需要给他们部分利益，显然这部分利益要超过他们在第 2 个人提出的可接受分配方案中所获得的利益。如果不这样，他们会反对，从而接受第 2 个人提出的方案。</p>
</li>
<li><p>问题变成了求第 2 个人提出的可接受方案。他的方案也要满足上面的两点。 以此类推，问题变成最后一个人提出可接受方案，显然可以提可接受的方案，因为没有人反对，把金币全部分给自己。</p>
</li>
<li><p>下面是他们的方案：</p>
<ol>
<li>第5个人的方案： 0 ， 0 ， 0 ， 0 ， 100 。（不需要别人的支持）</li>
<li>第4个人的方案： 0 ， 0 ， 0 ， 100 ， 0 。（不需要别人的支持）</li>
<li>第3个人的方案： 0 ， 0 ， 99 ， 0 ， 1 。（第5个人会支持他）</li>
<li>第2个人的方案： 0 ， 99 ， 0 ， 1 ， 0 。（第4个人会支持他）</li>
<li>第1个人的方案： 98 ， 0 ， 1 ， 0 ， 1 。（第3，5个人会支持他）</li>
</ol>
</li>
<li><p>这道题的答案有些让人吃惊，本以为第一个人最危险，反而能获得较大利益。问题出在题目的假设： 每个人都是理性的且追求最大的利益，从而低估了生命的价值。</p>
</li>
</ol>
</li>
<li><p>方案二</p>
<ol>
<li>1号的分法应该是：自己98枚，2号和4号没知有，3号和5号每人1枚。<br> 　　98 0 1 0 1<br> 　　推理如下；最后一个海盗没有被扔的可能，所以从5号开始<br> 　　 如果前4人都被扔了，则5号可以得到100枚<br> 　　 如果只剩4号和5号，4号会道给自己分100个给五号分0，自己的一票，达到了50%。<br> 　　 若剩3，4，5号三人，3号便会给自己99枚，5号1枚，5号会赞成3的方法，加上回自己一票，可通过。<br> 　　 如果是2号出方案答，他考虑到前面3，4，5的想法，便会给自己分99个给可以支持自己的4号1枚<br> 　　 一号想到了2的方法，所以一号的方法应该是98 0 1 0 1<br> 　　3号和五号支持1号，加上1号自己的1票，就可以通过了。</li>
</ol>
</li>
<li><p>方案三</p>
<ol>
<li>1号强盗分给3号1枚金币，4号或5号强盗2枚，独得97枚。分配方案可写成（97，0，1，2，0）或（97，0，1，0，2）。<br> 　　<br> 　　推理过程是这样的：从后向前推，如果1-3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。3号知道这一点，就会提（100，0，0）的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票他的方案即可通过。不过，2号推知到3号的方案，就会提出（98，0，1，1）的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。不过， 2号的方案会被1号所洞悉，1号并将提出（97 ，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>猜牌问题</strong></p>
<ol>
<li><p>S先生、P先生、Q先生他们知道桌子的抽屉里有16张扑克牌：红桃A、Q、4 黑桃J、8、4、2、7、3 草花K、Q、5、4、6 方块A、5。约翰教授从这16张牌中挑出一张牌来，并把这张牌的点数告诉 P先生，把这张牌的花色告诉Q先生。这时，约翰教授问P先生和Q 先生：你们能从已知的点数或花色中推知这张牌是什么牌吗？ 于是，S先生听到如下的对话：<br> P先生：我不知道这张牌。<br> Q先生：我知道你不知道这张牌。<br> P先生：现在我知道这张牌了。<br> Q先生：我也知道了。<br> 听罢以上的对话，S先生想了一想之后，就正确地推出这张牌是什么牌。<br> 请问：这张牌是什么牌？</p>
</li>
<li><p><strong>解题思路：</strong></p>
<p> <strong>由第一句话“P先生：我不知道这张牌。”可知，此牌必有两种或两种以上花色，即可能是A、Q、4、5。如果此牌只有一种花色，P先生知道这张牌的点数，P先生肯定知道这张牌。<br> 由第二句话“Q先生：我知道你不知道这张牌。”可知，此花色牌的点数只能包括A、Q、4、5，符合此条件的只有红桃和方块。Q先生知道此牌花色，只有红桃和方块花色包括A、Q、4、5，Q先生才能作此断言。<br> 由第三句话“P先生：现在我知道这张牌了。”可知，P先生通过“Q先生：我知道你不知道这张牌。”判断出花色为红桃和方块，P先生又知道这张牌的点数，P先生便知道这张牌。据此，排除A，此牌可能是Q、4、5。如果此牌点数为A，P先生还是无法判断。<br> 由第四句话“Q先生：我也知道了。”可知，花色只能是方块。如果是红桃，Q先生排除A后，还是无法判断是Q还是4。<br> 综上所述，这张牌是方块5。<br> 参考答案：<br> 这张牌是方块5。</strong></p>
</li>
</ol>
</li>
<li><p><strong>燃绳问题</strong></p>
<ol>
<li><p><strong>烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？</strong></p>
</li>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><strong>烧一根这样的绳，从头烧到尾1个小时。由此可知，头尾同时烧共需半小时。同时烧两根这样的绳，一个烧一头，一个烧两头；当烧两头的绳燃尽时，共要半小时，烧一头的绳继续烧还需半小时；如果此时将烧一头的绳的另一头也点燃，那么只需十五分钟。<br> 参考答案：<br> 同时燃两根这样的绳，一个烧一头，一个烧两头；等一根燃尽，将另一根掐灭备用。标记为绳2。再找一根这样的绳，标记为绳1。一头燃绳1需要1个小时，再两头燃绳2需十五分钟，用此法可计时一个小时十五分钟。</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>乒乓球问题</p>
<ol>
<li><p><strong>假设排列着100个乒乓球，由两个人轮流拿球装入口袋，能拿到第100个乒乓球的人为胜利者。条件是：每次拿球者至少要拿1个，但最多不能超过5个，问：如果你是最先拿球的人，你该拿几个？以后怎么拿就能保证你能得到第100个乒乓球？</strong></p>
</li>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><p><strong>1、我们不妨逆向推理，如果只剩6个乒乓球，让对方先拿球，你一定能拿到第6个乒乓球。理由是：如果他拿1个，你拿5个；如果他拿2个，你拿4个；如果他拿3个，你拿3个；如果他拿4个，你拿2个；如果他拿5个，你拿1个。<br> 2、我们再把100个乒乓球从后向前按组分开，6个乒乓球一组。100不能被6整除，这样就分成17组；第1组4个，后16组每组6个。<br> 3、这样先把第1组4个拿完，后16组每组都让对方先拿球，自己拿完剩下的。这样你就能拿到第16组的最后一个，即第100个乒乓球。</strong></p>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>先拿4个，他拿n个，你拿6-n，依此类推，保证你能得到第100个乒乓球。(1&lt;&#x3D;n&lt;&#x3D;5)</strong></li>
</ol>
</li>
<li><p><strong>试题拓展：</strong></p>
<ol>
<li><strong>假设排列着100个乒乓球，由两个人轮流拿球装入口袋，能拿到第100个乒乓球的人为胜利者。条件是：每次拿球者至少要拿2个，但最多不能超过7个，问：如果你是最先拿球的人，你该拿几个？以后怎么拿就能保证你能得到第100个乒乓球？（先拿1个，他拿n个，你拿9-n，依此类推）</strong></li>
<li><strong>假设排列着X个乒乓球，由两个人轮流拿球装入口袋，能拿到第X个乒乓球的人为胜利者。条件是：每次拿球者至少要拿Y个，但最多不能超过Z个，问：如果你是最先拿球的人，你该拿几个？以后怎么拿就能保证你能得到第X个乒乓球？（先拿X&#x2F;(Y+Z)的余数个，他拿n个，你拿(Y+Z)-n，依此类推。当然必须保证X&#x2F;(Y+Z)的余数不等于0）</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>喝汽水问题</p>
<ol>
<li><p><strong>1元钱一瓶汽水，喝完后两个空瓶换一瓶汽水，问：你有20元钱，最多可以喝到几瓶汽水？</strong></p>
</li>
<li><p><strong>解题思路1：</strong></p>
<ol>
<li><strong>一开始20瓶没有问题，随后的10瓶和5瓶也都没有问题，接着把5瓶分成4瓶和1瓶，前4个空瓶再换2瓶，喝完后2瓶再换1瓶，此时喝完后手头上剩余的空瓶数为2个，把这2个瓶换1瓶继续喝，喝完后把这1个空瓶换1瓶汽水，喝完换来的那瓶再把瓶子还给人家即可，所以最多可以喝的汽水数为：20＋10＋5＋2＋1＋1＋1＝40</strong></li>
</ol>
</li>
<li><p><strong>解题思路2：</strong></p>
<ol>
<li><strong>先看1元钱最多能喝几瓶汽水。喝1瓶余1个空瓶，借商家1个空瓶，2个瓶换1瓶继续喝，喝完后把这1个空瓶还给商家。即1元钱最多能喝2瓶汽水。20元钱当然最多能喝40瓶汽水。</strong></li>
</ol>
</li>
<li><p><strong>解题思路3：</strong></p>
<ol>
<li><strong>两个空瓶换一瓶汽水，可知纯汽水只值5角钱。20元钱当然最多能喝40瓶的纯汽水。N元钱当然最多能喝2N瓶汽水。</strong></li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>40瓶</strong></li>
</ol>
</li>
<li><p><strong>试题拓展：</strong></p>
<ol>
<li><strong>1元钱一瓶汽水，喝完后两个空瓶换一瓶汽水，问：你有N元钱，最多可以喝到几瓶汽水？（答案2N）</strong></li>
<li><strong>1元钱一瓶汽水，喝完后两个空瓶换一瓶汽水，问：你有N元钱，最多可以喝到几瓶汽水？（答案2N）</strong></li>
<li>1元钱一瓶汽水，喝完后四个空瓶换一瓶汽水，问：你有15元钱，最多可以喝到几瓶汽水？（答案20）</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>鬼谷考徒</strong></p>
<ol>
<li>孙膑，庞涓都是鬼谷子的徒弟；一天鬼出了这道题目：他从2到99中选出两个不同的整数，把积告诉孙，把和告诉庞。<br> 庞说：我虽然不能确定这两个数是什么，但是我肯定你也不知道这两个数是什么。<br> 孙说：我本来的确不知道，但是听你这么一说，我现在能够确定这两个数字了。<br> 庞说：既然你这么说，我现在也知道这两个数字是什么了。<br> 问这两个数字是什么？为什么？<ol>
<li><p><strong>解题思路1：</strong></p>
<ol>
<li><strong>假设数为 X,Y;和为X+Y&#x3D;A,积为X<em>Y&#x3D;B.<br> 根据庞第一次所说的：“我肯定你也不知道这两个数是什么”。由此知道，X+Y不是两个素数之和。那么A的可能11,17,23,27,29,35,37,41,47,51,53,57,59,65,67,71,77,79,83,87,89,95,97.<br> 我们再计算一下B的可能值：<br> 和是11能得到的积:18,24,28,30<br> 和是17能得到的积:30,42,52,60,66,70,72<br> 和是23能得到的积:42,60…<br> 和是27能得到的积:50,72…<br> 和是29能得到的积:…<br> 和是35能得到的积:66…<br> 和是37能得到的积:70…<br> ……<br> 我们可以得出可能的B为….，当然了，有些数（30&#x3D;5</em>6&#x3D;2*15）出现不止一次。<br> 这时候，孙依据自己的数比较计算后，“我现在能够确定这两个数字了。”<br> 我们依据这句话，和我们算出来的B的集合，我们又可以把计算出来的B的集合删除一些重复数。<br> 和是11能得到的积:18,24,28<br> 和是17能得到的积:52<br> 和是23能得到的积:42,76…<br> 和是27能得到的积:50,92…<br> 和是29能得到的积:54,78…<br> 和是35能得到的积:96,124…<br> 和是37能得到的积:,…<br> ……<br> 因为庞说：“既然你这么说，我现在也知道这两个数字是什么了。”那么由和得出的积也必须是唯一的，由上面知道只有一行是剩下一个数的，那就是和17积52。 那么X和Y分别是4和13。</strong></li>
</ol>
</li>
<li><p><strong>解题思路2：</strong></p>
<ol>
<li><strong>说话依次编号为S1，P1，S2。<br> 设这两个数为x，y，和为s，积为p。<br> 由S1，P不知道这两个数，所以s不可能是两个质数相加得来的，而且s＜＝41，因为如果s＞41，那么P拿到41×（s－41）必定可以猜出s了（关于这一点，参考老马的证明，这一点很巧妙，可以省不少事情）。所以和s为{11，17，23，27，29，35，37，41}之一，设这个集合为A。<br> 1).假设和是11。11＝2＋9＝3＋8＝4＋7＝5＋6，如果P拿到18，18＝3×6＝2×9，只有2＋9落在集合A中，所以P可以说出P1，但是这时候S能不能说出S2呢？我们来看，如果P拿到24，24＝6×4＝3×8＝2×12，P同样可以说P1，因为至少有两种情况P都可以说出P1，所以A就无法断言S2，所以和不是11。<br> 2).假设和是17。17＝2＋15＝3＋14＝4＋13＝5＋12＝6＋11＝7＋10＝8＋9，很明显，由于P拿到4×13可以断言P1，而其他情况，P都无法断言P1，所以和是17。<br> 3).假设和是23。23＝2＋21＝3＋20＝4＋19＝5＋18＝6＋17＝7＋16＝8＋15＝9＋14＝10＋13＝11＋12，咱们先考虑含有2的n次幂或者含有大质数的那些组，如果P拿到4×19或7×16都可以断言P1，所以和不是23。<br> 4).假设和是27。如果P拿到8×19或4×23都可以断言P1，所以和不是27。<br> 5).假设和是29。如果P拿到13×16或7×22都可以断言P1，所以和不是29。<br> 6).假设和是35。如果P拿到16×19或4×31都可以断言P1，所以和不是35。<br> 7).假设和是37。如果P拿到8×29或11×26都可以断言P1，所以和不是37。<br> 8).假设和是41。如果B拿到4×37或8×33，都可以断言P1，所以和不是41。<br> 综上所述：这两个数是4和13。</strong></li>
</ol>
</li>
<li><p><strong>解题思路3：</strong></p>
<ol>
<li>*<em>孙庞猜数的手算推理解法<br> 1)按照庞的第一句话的后半部分，我们肯定庞知道的和S肯定不会大于54。<br> 因为如果和54&lt;S&lt;54+99，那么S可以写为S&#x3D;53+a，a&lt;&#x3D;99。如果鬼谷子选的两个数字<br> 恰好是53和a，那么孙知道的积M就是M&#x3D;53*a，于是孙知道，这原来两个数中至少有<br> 一个含有53这个因子，因为53是个素数。可是小于100，又有53这个因子的，只能是<br> 53本身，所以孙就可以只凭这个积53*a推断出这两个数术53和a。所以如果庞知道的<br> S大于54的话，他就不敢排除两个数是53和a这种可能，也就不敢贸然说“但是我肯定<br> 你也不知道这两个数是什么”这种话。<br> 如果53+99&lt;S&lt;&#x3D;97+99，那么S可以写为S&#x3D;97+a，同以上推理，也不可能。<br> 如果S&#x3D;98+99，那么庞可以立刻判断出，这两个数只能是98和99，而且M只能是98*99，<br> 孙也可以知道这两个术，所以显然不可能。<br> 2)按照庞的第一句话的后半部分，我们还可以肯定庞知道的和S不可以表示为两个素数的和。<br> 否则的话，如果鬼谷子选的两个数字恰好就是这两个素数，那么孙知道积M后，就可以得到唯一的素因子分解，判断出结果。于是庞还是不敢说“但是我肯定你也不知道这两个数是什么”这种话。<br> 根据哥德巴赫猜想，任何大于4的偶数都可以表示为两个素数之和，对54以下的偶数，猜想肯定被验证过，所以S一定不能是偶数。<br> 另外型为S&#x3D;2+p的奇数，其中p是奇素数的那些S也同样要排除掉。<br> 还有S&#x3D;51也要排除掉，因为51&#x3D;17+2*17。如果鬼谷子选的是(17,2*17)，那么孙知道<br> 的将是M&#x3D;2*17*17，他对鬼谷子原来的两数的猜想只能是(17,2*17)。（为什么51要单独拿出来，要看下面的推理）<br> 3)于是我们得到S必须在以下数中：<br> 11 17 23 27 29 35 37 41 47 53<br> 另外一方面，只要庞的S在上面这些数中，他就可以说“但是我肯定你也不知道这两个<br> 数是什么”，因为这些数无论怎么拆成两数和，都至少有一个数是合数（必是一偶一<br> 奇，如果偶的那个大于2，它就是合数，如果偶的那个等于2，我们上面的步骤已经保<br> 证奇的那个是合数），也就是S只能拆成<br> 　a) S&#x3D;2+a*b　或　b) S&#x3D;a+2^n*b<br> 这两个样子，其中a和b都是奇数，n&gt;&#x3D;1。<br> 那么（下面我说的“至少两组数”中的两组数都不相同，而且的确存在（也就是那些<br> 数都小于100）的理由我就不写了，根据条件很显然）<br> 　a)或者孙的M&#x3D;2</em>a<em>b，孙就会在(2</em>a,b)和(2,a<em>b)至少两组数里拿不定主意（a和<br> 　　b都是奇数，所以这两组数一定不同）；<br> 　b)或者M&#x3D;2^n</em>a<em>b，<br> 　　如果n&gt;1，那么孙就会在(2^(n-1)<em>a,2</em>b)和(2^n</em>a,b)至少两组数里拿不定主意；<br> 　　如果n&#x3D;1，而且a不等于b，那么孙就会在(2<em>a,b)和(2b,a)至少两组数里拿不定主<br> 　　意；<br> 　　如果n&#x3D;1，而且a等于b，这意味着S&#x3D;a+2</em>a&#x3D;3a，所以S一定是3的倍数，我们只要<br> 　　讨论S&#x3D;27就可以了。27如果被拆成了S&#x3D;9+18，那么孙拿到的M&#x3D;9<em>18，他就会在<br> 　　(9，18)和(27,6)至少两组数里拿不定主意。<br> 　（上面对51的讨论就是从这最后一种情况的讨论发现的，我不知道上面的论证是否<br> 　过分烦琐了，但是看看51这个“特例”，我怀疑严格的论证可能就得这么烦）<br> 现在我们知道，当且仅当庞得到的和数S在<br> C&#x3D;{11, 17, 23, 27, 29, 35, 37, 41, 47, 53}<br> 中，他才会说出“我虽然不能确定这两个数是什么，但是我肯定你也不知道这两个数<br> 是什么”这句话<br> 孙膑可以和我们得到同样的结论，他还比我们多知道那个M。<br> 4)孙的话“我现在能够确定这两个数字了”表明，他把M分解成素因子后，然后组合成<br> 关于鬼谷子的那两个数的若干个猜想中，有且仅有一个猜想的和在C中。否则的话，他<br> 还是会在多个猜想之间拿不定主意。<br> 庞涓听了孙的话也可以得到和我们一样的结论，他还比我们多知道那个S。<br> 5)庞的话“我现在也知道这两个数字是什么了”表明，他把S拆成两数和后，也得到了<br> 关于鬼谷子的那两个数的若干个猜想，但是在所有这些拆法中，只有一种满足4)里的<br> 条件，否则他不会知道究竟是哪种情况，使得孙膑推断出那两个数来。<br> 于是我们可以排除掉C中那些可以用两种方法表示为S&#x3D;2^n+p的S，其中n&gt;1，p为素数。<br> 因为如果S&#x3D;2^n1+p1&#x3D;2^n2+p2，无论是(2^n1,p1)还是(2^n2,p2)这两种情况，孙膑都<br> 可以由M&#x3D;2^n1</em>p1或M&#x3D;2^n2<em>p2来断定出正确的结果，因为由M得到的各种两数组合，<br> 只有(2^n,p)这样的组合，两数和才是奇数，从而在C中，于是孙膑就可以宣布自己知道<br> 了是怎么回事，可庞涓却还得为(2^n1,p1)还是(2^n2,p2)这两种情况犯愁。<br> 因为11&#x3D;4+7&#x3D;8+3，23&#x3D;4+19&#x3D;16+7，27&#x3D;4+23&#x3D;16+11，35&#x3D;4+31&#x3D;16+19，37&#x3D;8+29&#x3D;32+5，<br> 47&#x3D;4+43&#x3D;16+31。于是S的可能值只能在<br> 17 29 41 53<br> 中。让我们继续缩小这个表。<br> 29不可能，因为29&#x3D;2+27&#x3D;4+25。无论是(2,27)和(4,25)，孙膑都可以正确判断出来：<br> 　a)如果是(2,27)，M&#x3D;2</em>27&#x3D;2<em>3</em>3<em>3，那么孙可以猜的组合是(2,27)(3,18)(6,9)，<br> 　　后面两种对应的S为21和15，都不在C中，故不可能，于是只能是(2,27)。<br> 　b)如果是(4,25)，M&#x3D;4</em>25&#x3D;2<em>2</em>5<em>5，那么孙可以猜的组合是(2,50)(4,25)(5,20)<br> 　　(10,10)。只有(4,25)的S才在C中。<br> 可是庞涓却要为孙膑的M到底是2</em>27还是4<em>25苦恼。<br> 41不可能，因为41&#x3D;4+37&#x3D;10+31。后面推理略。<br> 53不可能，因为53&#x3D;6+47&#x3D;16+37。后面推理略。<br> 研究一下17。这下我们得考虑所有17的两数和拆法：<br> (2,15)：那么M&#x3D;2</em>15&#x3D;2<em>3</em>5&#x3D;6<em>5，而6+5&#x3D;11也在C中，所以一定不是这个M，否则4)<br> 的条件不能满足，孙“我现在能够确定这两个数字了”的话说不出来。<br> (3,14)：那么M&#x3D;3</em>14&#x3D;2<em>3</em>7&#x3D;2<em>21，而2+21&#x3D;23也在C中。后面推理略。<br> (4,13)：那么M&#x3D;4</em>13&#x3D;2<em>2</em>13。那么孙可以猜的组合是(2,26)(4,13)，只有(4,13)<br> 的和在C中，所以这种情况孙膑可以说4)中的话。<br> (5,12)：那么M&#x3D;5<em>12&#x3D;2</em>2<em>3</em>5&#x3D;3<em>20，而3+20&#x3D;23也在C中。后面推理略。<br> (6,11)：那么M&#x3D;6</em>11&#x3D;2<em>3</em>11&#x3D;2<em>33，而2+33&#x3D;35也在C中。后面推理略。<br> (7,10)：那么M&#x3D;7</em>10&#x3D;2<em>5</em>7&#x3D;2<em>35，而2+35&#x3D;37也在C中。后面推理略。<br> (8,9)：那么M&#x3D;8</em>9&#x3D;2<em>2</em>2<em>3</em>3&#x3D;3<em>24，而3+24&#x3D;27也在C中。后面推理略。<br> 于是在S&#x3D;17时，只有(4,13)这种情况，孙膑才可以猜出那两数是什么，既然如此，庞涓就知道这两个数是什么，说出“我现在也知道这两个数字是什么了”。听了庞涓的话，于是我们也知道，这两数该是(4,13)。</em>*</li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>这两个数字是4和13。原因同上。</strong></li>
</ol>
</li>
<li><p><strong>试题拓展：</strong></p>
<ol>
<li>你有&gt;1并且&lt;30的两个不同的数字只把和告诉甲，然后只把积告诉乙。<br> 甲对乙说：“我不知道这两个数字是什么，但你也肯定不知道。”<br> 乙就说了：“我本来不知道的，你这么一说，我就知道两个数字是什么了。”<br> 甲于是说：“现在我也知道了!”<br> 请问这两个数字是分别是什么？ （答案：4和13。）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>舀酒难题</p>
<ol>
<li><p><strong>据说有人给酒肆的老板娘出了一个难题：此人明明知道店里只有两个舀酒的勺子，分别能舀7两和11两酒，却硬要老板娘卖给他2两酒。聪明的老板娘毫不含糊，用这两个勺子在酒缸里舀酒，并倒来倒去，居然量出了2两酒，聪明的你能做到吗？</strong></p>
<ol>
<li><p><strong>解题思路1：</strong></p>
<ol>
<li><strong>设舀7两的勺子为A和舀11两的勺子为B。要解决此题须使A不断舀酒倒入B中，B满后再倒入酒缸，如此反复即可。</strong></li>
</ol>
</li>
<li><p><strong>解题思路2：</strong></p>
<ol>
<li><strong>本题实质是计算下列式子：2<em>7-11&#x3D;3,2</em>7+3-11&#x3D;6,1<em>7+6-11&#x3D;2,2</em>7+2-11&#x3D;5,1<em>7+5-11&#x3D;1,2</em>7+1-11&#x3D;4,1*7+4-11&#x3D;0。即A、B两个勺子可量出1-6两酒，加上7、11，A、B两个勺子可量出1-18两酒</strong></li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>设舀7两的勺子为A和舀11两的勺子为B。倒法如下：<br>     A       B<br>     7       0<br>     0       7     A-&gt;B<br>     7       7<br>     3       11    A-&gt;B<br>     3       0<br>     0       3     A-&gt;B    （2<em>7-11&#x3D;3）<br>     7       3<br>     0       10    A-&gt;B<br>     7       10<br>     6       11    A-&gt;B<br>     6       0<br>     0       6     A-&gt;B    （2</em>7+3-11&#x3D;6）<br>     7       6<br />        2       11    A-&gt;B    （1*7+6-11&#x3D;2）<br>  A勺中有2两酒。</strong></li>
</ol>
</li>
<li><p><strong>试题拓展：：</strong></p>
<ol>
<li><strong>如果你有无穷多的水，一个3公升的提捅，一个5公升的提捅，两只提捅形状上下都不均匀，问你如何才能准确称出4公升的水？</strong></li>
<li><strong>有一个装满葡萄酒的8升罐子，另有一个3升，一个5升的空罐子，问怎么倒可以把葡萄酒分成两个4升的？</strong></li>
<li><strong>假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为 5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水。</strong></li>
<li><strong>两位妇人分别拿着4斤的奶瓶和5斤的奶瓶去奶店各买2斤奶，适逢店的称坏了，这时店里只有两大满奶桶，但聪明的店老板却成功地凭借现有的条件满足了两位妇人的要求。</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>五个囚犯</strong></p>
<ol>
<li><strong>5个囚犯，分别按1-5号在装有100颗绿豆的麻袋抓绿豆，规定每人至少抓一颗，而抓得最多和最少的人将被处死，而且，他们之间不能交流，但在抓的时候，可以摸出剩下的豆子数。问他们中谁的存活机率最大？？<br> 提示：<br> 1，他们都是很聪明的人<br> 2，他们的原则是先求保命，再去多杀人<br> 3，100颗不必都分完<br> 4，若有重复的情况，则也算最大或最小，一并处死</strong><ol>
<li><p>解题思路</p>
<ol>
<li><em>5个囚犯的策略<br> 由题设条件可知：摸到最大绿豆数的囚犯必死，摸到最小绿豆数的囚犯必死，摸到重复绿豆数的囚犯必死。<br> 整体来看，至少有两个囚犯必死。绿豆数为5时，2个囚犯必死(11111)。绿豆数为4时，3-4个囚犯必死(1211，2111)。绿豆数为3时，4-5个囚犯必死(131，311，221，212)。绿豆数为2、1时，5个囚犯必死。<br> 5个囚犯的策略应该是：5个囚犯必须使摸到的绿豆数不重复，这样才会有最多存活机会；又必须使自己摸到的绿豆数居中，才会有最大存活机会。<br> 明确了这一点，就可以往下分析了。<br> 具体分析求机率<br> 设1号囚犯摸到的绿豆数为N。<br> 则2号囚犯摸到的绿豆数为N+1或N-1。因为2号囚犯可以通过摸剩余绿豆的方法得知1号囚犯摸到的绿豆数,2号囚犯摸到的绿豆数为N的话就会重复是找死，如果摸到的绿豆数与N相差大于1的话，又会使得3号囚犯有机会使摸到的绿豆数居中。<br> 3号囚犯也会使自己摸到的绿豆数与1、2号的紧密相邻，即使自己摸到的绿豆数比1、2号的之中最大的大1，最小的小1。因为3号囚犯可以通过摸剩余绿豆的方法得知1、2号囚犯摸到的绿豆总数，又知1、2号囚犯摸到的绿豆数相差为1，从而判断出1、2号囚犯各自摸到的绿豆数。<br> 4、5号囚犯与3号囚犯想法基本相同。即使自己摸到的绿豆数比自己前面所有的之中最大的大1，最小的小1。<br> 综上所述，5个囚犯摸到的绿豆数为5个连续整数。<br> 1号囚犯存活机率。1号囚犯有两种情况必死：摸到的绿豆数最大或最小。摸到的绿豆数最大或最小，只能由后4位囚犯决定，由分析可知后4位囚犯的摸到绿豆数的位置都只有两个，即一组连续整数的两边。因此1号囚犯摸到的绿豆数为最大时的机率为（1&#x2F;2）</em>（1&#x2F;2）<em>（1&#x2F;2）</em>（1&#x2F;2）&#x3D;1&#x2F;16，最小时的机率也为1&#x2F;16，1号囚犯存活机率为1-（1&#x2F;16）<em>2&#x3D;7&#x2F;8<br> 2号囚犯存活机率。由对称性可知2号囚犯存活机率与1号相同，也为7&#x2F;8。<br> 3号囚犯存活机率。3号囚犯摸到的绿豆数为最大时的机率为（1&#x2F;2）</em>（1&#x2F;2）<em>（1&#x2F;2）&#x3D;1&#x2F;8，最小时的机率也为1&#x2F;8，1号囚犯存活机率为1-（1&#x2F;8）</em>2&#x3D;3&#x2F;4。<br> 4号囚犯存活机率。4号囚犯摸到的绿豆数为最大时的机率为（1&#x2F;2）<em>（1&#x2F;2）&#x3D;1&#x2F;4，最小时的机率也为1&#x2F;4，4号囚犯存活机率为1-（1&#x2F;4）</em>2&#x3D;1&#x2F;2。<br> 5号囚犯存活机率。5号囚犯摸到的绿豆数不是最大就是最小，必死无疑。5号囚犯存活机率为0。<br><br> [本题到此告一段落。但是5个囚犯的策略似乎有点问题：5号囚犯在必死无疑的情况下，还会为前4人保驾护航吗？他会不会临死拉个垫背的？于是有了以下分析。]<br><br> 5号囚犯的“觉醒”（临死拉个垫背的，在必死无疑的情况下多杀人）<br> 1-4号囚犯策略如前，则4个囚犯摸到的绿豆数为4个连续整数，而5号囚犯的“觉醒”促使他多杀人。要多杀人，他摸到的绿豆数必须为4个连续整数的中间两个，这样有4人必死，只有1人存活。5号囚犯必死，4号囚犯摸到的绿豆数为4个连续整数的最大或最小值，也必死，1-3号囚犯有可能存活。<br> 先不考虑5号囚犯。<br> 1号囚犯存活机率。1号囚犯摸到的绿豆数为4个连续整数的最大或最小值，则必死。1号囚犯摸到的绿豆数为最大时的机率为（1&#x2F;2）<em>（1&#x2F;2）</em>（1&#x2F;2）&#x3D;1&#x2F;8，最小时的机率也为1&#x2F;8，1号囚犯存活机率为1-（1&#x2F;8）<em>2&#x3D;3&#x2F;4<br> 2号囚犯存活机率。由对称性可知2号囚犯存活机率与1号相同，也为3&#x2F;4。<br> 3号囚犯存活机率。3号囚犯摸到的绿豆数为最大时的机率为（1&#x2F;2）</em>（1&#x2F;2）&#x3D;1&#x2F;4，最小时的机率也为1&#x2F;4，3号囚犯存活机率为1-（1&#x2F;4）<em>2&#x3D;1&#x2F;2。<br> 考虑5号囚犯。<br> 由于5号囚犯摸到的绿豆数必为4个连续整数的中间两个，故1-3号囚犯存活机率都将减半。即1、2号囚犯存活机率为（3&#x2F;4）</em>（1&#x2F;2）&#x3D;3&#x2F;8，3号囚犯存活机率（1&#x2F;2）*（1&#x2F;2）&#x3D;1&#x2F;4。<br><br> [5号囚犯的“觉醒”等于宣判了4号囚犯的死刑，4号囚犯考虑到这一点后，随之“觉醒”。]<br><br> 4、5号囚犯共同“觉醒”<br> 此情况很简单，大家同赴九泉。<br><br> 综合考虑后，1、2号囚犯存活机率最大</li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li>1、2号囚犯存活机率最大</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>爱因斯坦的问题</strong></p>
<ol>
<li><p><strong>爱因斯坦出了一道题，他说世界上有90％的人回答不出，看看你是否属于10％。</strong></p>
</li>
<li><p><strong>内容:<br> 　　1． 有5栋5种颜色的房子<br> 　　2． 每一位房子的主人国籍都不同<br> 　　3． 这五个人每人只喝一个牌子的饮料，只抽一个牌子的香烟，只养一种宠物<br> 　　4． 没有人有相同的宠物，抽相同牌子的烟，喝相同牌子的饮料<br> 　　已知条件：<br> 　　1． 英国人住在红房子里<br> 　　2． 瑞典人养了一条狗<br> 　　3． 丹麦人喝茶<br> 　　4． 绿房子在白房子的左边<br> 　　5． 绿房子主人喝咖啡<br> 　　6． 抽PALL MALL 烟的人养了一只鸟<br> 　　7． 黄房子主人抽DUNHILL烟<br> 　　8． 住在中间房子的人喝牛奶<br> 　　9． 挪威人住在第一间房子<br> 　　10． 抽混合烟的人住在养猫人的旁边<br> 　　11． 养马人住在抽DUNHILL烟人的旁边<br> 　　12． 抽BLUE MASTER烟的人喝啤酒<br> 　　13． 德国人抽PRINCE烟<br> 　　14． 挪威人住在蓝房子旁边<br> 　　15． 抽混合烟的人的邻居喝矿泉水<br> 　　问题：谁养鱼？</strong></p>
<ol>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><pre><code>黄        蓝         红            绿       白
 挪威      丹麦       英国          德国     瑞典
 猫        马         鸟            鱼       狗
 矿泉水    茶         牛奶          咖啡     啤酒
 DUNHILL   混合       PALL MALL     PRINCE   BLUE MASTER

 德国人养鱼。
</code></pre>
</li>
</ol>
</li>
<li><p><strong>试题拓展：</strong></p>
<ol>
<li>有五位小姐排成一列，所有的小姐姓不同、穿的衣服颜色不同、喝不同的饮料、养不同的宠物、吃不同的水果；<br>已知条件：<br>1、钱小姐穿红色衣服；<br>2 、翁小姐养了一只狗；<br>3、陈小姐喝茶；<br>4、穿绿衣服的站在穿白衣服的左边；<br>5、穿绿衣服的小姐喝咖啡；<br>6、吃西瓜的小姐养鸟；<br>7、穿黄衣服的小姐吃梨；<br>8、站在中间的小姐喝牛奶；<br>9、赵小姐站在最左边；<br>10、吃桔子的小姐站在养猫的旁边；<br>11、养鱼小姐旁边的那位吃梨；<br>12、吃苹果的小姐喝香槟；<br>13、江小姐吃香蕉；<br>14、赵小姐站在穿蓝衣服的小姐旁边；<br>15、喝开水的小姐站在吃桔子的小姐旁边；<br>请问哪位小姐养蛇？</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>盲人分袜</strong></p>
<ol>
<li><p><strong>有两位盲人，他们都各自买了两对黑袜和两对白袜，八对袜子的布质、大小完全相同，而每对袜子都有一张商标纸连着。两位盲人不小心将八对袜子混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？</strong></p>
<ol>
<li><p><strong>解题思路1：</strong></p>
<ol>
<li><strong>把八对袜子商标纸撕开一人一半平分，袜子不分左右。但是怎么穿呢？</strong></li>
</ol>
</li>
<li><p><strong>解题思路2：</strong></p>
<ol>
<li><strong>将八对袜子淋湿，在太阳下晒，先干的是黑袜，后干的是白袜。再平分。</strong></li>
</ol>
</li>
<li><p><strong>解题思路3：</strong></p>
<ol>
<li>在太阳下晒，热的是黑袜，稍凉的是白袜。再平分。</li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li>同上</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>国王与预言家</strong></p>
<ol>
<li><strong>在临上刑场前，国王对预言家说：“你不是很会预言吗？你怎么不能预言到你今天要被处死呢？我给你一个机会，你可以预言一下今天我将如何处死你。你如果预言对了，我就让你服毒死；否则，我就绞死你。”<br> 但是聪明的预言家的回答，使得国王无论如何也无法将他处死。<br> 请问，他是如何预言的？</strong><ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><strong>看似必死，其实不然。预言家如果预言：你不会处死我，国王肯定让他绞死，因为他预言错了。他如果预言：你会处死我，国王肯定让他服毒死，因为他预言对了。他想到这层后，便知道自己必死，他只能预言服毒死或绞死。如果预言服毒死，就预言对了，就会服毒而死。如果预言绞死，情况一，国王绞死他，预言正确，让他服毒死，矛盾；情况二，国王让他服毒死，预言错误，让他绞死，矛盾；于是国王无论如何也无法将他处死。</strong></li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>预言家预言：你将绞死我。</strong></li>
</ol>
</li>
<li><p><strong>试题拓展：</strong></p>
<ol>
<li><strong>在太平洋的一个小岛上生活着土人，他们不愿意被外人打扰，一天，一个探险家到了岛上，被土人抓住，土人的祭司告诉他，你临死前还可以有一个机会留下一句话，如果这句话是真的，你将被烧死，是假的，你将被五马分尸，可怜的探险家如何才能活下来？（答案：探险家说：我将被五马分尸。）</strong></li>
<li><strong>一个岔路口分别通向诚实国和说谎国。来了两个人，已知一个是诚实国的，另一个是说谎国的。诚实国永远说实话，说谎国永远说谎话。现在你要去说谎国，但不知道应该走哪条路，需要问这两个人。请问应该怎么问？（答案：应该问：你的国家怎么走?他肯定指向的是诚实国。）</strong></li>
<li><strong>从前，有一个国王，他手下有两个大臣，一个好，一个坏。坏大臣为了独自掌权，总想把好大臣害死。有一天他在国王面前讲了好大臣很多坏话。国王偏听偏信，决定第二天用抓阄的办法来处理好大臣。具体办法是：命令好大臣从盒子里任意抓一个阄，而盒里只有两个阄，一个写“生”，一个写“死”，抓到“生”就活，抓到“死”就死。<br> 　　当天夜里，坏大臣逼迫着做阄的人把两个阄都写成“死”字。这样，好大臣无论抓到哪个阄都得死。坏大臣走了以后，做阄的人就偷偷地给好大臣送了信，告诉他这一情况，请好大臣自己想办法。<br> 　　请问：好大臣在抓阄时，要想什么办法，才能免于处死呢？（请注意，逃走是不可能的）（答案：随便抓一个，吞到肚子里）</strong></li>
<li><strong>这是选自L?斯缪利安(爱丽丝漫游奇境记)中的一道益智趣题: 特威德勒弟弟与特威德勒哥哥站在他家右边的一棵树下咧开嘴笑着。爱丽丝见到他俩说:”要不是你们的绣花衣领不同，恐怕我分不清哪个是哥哥，哪个是弟弟呢。”<br> 　　一个兄弟答道:”你应当运用逻辑推理的方法。”说罢从口袋里掏出一张扑克牌，向爱丽丝扬了扬——那是一张方块皇后。他说道，”你看，这是一张红牌。红牌表明持牌的人是讲真话的，而黑牌表明持牌的人是讲假话的。现在，我兄弟的口袋里也有一张牌:不是红牌就是黑牌。他马上要说话了。如果他的牌是红的，他将要说真话;要是他的牌是黑的，他就要说假话。你的事儿就是判断一下是特威德勒弟弟呢，还是特威德勒哥哥呢？”<br> 　　正在这时，另一位兄弟开腔了:”我是特威德勒哥哥，我有一张黑牌。”<br> 　　请问，他是谁?<br />   （答案：如果说话的人讲的是真话，那他会是特威德勒哥哥，应持有一张黑牌，但他是决不可能既讲真话而又持黑牌的。因此，他必然在说假话，而这意味着他持有的必然是张黑牌。由于他讲的是假话，所以他决不会是持黑牌的特威德勒哥哥，而一定是持有黑牌的特威德勒弟弟。）</strong></li>
<li><strong>生死门问题。在你面前有两扇门, 其中一扇为生门, 另一则为死门。生门及死门都有一个人看守著, 而這两个人之中, 其中个只说真话, 另一个只说假话, 這两位守门人知道哪一扇门是生门, 哪一扇是死门, 而你则是不知道的, 同時, 你亦不知道哪一位是只说真话, 哪一位是只说假话, 更不知道哪位守哪扇门。<br> 请问有什么方法, 可以只请其中一位守门者一个问题, 就可以知道哪一扇是生门?</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>称球问题</p>
<ol>
<li><p><strong>12个球和一个天平，现知道只有一个和其它的重量不同，问怎样称才能用三次就找到那个球？（注意此题并未说明那个球的重量是轻是重，所以需要仔细考虑)</strong></p>
<ol>
<li><strong>此称法称三次就保证找出那个坏球，并知道它比标准球重还是轻。<br> 将十二个球编号为1-12。<br> 第一次，先将1-4号放在左边，5-8号放在右边。<br> 　　1.如果右重则坏球在1-8号。<br> 　　　　第二次将2-4号拿掉，将6-8号从右边移到左边，把9-11号放<br> 　　　　在右边。就是说，把1,6,7,8放在左边，5,9,10,11放在右边。<br> 　　　　　　1.如果右重则坏球在没有被触动的1,5号。如果是1号，<br> 　　　　　　　则它比标准球轻；如果是5号，则它比标准球重。<br> 　　　　　　　　第三次将1号放在左边，2号放在右边。<br> 　　　　　　　　　　1.如果右重则1号是坏球且比标准球轻；<br> 　　　　　　　　　　2.如果平衡则5号是坏球且比标准球重；<br> 　　　　　　　　　　3.这次不可能左重。<br> 　　　　　　2.如果平衡则坏球在被拿掉的2-4号，且比标准球轻。<br> 　　　　　　　　第三次将2号放在左边，3号放在右边。<br> 　　　　　　　　　　1.如果右重则2号是坏球且比标准球轻；<br> 　　　　　　　　　　2.如果平衡则4号是坏球且比标准球轻；<br> 　　　　　　　　　　3.如果左重则3号是坏球且比标准球轻。<br> 　　　　　　3.如果左重则坏球在拿到左边的6-8号，且比标准球重。<br> 　　　　　　　　第三次将6号放在左边，7号放在右边。<br> 　　　　　　　　　　1.如果右重则7号是坏球且比标准球重；<br> 　　　　　　　　　　2.如果平衡则8号是坏球且比标准球重；<br> 　　　　　　　　　　3.如果左重则6号是坏球且比标准球重。<br> 　　2.如果天平平衡，则坏球在9-12号。<br> 　　　　第二次将1-3号放在左边，9-11号放在右边。<br> 　　　　　　1.如果右重则坏球在9-11号且坏球较重。<br> 　　　　　　　　第三次将9号放在左边，10号放在右边。<br> 　　　　　　　　　　1.如果右重则10号是坏球且比标准球重；<br> 　　　　　　　　　　2.如果平衡则11号是坏球且比标准球重；<br> 　　　　　　　　　　3.如果左重则9号是坏球且比标准球重。<br> 　　　　　　2.如果平衡则坏球为12号。<br> 　　　　　　　　第三次将1号放在左边，12号放在右边。<br> 　　　　　　　　　　1.如果右重则12号是坏球且比标准球重；<br> 　　　　　　　　　　2.这次不可能平衡；<br> 　　　　　　　　　　3.如果左重则12号是坏球且比标准球轻。<br> 　　　　　　3.如果左重则坏球在9-11号且坏球较轻。<br> 　　　　　　　　第三次将9号放在左边，10号放在右边。<br> 　　　　　　　　　　1.如果右重则9号是坏球且比标准球轻；<br> 　　　　　　　　　　2.如果平衡则11号是坏球且比标准球轻；<br> 　　　　　　　　　　3.如果左重则10号是坏球且比标准球轻。<br> 　　3.如果左重则坏球在1-8号。<br> 　　　　第二次将2-4号拿掉，将6-8号从右边移到左边，把9-11号放<br> 　　　　在右边。就是说，把1,6,7,8放在左边，5,9,10,11放在右边。<br> 　　　　　　1.如果右重则坏球在拿到左边的6-8号，且比标准球轻。<br> 　　　　　　　　第三次将6号放在左边，7号放在右边。<br> 　　　　　　　　　　1.如果右重则6号是坏球且比标准球轻；<br> 　　　　　　　　　　2.如果平衡则8号是坏球且比标准球轻；<br> 　　　　　　　　　　3.如果左重则7号是坏球且比标准球轻。<br> 　　　　　　2.如果平衡则坏球在被拿掉的2-4号，且比标准球重。<br> 　　　　　　　　第三次将2号放在左边，3号放在右边。<br> 　　　　　　　　　　1.如果右重则3号是坏球且比标准球重；<br> 　　　　　　　　　　2.如果平衡则4号是坏球且比标准球重；<br> 　　　　　　　　　　3.如果左重则2号是坏球且比标准球重。<br> 　　　　　　3.如果左重则坏球在没有被触动的1,5号。如果是1号，<br> 　　　　　　　则它比标准球重；如果是5号，则它比标准球轻。<br> 　　　　　　　　第三次将1号放在左边，2号放在右边。<br> 　　　　　　　　　　1.这次不可能右重。<br> 　　　　　　　　　　2.如果平衡则5号是坏球且比标准球轻；<br> 　　　　　　　　　　3.如果左重则1号是坏球且比标准球重；</strong></li>
</ol>
</li>
</ol>
</li>
<li><p><strong>三个灯泡</strong></p>
<ol>
<li><p><strong>门外三个开关分别对应室内三个灯泡，线路良好，在门外控制开关时候不能看到室内灯的情况，现在只允许进门一次，确定开关和灯的对应关系？（这个也是微软面试题，我本人到认为这个是脑筋急转弯类型）</strong></p>
<ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><strong>如果有两个灯泡，只需打开一个灯，即可确定开关和灯的对应关系。现在有三个灯泡，必然要想其他办法。众所周知，灯泡打开一会儿会发热，从此入手即可解决问题。</strong></li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li>打开第一个开关10分钟，再关上，打开第二个开关，进屋。亮的灯由第二个开关控制，不亮的灯摸一摸，热的由第一个开关控制，另一个由第三个开关控制。</li>
</ol>
</li>
<li><p>试题拓展：</p>
<ol>
<li><strong>门外四个开关分别对应室内四个灯泡，线路良好，在门外控制开关时候不能看到室内灯的情况，现在只允许进门一次，确定开关和灯的对应关系？（答案：2个亮的1热1凉，2个灭的1热1凉）</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>黑帽子舞会</strong></p>
<ol>
<li><p><strong>一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其它人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什幺帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？</strong></p>
<ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li>设有x个黑帽子。<br> x&#x3D;1，则戴黑帽子的第一次就看到其他人都是白帽子，那么自己就肯定是黑帽子了。所以该打自己嘴巴。<br> 但第一次没人打，说明至少有两个黑帽子。<br> x&#x3D;2，第一次开灯后否没人打，说明黑帽不止一个，所以第二次如果有人只看到别人只有一顶黑帽子的话，就能判断自己头上是黑帽子，就该打嘴巴，但没人打，说明至少有3个黑帽。<br> x&#x3D;3,由于前两次没人打，所以至少三顶黑帽。第三次开灯后，有人打嘴巴，说明打嘴巴的人看到其他人只有两顶黑帽，所以能判断自己头上是黑帽。<br> 因此是三顶黑帽子。</li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>3个人戴着黑帽子。</strong></li>
</ol>
</li>
<li><p>试题拓展：</p>
<ol>
<li><strong>（据说这是某国外著名大学MBA入学考试题）<br> 一个村子里有50户人家,每户人家养一条狗,不幸的是村子里的有狗感染了疯狗病,现在要杀死疯狗。<br> 杀狗规则如下:<br> (1)必须确定是疯狗才能杀<br> (2)杀狗用猎枪,开枪杀狗人人都听的见,没聋子.<br> (3)只能观察其他人家的狗是否得了疯狗病,不能观察自己的狗是否有疯狗病<br> (4)只能杀自己家的狗,别人家的狗你就是知道有疯狗病也不能杀.<br> (5)任何观察到了其他人家的狗有疯狗病都不能告诉任何人.<br> (6)每人每天去观察一遍其他人家的狗是否疯狗<br> 现在现象是:第一天没有枪声,第二天没有枪声,第三天响起一片枪声.<br> 问:第三天杀了多少条疯狗?     （答案：3条疯狗。）</strong></li>
<li><strong>大女子主义村<br> 它发生在一个地点不明的愚昧的大女子主义村子里。<br> 在这个村子里，有50 对夫妇，每个女人在别人的丈夫对妻子不忠实时会立即知道，但从来不知道自己的丈夫如何。<br> 该村严格的大女子主义章程要求，如果一个女人能够证明她的丈夫不忠实，她必须在当天杀死他。<br> 假定女人们是赞同这一章程的、聪明的、能意识到别的妇女的聪明、并且很仁慈(即她们从不向那些丈夫不忠实的妇女通风报信)。<br> 假定在这个村子里发生了这样的事：所有这50个男人都不忠实，但没有哪一个女人能够证明她的丈夫的不忠实，以至这个村子能够快活而又小心翼翼地一如既往。<br> 有一天早晨，森林的远处有一位德高望重的女族长来拜访。她的诚实众所周知，她的话就像法律。她暗中警告说村子里至少有一个风流的丈夫。这个事实，根据她们已经知道的，只该有微不足道的后果，但是一旦这个事实成为公共知识，会发生什么？    （答案：第50天50个丈夫都被自己的女人杀死。）</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>蒙特门难题</strong></p>
<ol>
<li><strong>本智力题得名于一位美国电视游戏节目的主持人蒙特，他曾在多年之前主持一档档名为成交的节目。在其中的一个游戏中，Monty向竞猜者展示了三扇门。有一扇门之后是一辆小轿车。另两扇门之后是空房间。蒙特事先知道门后是什么，但您并不知道。<br> 游戏分为三步：<br> 1. 您选择一扇门。<br> 2. 蒙特将会打开剩余的两扇门中的一扇，展示一个空的房间。（他从不会打开那扇后面藏有汽车的。）<br> 3. 然后您可以选择是仍然选择在步骤1中选择的那扇门，还是选择去打开另一扇仍然关闭的。<br> 假定您选择了A门。然后蒙特打开了另两扇门中的一扇，假定为B门。现在您可以选择改选C门或者仍然坚持最初的选择，即A门。如果没有改变选择，那么可能会猜对也可能会猜错。另一方面，如果您改选C门，则还是既可能猜对也可能猜错。您会做出什么选择呢？在蒙特打开一扇门之后，是坚持最初的选择，还是改变前面已做的选择呢？为什么呢？<br /></strong><ol>
<li><p>第一种观点：改变选择（据说是正确答案）</p>
<ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><p><strong>理由1</strong></p>
<ol>
<li><strong>如果您选择A门，则猜中的机会是 1&#x2F;3，因为A门后可能有一辆汽车。B门之后有一辆汽车的机率也是 1&#x2F;3 ，并且C门之后有一辆汽车的机率还是 1&#x2F;3（由于必定有一辆车在某善门后，因此所有机率的总和应该为 1）。车在B门或C门之后的机率为2&#x2F;3。<br> 现在假定蒙特打开B门，展示这是一扇空门。 车在B门或C门之后的机率还是 2&#x2F;3，但我们知道在B门之后的机率为0，因为已经可以肯定那里没有任何东西。因此在C门之后的机率变为2&#x2F;3。机率的总和仍然为1。A门的机率为1&#x2F;3，B门的机率为0，C门的机率为2&#x2F;3。</strong></li>
</ol>
</li>
<li><p><strong>理由</strong>2</p>
<ol>
<li><strong>我们可以再通过实验来验证一下：<br> 假定有1000000 扇门。您从中选择一扇门来找那辆车。您正确的机率是百万分之一。车在其余的门后的机率是百万分之999999。 蒙特打开了999998 扇门来展示它们是空的。您最初的猜测正确的机率是1&#x2F;1000000,改变选择，您的猜测正确的机率是999999&#x2F;1000000。<br> 不妨和朋友玩一玩下面的游戏。使用三个纸杯盖住一辆小玩具汽车，或是其他什么东西。您们中的一个人应该作蒙特，隐藏车并将在另一个人做出选择之后揭起一个空纸杯。来上100次，再看一看结果如何。</strong></li>
</ol>
</li>
<li><p><strong>理由</strong>3</p>
<ol>
<li><strong>(1)首先，在游戏初始状态，设轿车在门X的后面，P(X)&#x3D; 1&#x2F;3<br> (2)设竞猜者选择了A门，然后Monty准备打开B门<br> (3)如果轿车在A门后，则Monty打开B门的概率为:<br> P(Monty打开B门|A)&#x3D; 1&#x2F;2<br> 如果轿车在B门后，则Monty打开B门的概率为:<br> P(Monty打开B门|B)&#x3D; 0<br> 如果轿车在C门后，则Monty打开B门的概率为:<br> P(Monty打开B门|C)&#x3D; 1<br> 则Monty打开B门的概率为：<br> P(Monty打开B门)&#x3D;P(A)P(Monty打开B门|A)<br> +P(B)P(Monty打开B门|B)<br> +P(C)P(Monty打开B门|C)<br> &#x3D;1&#x2F;6 + 0 + 1&#x2F;3<br> &#x3D;1&#x2F;2<br> (4)据Bayes定理，<br> P(A|Monty打开B门)&#x3D;P(A) * P(Monty打开B门|A)<br> &#x2F; P(Monty打开B门)<br> &#x3D;(1&#x2F;3 * 1&#x2F;2) &#x2F; (1&#x2F;2)<br> &#x3D;1&#x2F;3<br> P(C|Monty打开B门)&#x3D;P(C) * P(Monty打开B门|C)<br> &#x2F; P(Monty打开B门)<br> &#x3D;(1&#x2F;3 * 1) &#x2F; (1&#x2F;2)<br> &#x3D;2&#x2F;3</strong></li>
</ol>
</li>
</ol>
</li>
<li><p><strong>第二种观点：坚持最初选择</strong></p>
<ol>
<li><p>理由1</p>
<ol>
<li>如果您选择 A 门，则猜中的机会是 1&#x2F;3，现在假定蒙特打开 B 门，展示这是一扇空门, 车在 B 门之后的机率为 0，因为已经可以肯定那里没有任何东西。因此在A、C 门之后的机率变为 1&#x2F;2。机率的总和仍然为 1。<br> 机率都一样，为什么要改变选择呢？！</li>
</ol>
</li>
<li><p>理由2</p>
<ol>
<li><strong>我们不妨改变一下游戏：<br> Monty向竞猜者展示了三扇门，有一扇门之后是一辆小轿车。另两扇门之后是空房间。蒙特事先知道门后是什么，但竞猜者并不知道。竞猜者有三个人，但是不准选择同一扇门。<br> 游戏分为三步：<br> 1. 每人选择一扇门。<br> 2. 蒙特将会打开三扇门中的一扇，展示一个空的房间，淘汰一个人。（他从不会打开那扇后面藏有汽车的。）<br> 3. 然后剩余两人可以坚持最初选择，也可以改变选择。<br> 假设1号竞猜者选A门，2号竞猜者选B门，3号竞猜者选C门。蒙特打开B门，展示这是一扇空门，并淘汰2号竞猜者。假定改变选择是正确答案，机率由1&#x2F;3变为2&#x2F;3。于是1号竞猜者认为A门的机率为1&#x2F;3，C门的机率为2&#x2F;3；3号竞猜者认为C门的机率为1&#x2F;3，A门的机率为2&#x2F;3。产生矛盾，假定不成立。</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>三人住店</strong></p>
<ol>
<li><p><strong>有三个人去住旅馆，住三间房，每一间房$10元，于是他们一共付给老板$30，第二天，老板觉得三间房只需要$25元就够了于是叫小弟退回$5给三位客人，谁知小弟贪心,只退回每人$1，自己偷偷拿了$2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了$27，再加上小弟独吞了不$2，总共是$29。可是当初他们三个人一共付出$30那么还有$1呢？</strong></p>
<ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><strong>其实房客的确付了27元，但是30元的算法有问题，这里偷换了概念。10乘3等于30没有错；每人拿回1元等于每人出了9元也不错；老板得了25元，退回5元，总计30元没有错；客人付了30元，拿回3元得27元没有错；小弟拿5元给客人3元自己留2元也没有错；房客付了27元，老板25元小弟2元没有错；但是现在非要27加2得30，当然有错！聪明的你看出来了吧。</strong></li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>$27不应加$2，而应减；也不存在少$1。</strong></li>
</ol>
</li>
<li><p>这是个典型的偷梁换柱的题目。问题应为“服务员拿了2块钱”,是问者输入错误。  首先,我们应该弄清楚“他们每个人出了九块钱”是怎么回事：    三人交：10×3&#x3D; 30    老板收：30-5&#x3D; 25    每人给老板：25÷3&#x3D; 25&#x2F;3    每人被服务员拿：2÷3&#x3D; 2&#x2F;3    每人给老板和服务员的总额：25&#x2F;3+2&#x2F;3&#x3D; 9    每人给出10元，每人给老板和服务员的总额9元，所以应被找回1元。  其次，我们应该弄清楚为什么会出现“还有一块钱去哪里了”的现象：    三人给老板和服务员的总额：25+2&#x3D; 27（即“每个人出了九块钱”9×3&#x3D;27）     [Ps：这27包括服务员拿的2元了]    问：为什么会出现“还有一块钱去哪里了”的现象呢？    答：出题者 有意在 已经包含了“被服务员拿去的2元”的27元上，又加了一次“被服务员拿  去的2元”来麻痹大家，却没有加应该“找回的3元”。其实，我说“他们每个人出了九块钱，  服务员拿的两块钱包括在这三个九元里了”，你是不是就已经明白了呢？    也就是说，本来应该是：            （10×3-5）+2+3&#x3D;30    却被算作了：            （10×3-5）+2+2&#x3D;29<br> 所以那1块钱根本不存在</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>称量药丸</strong></p>
<ol>
<li><p><strong>你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的重量＋1。只称量一次，如何判断哪个罐子的药被污染了？</strong></p>
<ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li>** 1、先给四个罐子编号1、2、3、4。<br> 2、如果已知只有一个罐子被污染：则1号1个，2号拿2个，3号拿3个，4号拿4个，称一下，再减去15个药丸的标准重量。结果可能为1,2,3,4。<br> 若是1，就是1号罐；<br> 若是2，就是2号罐；<br> 若是3，就是3号罐；<br> 若是4，就是4号罐；<br> 3、如果四个罐子都可能被污染，也可能不被污染：则1号拿1个，2号拿2个，3号拿4个，4号拿8个，称一下，再减去15个药丸的标准重量。结果可能为0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15。<br> 若是0，四个罐子都没被污染；<br> 若是1，就是1号罐；<br> 若是2，就是2号罐；<br> 若是3，就是1、2号罐；<br> 若是4，就是3号罐；<br> 若是5，就是1、4号罐；<br> 若是6，就是2、3号罐；<br> 若是7，就是1、2、3号罐；<br> 若是8，就是4号罐；<br> 若是9，就是1、4号罐；<br> 若是10，就是2、4号罐；<br> 若是11，就是1、2、4号罐；<br> 若是12，就是2、4号罐；<br> 若是13，就是1、3、4号罐；<br> 若是14，就是2、3、4号罐；<br> 若是15，四个罐子全被污染。<br> （步骤3实际上已经包含步骤2。）**</li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>同上。</strong></li>
</ol>
</li>
<li><p><strong>试题拓展：</strong></p>
<ol>
<li><strong>有10瓶药丸，其中若干瓶内为超重药丸。普通药丸5g&#x2F;每粒，超重药丸6g&#x2F;每粒，每瓶药丸的数量相同。求：只用一架天平，只称一次，找出哪几瓶装有超重药丸。（答案：分别取出1、2、4、8、16、32、64、128、256、512粒）</strong></li>
<li><strong>有N瓶药丸，其中若干瓶内为超重药丸。普通药丸5g&#x2F;每粒，超重药丸6g&#x2F;每粒，每瓶药丸的数量相同。求：只用一架天平，只称一次，找出哪几瓶装有超重药丸。（答案：分别取出1、2、4、…、2^n粒）</strong></li>
<li><strong>10个箱子，每个箱子10个苹果，其中一个箱子的苹果是9两&#x2F;个，其他的都是1斤&#x2F;个。 要求利用一个秤，只秤一次，找出那个装9两&#x2F;个的箱子。（答案：编号，分别取出1、2、4、…、10个，秤，减，少n两就是n号）</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>表针重合</strong></p>
<ol>
<li><p><strong>在一天的24小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？</strong></p>
<ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><strong>很明显，1:05之后有一次，2:10之后有一次，3:15之后有一次，4:20之后有一次，5:25之后有一次，6:30之后有一次，7:35之后有一次，8:40之后有一次，9:45之后有一次，10:50之后有一次，12:00整有一次。24小时之中总共22次。<br> 而且，相邻两次重合之间所需时间相同，即12&#x2F;11小时。准确说都分别是0点，12&#x2F;11点，24&#x2F;11点，36&#x2F;11点，48&#x2F;11点，60&#x2F;11点，72&#x2F;11点，84&#x2F;11点，96&#x2F;11点，108&#x2F;11点，120&#x2F;11点，12点，144&#x2F;11点，156&#x2F;11点，168&#x2F;11点，180&#x2F;11点，192&#x2F;11点，204&#x2F;11点，216&#x2F;11点，228&#x2F;11点，240&#x2F;11点，252&#x2F;11点。<br> 有趣的是这11个点，正好是圆内接正11边形，其中一个顶点在12点处。</strong></li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>同上</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>奇怪的村庄</strong></p>
<ol>
<li><p><strong>某地有两个奇怪的村庄，张庄的人在星期一、三、五说谎，李村的人在星期二、四、六说谎。在其他日子他们说实话。一天，外地的王从明来到这里，见到两个人，分别向他们提出关于日期的题。两个人都说：”前天是我说谎的日子。”<br> 　　如果被问的两个人分别来自张庄和李村，那么这一天是星期几？</strong></p>
<ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><strong>列表如下：<br>    一    二    三    四    五    六    日<br> 张庄  假    真    假    真    假    真    真<br> 李村  真    假    真    假    真    假    真<br> 从这个表中应该不难看出，张庄的人只有在星期日、星期一那样说，李庄的人只有在星期一、星期二那样说，因此这一天是星期一</strong></li>
</ol>
</li>
<li><p><strong>参考答案：</strong></p>
<ol>
<li>这一天是星期一。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>爱瓦梯尔的学费</strong></p>
<ol>
<li><strong>古希腊有个著名的诡辩学者，叫普罗太哥拉丝。有一次，他收了一个很有才华的学生叫爱瓦梯尔，两人签了一份合同。普罗太哥拉丝向爱瓦梯尔传授法律知识，而爱瓦梯尔须分两次付清学费：第一次，是在开始授课的时侯，第二次，则在结业后爱瓦梯尔第一次出庭打官司赢了的时候。爱瓦梯尔交上第一次学费，便孜孜不倦地向老师学习法律，学习成绩十分出色。几年后他结业了，但是过了很长时间，总不交第二次的学费。<br> 　　普罗太哥拉丝等了再等，最后都等火了，要到法庭去告爱瓦梯尔，爱瓦梯尔却对普罗太哥拉丝说：“只要你到发庭去告我，我就可以不给你钱了，因为如果我官司打赢了，依照法庭的判决，我当然就不会把钱给输了的人；如果我官司打败了，依照我们的合同，由于第一次出庭败诉，我也不能把钱给你。因此，不论我在这场官司中打输还是打赢，我不可能把钱给你。你还是不要起诉吧。”<br> 　　普罗太哥拉丝听后却有自己的打算，他说：“只要我和你一打官司你就一定要把第二次学费付给我。因为，如果我这次官司打胜了，依照法律的判决，你理所当然地要付学费给我；如果我官司打败了，你当然也要付学费给我，我们当初的合同上就是这样写的。所以，不论怎样你总要向我交第二次的学费。”<br> 　　于是两个人都带着必胜的信心走进了法庭。<br> 　　法官听了他们的诉讼，看过他俩的合同，思索了一会，便当众宣读了他的判决……<br> 　　你知道这位法官怎样判决才能使爱瓦梯尔既交上了学费又心服口服吗？</strong></li>
</ol>
</li>
<li><p><strong>三筐水果</strong></p>
<ol>
<li><p><strong>有三筐水果，一筐装的全是苹果，第二筐装的全是橘子，第三筐是橘子与苹果混在一起。筐上的标签都是骗人的，（比如，如果标签写的是橘子，那么可以肯定筐里不会只有橘子，可能还有苹果）你的任务是拿出其中一筐，从里面只拿一只水果，然后正确写出三筐水果的标签。</strong></p>
<ol>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><strong>假设正确的是苹果A,橘子B,苹果和橘子C<br> 分两种情况：<br> （1）拿出一个水果恰是全是苹果或全是橘子<br> 如果标签B装的是A，那么标签是A的一定是C，如果A标签装的是B，则C装的是C，不符合题设。<br> 所以，在这三筐水果中拿出一个水果就能分辨出这三筐水果各装得是什么。<br> （2）拿出一个水果恰是第三筐是苹果和橘子C,则不能确定。因为不知道是不是第三筐C。</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>两个圆环</strong></p>
<ol>
<li><p><strong>两个圆环，半径分别是1和2，小圆在大圆内部绕大圆圆周一周，问小圆自身转了几周？如果在大圆的外部，小圆自身转几周呢？</strong></p>
<ol>
<li><p><strong>参考答案：</strong></p>
<ol>
<li><strong>从标着“混合”标签的筐里拿一只水果，就可以知道另外两筐装的是什么水果了。如果拿出的是苹果，标着“橘子”标签装的是混合水果，标着“苹果”标签装的是橘子。如果拿出的是橘子，标着“苹果”标签装的是混合水果，标着“橘子”标签装的是苹果。</strong></li>
</ol>
</li>
<li><p>试题拓展：</p>
<ol>
<li><strong>一天，金星大酒店里来了3组客人：两个男人，两个女人，还有一对夫妇，他（她）们开了3个房间，门口分别挂上了带有♂♂、♀♀、♂♀标记的牌子，以免进错房间。但是当日的粗心的服务生却把牌子给挂乱了位置，弄得房间里的人和牌子全都对不上号，在这种情况下，据说只要敲一个房间的门，听到里边的两人其中的一声回答，就能全部搞清楚3个房间里的人员情况。<br> 　　请问，要敲的该是挂有什么牌子的房间？为什么？<br>（答案是应该敲♂♀房间。注意这句话“房间里的人和牌子全都对不上号”，♂♀房间里当然不可能是一对夫妇。如果敲门以后听到里面是男人的声音，那么♀♀房间里面必然是一对夫妇、而♂♂房间里则是两个女人；同理，如果敲门以后听到里面是女人的声音，那么♂♂房间里面必然是一对夫妇、而♀♀房间里则是两个男人。答案：♂♀标记的房间）</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>((20211206233413-85ak71h “鲍西娅的肖像”))</strong></p>
</li>
<li><p><strong>推断生日</strong></p>
<ol>
<li><p>**月薪5万，微软中国研究院最新面试题 **</p>
</li>
<li><p>**小明和小强都是张老师的学生，张老师的生日是M月N日，2人都知道张老师的生日是下列10组中的一天，张老师把M值告诉了小明，把N值告诉了小强，张老师问他们知道他的生日是那一天吗？<br>   3月4日 3月5日 3月8日<br>   6月4日 6月7日<br>   9月1日 9月5日<br>   12月1日 12月2日 12月8日<br>   小明说：如果我不知道的话，小强肯定也不知道<br>   小强说：本来我也不知道，但是现在我知道了<br>   小明说：哦，那我也知道了<br>   请根据以上对话推断出张老师的生日是哪一天 **</p>
</li>
<li><p>** 如果您看过智力题2(猜牌问题)的话，此题立马可解！请参看猜牌问题。**</p>
</li>
<li><p><strong>解题思路：</strong></p>
<ol>
<li><p>**此题刚开始感觉无从下手，不知道该如何是好。但是这类题目，一般都是看你能不能利用其中的规律，或者打破常规的奇思妙想。什么情况下，一个人能根据他知道一个数字推出别人的生日呢？在这一题中，小明和小强知道的信息只有：生日可能的10个值，老师告诉他们的一个数字（月或者日）还有他们两个之间的对话。</p>
<p> 首先是小明先说话，他说他不知道。他知道的可能性也确实很小，因为无论老师高诉他是哪个月，都有2种或者3种可能性让他选择，除非他还知道其他的信息，不然他肯定不知道。不过他不仅说他不知道，而且还说“如果他不知道的话，小强肯定也不知道”。那么小强什么情况下肯定不知道呢？那就是和小明一样，老师告诉他的那个日对应至少2个月份，除非他还知道其他信息，那他肯定不能确定最终生日的。但是仔细观察后，我们可以发现：如果老师告诉小强，是7或者2的话，那么他就可以知道老师的生日了。因为7和2对应的月是唯一的。所以从第一句话可以知道：N不会为7和2，M也不会为6和12（后半句要想清楚了）。</p>
<p> 那现在的可能值就是：<br> 3月4日 3月5日 3月8日<br> 9月1日 9月5日<br> 现在小强说他知道了。那N就不可能为5了，因为M就有3和9两种可能。</p>
<p> 那现在的可能值就是：<br> 3月4日 3月8日<br> 9月1日<br> 现在小明也说他也知道了。那M就肯定为9了。因为M为3的为话，N就有4和8两种可能了。</p>
<p> 所以老师的生日是：9月1日。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>((20211206233658-v6ql4gr “遗嘱分牛”))</strong></p>
</li>
<li><p><strong>((20211206233739-e96eoz8 “帽子的颜色”))</strong></p>
</li>
<li><p><strong>土耳其商人和帽子</strong></p>
<ol>
<li><strong>许多著名的科学家常常喜欢出一些有趣的题目，来考一考别人的机敏和逻辑推理能力。伟大的物理学家爱因斯坦就曾经出过这样一道题:《土耳其商人和帽子的故事》。<br>   有一个土耳其商人，想找一个助手协助他经商。但是，他要的这个助手必须十分聪明才行。消息传出的三天后，有A、B两个人前来联系。<br>   这个商人为了试一试A、B两个人中哪一个聪明一些，就把他们带进一间伸手不见五指的漆黑的房子里。商人打开电灯说：”这张桌子上有五顶帽子，两顶是红色的，三顶是黑色的。现在，我把灯关掉，并把帽子摆的位置搞乱，然后，我们三人每人摸一顶帽子戴在头上。当我把灯开亮时，请你们尽快地说出自己头上戴的帽子是什么颜色的。” 说完之后，商人就把电灯关掉了，然后，三个人都摸了一顶帽子 戴在头上;同时，商人把余下的两顶帽子藏了起来。<br>   待这一切做完之后，商人把电灯重新开亮。这时候，那两个人看到商人头上戴的是一顶红色的帽子。<br>   过了一会儿，A喊道:”我戴的是黑帽子。” A是如何推理的?</strong></li>
</ol>
</li>
<li><p><strong>天堂里的游戏</strong></p>
<ol>
<li><strong>有个人死后来到天堂，圣彼得领着他在天堂各处参观。他们来到高墙下，圣彼得说：”嘘–轻点。”说完，他悄悄从旁边搬来一张长梯子。圣彼得先爬上去，然后招手让那个人也爬上去。他们站在梯子的顶端向里面张望着。原来，这 是一块被墙围起来的草地。草地的正中，坐着七个少年。”他们在干什么?”那个人问。圣彼得说:”如果不是早逝，”他们都是无与伦比的天才。到了天堂，他们志同道合，天天聚在一起玩智力游戏。今天，他们大概在猜 帽子吧。”<br> 六个少年A、B、C、D、E、F按六边形围坐着。另一个少年G则用毛巾蒙着眼睛坐在当中。有人往每人头上戴一顶帽子，其中四顶白帽子，三顶黑帽子。由于G挡住了视线，六个少年都看不见自己正对面的人戴的是 什么颜色的帽子。<br> 现在，让A、B、C、D、E、F猜自己头上戴的帽子的颜色。智力游戏一开始，六个少年陷入沉思，一时都猜不出来。这时，坐在当中的G说:”我猜到了，我戴的是白帽子。”<br> G是如何推理的?</strong></li>
</ol>
</li>
<li><p><strong>六张纸币</strong></p>
<ol>
<li><strong>有3个美国孩子，他们摸了摸衣兜，把兜中的钱全部掏出来，共是320美元，其中100美元的两张，50美元的两张，10美元的两张。据了解每个孩子所带的纸币没有一个是相同的。而且，没带100美元纸币的孩子也没带10美元的纸币，没带50美元纸币的孩子也没带100美元的纸币。<br> 　　你能不能弄清楚，3个孩子原来各自带了多少和什么样的纸币？</strong></li>
</ol>
</li>
<li><p><strong>11个教徒</strong></p>
<ol>
<li><strong>有一次，一艘船在海上遇到风暴。为了减轻船的重量，摆在25名乘客面前的选择是把一部分人抛到海里。这样，船和剩下的人也许还能得救。谁也不愿意自动跳入海中。乘客里有11个教徒，其中一个想出了一个主意。他让所有的25人坐成一圈，然后依次报数“1、2、3”，规定报到“3”的人就被抛到海里。最后报数的结果有14人被抛下海。剩下的是这11个教徒。那么，他是如何安排这些剩余者的位置的？</strong></li>
</ol>
</li>
<li><p><strong>((20211206233932-f4s56rk “计算年龄”))</strong></p>
</li>
<li><p><strong>飞行距离</strong></p>
<ol>
<li><em><em>有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以每小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以30公里每小时的速度和两辆火车同时启动，从洛杉矶出发，碰到另一辆车后返回，依次在两辆火车来回飞行，直到两辆火车相遇，请问，这只小鸟飞行了多长距离？<br> 解题思路：<br> 纽约到洛杉矶的路程设为s，因为鸟是不停飞，车相遇的时间就是鸟飞的时间，那么鸟飞的距离则是：[s&#x2F;(20+15)]</em> 30&#x3D;S*6&#x2F;7。<br> 即鸟飞的距离是纽约到洛杉矶路程的6&#x2F;7。</em></li>
</ol>
</li>
<li><p>猜数问题</p>
<ol>
<li><strong>一个教授逻辑学的教授，有三个学生，而且三个学生均非常聪明！一天教授给他们出了一个题，教授在每个人脑门上贴了一张纸条并告诉他们，每个人的纸条上都写了一个正整数，且某两个数的和等于第三个！（每个人可以看见另两个数，但看不见自己的）<br> 教授问第一个学生：你能猜出自己的数吗？回答：不能；<br> 问第二个，不能；<br> 第三个，不能；<br> 再问第一个，不能；<br> 第二个，不能；<br> 第三个：我猜出来了，144！<br> 教授很满意的笑了。请问您能猜出另外两个人的数吗？ 请说出理由！</strong></li>
</ol>
</li>
<li><p><strong>猴子搬香蕉</strong></p>
<ol>
<li><strong>一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。<br> 提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。</strong></li>
</ol>
</li>
<li><p><strong>最后剩下谁</strong></p>
<ol>
<li><strong>1～50 号运动员按顺序排成一排。教练下令：“单数运动员出列！”剩下的运动员重新排队编号。教练又下令：“单数运动员出列！”如此下去，最后只剩下一个人，他是几号运动员？如果教练下的令是“双数运动员出列！”最后剩下的又是谁？</strong></li>
</ol>
</li>
<li><p><strong>水平思考法</strong></p>
<ol>
<li><strong>有一家人决定搬进城里，于是去找房子。<br>   全家三口，夫妻两个和一个5岁的孩子。他们跑了一天，直到傍晚，才好不容易看到一张公寓出租的广告。他们赶紧跑去，房子出乎意料的好。于是，就前去敲门询问。这时，温和的房东出来，对这三位客人从上到下地打量了一番。<br>   丈夫豉起勇气问道：“这房屋出租吗?”<br>   房东遗憾地说：“啊，实在对不起，我们公寓不招有孩子的住户。”<br>   丈夫和妻子听了，一时不知如何是好，于是，他们默默地走开了。那5岁的孩子，把事情的经过从头至尾都看在眼里。那可爱的心灵在想：真的就没办法了?他那红叶般的小手，又去敲房东的大门。这时，丈夫和妻子已走出5米来远，都回头望着。门开了，房东又出来了。<br>   这孩子精神抖擞地说“……”<br>   房东听了之后，高声笑了起来，决定把房子租给他们住。<br>   问：这位5岁的小孩子说了什么话，终于说服了房东?</strong></li>
</ol>
</li>
<li><p><strong>细菌分裂</strong></p>
<ol>
<li><strong>有一个细菌，1分钟分裂为2个，再过1分钟，又分别分裂为2 个，总共分裂为4个。这样，一个细菌分裂成满满一瓶需要1个小时。同样的细菌，如果从2个开始分裂，分裂成一瓶需要几分钟。</strong></li>
</ol>
</li>
<li><p><strong>被困小岛</strong></p>
<ol>
<li><strong>加尔各答的近郊有一条世界著名的河流–恒河。河的中心有一个流沙堆积起来的小岛，岛上有一座古老的桥与河岸相连，可是这座桥已经破烂不堪，很少有人走了。<br>   但有一个人在散步时，由桥上走到小岛上去了。在返回时，刚走了两三步，桥就发出嘎嘎的响声，好像就要断似的，他只好又返回沙岛。这个人不会游泳，四处呼叫也无人理会。他只好呆在这个岛上，搜肠刮肚地想办法，竟在岛上困了十天，到第十一天，他才过了此桥回到河岸。你说这怎么回事?</strong></li>
</ol>
</li>
<li><p><strong>芭蕾舞演员的影像</strong></p>
<ol>
<li><strong>当您面向镜子照看时，映出的常常不见得都是您的真实容貌。一人站在两块相对排放着的立镜中间，就会照出一连串很多的影像。<br>   假设有一间小屋，屋内上下、左右、前后都铺满了无缝隙的镜子，请问:当有个芭蕾舞演员走进这间小屋时，她能看到什么样的影象呢?</strong></li>
<li>((20211206234426-z8l9sxu “其他问题”))</li>
</ol>
</li>
<li><p><a href="https://blog.csdn.net/baidu_14854543/article/details/40820015">软件测试常见的智力题_激情砍大树-CSDN博客_软件测试智力题</a></p>
 <br /></li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
        <category>999_面试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>其他逻辑性问题</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/04_01_%E5%85%B6%E4%BB%96%E9%80%BB%E8%BE%91%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>【1】假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水。<br>【2】周雯的妈妈是豫林水泥厂的化验员。 一天，周雯来到化验室做作业。做完后想出去玩。 “等等，妈妈还要考你一个题目，”她接着说，”你看这6只做化验用的玻璃杯，前面3只盛满了水，后面3只是空的。你 能只移动1只玻璃杯，就便盛满水的杯子和空杯子间隔起来 吗?” 爱动脑筋的周雯，是学校里有名的”小机灵”，她只想了一会儿就做到了。 请你想想看，”小机灵”是怎样做的?<br>【3】三个小伙子同时爱上了一个姑娘，为了决定他们谁能娶这个姑娘，他们决定用手枪进行一次决斗。小李的命中率是30％，小黄比他好些，命中率是50％，最出色的枪手是小林，他从不失误，命中率是100％。由于这个显而易见的事实，为公平起见，他们决定按这样的顺序：小李先开枪，小黄第二，小林最后。然后这样循环，直到他们只剩下一个人。那么这三个人中谁活下来的机会最大呢？他们都应该采取什么样的策略？</p>
<p>【4】一间囚房里关押着两个犯人。每天监狱都会为这间囚房提供一罐汤，让这两个犯人自己来分。起初，这两个人经常会发生争执，因为他们总是有人认为对方的汤比自己的多。后来他们找到了一个两全其美的办法：一个人分汤，让另一个人先选。于是争端就这么解决了。可是，现在这间囚房里又加进来一个新犯人，现在是三个人来分汤。必须寻找一个新的方法来维持他们之间的和平。该怎么办呢？<br>按：心理问题，不是逻辑问题<br>【5】在一张长方形的桌面上放了n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖<br>【6】一个球、一把长度大约是球的直径2&#x2F;3长度的直尺.你怎样测出球的半径？方法很多，看看谁的比较巧妙<br>【7】五个大小相同的一元人民币硬币。要求两两相接触，应该怎么摆？</p>
<p>【8】猜牌问题<br>S先生、P先生、Q先生他们知道桌子的抽屉里有16张扑克牌：红桃A、Q、4 黑桃J、8、4、2、7、3 草花K、Q、5、4、6 方块A、5。约翰教授从这16张牌中挑出一张牌来，并把这张牌的点数告诉 P先生，把这张牌的花色告诉Q先生。这时，约翰教授问P先生和Q 先生：你们能从已知的点数或花色中推知这张牌是什么牌吗？ 于是，S先生听到如下的对话：P先生：我不知道这张牌。<br>Q先生：我知道你不知道这张牌。<br>P先生：现在我知道这张牌了。<br>Q先生：我也知道了。<br>听罢以上的对话，S先生想了一想之后，就正确地推出这张牌是什么牌。<br>请问：这张牌是什么牌？<br>【9】一个教授逻辑学的教授，有三个学生，而且三个学生均非常聪明！<br>一天教授给他们出了一个题，教授在每个人脑门上贴了一张纸条并告诉他们，每个人的纸条上都写了一个正整数，且某两个数的和等于第三个！（每个人可以看见另两个数，但看不见自己的）<br>教授问第一个学生：你能猜出自己的数吗？回答：不能，问第二个，不能，第三个，不能，再问第一个，不能，第二个，不能，第三个：我猜出来了，是144！教授很满意的笑了。请问您能猜出另外两个人的数吗？<br>【10】某城市发生了一起汽车撞人逃跑事件<br>该城市只有两种颜色的车,蓝色15% 绿色85%<br>事发时有一个人在现场看见了<br>他指证是蓝车<br>但是根据专家在现场分析,当时那种条件能看正确的可能性是80%<br>那么,肇事的车是蓝车的概率到底是多少?<br>【11】有一人有240公斤水，他想运往干旱地区赚钱。他每次最多携带60公斤，并且每前进一公里须耗水1公斤（均匀耗水）。假设水的价格在出发地为0，以后，与运输路程成正比，（即在10公里处为10元&#x2F;公斤，在20公里处为20元&#x2F;公斤……），又假设他必须安全返回，请问，他最多可赚多少钱？<br>【12】现在共有100匹马跟100块石头，马分3种，大型马；中型马跟小型马。其中一匹大马一次可以驮3块石头，中型马可以驮2块，而小型马2头可以驮一块石头。问需要多少匹大马，中型马跟小型马？（问题的关键是刚好必须是用完100匹马）<br>【13】1&#x3D;5 2&#x3D;15 3&#x3D;215 4&#x3D;2145 那么5&#x3D;?<br>【14】有2n个人排队进电影院，票价是50美分。在这2n个人当中，其中n个人只有50美分，另外n个人有1美元（纸票子）。愚蠢的电影院开始卖票时1分钱也没有。<br>问： 有多少种排队方法 使得 每当一个拥有1美元买票时，电影院都有50美分找钱<br>注：<br>1美元&#x3D;100美分<br>拥有1美元的人，拥有的是纸币，没法破成2个50美分<br>【15】一个人花8块钱买了一只鸡，9块钱卖掉了，然后他觉得不划算，花10块钱又买回来了，11块卖给另外一个人。问他赚了多少?<br>【16】有一种体育竞赛共含M个项目，有运动员A，B，C参加，在每一项目中，第一,第二,第三名分别的X，Y，Z分，其中X,Y,Z为正整数且X&gt;Y&gt;Z。最后A得22分，B与C均得9分，B在百米赛中取得第一。求M的值，并问在跳高中谁得第二名。</p>
<p>【17】前提：<br>1 有五栋五种颜色的房子<br>2 每一位房子的主人国籍都不同<br>3 这五个人每人只喝一种饮料，只抽一种牌子的香烟，只养一种宠物<br>4 没有人有相同的宠物，抽相同牌子的香烟，喝相同的饮料<br>提示：<br>１　 英国人住在红房子里<br>２　 瑞典人养了一条狗<br>３　 丹麦人喝茶<br>４　 绿房子在白房子左边<br>５　 绿房子主人喝咖啡<br>６　 抽ＰＡＬＬ　ＭＡＬＬ烟的人养了一只鸟<br>７　 黄房子主人抽ＤＵＮＨＩＬＬ烟<br>８　 住在中间那间房子的人喝牛奶<br>９　 挪威人住第一间房子<br>１０　抽混合烟的人住在养猫人的旁边<br>１１　养马人住在抽ＤＵＮＨＩＬＬ烟的人旁边<br>１２　抽ＢＬＵＥ　ＭＡＳＴＥＲ烟的人喝啤酒<br>１３　德国人抽ＰＲＩＮＣＥ烟<br>１４　挪威人住在蓝房子旁边<br>１５　抽混合烟的人的邻居喝矿泉水<br>问题是：谁养鱼？？？<br>【18】5个人来自不同地方，住不同房子，养不同动物，吸不同牌子香烟，喝不同饮料，喜欢不同食物。根据以下线索确定谁是养猫的人。<br>1． 红房子在蓝房子的右边，白房子的左边（不一定紧邻）<br>2． 黄房子的主人来自香港，而且他的房子不在最左边。<br>3． 爱吃比萨的人住在爱喝矿泉水的人的隔壁。<br>4． 来自北京的人爱喝茅台，住在来自上海的人的隔壁。<br>5． 吸希尔顿香烟的人住在养马人的右边隔壁。<br>6． 爱喝啤酒的人也爱吃鸡。<br>7． 绿房子的人养狗。<br>8． 爱吃面条的人住在养蛇人的隔壁。<br>9． 来自天津的人的邻居（紧邻）一个爱吃牛肉，另一个来自成都。<br>10．养鱼的人住在最右边的房子里。<br>11．吸万宝路香烟的人住在吸希尔顿香烟的人和吸“555”香烟的人的中间（紧邻）<br>12．红房子的人爱喝茶。<br>13．爱喝葡萄酒的人住在爱吃豆腐的人的右边隔壁。<br>14．吸红塔山香烟的人既不住在吸健牌香烟的人的隔壁，也不与来自上海的人相邻。<br>15．来自上海的人住在左数第二间房子里。<br>16．爱喝矿泉水的人住在最中间的房子里。<br>17．爱吃面条的人也爱喝葡萄酒。<br>18．吸“555”香烟的人比吸希尔顿香烟的人住的靠右<br>【19】斗地主附残局<br>地主手中牌2、K、Q、J、10、9、8、8、6、6、5、5、3、3、3、3、7、7、7、7<br>长工甲手中牌大王、小王、2、A、K、Q、J、10、Q、J、10、9、8、5、5、4、4<br>长工乙手中牌2、2、A、A、A、K、K、Q、J、10、9、9、8、6、6、4、4<br>三家都是明手，互知底牌。要求是：在三家都不打错牌的情况下，地主必须要么输要么赢。<br>问：哪方会赢？<br>【20】一楼到十楼的每层电梯门口都放着一颗钻石，钻石大小不一。你乘坐电梯从一楼到十楼，每层楼电梯门都会打开一次，只能拿一次钻石，问怎样才能拿到最大的一颗？<br>【21】U2合唱团在17分钟内得赶到演唱会场，途中必需跨过一座桥，四个人从桥的同一端出发，你得帮助他们到达另一端，天色很暗，而他们只有一只手电筒。一次同时最多可以有两人一起过桥，而过桥的时候必须持有手电筒，所以就得有人把手电筒带来带去，来回桥两端。手电筒是不能用丢的方式来传递的。四个人的步行速度各不同，若两人同行则以较慢者的速度为准。Bono需花1分钟过桥，Edge需花2分钟过桥，Adam需花5分钟过桥，Larry需花10分钟过桥。他们要如何在17分钟内过桥呢？<br>【22】一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率<br>（假定生男生女的概率一样）<br>【23】为什么下水道的盖子是圆的？<br>【24】有7克、2克砝码各一个，天平一只，如何只用这些物品三次将140克的盐分成50、90克各一份？<br>【25】芯片测试：有2k块芯片，已知好芯片比坏芯片多．请设计算法从其中找出一片<br>好芯片，说明你所用的比较次数上限．<br>　其中：好芯片和其它芯片比较时，能正确给出另一块芯片是好还是坏．<br>坏芯片和其它芯片比较时，会随机的给出好或是坏。<br>【26】话说有十二个鸡蛋，有一个是坏的（重量与其余鸡蛋不同），现要求用天平称三次，称出哪个鸡蛋是坏的！<br>【27】100个人回答五道试题，有81人答对第一题，91人答对第二题，85人答对第三题，79人答对第四题，74人答对第五题，答对三道题或三道题以上的人算及格， 那么，在这100人中，至少有（ ）人及格。<br>【28】陈奕迅有首歌叫十年<br>吕珊有首歌叫3650夜<br>那现在问,十年可能有多少天?<br> 【29】<br>  1<br>　　1 1<br>　　2 1<br>　　1 2 1 1<br>　　1 1 1 2 2 1<br>　　下一行是什么？<br>【30】烧一根不均匀的绳要用一个小时，如何用它来判断半个小时？<br>烧一根不均匀的绳,从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子,问如何用烧绳的方法来计时一个小时十五分钟呢? （微软的笔试题）<br>【31】共有三类药，分别重1g,2g,3g，放到若干个瓶子中，现在能确定每个瓶子中只有其中一种药，且每瓶中的药片足够多，能只称一次就知道各个瓶子中都是盛的哪类药吗？<br>如果有4类药呢？5类呢？N类呢(N可数)？<br>如果是共有m个瓶子盛着n类药呢(m，n为正整数，药的质量各不相同但各种药的质量已知)？你能只称一次就知道每瓶的药是什么吗？<br>注：当然是有代价的，称过的药我们就不用了<br>【32】假设在桌上有三个密封的盒，一个盒中有2枚银币(1银币&#x3D;10便士)，一个盒中有2枚镍币(1镍币&#x3D;5便士)，还有一个盒中有1枚银币和1枚镍币。这些盒子被标上10便士、15便士和20便士，但每个标签都是错误的。允许你从一个盒中拿出1枚硬币放在盒前，看到这枚硬币，你能否说出每个盒内装的东西呢？<br>【33】有一个大西瓜,用水果刀平整地切,总共切9刀,最多能切成多少份,最少能切成多少份?<br>主要是过程，结果并不是最重要的<br>【34】一个巨大的圆形水池，周围布满了老鼠洞。猫追老鼠到水池边，老鼠未来得及进洞就掉入水池里。猫继续沿水池边缘企图捉住老鼠（猫不入水）。已知V猫&#x3D;4V鼠。问老鼠是否有办法摆脱猫的追逐？<br>【35】有三个桶，两个大的可装8斤的水，一个小的可装3斤的水，现在有16斤水装满了两大桶就是8斤的桶，小桶空着，如何把这16斤水分给4个人，每人4斤。没有其他任何工具，4人自备容器，分出去的水不可再要回来。<br>【36】从前有一位老钟表匠，为一个教堂装一只大钟。他年老眼花，把长短针装配错了，短针走的速度反而是长针的12倍。装配的时候是上午6点，他把短针指在“6 ”上，长针指在“12”上。老钟表匠装好就回家去了。人们看这钟一会儿7点，过了不一会儿就8点了，都很奇怪，立刻去找老钟表匠。等老钟表匠赶到，已经是下午7点多钟。他掏出怀表来一对，钟准确无误，疑心人们有意捉弄他，一生气就回去了。这钟还是8点、9点地跑，人们再去找钟表匠。老钟表匠第二天早晨8点多赶来用表一对，仍旧准确无误。 请你想一想，老钟表匠第一次对表的时候是7点几分？第二次对表又是8点几分？<br>【37】今有2匹马、3头牛和4只羊，它们各自的总价都不满10000文钱（古时的货币单位）。如果2匹马加上1头牛，或者3 头牛加上1只羊，或者4只羊加上1匹马，那么它们各自的总价都正好是10000文钱了。问：马、牛、羊的单价各是多少文钱？<br>【38】一天，harlan的店里来了一位顾客，挑了25元的货，顾客拿出100元，harlan没零钱找不开，就到隔壁飞白的店里把这100元换成零钱，回来给顾客找了75元零钱。过一会，飞白来找harlan，说刚才的是假钱，harlan马上给飞白换了张真钱，问harlan赔了多少钱？<br>【39】猴子爬绳<br>　　这道力学怪题乍看非常简单，可是据说它却使刘易斯．卡罗尔感到困惑。至于这道<br>怪题是否由这位因《爱丽丝漫游奇境记》而闻名的牛津大学数学专家提出来的，那就不<br>清楚了。总之，在一个不走运的时刻，他就下述问题征询人们的意见:<br>　　一根绳子穿过无摩擦力的滑轮，在其一端悬挂着一只10磅重的砝码，绳子的另一端<br>有只猴子，同砝码正好取得平衡。当猴子开始向上爬时，砝码将如何动作呢?<br>　　“真奇怪，”卡罗尔写道，”许多优秀的数学家给出了截然不同的答案。普赖斯认为砝<br>码将向上升，而且速度越来越快。克利夫顿(还有哈考特)则认为，砝码将以与猴子一样<br>的速度向上升起，然而桑普森却说，砝码将会向下降!”<br>　　一位杰出的机械工程师说”这不会比苍蝇在绳子上爬更起作用”，而一位科学家却认<br>为”砝码的上升或下降将取决于猴子 吃苹果速度的倒数”，然而还得从中求出猴子尾巴的<br>平方根。严肃地说，这道题目非常有趣，值得认真推敲。它很能说明趣题与力学问题之<br>间的紧密联系。<br>【40】两个空心球，大小及重量相同，但材料不同。一个是金，一个是铅。空心球表面图有相同颜色的油漆。现在要求在不破坏表面油漆的条件下用简易方法指出哪个是金的，哪个是铅的。<br>【41】有23枚硬币在桌上，10枚正面朝上。假设别人蒙住你的眼睛，而你的手又摸不出硬币的<br>反正面。让你用最好的方法把这些硬币分成两堆，每堆正面朝上的硬币个数相同。<br>【42】三个村庄A、B、C和三个城镇A、B、C坐落在如图所示的环形山内。<br>由于历史原因，只有同名的村与镇之间才有来往。为方便交通，他们<br>准备修铁路。问题是：如何在这个环形山内修三条铁路连通A村与A镇，<br>B村与B镇，C村与C镇。而这些铁路相互不能相交。（挖山洞、修立交<br>桥都不算，绝对是平面问题）。想出答案再想想这个题说明什么问题。<br>【43】屋里三盏灯,屋外三个开关,一个开关仅控制一盏灯,屋外看不到屋里<br>怎样只进屋一次,就知道哪个开关控制哪盏灯?<br>四盏呢~<br>【44】2+7-2+7全部有火柴根组成，移动其中任何一根，答案要求为30<br>说明：因为书写问题作如下解释，2是由横折横三根组成，7是由横折两根组成<br>【45】5名海盗抢得了窖藏的100块金子，并打算瓜分这些战利品。这是一些讲民主的海盗（当然是他们自己特有的民主），他们的习惯<br>是按下面的方式进行分配：最厉害的一名海盗提出分配方案，然后所有的海盗（包<br>括提出方案者本人）就此方案进行表决。如果50%或更多的海盗赞同此方案，此方<br>案就获得通过并据此分配战利品。否则提出方案的海盗将被扔到海里，然后下一名<br>最厉害的海盗又重复上述过程。<br>所有的海盗都乐于看到他们的一位同伙被扔进海里，不过，如果让他们选择的<br>话，他们还是宁可得一笔现金。他们当然也不愿意自己被扔到海里。所有的海盗都<br>是有理性的，而且知道其他的海盗也是有理性的。此外，没有两名海盗是同等厉害<br>的——这些海盗按照完全由上到下的等级排好了座次，并且每个人都清楚自己和其<br>他所有人的等级。这些金块不能再分，也不允许几名海盗共有金块，因为任何海盗<br>都不相信他的同伙会遵守关于共享金块的安排。这是一伙每人都只为自己打算的海<br>盗。<br>最凶的一名海盗应当提出什么样的分配方案才能使他获得最多的金子呢？<br>【46】他们中谁的存活机率最大？<br>5个囚犯，分别按1-5号在装有100颗绿豆的麻袋抓绿豆，规定每人至少抓一颗，而抓得最多和最少的人将被处死，而且，他们之间不能交流，但在抓的时候，可以摸出剩下的豆子数。问他们中谁的存活几率最大？提示：　　　　　　<br>1，他们都是很聪明的人　　　　　　<br>2，他们的原则是先求保命，再去多杀人　　　　　　<br>3，100颗不必都分完　　　　　　<br>4，若有重复的情况，则也算最大或最小，一并处死<br>【47】有5只猴子在海边发现一堆桃子,决定第二天来平分.第二天清晨,第一只猴子最早来到,它左分右分分不开,就朝海里扔了一只,恰好可以分成5份,它拿上自己的一份走了.第2,3,4,5只猴子也遇到同样的问题,采用了同样的方法,都是扔掉一只后,恰好可以分成5份.问这堆桃子至少有多少只？<br>【48】话说某天一艘海盗船被天下砸下来的一头牛给击中了,5个倒霉的家伙只好逃难到一个孤岛,发现岛上孤零零的,幸好有有棵椰子树,还有一只猴子!<br>大家把椰子全部采摘下来放在一起,但是天已经很晚了,所以就睡觉先.<br>晚上某个家伙悄悄的起床,悄悄的将椰子分成5份,结果发现多一个椰子,顺手就给了幸运的猴子,然后又悄悄的藏了一份,然后把剩下的椰子混在一起放回原处,最后还是悄悄滴回去睡觉了.<br>过了会儿,另一个家伙也悄悄的起床,悄悄的将剩下的椰子分成5份,结果发现多一个椰子,顺手就又给了幸运的猴子,然后又悄悄滴藏了一份,把剩下的椰子混在一起放回原处,最后还是悄悄滴回去睡觉了.<br>又过了一会 …<br>…<br>又过了一会 …<br>总之5个家伙都起床过,都做了一样的事情<br />早上大家都起床,各自心怀鬼胎的分椰子了,这个猴子还真不是一般的幸运,因为这次把椰子分成5分后居然还是多一个椰子,只好又给它了.<br>问题来了,这堆椰子最少有多少个?<br>【49】小明和小强都是张老师的学生，张老师的生日是M月N日，<br>2人都知道张老师的生日是下列10组中的一天，<br>张老师把M值告诉了小明，把N值告诉了小强，<br>张老师问他们知道他的生日是那一天吗？<br>3月4日 3月5日 3月8日<br>6月4日 6月7日<br>9月1日 9月5日<br>12月1日 12月2日 12月8日<br>小明说：如果我不知道的话，小强肯定也不知道<br>小强说：本来我也不知道，但是现在我知道了<br>小明说：哦，那我也知道了<br>请根据以上对话推断出张老师的生日是哪一天<br>【50】一逻辑学家误入某部落，被囚于牢狱，酋长欲意放行，他对逻辑学家说：“今有两门，一为自由，一为死亡，你可任意开启一门。现从两个战士中选择一人负责解答你所提的任何一个问题（Y&#x2F;N），其中一个天性诚实，一人说谎成性，今后生死任你选择。”逻辑学家沉思片刻，即向一战士发问，然后开门从容离去。逻辑学家应如何发问？<br>【51】说从前啊,有一个富人,他有30个孩子,其中15个是已故的前妻所生,其余15个是继室所生,这后一个妇人很想让她自己所生的最年长的儿子继承财产,于是,有一天,他就向他说:”亲爱的丈夫啊,你就要老了,我们应该定下来谁将是你的继承人,让我们把我们的30个孩子排成一个圆圈,从他们中的一个数起,每逢到10就让那个孩子站出去,直到最后剩下哪个孩子,哪个孩子就继承你的财产吧!”富人一想,我靠,这个题意相当有内涵了,不错,仿佛很公平,就这么办吧<del>不过,当剔选过程不断进行下去的时候,这个富人傻眼了,他发现前14个被剔除的孩子都是前妻生的,而且下一个要被剔除的还是前妻生的,富人马上大手一挥,停,现在从这个孩子倒回去数, 继室,就是这个歹毒的后妈一想,倒数就倒数,我15个儿子还斗不过你一个啊</del>她立即同意了富人的动议,你猜,到底谁做了继承人呢~<br>【52】“有一牧场，已知养牛27头，6天把草吃尽；养牛23头，9天把草吃尽。如果养牛21头，那么几天能把牧场上的草吃尽呢？并且牧场上的草是不断生长的。”<br>【53】一个商人骑一头驴要穿越1000公里长的沙漠，去卖3000根胡萝卜。已知驴一次性可驮1000根胡萝卜，但每走一公里又要吃掉一根胡萝卜。问：商人共可卖出多少胡萝卜？<br>【54】10箱黄金，每箱100块，每块一两<br>有贪官，把某一箱的每块都磨去一钱<br>请称一次找到不足量的那个箱子<br>【55】你让工人为你工作７天，给工人的回报是一根金条。金条平分成相连的７段，你必须在每天结束时都付费，如果只许你两次把金条弄断，你如何给你的工人付费？<br>【56】有十瓶药，每瓶里都装有100片药（仿佛现在装一百片的少了，都是十片二十片的，不管，咱们就这么来了），其中有八瓶里的药每片重10克，另有两瓶里的药每片重9克。用一个蛮精确的小秤，只称一次，如何找出份量较轻的那两个药瓶？<br>【57】一个经理有三个女儿，三个女儿的年龄加起来等于13，三个女儿的年龄乘起来等于经理自己的年龄，有一个下属已知道经理的年龄，但仍不能确定经理三个女儿的年龄，这时经理说只有一个女儿的头发是黑的，然后这个下属就知道了经理三个女儿的年龄。请问三个女儿的年龄分别是多少？为什么？<br>【58】有三个人去住旅馆，住三间房，每一间房$10元，于是他们一共付给老板$30，第二天，老板觉得三间房只需要$25元就够了于是叫小弟退回$5给三位客人，谁知小弟贪心,只退回每人$1，自己偷偷拿了$2，这样一来便等于那三位客人每人各花了九元，于是三个人一共花了$27，再加上小弟独吞了不$2，总共是$29。可是当初他们三个人一共付出$30那么还有$1呢？<br>【59】有两位盲人，他们都各自买了两对黑袜和两对白袜，八对袜了的布质、大小完全相同，　　而每对袜了都有一张商标纸连着。两位盲人不小心将八对袜了混在一起。他们每人怎样才能取回黑袜和白袜各两对呢？<br>【60】有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以每小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以30公里每小时的速度和两辆火车同时启动，从洛杉矶出发，碰到另一辆车后返回，依次在两辆火车来回飞行，直到两辆火车相遇，请问，这只小鸟飞行了多长距离？<br>【61】你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到红球的准确几率是多少？<br>【62】你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的重量＋1.只称量一次，如何判断哪个罐子的药被污染了？<br>【63】对一批编号为1～100，全部开关朝上(开)的灯进行以下*作：凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；3的倍数反方向又拨一次开关……问：最后为关熄状态的灯的编号。<br>【64】想象你在镜子前，请问，为什么镜子中的影像可以颠倒左右，却不能颠倒上下？<br>【65】一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其它人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什幺帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？<br>【66】两个圆环，半径分别是1和2，小圆在大圆内部绕大圆圆周一周，问小圆自身转了几周？如果在大圆的外部，小圆自身转几周呢？<br>【67】 1元钱一瓶汽水，喝完后两个空瓶换一瓶汽水，问：你有20元钱，最多可以喝到几瓶汽水？<br>【68】有3顶红帽子，4顶黑帽子，5顶白帽子。让10个人从矮到高站成一队，给他们每个人头上戴一顶帽子。每个人都看不见自己戴的帽子的颜色，却只能看见站在前面那些人的帽子颜色。（所以最后一个人可以看见前面9个人头上帽子的颜色，而最前面那个人谁的帽子都看不见。现在从最后那个人开始，问他是不是知道自己戴的帽子颜色，如果他回答说不知道，就继续问他前面那个人。假设最前面那个人一定会知道自己戴的是黑帽子。为什么？<br>【69】假设排列着100个乒乓球，由两个人轮流拿球装入口袋，能拿到第100个乒乓球的人为胜利者。条件是：每次拿球者至少要拿1个，但最多不能超过5个，问：如果你是最先拿球的人，你该拿几个？以后怎么拿就能保证你能得到第100个乒乓球？<br>【70】卢姆教授说：“有一次我目击了两只山羊的一场殊死决斗，结果引出了一个有趣的数学问题。我的一位邻居有一只山羊，重54磅，它已有好几个季度在附近山区称王称霸。后来某个好事之徒引进了一只新的山羊，比它还要重出3磅。开始时，它们相安无事，彼此和谐相处。可是有一天，较轻的那只山羊站在陡峭的山路顶上，向它的竞争对手猛扑过去，那对手站在土丘上迎接挑战，而挑战者显然拥有居高临下的优势。不幸的是，由于猛烈碰撞，两只山羊都一命呜呼了。<br>　　现在要讲一讲本题的奇妙之处。对饲养山羊颇有研究，还写过书的乔治．阿伯克龙比说道：“通过反复实验，我发现，动量相当于一个自20英尺高处坠落下来的30磅重物的一次撞击，正好可以打碎山羊的脑壳，致它死命。”如果他说得不错，那么这两只山羊至少要有多大的逼近速度，才能相互撞破脑壳？你能算出来吗？<br>【71】据说有人给酒肆的老板娘出了一个难题：此人明明知道店里只有两个舀酒的勺子，分别能舀7两和11两酒，却硬要老板娘卖给他2两酒。聪明的老板娘毫不含糊，用这两个勺子在酒缸里舀酒，并倒来倒去，居然量出了2两酒，聪明的你能做到吗？<br>【72】已知： 每个飞机只有一个油箱， 飞机之间可以相互加油（注意是相互，没有加油机） 一箱油可供一架飞机绕地球飞半圈，问题：为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？（所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场）<br>【73】在9个点上画10条直线，要求每条直线上至少有三个点？</p>
<p>【74】一个岔路口分别通向诚实国和说谎国。来了两个人，已知一个是诚实国的，另一个是说谎国的。诚实国永远说实话，说谎国永远说谎话。现在你要去说谎国，但不知道应该走哪条路，需要问这两个人。请问应该怎么问？<br>【75】在一天的24小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？**</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
        <category>999_面试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>设计测试用例</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/03_%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
    <content><![CDATA[<ol>
<li><p>给你一个杯子怎么测</p>
<ol>
<li><p>功能测试：主要关注水杯基本功能</p>
<ol>
<li>水杯是否可以正常装水</li>
<li>水杯是否可以正常喝水</li>
<li>水杯是否有盖子，盖子是否可以正常盖住</li>
<li>水杯是否有保温功能，保温功能是否正常保温</li>
<li>水杯是否会漏水，盖住盖子拧紧后是否会漏水</li>
</ol>
</li>
<li><p>界面测试：主要关注水杯外观、颜色、设计等方面</p>
<ol>
<li>外观是否完整</li>
<li>外观是否舒适</li>
<li>颜色搭配及使用是否让人感到舒适</li>
<li>杯子外观大小是否适中</li>
<li>杯子是否有图案，图案是否易磨损</li>
</ol>
</li>
<li><p>易用性测试：主要关注水杯使用是否方便</p>
<ol>
<li>水杯喝水时否方便</li>
<li>水杯拿起放下是否方便，这里会衍生到水杯形状的测试</li>
<li>水杯装水是否方便</li>
<li>水杯携带是否方方便</li>
<li>水杯是否有防滑功能</li>
<li>水杯装有低温或者高温水时，是否会让手感到不适</li>
</ol>
</li>
<li><p>性能测试：</p>
<ol>
<li>水杯装满水时，是否会露出来</li>
<li>水杯最大使用次数</li>
<li>水杯的保温性是否达到要求</li>
<li>水杯的耐寒性是否达到要求</li>
<li>水杯的耐热性是否达到要求</li>
<li>水杯掉落时时，是否可以正常使用</li>
<li>水杯长时间放置时，是否会发生泄露</li>
</ol>
</li>
<li><p>兼容性测试：主要关注水杯是否可以装其他液体，如果汁、汽油、酒精等可移植性测试：主要关注水杯放置环境等</p>
<ol>
<li>将水杯放在常温环境中，使用是否正常</li>
<li>将水杯放在零下的环境中，使用是否正常</li>
<li>将水杯放在高于正常温度的环境中，使用是否正常</li>
</ol>
</li>
<li><p>安全性测试：主要关注水杯外观和各种异常条件下是否释放有毒物质等</p>
<ol>
<li>当水杯装满热水时，水杯是否会烫手</li>
<li>当水杯装上水后，是否会产生有毒物质</li>
<li>把水杯放在零下环境时，是否会产生有毒物质</li>
<li>把水杯放在高温环境时，是否会产生有毒物质</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="图像上传功能的测试点"><a href="#图像上传功能的测试点" class="headerlink" title="图像上传功能的测试点"></a>图像上传功能的测试点</h3><ol>
<li><p>检查图片上传路径</p>
</li>
<li><p>检查图像上传和修改功能</p>
<ol>
<li><p>检查各种扩展图像文件的上传(例如JPEG、PNG、BMP等).</p>
</li>
<li><p>检查文件名中含有空格或其他可用特殊字符的图片的上传</p>
</li>
<li><p>检查重复名称图片上传</p>
</li>
<li><p>图片尺寸大于最大允许值，上传时应该显示适当的错误消息.</p>
</li>
<li><p>检查上传的图片文件类型外的其它文件时(例如txt、doc、pdf、exe 等等)，应该显示适当的错误消息</p>
</li>
<li><p>检查如果上传的图片满足指定的高度和宽度(如果有定义的话)则可以成功上传，否则不能上传</p>
</li>
<li><p>上传大尺寸图片时应显示上传进度条</p>
</li>
<li><p>检查上传过程中的取消按钮是否有效</p>
</li>
<li><p>检查文件选择对话框中的文件列表是否只显示支持文件类型</p>
</li>
<li><p>检查上传多个图像的功能</p>
</li>
<li><p>上传后检查图像质量，图像质量不应该改变</p>
</li>
<li><p>检查用户是否能够使用&#x2F;查看上传的图像</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="搜索框的测试"><a href="#搜索框的测试" class="headerlink" title="搜索框的测试"></a>搜索框的测试</h3><p> 1）  搜索按钮功能是否能够实现，验证搜索框的功能是否与需求一致。</p>
<p> 2）  点搜索后，原先的搜索条件是否清空。</p>
<p> 3）  查看比较长的名称是否能查到,输入过长查询数据，看其有没判断，报错;系统是否会截取允许的长度来检索结果。</p>
<p> 4）  是否有忽略空格的功能，需要有忽略前置空格和后置空格的功能，但不能把中间空格忽略</p>
<p> 5）  不输入任何内容点击搜索看查询的结果</p>
<p> 6）  查看搜索框内的默认内容是否与设置的一致，焦点放置搜索框中，搜索框默认内容是否自动被清空</p>
<p> 7）  输入系统中存在的与之匹配的条件,看其的查询后数据的完整性;显示记录条数正确、文字折行显示正确、页面布局美观,列标题项、列显示内容、排序方式符合需求定义</p>
<p> 8）  组合中文和各种特殊符号输入查看能否正确搜索到符合的内容</p>
<p> 9）  输入系统中不存在的与之匹配的条件，是否搜索出信息或者给予提示信息</p>
<p> 10）  使用复制粘贴，测试搜索框是否能执行</p>
<p> 11）  注意在光标停留的地方输入信息时,光标和所输入的信息会否跳到别的地方</p>
<p> 12）  反复输入相同的数据（5次以上）看是否报错</p>
<p> 13）  敏感词汇，提示用户为敏感词汇</p>
<p> 14）  不同搜所的条件之间来回选择，查看是否出现页面错误</p>
<p> 15）  测试多个搜所条件时，要注意搜所条件的组合测试，可能不同组合的测试会报错</p>
<p> 16）  点击搜索框，看能否在搜索栏下方显示提供设置好的-最近热门搜索词，点击任一可以直达搜索结果页</p>
<p> 17）  点击搜索框时，到有搜所历史时，能显示历史搜所内容，历史搜所内容应从上到下按时间排序，点击清空历史清空所有搜索记录。</p>
<p> 18）  查看搜索框最大输入字符数</p>
</li>
<li><h3 id="给你一个电梯，你怎么测"><a href="#给你一个电梯，你怎么测" class="headerlink" title="给你一个电梯，你怎么测"></a>给你一个电梯，你怎么测</h3><ol>
<li><p>功能：</p>
<ol>
<li>测试电梯能否实现正常的上升和下降功能。</li>
<li>电梯的按钮是否都可以使用</li>
<li>电梯内分楼层键是否正常电梯内开关门键是否正常</li>
<li>电梯内的报警键是否正常使用电梯外的上下键是否正常</li>
<li>电梯门的打开，关闭是否正常。</li>
<li>报警装置是否可用。</li>
<li>与其他电梯之间是否协作良好。</li>
<li>通风状况如何。</li>
<li>突然停电时的情况。</li>
<li>关注显示屏，电梯内外的显示屏显示的电梯层数、运行方向是否正常</li>
<li>是否有手机信号</li>
<li>有障碍物时，电梯门的感应系统是否有效</li>
<li>上升途中的响应。</li>
<li>电梯本来在 1 楼，如果有人按 18 楼，那么电梯在上升到 5 楼的时候，有人按了 10 楼，这时候是否会在 10 楼先停下来；</li>
<li>电梯下降到 10 层时显示满员，此时若 8 层有人等待电梯，是否在 8 层停。</li>
</ol>
</li>
<li><p>可靠性：</p>
<p> 1）  门关上的一刹那出现障碍物。</p>
<p> 2）  同时按关门和开门按钮。</p>
<p> 3）  点击当前楼层号码</p>
<p> 4）  多次点击同一楼层号码</p>
<p> 5）  同时按上键和下键</p>
</li>
<li><p>易用性：</p>
<p> 1）  电梯的按钮的设计符合一般人的习惯吗</p>
<p> 2）  楼层按键高度（小孩和一些身高矮的用户会按键不方便）</p>
<p> 3）  电梯是否有地毯、夏天是否有空调、通风条件、照明条件、手机信号是否通畅</p>
<p> 4）  电梯是否有扶手，是否有专针对残疾人的扶手等等</p>
</li>
<li><p>压力测试：</p>
<p> 1）  看电梯的最大承重量，在负载过重时报警装置是否有提醒</p>
<p> 2）  在一定时间内不断让电梯上升、下降</p>
</li>
<li><p>稳定性测试：</p>
<ol>
<li>看电梯在最大负载下平稳运行的最长时间</li>
</ol>
</li>
<li><p>安全性测试：</p>
<p> 1）  下坠时是否有制动装置</p>
<p> 2）  暴力破坏电梯时是否报警，超重是否报警</p>
<p> 3）  停电情况下电梯是否有应急电源装置</p>
</li>
<li><p>性能测试：</p>
<p> 1）  测试电梯负载单人时的运行情况（基准测试）</p>
<p> 2）  多人时的运行情况（负载测试）</p>
<p> 3）  一定人数下较长时间的运作（稳定性测试）</p>
<p> 4）  更长时间运作时的运行情况（疲劳测试）</p>
<p> 5）  不断增加人数导致电梯报警（拐点压力测试）</p>
</li>
</ol>
</li>
<li><h3 id="更换头像的测试点（站在app的角度来分析）"><a href="#更换头像的测试点（站在app的角度来分析）" class="headerlink" title="更换头像的测试点（站在app的角度来分析）"></a>更换头像的测试点（站在<strong>app</strong>的角度来分析）</h3><ol>
<li><p>功能：</p>
<p> 1，点击头像可以放大观看</p>
<p> 2，查看头像是否支持放大，缩小</p>
<p> 3，刚创建账号时是否显示默认头像</p>
<p> 4，查看头像之后点击其它区域自动退出</p>
<p> 5，头像支持的图片格式，图片大小</p>
<p> 6，支持相机拍摄的图片和从网上下载的图片</p>
<p> 7，选择完图片后是否有一个定框</p>
<p> 8，选择相片—从手机相册获取</p>
<p> 9，选择相片—用照相机拍照</p>
<p> 10，头像显示的是方形还是圆形</p>
<p> 11，选择图片范围时图片是否支持放大／缩小</p>
<p> 12，选择好图片区域后保存，头像是否居中显示，还是只显示选择图片区域的某个角落</p>
<p> 13，保存完图片后是否会有提示更换头像成功</p>
<p> 14，修改头像后去 app 其它模块时是否马上刷新显示最新的头像</p>
<p> 15，进入更换头像界面时可以取消更换头像</p>
<p> 16，选择从相册选取图片还是从照相机时都能取消，返回到修改头像界面</p>
<p> 17，头像是否支持本地缓存，断开网络之后是否还能显示头像</p>
<p> 18，网络异常时，修改头像失败，会有提示</p>
</li>
<li><p>弱网：</p>
<p> 双卡的情况下，切换到另一张卡</p>
<p> 连接到一个假热点</p>
<p> 用 fiddler模拟 2G3G4G情况下的弱网情况从手机流量切换到 wifi</p>
</li>
<li><p>性能：上传的时间上传过程中：</p>
<p> 手机死机??手机没电???手机卡停机????</p>
<p> 上传成功以后，去数据库查看有没有</p>
<p> 上传成功后，退出登录，在登录看是否是更新后的头像</p>
<p> 上传成功后，删除头像，切换到其他页面，再切换回来看头像的展示情况</p>
<p> 兼容性：</p>
<p> 更换成功后，在不同手机屏幕，不同分辨率，不同手机型号，不同系统版本的情况下，头像的展示情</p>
</li>
</ol>
</li>
<li><h3 id="qq登陆界面怎么测试，分析"><a href="#qq登陆界面怎么测试，分析" class="headerlink" title="qq登陆界面怎么测试，分析"></a><strong>qq</strong>登陆界面怎么测试，分析</h3><p> 主要考察： 测试者是否熟悉各种测试方法，是否有丰富的 App&#x2F;Web测试经验，以及相关开发经验，以及设计 Test case的能力。</p>
<ol>
<li><p>功能测试 (Function test)</p>
<ol>
<li><p>1）  输入正确的用户名和密码，点击提交按钮，验证是否能正确登录</p>
<p> 2）  输入错误的用户名或者密码,<br> 验证登录会失败，是否有相应的错误提示信息</p>
<p> 3）  登录成功后是否跳转到正确的页面</p>
<p> 4）  用户名和密码，如果太短或者太长，应该怎么处理</p>
<p> 5）  用户名和密码，中有特殊字符，和其他非英文的情况</p>
<p> 6）  记住用户名和密码的功能</p>
<p> 7）  登陆失败后，不能记录密码的功能</p>
<p> 8）  用户名和密码输入时前后有空格的处理</p>
<p> 9）  密码是否可见，是否用星号标识</p>
</li>
<li><p>UI测试</p>
<ol>
<li><p>1）布局是否合理，2个 Testbox和一个按钮是否对齐</p>
<p> 2）Testbox和按钮的长度、高度是否复合要求</p>
<p> 3）界面是否美观</p>
<p> 4）图片，颜色，字体，超链接，是否都显示正确</p>
</li>
</ol>
</li>
<li><p>性能测试 (performance test)</p>
<ol>
<li><p>1）  打开登录页面，需要几秒</p>
<p> 2）  输入正确的用户名和密码后，登录成功跳转到新页面，不超过5秒</p>
<p> 3）  能支持多少个用户同时登陆</p>
</li>
</ol>
</li>
<li><p>安全性测试 (Security test)</p>
<ol>
<li><p>1）登录成功后生成的Cookie，是否是<br> httponly (否则容易被脚本盗取) 2）用户名和密码是否通过加密的方式，发送给Web 服务器</p>
<p> 3）   用户名和密码的验证，应该是用服务器端验证，<br> 而不能单单是在客户端用 javascript验证</p>
<p> 4）<br />用户名和密码的输入框，应该屏蔽SQL注入攻击</p>
<p> 5）<br />用户名和密码的的输入框，应该禁止输入脚本 （防止 XSS 攻击）</p>
<p> 6）   错误登陆的次数限制（防止暴力破解）</p>
</li>
</ol>
</li>
<li><p>兼容性测试（Compatibility Test）</p>
<ol>
<li><p>1）主流的浏览器下能否显示正常（IE&#x2F;Edge,Firefox, Chrome, Safari等）</p>
<p> 2）不同的平台是否能正常工作，比如Windows, Mac</p>
<p> 3）  移动设备上是否正常工作，比如iPhone, Andriod</p>
<p> 4）  不同的分辨率</p>
<p> 5）  不同的浏览器大小（浏览器最大化， 和非最大化）</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="微信点赞"><a href="#微信点赞" class="headerlink" title="微信点赞"></a>微信点赞</h3><ol>
<li><p>功能测试</p>
<ol>
<li><p>1）给某个好友点赞，点赞数+1，点赞栏显示具体点赞人的名字，该用户手动点赞回馈</p>
<p> 2）  点完赞后，共同好友在点赞区能看到该人是不是点赞了，非共同好友看不到</p>
<p> 3）  两个头像一样的人点赞，能否正确显示</p>
<p> 4）  点完赞后，在点击点变成点赞取消</p>
<p> 5）  取消点赞–不通知用户</p>
<p> 6）  点赞后，通知用户，取消，在点赞，此时不通知用户</p>
<p> 7）  多个用户同时对其点赞，点赞数正常</p>
<p> 8）  最多能点多少个赞–边界值测试</p>
<p> 9）  可以从点击点赞区头像，进入相应人的主页查看</p>
<p> 10）点赞是否按照时间顺序排序</p>
<p> 11）点赞后是否能够正常评论</p>
</li>
</ol>
</li>
<li><p>app 端测试</p>
<ol>
<li><p>1）  弱网情况下，点赞能否实时更新</p>
<p> 2）  点赞时，有短信或者电话进来，能否显示点赞情况</p>
<p> 3）  耗电量，耗流量关注</p>
</li>
</ol>
</li>
<li><p>性能测试</p>
<ol>
<li><p>1）  大量用户并发点赞时，该接口的响应时间，最大承受的qps</p>
<p> 2）  大量用户并发点赞时，此时界面进行点赞，点赞功能是否正常</p>
</li>
</ol>
</li>
<li><p>兼容性测试</p>
<ol>
<li>不同手机型号，点赞功能，显示功能是否正常</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="微信发红包测试点"><a href="#微信发红包测试点" class="headerlink" title="微信发红包测试点"></a>微信发红包测试点</h3><ol>
<li><p>功能测试</p>
<ol>
<li><p>发给单个好友</p>
<p> ①    正确的金额+无留言+无表情</p>
<p> ②    错误的金额+无留言+无表情</p>
<p> ③    正确的金额+有留言+无表情</p>
<p> ④    错误的金额+有留言+无表情</p>
<p> ⑤    正确的金额+无留言+有表情</p>
<p> ⑥    错误的金额+无留言+有表情</p>
<p> ⑦    正确的金额+有留言+有表情</p>
<p> ⑧    错误的金额+有留言+有表情</p>
<p> 其中，金额（0.01-200）可以测试以下数据</p>
<p> 数字：测试 0, 0.009,0.01，0.011, 01， 199.99, 200, 200.01 这些边界值</p>
<p> 中文、英文、特殊字符或者这几种的组合是否支持复制粘贴 为空&#x2F;包含空格金额的增删查改</p>
<p> 留言可以测试以下数据</p>
<p> 数字、中文、英文、特殊字符、表情或者他们的组合 输入超长文本时，是否会给出相应的限制或提示</p>
<p> 包含空格</p>
<p> 是否支持复制黏贴留言的增删查改</p>
<p> 表情可以测试以下数据</p>
<p> 选择收藏的表情测试（动图&#x2F;静图） 选择下载的表情测试（动图&#x2F;静图） 录制表情，并添加进行测试</p>
<p> 表情的增删查改</p>
<p> ⑨    点击塞钱进红包，选择零钱付款，此时需要考虑金额＞零钱，金额＜零钱，金额&#x3D;零钱三种情况</p>
<p> ⑩    点击塞钱进红包，选择已添加的银行卡付款，此时同样需要考虑金额＞银行卡余额，金  额＜银行卡余额，金额&#x3D;银行卡余额三种情况</p>
<p> ⑪   点击塞钱进红包，选择使用新卡付款，按照流程添加新卡，此时同样需要考虑金额＞新  卡余额，金额＜新卡余额，金额&#x3D;新卡余额三种情况</p>
<p> ⑫   使用指纹确认付款（正确的&#x2F;不正确的指纹）</p>
<p> ⑬   使用密码确认付款（正确的&#x2F;不正确的密码<br> ）</p>
<p> ⑭   发送成功之后，对应的途径会减少相应的金额</p>
<p> ⑮   发送者&#x2F;接受者可以点击红包查看到红包的具体信息，且金额，留言，表情均能正确显示</p>
<p> ⑯   好友点击红包之后，零钱中将增加相应的金额，再次点击之后，只能查看到红包的信息</p>
<p> ⑰   24小时之内没有领取的红包，将退回原账户，此时原账户的零钱将增加相应金额的金钱。24小时后好友点击红包，显示红包已过期，无法查看到红包的余额</p>
<p> ⑱   右上角的红包记录中，可以查看刚刚发出的红包的金额</p>
<p> ⑲   检测帮助中心中链接是否均可以正常跳转，查看</p>
<p> 20 当红包超过 24 小时之后，则无法查看红包被每个人领取的详细信息</p>
</li>
<li><p>发送群红包（与发给好友的测试点相似，以下仅写出不同的部分）</p>
<ol>
<li><p>①    选择为拼手气红包时，群中每个人收到的金额随机（但加起来为红包的总金额），为普  通红包时，群中每个人收到的金额相同</p>
<p> ②    红包个数（1-100）：0，1，2，大于群成员人数，小于群成员人数，等于群成员人数，</p>
<p> 99，100，101，小数，中文、英文、特殊字符、表情或者他们的组合</p>
<p> ③    但红包没有被抢完时，此时首次点击该红包的人可以抢到一定金额的红包，不是首次点  击该红包的人只能查看该红包的信息；当红包抢完时，所有人只能查看该红包的信息。</p>
<p> ④    在 24小时之内红包的金额被完全抢完，且此时为拼手气红包时，金额最多的人会显示</p>
<p> 为最佳手气（若有两个人取得红包的最大值时，则只有一个人会显示为最佳手气）；若没有   被完全抢完，则没有最佳手气，且余额会退还到原账户</p>
<p> ⑤    群中所有人均可以抢红包（包括自己），每个人最多只有一次抢该红包的机会</p>
<p> ⑥    测试当红包个数使得每个红包分到钱小于 0.01，即总金额为 0.02，而红包个数为 3时的情况</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>兼容性测试</p>
<ol>
<li><p>1）苹果手机和安卓手机</p>
<p> 2）苹果手机的不同版本</p>
<p> 3）安卓手机不同的机型</p>
<p> 4）不同分辨率</p>
</li>
</ol>
</li>
<li><p>性能测试</p>
<ol>
<li><p>1）打开红包的响应时间不能超过三秒，高并发场景下不能超过 5秒</p>
<p> 2）耗电量</p>
<p> 3）消耗流量的多少</p>
<p> 4）所占内存等</p>
</li>
</ol>
</li>
<li><p>UI 测试&amp;易用性测试</p>
<ol>
<li><p>1）界面的设计风格是否统一</p>
<p> 2）界面中文字是否简洁，没有错别字</p>
<p> 3）是否易操作，易学习，易理解</p>
</li>
</ol>
</li>
<li><p>中断测试：前后台切换，网络异常，低电量，断电，来电，短信等</p>
</li>
<li><p>网络测试</p>
<ol>
<li><p>1）网络兼容性：2g&#x2F;3g&#x2F;4g，WiFi，热点，移动&#x2F;联通&#x2F;电信</p>
<p> 2）无网测试</p>
<p> 3）弱网：延时&amp;丢包</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="微信聊天功能测试用例"><a href="#微信聊天功能测试用例" class="headerlink" title="微信聊天功能测试用例"></a>微信聊天功能测试用例</h3><ol>
<li><p>消息发送（单聊，群聊，语音，文字，图片，表情，链接，字符及长度。。。）<br> 成员管理（加人，被加，退出，被动退出，编辑，删除。。。）</p>
<p> 群组管理（创建群，消息设置，申请入群，扫二维码入群，退群，通知提醒，头像编辑，名称编辑，简介编辑，权限编辑，成员编辑。。。）</p>
<p> 消息管理（发布通知，接收通知，发文件，消息提醒，通知提醒，声音，震动，好友请求，请求处理。。。）<br> 隐私管理（黑名单，允许好友查看动态，允许陌生人查看动态，允许通过手机号查找，允许真实姓名查找。。。） 权限管理（开放群（任何人入群），半开放群（验证入群），验证加好友，不需验证加好友。。。）</p>
<p> 登录退出（忘记密码，更换账号。。。）</p>
<p> 好友管理（扫二维码加人，加好友，查好友，好友推荐，群组推荐，联系人导入，拉黑名单，解除好友， 备注名。。。）</p>
<p> 动态管理（发动态，发投票，点赞，表情，评论，增加，删除，分享，隐藏，编辑。。。）<br> 消息推送（在线，离线，收发，时序。。。）</p>
<p> 文件管理（接收，离线接收，预览，删除，分享，转存，文件格式，大小。。。）</p>
</li>
</ol>
</li>
<li><h3 id="给你一个界面怎么测"><a href="#给你一个界面怎么测" class="headerlink" title="给你一个界面怎么测"></a>给你一个界面怎么测</h3><ol>
<li><p>这个具体看什么界面了，首先要搞清楚界面上有哪些功能点，一定要弄清楚哪些是展示性的信息，哪些可操作性的东西。然后从上到下根据界面上的一些功能进行逐一测试。具体的话：</p>
<ol>
<li><p>1）<br />首先肯定是做界面UI测试，主要检查看界面布局是否合理，是否美观，图片，颜色，字体，超链接，<br> 是否都显示正确，界面数据是否展示正常等等</p>
<p> 2）      然后根据界面上的各个功能点需求逐一检查，各个功能是否有问题。</p>
<p> 3）<br />考虑到时界面，所以得考虑兼容性问题，对于 Web端要不同的浏览器展示问题，浏览器缩放比例问题， 不同屏幕大小问题，看是否都能正常展示。对于 App 端当然要考虑不同的手机屏幕大小，分辨率等等。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="题目：有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。"><a href="#题目：有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。" class="headerlink" title="题目：有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。"></a>题目：有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。</h4><p> 1.分析这一段说明，列出原因和结果</p>
<p> 原因：</p>
<p> 1.售货机有零钱找</p>
<p> 2.投入1元硬币</p>
<p> 3.投入5角硬币</p>
<p> 4.押下橙汁按钮</p>
<p> 5.押下啤酒按钮</p>
<p> 结果：</p>
<p> 21.售货机〖零钱找完〗灯亮</p>
<p> 22.退还1元硬币</p>
<p> 23.退还5角硬币</p>
<p> 24.送出橙汁饮料</p>
<p> 25.送出啤酒饮料</p>
<p> 2.画出因果图</p>
<p> 如图所示。所有原因结点列在左边，所有结果结点列在右边。建立中间结点，表示处理的中间状态。中间结点：</p>
<ol start="11">
<li>投入1元硬币且押下饮料按钮</li>
<li>押下〖橙汁〗或〖啤酒〗的按钮</li>
<li>应当找5角零钱并且售货机有零钱找</li>
<li>钱已付清</li>
</ol>
<p> 3.转换成判定表：</p>
<p> 4.设计测试用例</p>
<p> 在售货机有零钱找的情况下，投入1元硬币，押下橙汁按钮，找回5角硬币并送出橙汁饮料。</p>
<p> 在售货机有零钱找的情况下，投入1元硬币，押下啤酒按钮，找回5角硬币并送出啤酒饮料。</p>
<p> 在售货机有零钱找的情况下，投入1元硬币，系统不做任何处理。</p>
<p> 在售货机有零钱找的情况下，投入5角硬币，押下橙汁按钮，送出橙汁饮料。</p>
<p> 在售货机有零钱找的情况下，投入5角硬币，押下啤酒按钮，送出啤酒饮料。</p>
<p> 在售货机有零钱找的情况下，投入5角硬币，系统不做任何处理。</p>
<p> 在售货机有零钱找的情况下，押下橙汁按钮，系统不做任何处理。</p>
<p> 在售货机有零钱找的情况下，押下啤酒按钮，系统不做任何处理。</p>
<p> 在售货机没有零钱找的情况下，投入1元硬币，押下橙汁按钮，售货机“零钱找完”灯亮，并退还1元硬币。</p>
<p> 在售货机没有零钱找的情况下，投入1元硬币，押下啤酒按钮，售货机“零钱找完”灯亮，并退还1元硬币。</p>
<p> 在售货机没有零钱找的情况下，投入1元硬币，售货机“零钱找完”灯亮。</p>
<p> 在售货机没有零钱找的情况下，投入5角硬币，押下橙汁按钮，售货机“零钱找完”灯亮，并送出橙汁饮料。</p>
<p> 在售货机没有零钱找的情况下，投入5角硬币，押下啤酒按钮，售货机“零钱找完”灯亮，并送出啤酒饮料。</p>
<p> 在售货机没有零钱找的情况下，投入5角硬币，售货机“零钱找完”灯亮。</p>
<p> 在售货机没有零钱找的情况下，押下橙汁按钮，售货机“零钱找完”灯亮。</p>
<p> 在售货机没有零钱找的情况下，押下啤酒按钮，售货机“零钱找完”灯亮。 幼儿园教育活动的特点</p>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
        <category>999_面试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>项目介绍</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/02_%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<ol>
<li><p>项目名称：家家好货<br> 项目描述：家家好货项目，属于 b&#x2F;s 架构，通过这个平台可以买到绿色安全的农副产品，老人和小朋友食用更放心，可以足不出户就能享受到大自然的味道。项目主要有前端和后台两个端,前端包含首页、店铺、商品分类、积分中心、会员中心、我的中心、商家中心、等几个模块，后台含控制台、设置、会员、商品、店铺、交易、网站等几个模块。<br> 1、参与需求评审，根据需求文档完成用例的编写；<br> 2、独立完成负责模块的功能测试；3、熟练使用 postman、jmeter 完成接口测试;<br> 4、测试过程中会同步关注日志以及数据库的相关信息；<br> 5、使用 fiddler 和 F12 定位问题，分析问题；<br> 6、使用 linux 命令查看日志定位问题；<br> 7、熟练使用禅道管理 BUG，使用 SVN 管理项目中的相关文档；<br> 8、向领导汇报工作进度，编写测试报告和测试总结。</p>
</li>
<li><p>项目名称：淘东		              时间：2020年10月—2021年8月<br> 描述：淘东是一套完善的电子商务系统，通过这个平台可以方便我们买自己想要的商品，并且可以在这个平台建立自己的商铺进行买卖，平台类似于淘宝，京东以便捷，实惠的购物体验服务为核心的，我们这个平台，免费送货上门，无条件退等为客户提供了完美购物，项目主要有前端和后台两个部分，前端包含店铺、品牌、商品、积分中心、用户中心、商家中心、客户中心等几个模块，后台包含控制台、设置、会员、商品、店铺、交易、网站等几个模块。<br> 业绩：<br> 1.参与项目内需求的评审和测试用例的编写；<br> 2.使用SVN进行项目文档的管理；<br> 3.配合开发定位、解决bug并利用禅道对Bug进行管理和跟踪；<br> 4.使用postman工具对接口进行测试；<br> 5.帮助开发人员进行问题定位并协助解决；<br> 6.编写测试报告，并向上级汇报工作进度情况。</p>
</li>
<li><p>项目名称：智慧校园                     时间：2020年6月—2020年9月<br> 描述：智慧校园是b&#x2F;s架构 推出的面向全国高校师生的智能校园生活应用，为大学生提供学习、生活、就业等全方位优质服务作为连接校内外优质服务的移动互联网平台，智慧校园一直致力于全方位满足大学生学习成长、社交分享、校园生活、就业深造。今日校园将继续“一切为了大学生成长”为使命，助力国内高校实现高校信息化，享受“智慧校园”的便捷、智能、人性化成果。<br> 业绩：<br> 1.协助测试组长对测试流程进行分析改进；<br> 2.掌握软件中各种功能以及站在用户角度去体验；<br> 3.协助测试组长对测试流程进行分析改进；<br> 4.大版本更新时负责模块测试，发现bug，提交bug，反馈后及时跟踪检查；<br> 5.提交测试报告，进行项目总结。</p>
</li>
<li><p>项目名称：布谷鸟                    时间：2019年11月—2020年4月<br> 描述：布谷鸟属于c&#x2F;s架构参考了飞鸽传书(IPMSG)和 QQ（官方说法）用于和企业管理系统集成，实现业务流程、任务、公告的相关提醒等。具有通讯聊天、群聊、传送文件、离线文件、录音留言、消息签收、语音、视频、网络硬盘、公告、视频会议的软件工具。支持上万级用户并发。安全、稳定、高效、维护方便、跟咱们所用到的QQ大致是一样的。<br> 业绩：<br> 1、参与项目内需求的评审，测试用例的编写与评审；<br> 2、使用SVN管理项目中所有的文档；<br> 3、使用mysql数据库进行数据检验，增、删、改、查脚本；<br> 4、配合开发定位问题，使用的是f12、fiddler；<br> 5、使用禅道对Bug进行管理和跟踪；<br> 6、编写测试报告和测试总结。</p>
</li>
<li><p>项目名称：达方快递<br> 项目描述：达方快递管理系统属于 b&#x2F;s 架构，四达快递管理系统是为了适应快递业务的不足各层基本操作的同时，做到了管理层协调管理的简化，进行有效的控制运营。整个系统的管理主要分为系统管理、基础设置、取派、中转、路由、PDA、财务管理、报表管理八个模块。<br> 1、参与项目内需求的评审，测试用例的编写与评审；<br> 2、测试中使用 Mysql 数据库数据校验，增、删、改、查语句；<br> 3、同时配合开发定位问题，使用的是 f12；<br> 4、使用禅道对 Bug 进行管理和跟踪缺陷；<br> 5、掌握 linux 命令查看日志定位问题等常用命令；<br> 6、使用 SVN 管理项目中的相关文档；<br> 7、编写测试报告并向领导汇报工作；</p>
</li>
<li><p>项目名称：居美酒店<br> 项目描述：居美酒店客房管理系统是一款便捷、高效的酒店客房管理程序，b&#x2F;S 架构，该软件界面简洁、功能实用，非常适合中小型酒店使用。轻松对酒店客房进行管理，提高了酒店的入住率、节省客户入住和退房的时间，从而增加客户的满意度，同时也减轻使用者工作负担。系统主要有预定管理、预订查询、前台接洽、会员管理、账户查询、班次结算、夜审功能、详细的房态信息这几个。<br> 1、参与需求评审，编写测试计划和测试用例；<br> 2、使用 SVN 管理项目中所有的文档；<br> 3、使用 JIRA 管理 BUG 并跟踪缺陷;<br> 4、配合开发定位问题，使用的是 fiddler 进行抓包；<br> 5、编写测试计划并向领导汇报工作进度。</p>
</li>
<li><p>项目名称：叮叮　　　　　　　　                                                     2020.08—2021.10<br>  描述： 叮叮属于 app办公用软件  （官方说法）用于和企业管理系统集成，实现业务流程、任务、公告的相关提醒等。具有通讯聊天、群聊、传送文件、、 发表评论留言、消息签收、语音、视频、网络硬盘、公告、视频会议的软件工具。支持上万 家企业使用方便、安全、快捷 。<br> 职责：<br> 1、参与项目内需求的评审，测试用例的编写与评审；<br> 2、使用SVN管理项目中所有的文档；</p>
<p> 3、使用mysql数据库进行数据校验</p>
<h6 id="4、使用f12、fiddler-执行操作-；-协助开发定位问题，"><a href="#4、使用f12、fiddler-执行操作-；-协助开发定位问题，" class="headerlink" title="4、使用f12、fiddler 执行操作  ； 协助开发定位问题，"></a>4、使用f12、fiddler 执行操作  ； 协助开发定位问题，</h6><h6 id="5、使用禅道工具跟踪bug修复bug"><a href="#5、使用禅道工具跟踪bug修复bug" class="headerlink" title="5、使用禅道工具跟踪bug修复bug"></a>5、使用禅道工具跟踪bug修复bug</h6></li>
<li><p>项目名称：聚淘宝                                                 2019.05—2020.08                 </p>
<p> 描述：聚淘宝是一套完善的电子商务系统,通过这个平台可以方便消费者买自己想要的商品，并描且可以在这个平台建立自己的商铺进行买卖，平台类似于淘宝，360、实惠购物体验服务为核心的，我们这个平台，免费送货上门，无条件退等为客户提供了完美购物，项目主要有前端和后台两个部分，前端包 含店铺、品牌、商品、积分中心、用户中心、商家中心、客户中心等几个模块，后台包含控制台、设置、会员、商品、店铺、交易、网站等几个模块 。</p>
<p> 职责：</p>
<p> 1.参与项目内需求的评审和测试用例的编写；</p>
<ol start="2">
<li><p>使用SVN进行项目文档的管理；</p>
</li>
<li><p>根据测试用例执行功能测试；</p>
</li>
<li><p>使用Fiddler进行抓包和分析问题，用禅道对bug进行管理跟踪；</p>
</li>
<li><p>运用Mysql数据库执行SQL语句；</p>
</li>
<li><p>使用Jmeter工具对接口进行测试；</p>
</li>
<li><p>负责产品上线后的基本功能验证，保证产品的正常使用；</p>
</li>
<li><p>编写测试报告，向上级汇报工作情况；</p>
</li>
</ol>
</li>
<li><p>项目名称：菜无忧                                                  2017.04—2019.04</p>
<h6 id="描述：菜无忧运营以精、简、快为主旨的零售创新模式，依托创新性和落地性的生鲜前置仓，-产品适用于生鲜配送、莱央厨、团膳食堂、餐饮酒店等企业并严控产品品质和食品安全体系。"><a href="#描述：菜无忧运营以精、简、快为主旨的零售创新模式，依托创新性和落地性的生鲜前置仓，-产品适用于生鲜配送、莱央厨、团膳食堂、餐饮酒店等企业并严控产品品质和食品安全体系。" class="headerlink" title="描述：菜无忧运营以精、简、快为主旨的零售创新模式，依托创新性和落地性的生鲜前置仓， 产品适用于生鲜配送、莱央厨、团膳食堂、餐饮酒店等企业并严控产品品质和食品安全体系。"></a><strong>描述：菜无忧运营以精、简、快为主旨的零售创新模式，依托创新性和落地性的生鲜前置仓，</strong> <strong>产品适用于生鲜配送、</strong>莱央厨、团膳食堂、餐饮酒店等企业并严控产品品质和食品安全体系。</h6><h6 id="1-参与项目内需求的评审和测试用例的编写；"><a href="#1-参与项目内需求的评审和测试用例的编写；" class="headerlink" title="1.参与项目内需求的评审和测试用例的编写；"></a><strong>1.参与项目内需求的评审和测试用例的编写；</strong></h6><h6 id="2-根据测试用例执行功能测试；"><a href="#2-根据测试用例执行功能测试；" class="headerlink" title="2. 根据测试用例执行功能测试；"></a><strong>2. 根据测试用例执行功能测试；</strong></h6><h6 id="3-使用Fiddler进行抓包和分析问题，用禅道对bug进行管理跟踪；"><a href="#3-使用Fiddler进行抓包和分析问题，用禅道对bug进行管理跟踪；" class="headerlink" title="3. 使用Fiddler进行抓包和分析问题，用禅道对bug进行管理跟踪；"></a><strong>3. 使用Fiddler进行抓包和分析问题，用禅道对bug进行管理跟踪；</strong></h6><h6 id="4-运用Mysql数据库执行SQL语句；"><a href="#4-运用Mysql数据库执行SQL语句；" class="headerlink" title="4. 运用Mysql数据库执行SQL语句；"></a><strong>4. 运用Mysql数据库执行SQL语句；</strong></h6><h6 id="5-使用Jmeter工具对接口进行测试；"><a href="#5-使用Jmeter工具对接口进行测试；" class="headerlink" title="5. 使用Jmeter工具对接口进行测试；"></a><strong>5. 使用Jmeter工具对接口进行测试；</strong></h6><h6 id="6-负责产品上线后的基本功能验证，保证产品的正常使用；"><a href="#6-负责产品上线后的基本功能验证，保证产品的正常使用；" class="headerlink" title="6. 负责产品上线后的基本功能验证，保证产品的正常使用；"></a><strong>6. 负责产品上线后的基本功能验证，保证产品的正常使用；</strong></h6></li>
<li><p><strong>项目名称：享旅游                                          2016.10 —2017.04</strong></p>
<p> <strong>描述：这是一个关于旅游的APP项目，能为广大旅游爱好者提供方便、快捷、高效的旅游 服务，既有国内游又有国外游。主要分：首页、订单、消息、我的，四个大的功能模块。</strong></p>
<p> <strong>职责：</strong></p>
<p> <strong>1.根据需求文档编写测试用例以及参与用例的评审；</strong></p>
<p> <strong>2.根据测试用例执行功能测试；</strong></p>
<p> <strong>3.使用禅道对缺陷进行提交和后续的跟踪；</strong></p>
<p> <strong>4.使用Postman工具进行接口测试；</strong></p>
<p> <strong>5.对修改后的缺陷进行回归测试；</strong></p>
<p> <strong>6..对测试工作进行汇总并向组长汇报工作进度情况，版本发布上线。</strong></p>
</li>
<li><p><strong>项目名称：青驿                                               2015.02—2016.09</strong></p>
<p> <strong>描述：青驿是面向旅游用户的内容社交平台。数百万旅友通过它智能结伴、获取攻略、记录旅游、问答交流、讨论行程、旅行地、度假等话题。</strong></p>
<p> <strong>职责：</strong></p>
<p> <strong>1. 参加需求评审，更快的熟悉需求；</strong></p>
<p> <strong>2. 根据需求文档编写测试用例，参加用例评审会议；</strong></p>
<p> <strong>3. 根据测试用例执行功能测试；</strong></p>
<p> <strong>4. 使用禅道工具提交bug跟进bug修复bug</strong></p>
</li>
<li><p>项目名称：每日优鲜              时间：2021年1月—2021年10月</p>
<p> 描述; 每日优鲜是优鲜集团打造的专业生鲜食材供应链同城配送的电商平台，集成了目前线上购物的所有功能.整个系统涉及卖家端，买家端，和平台管理端。功能覆盖到买家常用的地址维护，下单，购物搜索买家常用的商品管理，会员管理，活动管理端，还以平台端，包含的交易管理，商家管理，活动管理。</p>
<p> 我的职责：</p>
<p> 1、参与项目内需求的评审，测试用例的编写与评审；</p>
<p> 2、使用SVN管理项目中所有的文档；</p>
<p> 3、使用mysql数据库进行数据检验，增、删、改、查操作没有问题；</p>
<p> 4、使用的是f12、fiddler配合开发定位问题；</p>
<p> 5、使用禅道和TAPD对Bug进行管理和跟踪；</p>
<p> 6、编写测试报告和测试总结。</p>
</li>
<li><p>项目名称：皮皮虾        时间：2020年7月—2020年12月<br> 项目描述：皮皮虾是一款类似抖音短视频app，功能模块有上传，拍摄，搜索，推荐引擎，等</p>
<p> 我的职责：</p>
<p> 1、 需求分析编写测试用例，用例评审</p>
<p> 2、 根据用例执行功能和接口测试</p>
<p> 3、 使用禅道对bug进行管理和跟踪                                                                                                                           </p>
<p> 4、 配合开发定位问题，使用fiddler、f12</p>
<p> 5、 对修改后的缺陷进行回归测试；</p>
<p> 6、 使用不同品牌不同安卓版本不同屏幕分辨率手机，进行兼容性测试和其它测试；</p>
<p> 7、 编写测试报告和测试总结</p>
</li>
<li><p>项目名称：天天生鲜                         时间2020年8月——2021年9月</p>
<p> 项目描述：天天生鲜是一款电商平台，对于用户而言能够实现登陆，注册，商品浏览，购买等，对于商家而言，实现商品的管理，即添加，修改，删除等。</p>
<p> 职责：</p>
<ol>
<li>参与项目内需求评审，测试用例编写与评审；</li>
<li>使用禅道管理Bug（提交、管理、关闭）；</li>
<li>使用F12，Fiddler工具协助开发定位问题；</li>
<li>使用Jmeter进行接口测试，性能测试。</li>
</ol>
</li>
<li><p>项目名称：智慧分享                                   时间：2020年4月 ——2021年6月</p>
<p>  项目描述：智慧分享是一款团队知识分享产品，通过知识分享、论坛、直播、活动、微课堂等核心应用，满足团队成员的知识管理、学习培训、沟通等多元化的需求，帮助团队成员快速成长，助力团队管理升级。</p>
<p> 职责：</p>
<ol>
<li>参与项目内需求评审，测试用例编写与评审；</li>
<li>在测试中发现Bug，通过禅道提交Bug及时跟踪Bug进度；</li>
<li>使用F12、Fiddler(Postman等)协助开发定位问题解决问题；</li>
<li>使用Mysql数据库进行数据校验；</li>
</ol>
</li>
<li><p>项目名称：TTXX—Powered                                      时间2019年11月——2020年3月</p>
<p> 项目描述：TTXX—Powered  是一款在线课程平台，包含课程分类、付费阅读、在线购物、个人中心等功能，整个系统架构非常简单，适合个人学习提升技能和分享技能。注重界面美感与用户体验，打造独特的技能学习分享平台。</p>
<p> 职责：</p>
<ol>
<li>参与项目内需求评审，测试用例编写与评审；</li>
<li>根据测试用例进行功能测试；</li>
<li>使用禅道管理Bug（提交、管理、关闭）；</li>
<li>使用F12、Fiddler协助开发定位问题；</li>
</ol>
</li>
<li><p>项目名称：飞翼买菜		                                            时间：2021年1月—2021年8月</p>
<p> 飞翼买菜致力于通过产地直采、前置仓配货和最快29分钟配送到家的服务模式，通过技术驱动产业链升级，为用户提供品质确定、时间确定、品类确定的生鲜消费体验。项目主要有前端和后台两个部分，前端包含商品信息、分类、订单、会员、地址、商户中心、客户中心等几个模块，后台包含客户管理、员工管理、仓库管理、运营中心、财务管理、订单管理、促销管理、统计信息等几个功能模块。</p>
<p> 业绩：</p>
<ol>
<li>参加项目的需求评审，编写测试用例</li>
<li>使用jmeter工具进行接口测试</li>
<li>利用fiddler 和 F12抓包协助开发定位问题</li>
<li>用禅道工具管理BUG和跟进BUG</li>
<li>汇报测试报告和测试总结</li>
</ol>
</li>
<li><p>项目名称：快鲸物业管理系统                                           时间：2020年6月—2020年12月</p>
<p> 快鲸智慧物业系统是以企业微信、微信公众号、微信小程序、APP为载体，为小区业主提供在线报修、在线缴费、新闻通知、活动投票等服务，打造线上线下统一的移动物业服务平台。</p>
<p> 本人在项目中的岗位是软件测试工程师，主要负责功能测试和部分项目专项测试</p>
<p> 业绩：</p>
<ol>
<li>参加项目的需求评审，编写项目的测试用例</li>
<li>使用jmter工具对接口进行测试</li>
<li>利用fiddler 和 F12抓包协助开发定位问题</li>
<li>使用禅道工具管理BUG以及跟踪BUG</li>
<li>提交项目报告和总结</li>
</ol>
</li>
<li><p>项目名称：微信来客电商小程序                                        时间：2019年6月—2020年6月</p>
<p> 微信来客电商小程序是来客电商一个分类，同时同步了电商行业主流的营销插件（拼团、砍价、竞拍、优惠卷、满减、秒杀、分销），注重界面美感和用户体验，打造独特的互联网电商生态圈。</p>
<p> 业绩：</p>
<ol>
<li>参加项目的需求评审，编写项目的测试用例</li>
<li>利用禅道工具提交BUG和管理BUG</li>
<li>使用jmter工具对接口进行测试</li>
<li>使用fiddler和F12协助开发定位问题，并协助解决</li>
<li>提交项目报告和总结</li>
</ol>
</li>
<li><p>项目名称：易购商城		                                       时间：2020年9月—2021年9月</p>
<p> 描述：易购商城是一套完善的电子商务系统，通过这个平台可以方便我们买自己想要的商品，并且可以在这个平台建立自己的商铺进行买卖，平台类似于淘宝，京东以便捷，实惠的购物体验服务为核心的，我们这个平台，免费送货上门，无条件退等为客户提供了完美购物，项目主要有前端和后台两个部分，前端包含店铺、品牌、商品、积分中心、用户中心、商家中心、客户中心等几个模块，后台包含控制台、设置、会员、商品、店铺、交易、网站等几个模块。</p>
<p> 职责：</p>
<ol>
<li>参与需求分析编写测试用参与用例评审</li>
<li>根据测试用例对功能进行测试</li>
<li>使用postman进行接口测试</li>
<li>使用fiddler、f12 协助开发定位问题</li>
<li>使用禅道对bug进行管理（提交、跟踪、关闭）</li>
<li>向上级汇报工作进度</li>
</ol>
</li>
<li><p>项目名称：薄荷语音                                                 时间：2020年1月—2020年9月</p>
<p> 描述：薄荷语音是一款app,在这里可以与自己喜欢的主播聊天互动，同样也有情感，聊天交友，助眠类型的房间，给与用户一个放松，缓解压力的空间</p>
<p> 职责：</p>
<ol>
<li>需求分析编写测试用例用例评审</li>
<li>根据用例执行功能和接口测试</li>
<li>使用禅道对bug进行管理和跟踪</li>
<li>使用fiddler、f12配合开发定位问题</li>
<li>对修改后的缺陷进行回归测试；</li>
<li>使用不同品牌不同安卓版本不同屏幕分辨率手机，进行测试</li>
</ol>
</li>
<li><p>项目名称：爱驴游                                                     时间：2018年12月—2019年12月</p>
<p> 描述：这是一个关于旅游的APP项目，能为广大旅游爱好者提供方便、快捷、高效的旅游服务， 既有国内游也有国外游。主要分：首页、订单、消息、我的，四个大的功能模块。</p>
<p> 职责：</p>
<p> 1.熟悉项目需求规格说明书和业务规则；</p>
<p> 2.根据需求文档编写测试用例以及参与用例的评审；</p>
<p> 3.根据测试用例执行功能测试；</p>
<p> 4.使用SVN对缺陷进行管理，使用禅道对缺陷进行提交和后续的跟踪；</p>
<p> 5.使用Postman工具进行接口测试；</p>
<p> 6.对修改后的缺陷进行回归测试；</p>
<p> 9.对测试工作进行汇总并向组长汇报工作进度情况，版本发布上线。</p>
</li>
<li><p>项目名称：自由买菜                                                    时间：2016年9月—2018年12月</p>
<p> 描述：自由买菜运营以精、简、快为主旨的零售创新模式，依托创新性和落地性的生鲜前置仓，实现订单30分钟即时送达，并严控产品品质和食品安全。</p>
<p> 职责：</p>
<p> 参与需求分析，编写测试用例，参与用例评审</p>
<p> 根据测试用例对功能进行测试</p>
<p> 使用postman接口工具进行测试</p>
<p> 使用抓包工具fiddler、f12</p>
<p> 协助开发定位问题，跟踪bug的进度和管理bug</p>
<p> 并向上级汇报工作进度</p>
<p> 项目名称：花粉淘                                                       时间:2013年10月—2014年9月  </p>
<p> 描述：花粉淘是一款拥有海量优惠券的网络商城，有咚咚抢，9.9包邮，人气榜单，抢红包等模块，还有今日上新，每日半价等特色专区，让您享受低廉的价格选购到心动的商品，还有折扣优惠券等你来领取。</p>
<p> 职责：</p>
<ol>
<li>参与需求分析，编写测试用例，参与用例评审</li>
<li>根据测试用例对功能进行测试</li>
<li>使用postman接口工具进行测试</li>
<li>使用抓包工具fiddler、f12，协助开发定位问题</li>
<li>使用tapd工具管理bug</li>
<li>并向上级汇报工作进度</li>
</ol>
</li>
<li><p>项目名称：易购商城		                                       时间：2020年02月—至今</p>
<p> 描述：易购商城是一套完善的电子商务系统，通过这个平台可以方便我们买自己想要的商品，并且可以在这个平台建立自己的商铺进行买卖，平台类似于淘宝，京东以便捷，实惠的购物体验服务为核心的，我们这个平台，免费送货上门，无条件退等为客户提供了完美购物，项目主要有前端和后台两个部分，前端包含店铺、品牌、商品、积分中心、用户中心、商家中心、客户中心等几个模块，后台包含控制台、设置、会员、商品、店铺、交易、网站等几个模块，我在公司主要负责模块会员、商品、店铺。</p>
<p> 职责：</p>
<ol>
<li>参与需求分析编写测试用参与用例评审</li>
<li>根据测试用例对功能进行测试</li>
<li>使用postman进行接口测试</li>
<li>使用fiddler、f12 协助开发定位问题</li>
<li>使用禅道对bug进行管理（提交、跟踪、关闭）</li>
<li>向上级汇报工作进度</li>
<li>使用mylsql数据库进行数据校验</li>
</ol>
</li>
<li><p>项目名称：七天课堂</p>
<pre><code>                                             时间：2019年1月—2020年1月
</code></pre>
<p> 七天课堂，属于c&#x2F;s 架构,是专业的中小学互联网在线教育平台，坚持培养”持续性学习习惯”的教学理念，致力于为10-18岁的孩子提供优质、便捷的在线课外辅导，让孩子利用碎片化时间，享受到低成本，高效率的学习。其产品涵盖K12教育领域的小学、初中的语文，数学，英语，等，优质的在线课程辅导服务。</p>
<p> 分为前段和客服端</p>
<p> 前端主要有（网站首页，讲师，课程，付费阅读，在线购买，）</p>
<p> 客服端主要有（后台首页，系统设置，产品管理，交易管理，会员设置，购买授权，检测更新）</p>
<p> 产品管理（单项管理，商品管理，分类管理，课程管理，讲师管理）</p>
<p> 会员设置（管理员管理，会员管理，商家管理，）</p>
<p> 交易管理（订单管理，统计管理，会员卡充值，付费阅读，在线购买）职责：</p>
<ol>
<li>需求分析编写测试用例用例评审</li>
<li>根据用例执行功能和接口测试</li>
<li>使用禅道对bug进行管理和跟踪</li>
<li>使用fiddler、f12配合开发定位问题</li>
<li>使用mylsql数据库进行数据校验</li>
<li>对修改后的缺陷进行回归测试；</li>
<li>使用不同品牌不同安卓版本不同屏幕分辨率手机，进行专项性能测试</li>
</ol>
</li>
<li><p>项目名称：蔬东坡社区团购</p>
<pre><code>                                                                       2018年03月—2019年01月   
</code></pre>
<p> 通过这个平台可以买到绿色安全的农副产品，专注为生鲜农产品大全流通行业的社区团购运营商、配送商、批发商、半成品加工商、餐饮管理公司大全和生鲜连锁门店提供生鲜配送，可以足不出户就能享受到大自然的味道。项目主要有前端和后端,前端包含首页、店铺、商品分类、积分中心、会员中心、我的中心、商家中心。</p>
<p> 后台包含控制台、设置、会员、商品、店铺、交易、网站等几个模块。</p>
<ol>
<li>参与需求分析，编写测试用例，参与用例评审</li>
<li>根据测试用例对功能进行测试</li>
<li>使用postman接口工具进行测试</li>
<li>使用抓包工具fiddler、f12</li>
<li>协助开发定位问题，跟踪bug的进度和管理bug</li>
<li>并向上级汇报工作进度</li>
<li>使用不同品牌不同安卓版本，不同屏幕分辨率手机，进行专项性能测试</li>
</ol>
</li>
<li><p>项目名称：达方快递														2017年12月—2018年3月   </p>
<p> 达方快递管理系统属于b&#x2F;s 架构，四达快递管理系统是为了适应快递业务的不足各层基本操作的同时，做到了管理层协调管理的简化，进行有效的控制运营。整个系统的管理主要分为系统管理、基础设置、取派、中转、路由、PDA、财务管理、报表管理八个模块</p>
<p> 职责：</p>
<p> 1.熟悉项目需求规格说明书和业务规则；</p>
<p> 2.根据需求文档编写测试用例以及参与用例的评审；</p>
<p> 3.根据测试用例执行功能测试；</p>
<p> 4.使用SVN对缺陷进行管理，使用禅道对缺陷进行提交和后续的跟踪；</p>
<p> 5.使用Postman工具进行接口测试；</p>
<p> 6.对修改后的缺陷进行回归测试；</p>
<p> 9.对测试工作进行汇总并向组长汇报工作进度情况，版本发布上线。</p>
</li>
<li><p>项目名称：e药网                                              				2017年06月—2017年12月</p>
<p> e药网始终致力于用互联网的思维方式，切入数字和移动医疗健康领域，解决中国老百姓”看病难、买药贵”的问题，为社会创造更大的价值。云平台解决方案、智能供应链、大数据、医疗专业能力构建的内核优势，1药网在平台运营、产品采购、供应链管理、医疗服务、顾客体验、仓储配送等各方面构筑起了核心竞争力参与需求分析，编写测试用例，参与用例评审</p>
<ol>
<li>根据测试用例对功能进行测试</li>
<li>使用postman接口工具进行测试</li>
<li>使用抓包工具fiddler、f12，协助开发定位问题</li>
<li>使用bugfree工具管理bug</li>
<li>并向上级汇报工作进度</li>
</ol>
</li>
<li><p>项目名称：正大优鲜                    时间：2021年1月—至今</p>
<p> 属于 b&#x2F;s 架构，通过这个平台可以致力于每个家庭买得省心，吃的放心，让消费者足不出户就能采购到新鲜的产品，生鲜商品100%批次质检，拿到手更安心。<br> 项目分为用户端和商家端，用户端有APP、小程序、web端、商家端分为控制台、设置、会员、商品、店铺、交易、网站等模块。<br> 我在本项目中主要负责：会员、商品、店铺</p>
<p> 我的责任：</p>
<p> 1.参与项目内需求的评审和测试用例的编写；</p>
<p> 2.使用SVN进行项目文档的管理；</p>
<p> 3.使用用禅道对Bug进行管理和跟踪；</p>
<p> 4.使用postman工具对接口进行测试；</p>
<p> 5.使用F12帮助开发人员进行问题定位并协助解决；</p>
<p> 6.编写测试报告，并向上级汇报工作进度情况。</p>
</li>
<li><p>项目名称：智慧校园                     时间：2020年4月—2021年1月</p>
<p> 描述：智慧校园是b&#x2F;s架构 推出的面向全国高校师生的智能校园生活应用，为大学生提供学习、生活、就业等全方位优质服务作为连接校内外优质服务的移动互联网平台，智慧校园一直致力于全方位满足大学生学习成长、社交分享、校园生活、就业深造。今日校园将继续“一切为了大学生成长”为使命，助力国内高校实现高校信息化，享受“智慧校园”的便捷、智能、人性化成果。</p>
<p> 我的责任：</p>
<p> 1.协助测试组长对测试流程进行分析改进；</p>
<p> 2.掌握软件中各种功能以及站在用户角度去体验；</p>
<p> 3.更新时负责模块测试，发现bug，提交bug，反馈后及时跟踪检查；</p>
<p> 4.提交测试报告，进行项目总结。</p>
</li>
<li><p>项目名称：闪送                         时间：2019年8月—2020年4月</p>
<p> 描述：闪送作为目前同城即时速递行业一对一急送平台，是同城即时速递行业的开拓者，定义了一对一急送的服务标准和服务时效。闪送一对一的服务模式，明确闪送员从取件到送达全程一次只服务一个客户，点对点送达，所以服务的时效更快、确定性更高、安全性更好，也能够为客户不同类型的递送提供各种专属化服务</p>
<p> 我的责任：</p>
<p> 1、参与项目内需求的评审，测试用例的编写与评审；</p>
<p> 2、使用SVN管理项目中所有的文档；</p>
<p> 3、使用mysql数据库进行数据检验，增、删、改、查；</p>
<p> 4、配合开发定位问题，使用的是f12；</p>
<p> 5、使用禅道对Bug进行管理和跟踪；</p>
<p> 6、编写测试报告</p>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
        <category>999_面试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>简历编写</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/01_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<ul>
<li>分析<ul>
<li>有价值<br>有亮点<br>易匹配<br>无硬伤</li>
</ul>
</li>
<li>选择一份合适的简历模板<ul>
<li>排版简洁<br>段落清晰<br>重点突出<br>内容完备<br>导出为pdf</li>
</ul>
</li>
</ul>
<p>简历是入职职场的一张名片，也是进入职场一块“敲门砖”。从某种角度说，简历也是一张专业人员的说明书。</p>
<p>软件测试人员作为IT行业具有技术含量的职业，一份优秀的简历包含的内容以及如何写好简历尤为重要。接下来从以下两方面来介绍这个话题：</p>
<blockquote>
<pre><code> 1、简历包含的内容

2、如何写好简历
</code></pre>
</blockquote>
<p>一、简历包含的内容</p>
<p>简历是一张个人说明书，也是有不可缺少的结构和要素的。一般由以下7个部分构成。来，我们来看下：</p>
<blockquote>
<pre><code>1、个人信息 -- 描述个人的基本信息

2、求职意向 -- 描述个人求职的职位、地点等信息

3、教育经历 -- 描述本人毕业时间学习经历等信息

4、专业技能 -- 描述个人具备的专业技能

5、工作经历 -- 描述个人曾经的工作经历

6、项目经验 -- 描述曾经做过的项目，并通过项目体现个人的专业技能

7、个人评价 -- 自己对自己的评价描述
</code></pre>
</blockquote>
<p>自己的简历写完后，一定要检查以上7个要素是否有缺少。</p>
<p>针对以上7个部分，我们分别来介绍，应该如何写，才能铸就一篇好的简历。</p>
<p>二、如何写好简历<br>1、个人信息</p>
<p>如下模板个人信息包含个人：姓名、性别、年龄、工作年限、学历、手机号、电子邮箱等</p>
<p><img src="/assets/2/image-20220516204104-ajzv2xu.png" alt="image.png"></p>
<p>个人信息要求 ：该部分内容是必须的内容，需要准确</p>
<p>关键信息的正确性：姓名、手机号、邮箱地址，联系方式不能出现错误。<br>其他事项（选填）：可以有相片（如果漂亮帅气可以放）、婚姻状态等<br>上述黑色字体内容必须要有，在学历这儿至少要求大专以上。<br>2、求职意向</p>
<p>如下模板求职意向包含信息：求职岗位、意向城市、工作性质、期望薪资。</p>
<p><img src="/assets/2/image-20220516204115-fj2jj43.png" alt="image.png"></p>
<p>求职意向，该部分内容是必须的内容，可以合并到个人信息中去。</p>
<p>工作性质：全职、兼职</p>
<p>求职岗位：体现专一性，可以具体化，如，软件测试工程师、自动化测试工程师、性能测试工程师</p>
<p>意向城市：需要给定意向的城市，不建议简历里包含多个城市（写多个城市会认为个人技能不足）</p>
<p>期望薪资：薪资不建议写出具体值，可以给出范围，一般写面议（市场经济下变化还是比较大的）</p>
<p>3、教育经历</p>
<p>如下模板教育经历包含信息：最高学历学习时间、学校、学历、专业等</p>
<p><img src="/assets/2/image-20220516204122-86w8bzd.png" alt="image.png"></p>
<p>教育经历，该部分内容是非必须内容，如果写教育经历时间需要和个人信息的工作年限能对应上。</p>
<p>学习时间：写最高学历的教育经历时间</p>
<p>毕业学校：如果是985&#x2F;211等院校，赶紧写；一般普通本科院校直接写；专科高职类院校可以不写</p>
<p>专业：如果是计算机相关专业可以直接写，如果是非计算机相关专业的可以不写</p>
<p>奖励：曾经得到的具有代表性的奖励，不推荐写计算机四级以下的证（如果写IT相关证书，建议有一定含金量的证书）</p>
<p>4、专业技能<br>设计一般的专业技能【模板一】</p>
<p><img src="/assets/2/image-20220516204131-75kq5qu.png" alt="image.png"></p>
<p>设计优秀的专业技能【模板二】</p>
<p><img src="/assets/2/image-20220516204137-ahkr1yr.png" alt="image.png"></p>
<p>专业技能&#x2F;个人技能：该部分内容是必须内容，并且简历中非常重要部分：</p>
<p>专业技能数量要求在8~12条左右为宜</p>
<p>内容需要体现技能的描述及对于技能的应用能力</p>
<p>专业技能数量程度用词</p>
<p>精通：技能非常熟悉，并且能够灵活运用，解决测试中的问题</p>
<p>掌握：对技术技能熟悉，能够运用到实践中去</p>
<p>熟悉：对技术技能能够理解，有一定的动手运用能力</p>
<p>了解：听过，相当于不会</p>
<p>编写的技能描述需要把技术描述出来，还需要将该技术的核心应用简要描述出来</p>
<blockquote>
<pre><code>eg: 上述模板二中的第2、5、6、8、11条

eg: 上述模板一种的第3条，只罗列了技术，并没有体现出核心运用
</code></pre>
</blockquote>
<p>5、工作经历<br>如下模板工作经历，包含曾经从事的工作职位时间名称等信息</p>
<p><img src="/assets/2/image-20220516204210-5aw9oka.png" alt="image.png"></p>
<p>工作经历：该部分内容是非必须内容，简要描述曾经的工作职位和时间经历</p>
<p>曾经公司名称：需要真实存在，能够查询到（即便是已经倒闭&#x2F;破产）</p>
<p>曾经工作时间：时间描述范围和上述个人信息的工作年限和毕业时间要能对应上（不要出现前后的时间矛盾的情况，一看就是不真实的经历）</p>
<p>6、项目经验<br>项目经验包含的核心内容有：项目的基本介绍，干什么用的&#x2F;提供什么服务？项目的用户是谁？项目包含的核心模块？项目对应的核心技术栈？本人（作为测试工程师）如何在项目中开展工作（即如何测试设计和实现测试的过程）。</p>
<p><img src="/assets/2/image-20220516204219-7cj05lk.png" alt="image.png"></p>
<p>项目经验：该部分内容是必须内容，并且简历中非常重要部分，需要体现上述的专业技能</p>
<p>项目时间：可以不写，如果写项目经历时间，同样需要注意和上述教育经历、工作年限时间对应正确</p>
<p>项目名称：需要添加项目名称（公司内部对项目的命名）</p>
<p>项目类型：B&#x2F;S（web类项目） C&#x2F;S（客户端的项目）</p>
<p>项目简介：能够回答项目是干什么的？项目给谁用的？项目的核心模块有哪些？项目包含的技术栈有哪些？（其中如果对于技术实现不清楚的可以不写）</p>
<p>个人职责：</p>
<p>1.描述项目中测试流程，分条列出；</p>
<p>2.在根据流程细化突出职责过程中测试设计与测试执行、缺陷跟踪的核心；</p>
<p>3.在设计与执行过程中需要体现专业技能的描述，并且突出技能的应用</p>
<p>额外附加（面试）</p>
<p>1.在描述专业技能时，需要结合项目的实际案例讲述，并且能够将运用过程能够说出</p>
<p>2.在描述运用核心技能时，最好也能通过具体案例描述分析定位解决问题的能力（比如过程中遇到过影响较深的bug，你是如何分析定位，最后如何协助研发解决等过程，当然你列举的例子具有一定深度，不是一般的bug）</p>
<p>7、个人评价<br>个人评价一般是由个人主观总结的。0</p>
<p><img src="/assets/2/image-20220516204229-k0e099c.png" alt="image.png"></p>
<p>自我评价：该部分内容是非必须内容，建议填写</p>
<p>能体现出测试人员具备的一些521素质（专心、细心、耐心、责任心、自信心；沟通能力、总结能力；团队合作精神）</p>
<p>如果经常研究技术，可以涉及一些技术文档链接，的确是自己的总结编写的，且是批量的。</p>
<p>三、写在最后<br>总之，简历是职业人的一张“名片”，需要突出重点（专业技能）和优势（项目经验核心能力），简历能够给求职路上的你约到面试的机会。具备扎实的技能基础上，适当的包装可以让你成为测试这条岭上最靓的那个“仔”，剩下的就是看你面试的表达能力了，加油！<br><br /></p>
<ul>
<li><a href="02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/02_%E7%AE%80%E5%8E%86%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8E%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/">简历的内容与逻辑结构</a></li>
<li><a href="02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/03_%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/">简历模板</a></li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>09_简历编写</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>简历的内容与逻辑结构</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/02_%E7%AE%80%E5%8E%86%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8E%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li>个人信息<ul>
<li>姓名</li>
<li>性别</li>
<li>联系方式</li>
<li>出生日期</li>
<li>工作经验</li>
<li>所在城市</li>
<li>到岗时间</li>
</ul>
</li>
<li>职业技能<ul>
<li>层次感-由浅入深     软件测试流程，数据库，编程语言，框架</li>
<li>有度量-避免纯粹的罗列，增加可度量的信息，让面试官对你的能力更有感知<ul>
<li><img src="/assets/1/image-20211120235052-y2bf7bf.png" alt="image.png"></li>
</ul>
</li>
<li>反例：熟悉软件测试流程，熟悉python语言，了解shell语言，熟悉appium测试框架</li>
<li>合并小的技能点</li>
</ul>
</li>
<li>工作经历<ul>
<li>公司名称</li>
<li>起始时间</li>
<li>职位名称（高级测试工程师&#x2F;测试开发工程师&#x2F;项目组长&#x2F;测试经理&#x2F;测试总监）</li>
<li>负责事项-对你在公司的所负责事情一个概括总结</li>
<li>所取得成果-优秀员工&#x2F;为团队赋能</li>
<li>常见问题：时间顺序不对，信息冗余</li>
<li><img src="/assets/1/image-20211120235145-jy99j5o.png" alt="image.png"></li>
</ul>
</li>
<li>项目经验<ul>
<li>项目经验的书写使用STAR法则<ul>
<li>stuation（情景）：要解决的问题和背景</li>
<li>task（任务）：承担的责任和角色</li>
<li>action（行为）：方案和做法</li>
<li>result（结果）：效果和意义</li>
<li><img src="/assets/1/image-20211120235227-8cc7bhv.png" alt="image.png"></li>
</ul>
</li>
<li>示范<ul>
<li><img src="/assets/1/image-20211120235310-ge9ge7x.png" alt="image.png"></li>
</ul>
</li>
<li>常见问题：<ul>
<li>有十年+工作经验，做过的项目非常多，导致简历篇幅过长</li>
<li>项目经验没有亮点</li>
<li>几段项目经验重复度非常高</li>
<li>产品功能描述不清楚</li>
<li>缺少可量化的数据</li>
</ul>
</li>
</ul>
</li>
<li>教育经验<ul>
<li><img src="/assets/1/image-20211120235345-diyidk8.png" alt="image.png"></li>
</ul>
</li>
<li>自我评价<ul>
<li><img src="/assets/1/image-20211120235352-1bb1tje.png" alt="image.png"><ul>
<li><img src="/assets/1/image-20211120235402-pi4n3vj.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211120235405-0kaztpm.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>09_简历编写</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>简历模板</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E7%AE%80%E5%8E%86%E7%BC%96%E5%86%99/03_%E7%AE%80%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>**							个人简历**</p>
<p><img src="/assets/1/wpsAB08.tmp-20211204160532-fbqhei4.png"></p>
<p><img src="/assets/1/wpsAB09.tmp-20211204160532-8eogch6.png"></p>
<table>
<thead>
<tr>
<th align="center"><strong>姓名：</strong></th>
<th><strong>肖</strong>XX</th>
<th><strong>性别：</strong></th>
<th><strong>男</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">居住地：</td>
<td><strong>上海市</strong></td>
<td><strong>出生：</strong></td>
<td><strong>1988.1.28</strong></td>
</tr>
<tr>
<td align="center"><strong>学历：</strong></td>
<td><strong>本科</strong></td>
<td><strong>毕业时间：</strong></td>
<td><strong>2014.7.1</strong></td>
</tr>
<tr>
<td align="center"><strong>岗位：</strong></td>
<td><strong>软件测试工程师</strong></td>
<td><strong>工作年限：</strong></td>
<td><strong>5年</strong></td>
</tr>
<tr>
<td align="center"><strong>电话：</strong></td>
<td><strong>XXXXXXXXXXX</strong></td>
<td><strong>邮箱：</strong></td>
<td><strong>XXXXXX</strong> <strong>@163.com</strong></td>
</tr>
</tbody></table>
<p><img src="/assets/1/wpsAB1A.tmp-20211204160532-mka84wt.png"></p>
<p><img src="/assets/1/wpsAB1B.tmp-20211204160532-9j5fvdg.png"></p>
<h5 id="工作时间："><a href="#工作时间：" class="headerlink" title="工作时间："></a>工作<strong>时间：</strong></h5><p>*<em>2019.05—2021.10              <strong><strong>苏州</strong></strong>XXX</em><em><strong>计算机科技有限公</strong></em><em>司              软件测试工程师</em>*</p>
<p><em>2016.10—2019.04               <strong><strong>苏州</strong></strong>XX<strong>信息科技股份有限</strong></em>公司　　        软件测试工程师</p>
<p><em>2015.02—2016.09               南京<strong>XX</strong></em>软件有限公司                            软件测试工程师　</p>
<p><img src="/assets/1/wpsAB1C.tmp-20211204160532-99miff9.png"></p>
<p><img src="/assets/1/wpsAB1D.tmp-20211204160532-dm5mmcm.png"></p>
<p><strong>2010.9-2014.7</strong>             <strong>郑州<strong><strong>XX</strong></strong>学院           计算机科学与技术</strong>          <em>本科</em></p>
<p><img src="/assets/1/wpsAB1E.tmp-20211204160532-mgpha29.png"></p>
<p><img src="/assets/1/wpsAB1F.tmp-20211204160532-qw52apk.png"></p>
<p><strong>1.根据需求编写测试用例，并进行评审；</strong></p>
<p><strong>2.熟练使用myspl语句增、删、改、查、数据库；</strong></p>
<p><strong>3.熟练使用f12、fiddler抓包工具定位问题；</strong></p>
<p><strong>4.熟练使用postman进行接口测试；</strong></p>
<p><strong>5.熟练使用禅道工具提交bug跟踪bug进度；</strong></p>
<p><strong>6.熟练使用<strong><strong>L</strong></strong>inux的基本命令操作；</strong></p>
<p><img src="/assets/1/wpsAB20.tmp-20211204160532-o6r2nk8.png"></p>
<p><img src="/assets/1/wpsAB21.tmp-20211204160532-ttkk4fv.png"></p>
<p>项目名称：叮叮　　　　　　　　                                                     2020.08—2021.10</p>
<p> <strong>描述：</strong> <strong>叮叮属于</strong> <strong>app办公用软件</strong>  <strong>（官方说法）用于和企业管理系统集成，实现业务流程、任务、公告的相关提醒等。具有通讯聊天、群聊、传送文件、、</strong> <strong>发表评论留言、消息签收、语音、视频、网络硬盘、公告、视频会议的软件工具。支持上万</strong> <strong>家企业使用方便 、安全、快捷</strong> <strong>。</strong></p>
<p><strong>职责：</strong></p>
<p><strong>1、参与项目内需求的评审，测试用例的编写与评审；</strong></p>
<p><strong>2、使用SVN管理项目中所有的文档；</strong></p>
<p><strong>3、使用mysql数据库进行数据<strong><strong>校</strong></strong>验</strong></p>
<p><strong>4、使用f12、fiddler</strong> <strong>执行操作</strong>  <strong>；</strong> <strong>协助开发定位问题，</strong></p>
<p><strong>5、使用禅道工具跟踪bug修复bug</strong></p>
<p>项目名称：聚淘宝                                                 2019.05—2020.08                  </p>
<p><strong>描述：聚淘宝是一套完善的电子商务系统,通过这个平台可以方便消费者买自己想要的商品，并描且可以在这个平台建立自己的商铺进行买卖，平台类似于淘宝，360、实惠购物体验服务为核心的，我们这个平台，免费送货上门，无条件退等为客户提供了完美购物，项目主要有前端和后台两个部分，前端包 含店铺、品牌、商品、积分中心、用户中心、商家中心、客户中心等几个模块，后台包含控制台、设置、会员、商品、店铺、交易、网站等几个模块 。</strong></p>
<p><strong>职责：</strong></p>
<p><strong>1.参与项目内需求的评审和测试用例的编写；</strong></p>
<p><strong>2. 使用SVN进行项目文档的管理；</strong></p>
<p><strong>3. 根据测试用例执行功能测试；</strong></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>09_简历编写</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官最常问的面试题及答案</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/01_%E9%9D%A2%E8%AF%95%E5%AE%98%E6%9C%80%E5%B8%B8%E9%97%AE%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<p>1、web测试和APP测试的区别？<br>web测试和APP测试都离不开测试的基础知识和测试原理。</p>
<p>不同点是：web 测试更多的是考虑自身功能和浏览器兼容，app 测试要考虑手机本身固有的属性，所以 app 测试还需要注意以下几点：</p>
<p>中断测试（来电去电，短信，蓝牙，NFC 支付，闹钟，数据线插拔，锁屏，断电，关机重启等）</p>
<p>安装卸载测试（全新安装，新版本覆盖旧版本，卸载旧版本安装新版本，卸载新版本安装旧版本）</p>
<p>外在因素测试（网络切换，硬件按键，不同分辨率，兼容性，系统，系统版本）</p>
<p>2、如何测试一个APP的登录场景<br>页面基本元素的操作；</p>
<p>大量字符，特殊字符，边界值，必填项校验；</p>
<p>注册手机号的特殊性验证，注册邮箱的格式验证；</p>
<p>密码大小写是否敏感，密码是否加密展示，密码是否有可见按钮功能，密码框能否使用复制粘贴；</p>
<p>验证码校验：必填项，过期，错误，无网络时获取验证码，多次获取，超过获取次数，输入验证码后，修改手机号；</p>
<p>登录时与系统的交互：锁屏，蓝牙，home，后退，横竖屏，修改字体字号；</p>
<p>逆向思维：已注册账号注册，未注册账号忘记密码，未注册账号登录，注册过程中退出再次注册；</p>
<p>输入法交互，切换输入法，切换输入模式，手写&#x2F;九宫格；</p>
<p>登录账号的多样性：多个账号轮流登录，同一个账号多角色登录；</p>
<p>第三方登录验证：账号授权，信息正确，取消授权；</p>
<p>登录页面跳转，返回，登录成功及其他页面跳转；</p>
<p>手机兼容性测试：分辨率兼容，系统兼容，系统版本兼容，App 版本兼容；</p>
<p>网络切换，网络断开，弱网。</p>
<p>3、push消息如何测试？<br>检查 Push 消息是否按照指定的业务规则发送；</p>
<p>检查不接收推送消息时，用户不会再接收到 Push 消息；</p>
<p>如果用户设置了免打扰的时间段，检查在免打扰时间段内，用户接收不到 Push。在非免打扰时间段内，用户能正常收到 Push；</p>
<p>当 Push 消息是针对登录用户的时候，需要检查收到的 Push 与用户身份是否相符，没有错误的将其他人的消息推送过来。一般情况下，只对手机上最后一个登录用户进行消息推送；</p>
<p>测试 Push 时，在开关机、待机状态下执行推送，消息及其推送跳转的正确性；</p>
<p>push 消息时，会有红点展示，推送消息阅读前后数字的变化是否正确；</p>
<p>应用在开发、未打开状态、应用启动且在后台运行的情况下是 push 显示和跳转是否正确；</p>
<p>多条推送的合集的显示和跳转是否正确。</p>
<p>4、APP的闪退通常是什么原因？<br>缓存垃圾太多，Android 系统的特性，如果长时间不清理垃圾文件，会导致越来越卡，甚至闪退；</p>
<p>运行程序太多，导致内存不足；</p>
<p>应用版本兼容问题，分辨率兼容问题；</p>
<p>APP访问网络的地方，组件能否正常下载并显示；</p>
<p>APP的 SDK 与手机系统不兼容；</p>
<p>系统升级后，新版本不兼容老版本的 API，返回对象失败，报空指针；</p>
<p>软件权限未开放。</p>
<p>5、测试过程中遇到 app 出现 crash 或者 ANR，你会怎么处理？<br>APP 出现 Crash 或 ANR，可以从以下几个方面处理：</p>
<p>可以先把日志过滤出来：adb logcat | findstr xxxxx(过滤日志信息) ；</p>
<p>然后再搜索其中的关键字，比如：exception、crash，看看是哪些方法或者异常导致了问题；</p>
<p>初步定位问题原因后，可以交给开发人员去具体查找深层原因并修复。</p>
<p>6、你平常会看日志吗, 一般会出现哪些异常（Exception）?<br>常见的几种如下：</p>
<p>NullPointerException - 空指针引用异常</p>
<p>ClassCastException - 类型强制转换异常</p>
<p>IllegalArgumentException - 传递非法参数异常</p>
<p>ArithmeticException - 算术运算异常</p>
<p>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常</p>
<p>IndexOutOfBoundsException - 下标越界异常</p>
<p>NegativeArraySizeException - 创建一个大小为负数的数组错误异常</p>
<p>NumberFormatException - 数字格式异常</p>
<p>SecurityException - 安全异常</p>
<p>UnsupportedOperationException - 不支持的操作异常</p>
<p>7、APP 测试的内容主要包括哪些，如何开展？<br>功能测试：</p>
<p>业务逻辑正确性测试：依据产品文档-&gt;测试用例编写。</p>
<p>兼容性测试：</p>
<p>1.系统版本：Android:官方版本,定制版本;IOS：官方提供版本。</p>
<p>2.分辨率：720 * 1280 1080* 1920。</p>
<p>3.网络情况:2g 3g 4g 5g Wi-Fi。</p>
<p>异常测试：</p>
<p>1.热启动应用:应用在后台长时间待机;应用在后台待机过程中，手机重启。</p>
<p>2.网络切换和中断恢复:网络切换;中断恢复。</p>
<p>3.电话信息中断恢复。</p>
<p>升级，安装，卸载测试：</p>
<p>1.升级测试：临近版本升级(1.0-&gt;1.1);跨版本(1.0-&gt;…-&gt;2.2)。</p>
<p>2.安装测试：首次安装;覆盖安装(同版本，不同版本覆盖);卸载后安装。</p>
<p>3.卸载测试：首次卸载;卸载安装后再卸载。</p>
<p>健壮性测试：</p>
<p>1.手机资源消耗：cpu，内存。</p>
<p>2.流量消耗：图片，数据，视频。</p>
<p>3.电量测试。</p>
<p>4.崩溃恢复。</p>
<p>8、APP 性能测试关注点及常见 APP 性能测试工具<br>包体大小：</p>
<p>包体大小能被列为性能指标，是从 APP 性能指标及运营两个维度考虑的，用户是更希望包体小的同时性能要好，有时它们会是一个互相取舍的关系。</p>
<p>启动时长：</p>
<p>移动应用的启动时间是用户体验的一个重要方面，IOS 一直建议尽可能的缩短启动时间，防止用户不愿意使用它们。对于浏览器而言，由于程序启动时还会有教育页和闪屏的下发，因此启动时间的获取显得尤为重要。</p>
<p>启动时间分为冷启动时间和热启动时间，所谓的“冷启动”，就是一个完全没有运行的应用的启动时间，与热启动（应用已经在后台运行，某个事件将其带至前台）相比，由于此时系统尚未建立缓存，因此冷启动往往要较平时（热启动）耗费更长的时间。</p>
<p>内存使用：</p>
<p>在 Android 系统中，每个 APP 进程除了同其他进程共享(shared dirty)外，还独用私有内存(private dirty)，通常我们使用 PSS(&#x3D;私有内存+比例分配共享内存)来衡量一个 APP 的内存开销。移动设备的内存资源是非常有限，为每个 APP 进程分配的私有内存也是有限制。一方面我们要合理的申请内存使用，以免导致频繁的 GC（垃圾回收机制）影响性能和大对象申请发生内存溢出；另一方面，我们要及时释放内存，以免发生内存泄漏。</p>
<p>CPU 占用率：</p>
<p>一般情况下，用主流手机使用 APP20%-40%的 CPU 占用率算是合理的，当然这个数值随着近年来手机硬件配置的提高，会略微下降，如果 CPU 占用率超过 80%就非常值得我们去关注了。</p>
<p>图片处理器每秒刷新的帧数(FPS)：</p>
<p>可用来指示页面是否平滑的渲染。手机 APP 帧率 FPS，30-60 都可接受，上了 60 对于人眼主观感受差别就不大了。对于移动应用开发而言，并不是 FPS 越高就一定越好，FPS 取决于显卡，其次是内存、CPU，然后是网络。故综合 APP 其他性能指标，选择一个适合的 FPS 即可。</p>
<p>电量：</p>
<p>相对于 PC 来说，移动设备的电池电量是非常有限的，保持持久的续航能力尤为重要。另外，android 的很多特性都比较耗电(如屏幕，GPS，sensor 传感器，唤醒机制，CPU，连网等的使用)，我们必须要慎重检查 APP 的电量使用，以免导致用户手机耗电发热，带来不良体验。</p>
<p>流量：</p>
<p>目前的网络类型包含 2G\3G\4G\5G\wifi，其中还有不同运营商的区分，我们在 APP 的使用中经常遇到大资源，重复请求，调用响应慢，调用失败等各种情况。在不同的网络类型之下，我们不仅要控制流量使用，还需要加快请求的响应。另外，对于需要联网的手游来说，部分游戏对不同联网方式的网络类型采用了不同的流量消耗策略，主要分为 wifi 环境和蜂窝网络环境。所以针对不同的游戏，我们统计流量消耗时，可能要连接不同的网络进行测试。</p>
<p>app 性能测试工具</p>
<p>GT 和 iTest，Emmagee APT ，DDMS ，手机自带开发者选项中的工具，也可以通过 adb 命令来查看等。</p>
<p>9、如何对 app 进行弱网测试<br>弱网测试可以测试 APP 的加载时间、可用性、稳定性和健壮性。这时我们就可以借助工具来模拟不同的网络状况，模拟 2G、3G 或弱网情况进行测试。工具可以选择 Fiddler 也可以选择 Charles 也可以选择其他工具。</p>
<p>10、常见的 adb 命令<br>注：adb 使用的端口号是 5037，以下总结工作中常用到的 adb 命令。</p>
<p>1.查看帮助手册列出所有的选项说明及子命令：<br>adb help</p>
<ol start="2">
<li>获取设备列表及设备状态：<br> adb devices</li>
</ol>
<p>3.安装应用：adb install 路径\xx.apk, 安装应用；adb install -r 重新安装。<br>adb install</p>
<p>adb install -r</p>
<ol start="4">
<li>获取设备的状态，设备的状态有 device , offline , unknown3 种，其中 device：设备正常连接，offline：连接出现异常，设备无响应，unknown：没有连接设备。<br> adb get-state</li>
</ol>
<p>5.卸载应用：adb uninstall &lt;包名&gt;, 后面的参数是应用的包名，区别于 apk 文件名。<br>adb uninstall</p>
<p>6.将 Android 设备上的文件或者文件夹复制到电脑本地：adb pull &lt;远程路径&gt; &lt;本地路径&gt;, 如复制 Sdcard 下的 pull.txt 文件到 D 盘：adb pull sdcard&#x2F;pull.txt d:\，重命名：adb pull sdcard&#x2F;pull.txt d:\rename.txt。<br>adb pull</p>
<p>7.推送本地文件至 Android 设备：adb push &lt;本地路径&gt; &lt;远程路径&gt;, 如推送 D 盘下的 ITester.txt 至 Sdcard：adb push d:\ITester.txt sdcard&#x2F; （注意 sdcard 后面的斜杠不能少）。<br>adb push</p>
<p>8.结束和启动 adb 服务：adb kill-server &#x2F;adb start-server , 结束 adb 服务&#x2F;启动 adb 服务，通常两个命令一起用，设备状态异常时使用 kill-server，运行 start-server 进行重启服务。<br>adb kill-server</p>
<p>adb start-server</p>
<p>9.打印及清除系统日志：adb logcat , 打印 Android 的系统日志 ；adb logcat -c,清除日志。<br>adb logcat</p>
<p>adb logcat -c</p>
<p>10.查找包名&#x2F;活动名<br>adb logcat | findstr START</p>
<p>11.生成 bugreport 文件：adb bugreport , 打印 dumpsys、dumpstate、logcat 的输出，也是用于分析错误，输出比较多，建议重定向到一个文件中，如 adb bugreport &gt; d:\bugreport.log。<br>adb bugreport</p>
<ol start="12">
<li>重启 Android 设备：adb reboot , adb reboot recovery，重启到 Recovery 界面；adb reboot bootloader，重启到 bootloader 界面。<br> adb reboot</li>
</ol>
<p>adb reboot recovery</p>
<p>adb reboot bootloader</p>
<p>13.获取 root 权限：adb root , adb remount,可以直接获取 root 权限，并挂载系统文件系统为可读写状态。<br>adb root</p>
<p>adb remount</p>
<p>14.返回设备序列号 SN 值：<br>adb get-serialno</p>
<p>15.获取设备的 ID：<br>adb get-product</p>
<p>16.进入设备 shell：<br>adb shell</p>
<p>17.列出所有的应用的包名：<br>adb shell pm list package</p>
<p>18.截屏并保存至 sdcard 目录：<br>adb shell screencap -p &#x2F;sdcard&#x2F;screen.png</p>
<p>19.录制视频并保存至 sdcard：adb shell screenrecord sdcard&#x2F;record.mp4,执行命令后操作手机，ctrl + c 结束录制，录制结果保存至 sdcard：<br>adb shell screenrecord sdcard&#x2F;record.mp4</p>
<p>20.获取设备分辨率：<br>adb shell wm size</p>
<p>21.列出指定应用的 dump 信息，adb shell pm dump 包名。<br>adb shell pm dump</p>
<p>22.列出对应包名的 .apk 位置，adb shell pm path 包名。<br>adb shell pm path</p>
<p>23.查看当前终端中的进程信息：<br>adb shell ps</p>
<p>24.monkey 测试：adb shell monkey –p 程序包 –v 测试次数 ,比如“adb shell monkey –p com.htc.Weather –v 20000”意思是对 com.htc.Weather 这个程序包单独进行一次 20000 次的 monkey 测试。<br>adb shell monkey –p 程序包 –v 测试次数</p>
<p>25.显示所有程序包：<br>adb shell ps | grep [process]</p>
<p>26.根据进程 pid 或包名查看进程占用的内存：<br>adb shell dumpsys meminfo</p>
<p>adb shell dumpsys meminfo<package_name></p>
<ol start="27">
<li>APP 启动：<br> adb shell am start -n packageName&#x2F;activity</li>
<li>APP 关闭：<br> adb shell am force-stop 包名</li>
</ol>
<p>29.监控 APP 启动时间：<br>adb shell am start -W packageName&#x2F;activity</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>10_模拟面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>项目</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/08_%E7%AC%AC%E5%85%AB%E7%AB%A0%E9%A1%B9%E7%9B%AE/01_%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<ol>
<li><h3 id="简单介绍下最近做过的项目"><a href="#简单介绍下最近做过的项目" class="headerlink" title="简单介绍下最近做过的项目"></a>简单介绍下最近做过的项目</h3><ol>
<li>根据自己的项目整理完成</li>
</ol>
</li>
<li><h3 id="拿一个你所负责的模块，讲下具体怎么测的？"><a href="#拿一个你所负责的模块，讲下具体怎么测的？" class="headerlink" title="拿一个你所负责的模块，讲下具体怎么测的？"></a>拿一个你所负责的模块，讲下具体怎么测的？</h3><ol>
<li>根据自己的项目整理完成</li>
</ol>
</li>
<li><h3 id="你在这个项目里面主要做了些什么工作"><a href="#你在这个项目里面主要做了些什么工作" class="headerlink" title="你在这个项目里面主要做了些什么工作"></a>你在这个项目里面主要做了些什么工作</h3><ol>
<li>【根据自己的简历上的工作职责来回答，写了什么职责就回答什么】</li>
<li>参考答案：<ol>
<li>前期做得做得比较多的就是功能测试跟接口测试，主要就是需求分析，用例编写，组织用例评审会议，例外就是写测试计划，测试报告，协助开发定位分析问题，执行用例，跟踪 Bug。每天都要写工作计划等。后期有主要就是做 App 的一些专项测试<br> 另外就是参与了项目的一些接口自动化脚本的编写与调试等。<br> 不过，最近这个项目有做一些性能测试，主要就是并发跟压测这块。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="你们项目组有多少人，开发多少个，测试多少个？"><a href="#你们项目组有多少人，开发多少个，测试多少个？" class="headerlink" title="你们项目组有多少人，开发多少个，测试多少个？"></a>你们项目组有多少人，开发多少个，测试多少个？</h3><ol>
<li>【这个一定要根据自己的简历项目大小来说，不能乱说】</li>
<li>一般测试与开发大概就是 1:4 的比例回答。一个项目组大概 13-20 个人算是正常的，自己根据自己的项目大小来定。</li>
<li>产品 1，项目 1个，架构师 1个，前端 3个，后端 5个，ios 1个，Android 1个，测试 3个（测试主管，核心测试人员），运维1个，ui一个</li>
</ol>
</li>
<li><h3 id="测试人员怎么分工的？"><a href="#测试人员怎么分工的？" class="headerlink" title="测试人员怎么分工的？"></a>测试人员怎么分工的？</h3><ol>
<li>参考答案：一定要把自己的项目吃透，结合自己的项目来讲，要把项目的核心业务流程吃透。</li>
<li>项目组的分工一般两种规则：<ol>
<li>根据模块来划分，自己领取各自熟悉的模块负责，或者由老大来分配工作任务。</li>
<li>根据端来划分，要不负责前端的web端，要不负责前端的 app端，要不就是负责后台。</li>
<li>前端的某些功能设计要后台的模块关联的，一般都要考虑后台的数据检查问题，涉及业务流程性的，测试前端的要考虑后台，测后台的也要考虑前端，都要同时关注。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="项目的迭代周期？多久一迭代？一个版本你们发现多少-bug"><a href="#项目的迭代周期？多久一迭代？一个版本你们发现多少-bug" class="headerlink" title="项目的迭代周期？多久一迭代？一个版本你们发现多少 bug"></a>项目的迭代周期？多久一迭代？一个版本你们发现多少 <strong>bug</strong></h3><ol>
<li>【切记根据自己所选择的项目来回答】</li>
<li>参考答案 1：<ol>
<li>我们公司是这样的，迭代还是蛮快的，一般是两个星期一个迭代，迭代测试两轮，一轮sit,一轮uat。</li>
<li>Bug的话不一定哦，关键还得看开发，哈哈，开发的版本质量好的话，BUG就会少些，整个版本比较好的情况下大概也就二十来个 BUG，当然如果遇到开发是个新手，那么找到 60个 70 个也是很常见的，比如之前的那个项目，足足发现了 72个BUG，这样的情况下追踪 BUG 的工作量都比较的大，如果是版本迭代的话，那么基本就不会出现多少 BUG了</li>
</ol>
</li>
<li>参考答案 2：<ol>
<li>因为我们项目的用户活动和三方合作平台比较多，一般半个月或者 1个月肯定会有一个迭代版本。假如用户或者合作方突然有很紧急的需求，那一般老大他们会向上发邮件和 oa呈批给（产品经理，项目经理），如果通过了就会马上加急处理这个需求，测试完成直接上线。</li>
<li>现在都是维护为主，但新需求也不断有，一般一个版本上百个 bug 是有的。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="你们公司有几套环境"><a href="#你们公司有几套环境" class="headerlink" title="你们公司有几套环境"></a>你们公司有几套环境</h3><ol>
<li>三套环境，sit环境，uat环境， 线上环境</li>
</ol>
</li>
<li><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ol>
<li><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/01_apache%E7%8E%AF%E5%A2%83/">Apache</a><ol>
<li>安装apache</li>
<li>安装php</li>
<li>安装mysql</li>
</ol>
</li>
<li><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/02_Tomcat%E7%8E%AF%E5%A2%83/">Tomcat</a><ol>
<li>安装jdk、配置环境变量</li>
<li>安装Tomcat</li>
<li>安装mysql</li>
</ol>
</li>
<li>iis<ol>
<li>iis 只能在windows使用，而且iis 还是windows自带的，不安全</li>
</ol>
</li>
<li><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/03_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">持续集成</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>08_第八章项目</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题问题分析</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/01_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>笔试题<ul>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/03_%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/">给一个需求，设计测试用例</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/04_%E9%80%BB%E8%BE%91%E6%80%A7%E9%97%AE%E9%A2%98/">逻辑性问题</a></li>
<li><a href="">数据库相关</a></li>
</ul>
</li>
<li>面试题<ul>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/01_%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/">自我介绍</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/02_%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/">项目介绍</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/05_%E4%B8%AA%E4%BA%BA%E9%97%AE%E9%A2%98/">个人问题</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/06_%E5%BC%80%E6%94%BE%E6%80%A7%E9%97%AE%E9%A2%98/">开放性问题</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>自我介绍</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/999_%E9%9D%A2%E8%AF%95%E6%96%87%E4%BB%B6/01_%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<ol>
<li>面试官好，我是～，做软件测试用工程师～年，会用fidder 和f12抓包协助开发定位问题，用postman做接口测试，我们之前公司用的数据库是MySQL ，对里面的增删改查多表检查都没问题，liux基本命令都会，我们提bug工具是禅道，对用例和bug的管理和跟踪，在项目中，我全程参与了需求评审，测试计划的设定，编写测试用例，执行测试我的自我介绍已完毕，您看我还有什么需要补充的吗？</li>
<li>面试官您好，我叫～，来自于～。做软件测试工作有～年了。在期间做了不少的项目，积累了不少的测试经验，能够独立完成软件测试的测试工作，主要做过功能测试、app专项测试和接口测试方面的工作。对于linux、数据库、fiddler、jmeter的应用都比较熟悉。用jmeter做过一些性能测试，最近一段时间做了自动化测试，主要是用的python+selenium框架实现的，我平常喜欢看看书。这个是我一个简单的自我介绍，您看，我这边还需要做什么补充吗？</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>11_面试题分析</category>
        <category>999_面试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>安全测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/07_%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/01_%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<ol>
<li>安全测试分类：<ol>
<li>web安全  app安全   硬件安全  游戏安全   系统安全</li>
</ol>
</li>
<li><h2 id="数据库方面的"><a href="#数据库方面的" class="headerlink" title="数据库方面的"></a>数据库方面的</h2><ol>
<li>sql注入：<br> 存在于动态网站<br> 文件类型有：.asp  .php  .apsx   .jsp   .do<br> SQL语句</li>
</ol>
</li>
<li><h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><ol>
<li>用户输入非法数据并与后台sql代码进行拼接，并被执行导致数据库中数据的泄露</li>
</ol>
</li>
<li><h3 id="什么是sql注入"><a href="#什么是sql注入" class="headerlink" title="什么是sql注入"></a>什么是sql注入</h3><ol>
<li>利用现有的应用程序，将恶意的sql代码注入带后台数据库中进行引擎执行的行为</li>
</ol>
</li>
<li><h5 id="xss跨站脚本攻击（存储型xss和反射型xss）"><a href="#xss跨站脚本攻击（存储型xss和反射型xss）" class="headerlink" title="xss跨站脚本攻击（存储型xss和反射型xss）"></a>xss跨站脚本攻击（存储型xss和反射型xss）</h5><ol>
<li>跨站脚本攻击（cross site script 为了区别于css简称xss）指的是恶意攻击者往web页面里面插入恶意html代码，当用户浏览该网页时嵌入其中web里面的html代码会被执行，从而达到恶意用户的特殊目的</li>
</ol>
</li>
<li><h5 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h5><ol>
<li>定义<ol>
<li>非法用户通过该漏洞将js脚本存储到数据库中，导致访问该页面内容所有用户受到危害</li>
<li>例如，非法用户可以获取用户的cookie，将cookie值发送到一个地方</li>
</ol>
</li>
<li>防御方法<ol>
<li>对用户输入的内容做过滤（限制，设置黑名单）</li>
<li>对用户输入内容进行解码后在做过滤</li>
</ol>
</li>
<li>跨站请求伪造（csrf）<ol>
<li>因为这个不是用户真正想发出的请求，这就是所谓的请求伪造，因为这些请求也是可以从第三方网站提交的，所以前缀跨站二字</li>
<li>用户登录访问了一个授信任的站点，在用户还没有退出登录的时候，打开另一个tab页，访问了网站B，在B网站中，有csrf攻击代码访问网站A</li>
<li>网站是通过cookie 来识别用户的，当用户成功进行身份验证之后浏览器就会得到一个标识，其身份的cookie，只要不关闭浏览器或者退出登录，以后访问这个网站会带上这个cookie<ol>
<li>登录受信任网站A，并在本地生成cookie</li>
<li>在不登出A的情况下，访问危险网站B</li>
</ol>
</li>
</ol>
</li>
<li>任意文件的下载<ol>
<li>任意文件下载是因为一般的网站提供了下载文件功能，但是在获取文件到下载文件的时候，并没有进行一些过滤，用户可能会顺流而上，下载上级目录页面文件，而这些文件有时候是不对外提供的资源，这就导致了漏洞产生</li>
</ol>
</li>
<li>文件上传（网站限制不严格）<ol>
<li>文件上传是web应用的很常见的一种功能，本身是一项正常的业务需求，不存在什么问题，但如果在上传的时候没有对文件进行正确的处理，则很可能会发生安全漏洞问题</li>
<li>由于服务器端没有对用户上传的文件进行正确的处理，导致攻击者可以向某个可通过web访问的目录上上传任意文件，being且改文件可以被web服务器接卸执行</li>
</ol>
</li>
<li>越权<ol>
<li>横向和纵向<ol>
<li>横向越权:通过修改URL非法进入同级别页面，可以浏览他人的信息的方式就是横向越权</li>
<li>纵向越权：有关手机的越权（安卓手机的root以及苹果手机越狱）都是纵向越权<ol>
<li>产生的原因是权限配置不当造成的危害</li>
<li>暴力破解<ol>
<li>撞库事件：12306<ol>
<li>撞库是黑客通过手机互联网已泄露的用户密码信息，生成对应数据字表，尝试批量登录其他网站，导致系统可以登陆的用户，犹豫很多用户习惯在各大网站和应用使用同一套用户名和密码，这就意味着一旦其中一个站点用户隐私泄露后，就有可能被手机并用做撞库的数据</li>
</ol>
</li>
<li>验证码：动态口令</li>
<li>防止暴力破解的方法<ol>
<li>限制用户登录、访问的次数</li>
<li>添加验证码机制（图片、短信、语音）</li>
<li>加密（123456）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>敏感信息的泄露<ol>
<li>数据加密</li>
<li>加密方式<ol>
<li>https  md5 sha  aes des <ol>
<li>https   &#x3D;   http + ssl   证书：公钥+私钥</li>
<li>https是发出时通过私钥先对请求数据进行加密，然后再使用公钥对数据进行加密，当接收端接受到数据时，先使用公钥对数据进行解密，然后再使用私钥对数据进行解密</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>07_第七章安全测试</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础练习</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/10_python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>一. 数据类型</p>
<ol>
<li>数据类型实战<ol>
<li>示例1：存在一个变量number &#x3D;1 ，如果需要输出格式为“001”应如何实现？<ol start="4">
<li><blockquote>
<p>number &#x3D;1<br>print(“03d” %number)</p>
</blockquote>
</li>
<li>上面的实例中，变量number的数据类型是数值型，如果需要格式化字符串输出，则需要使用%d,相当于使用%d替换number变量的真实值1,即如果表达式是”%d”%number,那么结果实际是输出1;而题目要求输出格式是001，则需要在1前面添加两个0，所以此时可以通过使用03d表示输出3位数值型;如果真实数值只有1位，则会在高位自动补0输出，所以结果可以得到001。</li>
<li>注意：<br> 此处有同学可能会想可不可直接使用pit(0O1)?若采用这种方式输出，终端会提示“不允许十进制<br> 整数前添加0：八进制整型文字前可以使用0作为前缀”。</li>
</ol>
</li>
<li>示例2：存在一个变量number1&#x3D;1.222222,如果需要保留两位小数应如何实现？<ol>
<li><blockquote>
<p>print (“8.2f”Snumber1)</p>
</blockquote>
</li>
<li>上面的示例与示例1类似，示例1主要是对整数的处理，示例2主要是对小数的处理。小数的格式化输出需要使用%f,结合示例1综合分析可知保留两位小数表示为%.2f。</li>
</ol>
</li>
<li>示例3：存在一个变量number2&#x3D;1,如果需要输出“%d1”应如何实现？<ol>
<li><blockquote>
<p>print(“%%d%d”%number2)</p>
</blockquote>
</li>
<li>示例3需要输出“%d”字符串，在字符串格式化输出中%d表示整型占位符，如果需要以字符串的形式输出，则需要在%d前面添加%进行转义。所以上述代码中%%d表示输出“%d”字符串，第二个%d表示number2的占位符，即可得到结果“%d1”。</li>
</ol>
</li>
</ol>
</li>
<li>字符串主流机制问题<ol>
<li>在Python中会出现字符串驻留(intern)的情况，这是由于CPython的优化产生的，即在某些情况下尝试使用现有的不可变对象，而不是每次都创建一个新对象，这些驻留的对象在内部使用类似字典的结构（驻留池）进行驻留。在被驻留之后，许多变量可能指向内存中的相同字符串对象，从而节省内存。简单来说，字符串驻留表示一种方法，能够实现仅仅存储一份相同而又不可变的字符串。字符串存储的非驻留机制与驻留机制如图1.1所示。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>APP自动化</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/09_APP%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[<p>APP自动化</p>
<h2 id="什么是App自动化？为什么要做App自动化？"><a href="#什么是App自动化？为什么要做App自动化？" class="headerlink" title="什么是App自动化？为什么要做App自动化？"></a>什么是App自动化？为什么要做App自动化？</h2><p>App自动化是指给 Android或iOS上的软件应用程序做的自动化测试。<br><strong>手工测试和自动化测试的对比如下：</strong><br> <strong>手工测试优势：</strong> 不可替代、发现更多bug、包含了人的想象力与理解力。</p>
<blockquote>
<p>注意，不是所有功能都需要自动化。<br> <strong>自动化测试优势：</strong> 可重复、效率高，增加软件信任度。<br>执行自动化测试可以让测试同事有更多的精力来关注复杂场景，做更多更深层次的测试。</p>
</blockquote>
<h2 id="风险分析"><a href="#风险分析" class="headerlink" title="风险分析"></a><strong>风险分析</strong></h2><p><strong>自动化测试的主要风险分析如下：</strong><br>（1）测试用例覆盖率（覆盖率决定测试效率，选择合适用例，应约占功能用例集的20%~50%）<br>（2）测试结果准确度（准确度决定了测试有效性，应尽可能减少误报）。<br>（3）自动化代码维护（维护决定了成本，数据关键字驱动自动化框架，代码应尽可能优化和少改动）。<br>（4）版本开发和测试时间进度（当项目需求和功能较为稳定时，建议用自动化）。<br>（5）开发对控件元素增修改的程度（需开发人员尽可能地用name元素，并且和UI设计一致，修改变动程度不大，测试人员可根据提供的元素提前介入，开发自动化脚本）。<br>App源码权限控制，iOS上测试需要源码。实际测试只需SVN或者git下载权限，而不需要上传权限。防止改动SVN或者git 上的源码。</p>
<hr>
<h2 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a><strong>技术框架</strong></h2><p><strong>1、自动化学习过程</strong><br>自动化测试环境的部署–&gt;自动化测试脚本开发能力—&gt;自动化测试框架研发—&gt;手机自动化持续集成<br><strong>2、andorid 系统架构图</strong><br><img src="/assets/1/image-20211205190326-wan8a0k.png" alt="image.png"><br><strong>3、手机自动化测试环境</strong><br>安装Appium–&gt;安装手机模拟器–&gt;安装selenium和appium的客户端–&gt;安装被测试app<br><strong>4、</strong> <strong>Appium 软件架构</strong><br><img src="/assets/1/image-20211205190332-te9euht.png" alt="image.png"><br>5、<strong>常用的定位技术和工具</strong><br><img src="/assets/1/image-20211205190339-t5x1z1g.png" alt="image.png"><br><strong>6、自动化测试脚本技术</strong><br><img src="/assets/1/image-20211205190345-dv6lxzo.png" alt="image.png"><br><strong>7、技术框架结构图</strong><br><img src="/assets/1/image-20211205190351-9b4ojeg.png" alt="image.png"></p>
<hr>
<h2 id="APP自动化测试流程"><a href="#APP自动化测试流程" class="headerlink" title="APP自动化测试流程"></a><strong>APP自动化测试流程</strong></h2><p><strong>1、环境的安装</strong><br><strong>1.1 环境的准备</strong></p>
<ul>
<li>jdk1.6以上</li>
<li>python2.7以上</li>
<li>android-sdk</li>
<li>Appium desktop 安装</li>
</ul>
<p><strong>1.2 jdk 安装</strong></p>
<ul>
<li>下载JDK后傻瓜式安装，<strong>注意：不要有中文路径和空格</strong></li>
<li><strong>配置环境变量：</strong></li>
</ul>
<p><strong>右击“我的电脑”–&gt;”属性”–&gt;”高级系统设置”–&gt;”高级”–&gt;”环境变量”</strong></p>
<ol>
<li>在系统变量里新建”JAVA_HOME”变量，变量值为：C:\Program Files\Java\jdk1.8.0_60（根据自己的jdk的安装路径填写）</li>
<li>在系统变量里新建”classpath”变量，变量值为：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar <strong>(注意最前面有一点)</strong></li>
<li>找到path变量（已存在不用新建）添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</li>
</ol>
<p><strong>1.3 python 安装</strong></p>
<ol>
<li><strong>傻瓜式安装</strong> ，</li>
<li><strong>配置环境变量</strong> ：电脑属性系统变量添加python根目录</li>
</ol>
<p><strong>1.4 安装Android的测试开发环境</strong></p>
<ol>
<li><strong>Android-SDK的安装：</strong> SDK manager.exe 双击打开下载<br><img src="/assets/1/image-20211205190359-2l4539b.png" alt="image.png"></li>
</ol>
<p><strong>2.android-sdk环境变量的配置</strong><br>具体操作步骤：</p>
<ul>
<li><strong>新建ANDROID_HOME</strong><br>路径为C:\Program Files (x86)\Android\android-sdk\</li>
<li><strong>在Path 变量中加入路径</strong><br>%ANDROID_HOME%\platform-tools 和 %ANDROID_HOME%\tools</li>
</ul>
<p><strong>3.检查adb 环境变量</strong><br><img src="/assets/1/image-20211205190406-lp0oe3n.png" alt="image.png"><br><strong>4.连接手机</strong><br>如果是真机，手机插上USB连接电脑，打开开发者模式，cmd输入adb devices<br>如果是模拟器，需要输入adb connect 127.0.0.1:62001或者52001连接，然后再输入adb devices<br><strong>Appium desktop 安装</strong><br>下载地址：<a href="https://github.com/appium/appium-desktop/releases/tag/v1.3.1">https://github.com/appium/appium-desktop/releases/tag/v1.3.1</a><br>傻瓜式安装 注意：一定要选择所有用户权限要不然用不了<strong>UiAutomator2</strong><br><strong>2、 API脚本</strong><br><strong>2.1 如何获取APP启动的AppPackage和AppActivity</strong></p>
<ol>
<li><strong>通过appt获取切换到aapt所在的目录，执行aapt dump</strong> （aapt是sdk自带的一个工具，在sdk\builds-tools\目录下）使用命令aapt dump badging “D:\ jinritoutiao_7500.apk”运行后的结果中以下两行分别是应用包名package和入口activity名称<br>package: name&#x3D;’ com.ss.android.article.news’<br>launchable-activity: name&#x3D;‘com.ss.android.article.news.activity.LaunchActivity’</li>
</ol>
<p>**2. 通过 adb shell am start **com.ss.android.article.news&#x2F;com.ss.android.article.news.activity.MainActivity<br>来判断启动的app 是否正确<br><strong>2.2 启动appium</strong><br><img src="/assets/1/image-20211205190411-bss5xmz.png" alt="image.png"><br><img src="/assets/1/image-20211205190416-w001ahq.png" alt="image.png"><br><strong>2.3 写脚本</strong><br> <strong>1.platformName：</strong> 这里是 android 的 apk<br> <strong>2.deviceName：</strong> 手机设备名称，通过 adb devices 查看<br> <strong>3.platformVersion：</strong> android 系统的版本号<br> <strong>4.appPackage：</strong> apk 包名<br> <strong>5.appActivity：</strong> apk 的 launcherActivity<br><img src="/assets/1/image-20211205190422-d8tyhef.png" alt="image.png"><br><strong>2.4生成测试报告</strong><br><img src="/assets/1/image-20211205190433-n8seppi.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/06_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<ul>
<li>python系列<ul>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_python%E5%9F%BA%E7%A1%80/">python基础</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">UI自动化</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/">接口自动化</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_APP%E8%87%AA%E5%8A%A8%E5%8C%96/">APP自动化</a></li>
</ul>
</li>
<li>自动化平台<ul>
<li><strong>Phoenix Framework</strong></li>
<li><strong>metersphere</strong>       </li>
<li><strong>PhoenixPlatform</strong></li>
<li><strong>LuckyFrameWeb</strong></li>
<li><strong>Automagica</strong></li>
<li><strong>phoenixframe</strong></li>
<li><strong>TestMP</strong></li>
<li><strong>sosotest</strong></li>
<li><strong>EasyTest</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li><p><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/01_pycharm/01_%E8%AE%A4%E8%AF%86PycharmPython/">认识pycharm、认识python</a></p>
</li>
<li><p><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/10_python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/">python基础练习</a></p>
</li>
<li><p>列表与元组的区别</p>
<ol>
<li>他们最大的区别:<br> 1）列表可以修改，元组不可以修改，列表就相当于一个动态数组，而元组是一个静态数组，<br> 2）从设计上说，列表是用来保存多个相互独立对象的数据集合，而元组设计的初衷就是为了描述一个不会改变的事物的多个属性<br> 3）然后列表的声明用中括号,元组的声明用小括号,并且元组只有一个元素的时候需要在后面加逗号</li>
</ol>
</li>
<li><h3 id="python序列有哪些？"><a href="#python序列有哪些？" class="headerlink" title="python序列有哪些？"></a><strong>python</strong>序列有哪些？</h3><ol>
<li>有序序列：字符串，元组，列表无序序列：字典，集合<br> 序列特点：<br> —-都可以通过索引得到每一个元素<br> —默认索引值总是从零开始<br> —可以通过切片的方法得到一个范围内的元素的集合<br> —有很多共同的操作符(重复操作符、拼接操作符、成员关系操作符)</li>
</ol>
</li>
<li><h3 id="如何获取字典中的所有键？"><a href="#如何获取字典中的所有键？" class="headerlink" title="如何获取字典中的所有键？"></a>如何获取字典中的所有键？</h3><ol>
<li>我们可以直接遍历这个字典，用 keys()函数取出所有的键<blockquote>
<p>for key in dict.keys()</p>
</blockquote>
</li>
<li>如果说要取出字典中所有的键和对应的值，我们用 items()函数<blockquote>
<p>for  key,value in dict.items()</p>
</blockquote>
</li>
</ol>
</li>
<li><h3 id="列表和字典有什么区别？"><a href="#列表和字典有什么区别？" class="headerlink" title="列表和字典有什么区别？"></a>列表和字典有什么区别？</h3><ol>
<li>1）dict 生成慢，查找快。list 生成快，查找慢，<br> 2）另外list 是有序的，dict 是无需的，<br> 3）list 通过索引访问，dict 使用 key 访问，</li>
</ol>
</li>
<li><h3 id="截取字符串里面部分字符怎么做？"><a href="#截取字符串里面部分字符怎么做？" class="headerlink" title="截取字符串里面部分字符怎么做？"></a>截取字符串里面部分字符怎么做？</h3><p> 1）一般就是在定义的这个字符串变量后面用中括号[]，然后里面填写需要截取的索引数</p>
<blockquote>
<p>print(str[2:])<br>print(str[:2])                             #从开始到2）<br>print(str[2:5])<br>print(str[:])&gt;<br> 2）  利用字符串的中的内置函数split()</p>
</blockquote>
</li>
<li><blockquote>
<p>str1 &#x3D; ‘2018-11-2014:40:00’<br>print(‘年份：’,str1.split(‘    ‘)[0].split(‘-‘)[0])<br>print(‘月份：’,str1.split(‘    ‘)[0].split(‘-‘)[1])<br>print(‘日期：’,str1.split(‘    ‘)[0].split(‘-‘)[2])<br>print(‘ 时 ：’,str1.split(‘ ‘)[1].split(‘:’)[0])<br>print(‘ 分 ：’,str1.split(‘ ‘)[1].split(‘:’)[1])<br>print(‘ 秒 ：’,str1.split(‘ ‘)[1].split(‘:’)[2])</p>
</blockquote>
</li>
<li><h3 id="如何遍历列表，字典？"><a href="#如何遍历列表，字典？" class="headerlink" title="如何遍历列表，字典？"></a>如何遍历列表，字典？</h3><p> 1）  列表遍历</p>
<blockquote>
<p>list&#x3D;[3,4,6,89]<br>for i in range(0,len(list)):<br>print(‘%d’ %list[i])<br>for i in list:<br>print(i)<br> 2）  字典遍历<br>dict &#x3D; {‘name’:’jason’,’pwd’:123456}<br>for key in dict.keys():<br>print(dict[key])<br>for value in dict.values():<br>print(value)<br>for key,value in dict.items():<br>print(key,value)</p>
</blockquote>
</li>
<li><h3 id="列出-5个-python标准库？"><a href="#列出-5个-python标准库？" class="headerlink" title="列出 5个 python标准库？"></a>列出 <strong>5</strong>个 <strong>python</strong>标准库？</h3><ol>
<li>os：提供了不少与操作系统相关联的函数<br> sys:      通常用于命令行参数<br> re:        正则匹配<br> math: 数学运算<br> datetime:处理日期时间</li>
</ol>
</li>
<li><h3 id="python内建数据类型有哪些？"><a href="#python内建数据类型有哪些？" class="headerlink" title="python内建数据类型有哪些？"></a>python<strong>内建数据类型有哪些？</strong></h3><ol>
<li>整型–int<br> 布尔型–bool<br> 浮点型–float<br> 字符串–str<br> 列表–list<br> 元组–tuple<br> 字典–dict</li>
</ol>
</li>
<li><h3 id="如何将字符串转换为小写？"><a href="#如何将字符串转换为小写？" class="headerlink" title="如何将字符串转换为小写？"></a>如何将字符串转换为小写？</h3><blockquote>
<p>s&#x3D;’What is Your Name?’<br>print(s.lower())                #返回小写字符串<br>print(s.upper())               #返回大写字符串<br>print(s.capitalize())         #字符串首字符大写<br>int(s.title())     # 每个单词的首字母大写<br>print(s.swapcase()) # 大小写互换</p>
</blockquote>
</li>
<li><h3 id="Python题目-1689年到-2019年，打印出所有的闰年"><a href="#Python题目-1689年到-2019年，打印出所有的闰年" class="headerlink" title="Python题目 1689年到 2019年，打印出所有的闰年"></a><strong>Python</strong>题目 <strong>1689</strong>年到 <strong>2019</strong>年，打印出所有的闰年</h3><blockquote>
<p>if i%4&#x3D;&#x3D;0 and i%100!&#x3D;0 or i%400&#x3D;&#x3D;0:<br>print(i)</p>
</blockquote>
</li>
<li><pre><code> dict1=&#123;&quot;abc&quot;:&quot;123&quot;,&quot;def&quot;:&quot;456&quot;,&quot;ghi&quot;:&quot;789&quot;&#125;
 #输出结果：abc    def    ghi
 for a in dict1:
     print(a,end=&quot;\t&quot;)
 #输出结果：abc    def    ghi
 print()
 for a in dict1.keys():
     print(a,end=&quot;\t&quot;)
 #输出结果：123    456    789
 print()
 for a in dict1.values():
     print(a,end=&quot;\t&quot;)
 #输出结果：abc 123    def 456    ghi 789  
 print()
 for a,b in dict1.items():
     print(a,b,end=&quot;\t&quot;)
</code></pre>
<pre><code>#折纸多少次超过珠穆朗玛峰
import sys
h=0.08
for i in range(sys.maxsize):
    h+=h
    if h&gt;8848130:
        print(i,h)
        break
</code></pre>
<pre><code>#求5的阶乘，即5*4*3*2*1
num=5
for i in range(1,5):
    num*=i
print(num)
</code></pre>
<pre><code>#计算1+1/2+1/3+...1/20=?
a=0
b=1
for i in range(1,21):
    print(i)
    b*=i
    a+=1/b
print(a)
</code></pre>
<pre><code>#打印出所有的 &quot;水仙花数 &quot;，所谓 &quot;水仙花数 &quot;是指一个三位数，其各位数字立方和等于该数本身。
#例如：153是一个 &quot;水仙花数 &quot;，因为153=1的三次方＋5的三次方＋3的三次方。
x=0
for i in range(100,1000):
    b=i//100
    s=(i-100*b)//10
    g=(i-s*10-b*100)
    if i==g*g*g+s*s*s+b*b*b:
        x+=1
        print(i,end=&quot;\t&quot;)
</code></pre>
<pre><code>#百钱买百鸡
#5文钱可以买一只公鸡，3文钱可以买一只母鸡，1文钱可以买3只雏鸡。现在用100文钱买100只鸡，那么各有公鸡、母鸡、雏鸡多少只？
for a in range(0,21):
    for b in range(0,34):
        for c in range(0,300):
            if 5*a+3*b+c/3 == 100 and a+b+c==100:
                print(a,b,c)
</code></pre>
<pre><code>#百马百担
#有一百匹马，驮一百担货，大马驮3担，中马驮2担，两只小马驮1担，问有大，中，小马各几匹？
for a in range(0,34):
    for b in range(0,51):
        for c in range(0,201,2):
            if a*3+b*2+c//2==100 and a+b+c==100:
                print(a,b,c)
</code></pre>
<pre><code>#输入两个数，求两个数的最大公约数和最小公倍数
#1.接收两个数字
num1 = int(input(&#39;Num1:&#39;))
num2 = int(input(&#39;Num2:&#39;))
# 2.找出两个数中最小的值
min_num = min(num1, num2)
# 3.最大公约数的范围在1～min_num
for i in range(1, min_num + 1):
    if num1 % i == 0 and num2 % i == 0:
        # 当循环结束的时候，gys中保存的就是最大公约数
        Bgys = i
# 4.最小公倍数
Lgbs = int((num2 * num1) / Bgys)
print(&#39;%s和%s的最大公约数是:%s&#39; % (num1, num2, Bgys))
print(&#39;%s和%s的最小公倍数是:%s&#39; % (num1, num2, Lgbs))
</code></pre>
<pre><code>#打印1-100之间所有7的倍数的个数及总和
list1=[]
numm=0
for i in range(7,101,7):
    numm+=i
    list1.append(i)
print(len(list1))
print(numm)
</code></pre>
<pre><code>#打印1-100之间所有奇数之和
numm=0
for i in range(1,100,2):
    numm+=i
print(numm)
</code></pre>
<pre><code>#取出1~100之间的质数
#2、3、5、7、11、13、17、19、23、29、31、37、41、43、47、53、59、61、67、71、73、79、83、89、97
zhishu=[]
for a in range(2,100):
    list1 = []
    for i in range(1,a+1):
        if a%i==0:
            list1.append(i)
    if len(list1) &gt; 2:
       continue
    else:
        # print(a)
        zhishu.append(a)
print(zhishu)
print(len(zhishu))
</code></pre>
<pre><code># 求一组数的最小值
a=[22,54,6,223,72354,30,11,22111,12]
maxx=a[0]
for x in range(len(a)-1):
    if maxx&gt;=a[x+1]:
        maxx=a[x+1]
print(maxx)
</code></pre>
<pre><code># 生成10个0-50之间的随机数，求第二大的值
import random
list1=[]
for i in range(10):
    num=random.randint(0,51)
    list1.append(num)
print(list1)
num1=list1[0]
num2=list1[0]
for i in range(1,len(list1)):
    if num1 &lt; list1[i]:
        num2 = num1
        num1 = list1[i]
    elif num2 &lt; list1[i]:
        num2 = list1[i]
print(num1,num2)
</code></pre>
<pre><code>#随机1000个0-10之间的数。求每个数出现的次数
import random
list1=[random.randint(0,10) for i in range(1000)]
set1=set(list1)
for i in set1:
    print(&quot;%s出现的次数是%s次&quot;%(i,list1.count(i)))
</code></pre>
<pre><code># 耶稣有13个门徒，其中有一个就是出卖耶稣的叛徒，请用排除法找出这位叛徒：
# 13人围坐一圈，从第一个开始报号：1，2，3，1，2，3凡是报到“3”就退出圈子，最后留在圈子内的人就是出卖耶稣的叛徒
def josephus(n,k):
    #n代表总人数，k代表报数的数字
    List = list(range(1,n+1))
    index = 0
    while List:
        temp = List.pop(0)
        index += 1
        if index == k:
            index = 0
            continue
        List.append(temp)
        if len(List)==2:
            print(List)
            break
if __name__ == &#39;__main__&#39;:
    josephus(13,3)
</code></pre>
<pre><code>import random

# 随机生成一个个数为5-10的列表
# 随机生成5-10个1-100的随机数放入这个列表并按从大到小排列
# 随机生成一个1-100的随机数，按该数字大小放到上面列表内相应的位置

list1=[]
lenlist=random.randint(5,10)
print(&quot;随机生成列表元素量为：&quot;,lenlist-1)
for a in range(1,lenlist):
  list1.append(random.randint(1,100))
print(&quot;随机生成的随机列表为：&quot;,list1)
list1.sort(reverse=True)
print(&quot;随机列表从大到小排序：&quot;,list1)
i=random.randint(1,100)
print(&quot;随机生成的一个数字是：&quot;,i)
for b in range(len(list1)):
  if i&gt;list1[b]:
    list1.insert(b,i)
    break
print(&quot;随机数加入随机列表后：&quot;,list1)
</code></pre>
</li>
<li><p>打印九九乘法表</p>
</li>
<li><pre><code> #九九乘法表1
 for a in range(1,10):
     for b in range(1,a+1):
         print(&quot;%s*%s=%s&quot;%(a,b,a*b),end=&quot;\t&quot;)
     print()
</code></pre>
<pre><code>#九九乘法表2
for a in range(1,10):
    for b in range(1,10):
        print(&quot;%s*%s=%s&quot;%(a,b,a*b),end=&quot;\t&quot;)
    print()
</code></pre>
<pre><code>#九九乘法表倒序
for a in reversed(range(1,10)):
    for b in reversed(range(1,a+1)):
        print(&quot;%s * %s = %s&quot;%(a,b,a*b),end=&quot;\t&quot;)
    print()
</code></pre>
</li>
<li><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre><code>def bubble_sort(nums):
    for i in range(len(nums) - 1):  # 这个循环负责设置冒泡排序进行的次数
        for j in range(len(nums) - i - 1):  # j为列表下标
            if nums[j] &gt; nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
    return nums


print(bubble_sort([45, 32, 8, 33, 12, 22, 19, 97]))
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_selenium/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>UI自动化测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<ol>
<li><h3 id="有没有做过-Web-UI自动化，你们自动化怎么做的？"><a href="#有没有做过-Web-UI自动化，你们自动化怎么做的？" class="headerlink" title="有没有做过 Web UI自动化，你们自动化怎么做的？"></a>有没有做过 <strong>Web UI</strong>自动化，你们自动化怎么做的？</h3><ol>
<li>前一个项目是有参与过web 自动化测试工作的，我们公司当时用的 python+selenium+unittest 框架来写自动化脚本的。具体的话，首先需要搭建测试环境，把需要用的一些库安装好，像 python，pycharm，selenium， ddt,xrld，pymysql 等测试库，然后把对应的浏览器驱动放在 python 根目录就好了。这里需要注意版本的兼容性问题。然后就是开始着手编写脚本，脚本编写这块其实主要是调用 Selenium 库中的 API 函数来实现的，脚本为非就是根据功能测试用例的操作步骤实现也页面元素进行定位，与操作。我觉得 Web 自动化测试最核心关键的还是：元素定位，断言,后期主要就是工程的维护与优化。对于元素定位，selenium中给我们提供了 8种定位方式，元素定位我一般是用的 id定位和xpath定位，css selector样式定位和link test定位,偶尔也会用到，基础定位很简单。元素定位一般我有一个原则：有 ID尽量用id定位，尽量避免用 name，class name定位，因为这两个可能在页面会有重复名字。如果没有 id，优先选择使xpath,css_selector,link_text进行定位。不过元素定位这块，有时候会定位不成功， 比如，像页面加载延迟的问题，导致元素定位失败，这里可能需要进行延迟处理，延迟处理的方式,一般有 3种，一种就是强制等待，一种就是隐性等待，一种就是显性等待。除了这个之外，我们一定要注意iframe 内嵌网页的问题，还是有就是多窗口的问题，有时候最恼火的可能就是动态 id的问题，对于动态 id的处理，一定要保证定位方式中尽量出现与 id有关的东西。可以使用先定位父元素再定位子元素的方式，也可以通过定位周边元素的方式来进行处理。<br> 例外断言这块，其实 unittest 框架中提供了丰富的断言方法，主要是通过调用 unittest 框架中提供的各种断言方法来实现的，主要用得比较多的就是，assertEqual(a,b)，assertIn(a, b)，assertIsInstance(a,b) 等，对于Web UI自动化的断言我们主要关注的是：页面的跳转是否正确，页面上的核心信息是否正确， 从这两个方面去检查实际结果与预期结果是否一致。脚本这块差不多就是这么写的，最后我们需要引入一个 htmlreport 库去自动生成自动化报告，然后就是对报告进行分析，报告这一块的话，主要有通过，异常，失败几种请情况，如果错误的话，基本一般都是脚本问题，这个时候我们需要去重新调试我们的脚本，如果是失败的话，一般来说，我都会先检查自己的脚本是否有问题，如果没有问题基本就可以提 Bug了。web自动化当时就这么做的。<br> Web UI 自动化差不多就这些吧…..</li>
</ol>
</li>
<li><h3 id="自动化测试流程是什么？"><a href="#自动化测试流程是什么？" class="headerlink" title="自动化测试流程是什么？"></a>自动化测试流程是什么？</h3><ol>
<li>前期项目组会评估项目是否合适做自动化测试<ol>
<li>例外就是看下哪些模块需要做自动化，适合做。</li>
</ol>
</li>
<li>人员安排，分工</li>
<li>确定测试框架</li>
<li>各自领取自己负责模块(根据功能来进行划分，功能测试的模块)<ol>
<li>整理功能模块的用例，把能做自动化的用例提炼出，规整成自动化用例文档，准备数据，整理数据，管理资源，环境的准备</li>
</ol>
</li>
<li>搭建测试环境</li>
<li>脚本开发</li>
</ol>
</li>
<li>你们自动化覆盖率有多少？<ol>
<li>2 年以内，把原来手工做的事情 30%用自动化脚本去替代<br> 2 年以上，实现 40-70%<br> 当时覆盖的确实也不是很多，差不多 30-40%的样式吧。</li>
</ol>
</li>
<li><h3 id="元素定位的方式有哪些？你常用的元素定位方式？"><a href="#元素定位的方式有哪些？你常用的元素定位方式？" class="headerlink" title="元素定位的方式有哪些？你常用的元素定位方式？"></a>元素定位的方式有哪些？你常用的元素定位方式？</h3><ol>
<li>元素定位主要有 8 种定位方式:id,xpath,css,link_text,tag,name,class_name,partial_link_text</li>
<li>我一般常用就是：id,xpath,css,link_text。像 xpath 可以通过路径来定位，也可以通属性来实现，css 可以通过样式来实现，也可以通过属性来实现。</li>
</ol>
</li>
<li><h3 id="定位不到元素，你碰到过哪些，怎么解决？"><a href="#定位不到元素，你碰到过哪些，怎么解决？" class="headerlink" title="定位不到元素，你碰到过哪些，怎么解决？"></a>定位不到元素，你碰到过哪些，怎么解决？</h3> 1、像页面加载延迟的问题，这个需要通过等待延迟的方式来处理。<br> 2、不过有时候，页面加载完成，但是元素暂时还不可见，导致定位不成功<br> 这个可以选择使用显示等待来处理，这里需要用到 WebDriverWait 类来实现<br> 3、还有就是像内嵌网页的问题，需要使用driver.switch_to.frame(name&#x2F;index)这个函数来跳转到处理<br> 4、还有要注意多窗口问题，动态 id问题等的问题，对于多窗口处理，可以使用<br> driver.switch_to.window() 的方式来进行处理，而对于动态 id的问题，需要注意的是有些 id 跟数字有关，可能会动态变化，可以使用 xpath,也可以使用<br> css_select,属性定位或者样式定位，或者可以通过父元素来找元素，或者通过兄弟节点来找对应的元素。等等<br> 5、还有要特别注意滚动条的问题，这里通过调用js 代码来实现的，driver.execute_script(js)<br> 7、再这就是有时候会碰到某些元素的是不可见的，比如 display 属性为 none,这就需要通过 javaScript 修改 display 的值。<br> js &#x3D;’document.querySelectorAll(“select”)[1].style.display&#x3D;”block”;’<br> driver.execute_script(js)</li>
<li><h3 id="xpath定位的方法？xpath怎么写？"><a href="#xpath定位的方法？xpath怎么写？" class="headerlink" title="xpath定位的方法？xpath怎么写？"></a><strong>xpath</strong>定位的方法？<strong>xpath</strong>怎么写？</h3><ol>
<li>Xpath写法：&#x2F;&#x2F;*div[@id&#x3D;’u1’]&#x2F;a[7]                              #相对路径<br> Xpath写法：&#x2F;html&#x2F;body&#x2F;div[1]&#x2F;div&#x2F;div&#x2F;div[3]&#x2F;a[7]                                          #绝对路径<br> #先找父元素，结合属性find_element_by_xpath(&#x2F;&#x2F;div[@id&#x3D;’u1’]&#x2F;a[@name&#x3D;’tj_login’])<br> #根据属性来的<br> Xpath写法 1：&#x2F;&#x2F;div[@id&#x3D;’hd’or@name&#x3D;’q’]<br> Xpath 写 法 2：&#x2F;&#x2F;a[@name&#x3D;’tj_trxueshu’ and<br> @class&#x3D;’mnav’] Xpath 写法 3：&#x2F;&#x2F;a[@name&#x3D;’tj_trxueshu’][@class&#x3D;’mnav’]</li>
</ol>
</li>
<li><h3 id="如何去定位内嵌界面？"><a href="#如何去定位内嵌界面？" class="headerlink" title="如何去定位内嵌界面？"></a>如何去定位内嵌界面？</h3> 1、定位元素的时候看到frame 的需要进入内嵌<br> 2、如果有内嵌有id或 name值时直接进入内嵌 driver.switch_to.frame(‘id值或 name值’)<br> 3、如果内嵌没有id或 name值，先定义一个内嵌再进入：<br> a&#x3D;driver.find_element_by_class_name(‘’)<br> driver.switch_to.frame(a)<br> 4、如果有多层内嵌，要一层一层进入<br> 5 、 记 得 退 出 内 嵌 ：<ol>
<li>driver.switch_to.default_content()</li>
<li>driver.switch_to.parent_frame()–进入父级内嵌，调至上一级内嵌</li>
</ol>
</li>
<li><h3 id="如何在不同的网页之间切换-如何处理定位问题？"><a href="#如何在不同的网页之间切换-如何处理定位问题？" class="headerlink" title="如何在不同的网页之间切换**?** 如何处理定位问题？"></a>如何在不同的网页之间切换**?** 如何处理定位问题？</h3><ol>
<li>(窗口句柄的列表)<br> 先获取所有窗口的句柄：handles &#x3D;driver.window_handles<br> 然后跳转到指定的窗口上：driver.switch_to.window(handles[1])</li>
</ol>
</li>
<li><h3 id="如何去定位滚动条？滚动条怎么处理？"><a href="#如何去定位滚动条？滚动条怎么处理？" class="headerlink" title="如何去定位滚动条？滚动条怎么处理？"></a>如何去定位滚动条？滚动条怎么处理？</h3><ol>
<li>一般当我们页面上的元素超过一屏后，想操作屏幕下方的元素，是不能直接操作的，会报元素不可见异常的。这时候需要借助滚动条来拖动屏幕，使被操作的元素显示在当前的屏幕上，selenium提供了一个操作js的方法:execute_script()，可以直接执行 js的脚本。<br> 滚动到底部：<br> js&#x3D;”var q&#x3D;document.getElementById(‘id’).scrollTop&#x3D;10000”<br> driver.execute_script(js)<br> 滚动到顶部：<br> js&#x3D;”var q&#x3D;document.documentElement.scrollTop&#x3D;0” driver.execute_script(js)<br> #把滚动条拉到指定位置<br> 虽然用上面的方法可以解决拖动滚动条的位置问题，但是有时候无法确定我需要操作的元素在什么位置，<br> 有可能每次打开的页面不一样，元素所在的位置也不一样，这个时候我们可以先让页面直接跳到元素出现的位置，然后就可以操作了。<br> target_element&#x3D; driver.find_element_by_xpath(‘&#x2F;&#x2F;*[@id&#x3D;”4”]&#x2F;h3&#x2F;a’) driver.execute_script(“arguments[0].scrollIntoView();”,target_element)</li>
</ol>
</li>
<li><h3 id="如何去模拟键盘与鼠标的操作？"><a href="#如何去模拟键盘与鼠标的操作？" class="headerlink" title="如何去模拟键盘与鼠标的操作？"></a>如何去模拟键盘与鼠标的操作？</h3><ol>
<li>模拟键盘：<ol>
<li>要导入一个包:fromselenium.wedriver.common.keysimport<br> Keys</li>
<li>快捷键输入，通过send_keys()方法可以来模拟键盘输入操作。</li>
<li>send_keys(Keys.CONTROL,’a’)        #全 选（Ctrl+A）</li>
<li>send_keys(Keys.CONTROL,’c’)                # 复 制 （Ctrl+C）</li>
<li>send_keys(Keys.CONTROL,’x’)                # 剪 切 （Ctrl+X）</li>
<li>send_keys(Keys.CONTROL,’v’)                # 粘贴 （Ctrl+V）</li>
<li>send_keys(Keys.ENTER)                        #回车键</li>
<li>send_keys(Keys.BACK_SPACE)                #删除键</li>
<li>send_keys(Keys.SPACE)                           #空格键</li>
<li>send_keys(Keys.TAB)                               #制表键</li>
<li>send_keys(Keys.ESCAPE)                         #回退键</li>
<li>模拟鼠标语法：ActionChains（diver）.<br> 鼠标操作动作(操作的元素).perform（）<br> 鼠标操作动作有：click()单击、context_click()右击、double_click()双击、move_to_element()鼠标悬停     </li>
<li>先导入一个鼠标的包：fromselenium.webdriver.common.action_chainsimport ActionChains</li>
<li>然后定位元素：driver.find_element_by_xpath(),可以定义为一个变量 aa</li>
<li>然后通过语法执行：ActionChains（driver）.move_to_element(aa).perform（）</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="元素定位，有时候定位得到，有时候定位不到，可能是什么原因？"><a href="#元素定位，有时候定位得到，有时候定位不到，可能是什么原因？" class="headerlink" title="元素定位，有时候定位得到，有时候定位不到，可能是什么原因？"></a>元素定位，有时候定位得到，有时候定位不到，可能是什么原因？</h3><ol>
<li>可能是网络问题，导致页面加载延迟，这个可以做延迟等待，一般选择隐式等待，在脚本前面加上driver.implicitly_wait(20)。</li>
<li>也有可能是页面结构发生变化导致的，这个时候最好选择通过 xpath，或 css 结合属性进行或者样式定位可能会好点，或者采用 JQuery 定位的方式来进行定位元素。</li>
</ol>
</li>
<li><h3 id="对于不可见的元素，你如何定位，如何处理？"><a href="#对于不可见的元素，你如何定位，如何处理？" class="headerlink" title="对于不可见的元素，你如何定位，如何处理？"></a>对于不可见的元素，你如何定位，如何处理？</h3><ol>
<li>我们可以通过 javaScript 修改 display 的值，来实现         #修改元素的属性<br> #我们需要通过 javaScript 修改 display 的值。<br> js &#x3D;’document.querySelectorAll(“select”)[1].style.display&#x3D;”block”;’<br> driver.execute_script(js)</li>
</ol>
</li>
<li><h3 id="你们自动化用例是怎么管理的？"><a href="#你们自动化用例是怎么管理的？" class="headerlink" title="你们自动化用例是怎么管理的？"></a>你们自动化用例是怎么管理的？</h3><ol>
<li>所有用例都是放在 test_case的目录下的统一管理的。</li>
<li>每个某块一个.py文件，数据独立放在excel表格中</li>
<li>所有的具体用例脚本都是依据 unittest来编写的，<br> 利用 ddt模型的装饰器来引用数据<br> 然后跑用例这块，主要用的是 unittest 框架来统一加载用例，并执行用例的如果要全量跑，调用 unittest 中的 defaultTestLoader.discover 这个函数来加载 test_case 目录下的所有.py 文件。</li>
</ol>
</li>
<li><h3 id="数据驱动有没有了解过，具体怎么做的？"><a href="#数据驱动有没有了解过，具体怎么做的？" class="headerlink" title="数据驱动有没有了解过，具体怎么做的？"></a>数据驱动有没有了解过，具体怎么做的？</h3><ol>
<li>其实就是把数据与脚本分离，好处就是方便维护管理，后期数据有变动，只要改 excel表的数据就可以，脚本不用动封装一个读取 excel 表格的函数&#x2F;方法，调用这个函数来读取数据。然后利用 ddt 模型，使用 ddt 内部装饰器来实现数据引用。我们当时就是这么做的。</li>
</ol>
</li>
<li><h3 id="自动化中如何去操作excel表格？"><a href="#自动化中如何去操作excel表格？" class="headerlink" title="自动化中如何去操作excel表格？"></a>自动化中如何去操作<strong>excel</strong>表格？</h3><ol>
<li>需要用到 xlrd 库，调用这个库中的 API 函数来实现的。<br> 第一步：导包 import xlrd<br> 第二步：book &#x3D; xlrd.open_workbook(文件路径)<br> 第三步：table &#x3D; book.sheet_by_name(表名)<br> 第四步：读某行数据<br> 一般都按行来读取table.row_values(x)<br> 如果要读全部的数据，多行数据，利用循环读取就可以。<blockquote>
<p>List&#x3D;[]<br>for i in range(1,table.nrows):<br>List.append(table.row_values(i))<br>return list</p>
</blockquote>
</li>
</ol>
</li>
<li><h3 id="自动化中如何去操作数据库？"><a href="#自动化中如何去操作数据库？" class="headerlink" title="自动化中如何去操作数据库？"></a>自动化中如何去操作数据库？</h3><ol>
<li>这里需要用到一个 pymysql 这个库，然后自己封装一个函数具体就是：<br> 第一步：导包 import pymysql<br> 第二步：连接数据库conenct&#x3D;pymysql.connect(ip地址，端口，数据库名，账号，密码，编码方式)   它会返回一个连接对象<br> 第三步：实现查询，删除，更新，增加的函数这里主要就是，比如查询操作。<br> A. 创建一个游标对象      cursor &#x3D;Connnect.cursor()<br> B. 定义 sql 语句<br> C. 调 用 cursor.excute(sql) 最终会返回数据<br> D. 提交connect.commit()<br> E. 提取返回的数据    result &#x3D;cursor.fetchall()<br> F. 返回这个 result</li>
</ol>
</li>
<li><h3 id="Web-UI-自动化你是怎么做断言的？"><a href="#Web-UI-自动化你是怎么做断言的？" class="headerlink" title="Web UI 自动化你是怎么做断言的？"></a>Web UI 自动化你是怎么做断言的？</h3><ol>
<li>断言主要检查几个点：<ol>
<li>页面跳转是否正确(title,url)</li>
<li>页面数据是否正确(核心数据，页面上的关键信息，或者页面上的某个元素是否出现) 3.如果要检查数据库，需要连接数据库，查询数据，与预期结果进行对比</li>
</ol>
</li>
<li>基本都调用 unittest 框架中提供的断言函数来实现的，用得比较多的就是AssertEqual、AssertIn、AssertListEqual<ol>
<li>提取元素 text 断言：user_text&#x3D;driver.find_element_by_css_selector(“#J_account&gt;a”).text #获取实际的值(展示账户名内容)<br> assert ‘admin’ in user_text #断言 admin 在实际值里</li>
<li>提取元素属性去断言：<br> login_button_value&#x3D;driver.find_element_by_id(“Iajax-login-submit”).get_attribute(‘value ‘)# 获取登录按钮的属性,value 值是‘登录’<br> assert ‘登录’login_button_value #断言‘登录’是这个按钮的属性</li>
<li>提取界面 title 值去断言：<br> assert “p2p 信贷—最大、最安全的网络借贷平台” in driver.title,”失败”或者 in 改为 not in</li>
<li>提取元素是否可用来进行断言<br> assert driver.find_element_by_css_selector(“div.user_money &gt; a:nth-child(1)”).is_enabled()Tru e,”元素不存在。不可用”</li>
<li>数据库断言，去数据库查询结果，是否跟预期一致     AssertDictEqual</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="有没有自己封装过一些函数？封装过哪些函数？"><a href="#有没有自己封装过一些函数？封装过哪些函数？" class="headerlink" title="有没有自己封装过一些函数？封装过哪些函数？"></a>有没有自己封装过一些函数？封装过哪些函数？</h3><ol>
<li>模块封装：封装界面上的所有元素，一些公共模块（数据库操作，读取 exell 数据公共方法等），测试数据（返回一些变量，字典列表 exell 表等），一些元素操作，测试用例等等<br> 封装的目的：为了后期维护和管理更加方便，如果修改数据时直接在模块中修改就行<br> def get_data(filename,tablname):<br> #1. 打开 excel 文件<br> book &#x3D;xlrd.open_workbook(filename)<br> #2. 打开一个表<br> sheet &#x3D; book.sheet_by_name(tablname) print(sheet.nrows)<br> #3. 对表操作 列，行，单元格list &#x3D; []<br> for i in  range(1,sheet.nrows):<br>  list.append(sheet.row_values(i))<br> return list</li>
</ol>
</li>
<li><h3 id="如何生成自动化测试报告？"><a href="#如何生成自动化测试报告？" class="headerlink" title="如何生成自动化测试报告？"></a>如何生成自动化测试报告？</h3><ol>
<li>我们当时用的是 HtmlReport 这个库来生成自动化测试报告的。</li>
<li><img src="/assets/1/image-20211203221528-ukvm32r.png" alt="image.png"></li>
</ol>
</li>
<li><h3 id="对于生成的自动化测试报告如何分析？"><a href="#对于生成的自动化测试报告如何分析？" class="headerlink" title="对于生成的自动化测试报告如何分析？"></a>对于生成的自动化测试报告如何分析？</h3> 1、主看总共执行了多少用例，通过了多少，失败了多少，错误了多少<br> 2、对于错误的用例，基本都脚本问题，查看报告中的日志详细信息，看具体哪个位置出错了，针对性去进行调试，修改。<br> 3、对于失败的用例，也是首先看报告中的日志，看具体哪个位置出错了，一般首先怀疑自己的脚本，先确定脚本是否有问题，如果脚本没有问题，那可以确定就是 Bug了，提 Bug即可。</li>
<li><h3 id="selenium库中用过哪些函数？"><a href="#selenium库中用过哪些函数？" class="headerlink" title="selenium库中用过哪些函数？"></a><strong>selenium</strong>库中用过哪些函数？</h3><ol>
<li><pre><code>&quot;&quot;&quot;
driver = WebDriver.Chrome()
driver.quit()                                             #退出浏览器
driver.close()                                           #关闭窗口
driver.implicitly_wait()    #设置隐性等待延迟
driver.current_url                                  #获取当前的url
driver.page_source                              #获取当前页面的源代码
driver.title                                                 #获取当前页面的标题
driver.maximize_window()               #窗口最大化
driver.get()                      #加载一个网页
driver.back()   后退
driver.forward()   前进
driver.refresh()  刷新
selenium处理alert() 提示框：
driver.switchTo().alert(); 获取alert
alert.accept(); 点确定
alert.dismiss(); 点取消
alert.getText();获取alert的内容
&quot;&quot;&quot;
</code></pre>
#元素定位的driver.find_element_by_id()<br>driver.find_element(By.xxx,’’) #iframe 跳转的driver.switch_to.frame()<br>driver.switch_to.parents_frame() driver.switch_to.default_content()  #窗口跳转driver.switch_to.window()<br>#对话框的处理driver.switch_to.alert<br>.accept()<br>.dismiss()<br>.text<br>.send_keys()<br>#执行 js 脚本的driver.execute_script(js)<br>Element 类：<br>element.click() element.submit()<br>element.send_keys() element.clear() element.text element.get_attribute()<br>element.is_displayed()<br>element.find_element_by_xpath()</li>
</ol>
</li>
<li><h3 id="selenium2与-selenium1的区别是什么？"><a href="#selenium2与-selenium1的区别是什么？" class="headerlink" title="selenium2与 selenium1的区别是什么？"></a><strong>selenium2</strong>与 <strong>selenium1</strong>的区别是什么？</h3><ol>
<li>Selenium 1.0使用的是 Javascript注入技术与浏览器打交道，需要SeleniumRC启动一个 Server， 将操作 Web元素的 API调用转化为一段段Javascript，在 Selenium内核启动浏览器之后注入这段Javascript。开发过Web 应用的人都知道，Javascript 可以获取并调用页面的任何元素，自如的进行操作。由此才实现了 Selenium的目的：自动化Web操作。这种 Javascript注入技术的缺点是速度不理想，而且稳定性大大依赖于 Selenium内核对API翻译成的Javascript质量高低。<br> Selenium 2.0 则是把selenium 1.0 中selenium RC 替换为了 WebDriver ，WebDriver 利用浏览器原生的API，封装成一套更加面向对象的 SeleniumWebDriverAPI，直接操作浏览器页面里的元素，甚至操作浏览器本身（截屏，窗口大小，启动，关闭，安装插件，配置证书之类的）。由于使用的是浏览器原生的 API，速度大大提高，而且调用的稳定性交给了浏览器厂商本身，显然是更加科学。然而带来的一些副作用就是，不同的浏览器厂商，对 Web 元素的操作和呈现多少会有一些差异，这就直接导致了 SeleniumWebDriver 要分浏览器厂商不同，而提供不同的实现。例如 Firefox 就有专门的 FirefoxDriver，Chrome 就有专门的 ChromeDriver 等等</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Puppeteer</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_Puppeteer/</url>
    <content><![CDATA[<ul>
<li><p>python系列</p>
<ul>
<li><p><a href="">python基础</a></p>
</li>
<li><p><a href="">UI自动化</a></p>
<ul>
<li><p><a href="">Selenium</a></p>
</li>
<li><p><a href="">Puppeteer</a></p>
</li>
<li><p><a href="">Playwright</a></p>
<ul>
<li><a href="">“【PlayWright教程（一）】核心概念”</a></li>
<li><a href="">“PlayWright教程（二）】基础操作汇总”</a></li>
</ul>
</li>
</ul>
</li>
<li><p><a href="">接口自动化</a></p>
</li>
<li><p><a href="">APP自动化</a></p>
</li>
</ul>
</li>
<li><p>自动化平台</p>
<ul>
<li><strong>Phoenix Framework</strong></li>
<li><strong>metersphere</strong>       </li>
<li><strong>PhoenixPlatform</strong></li>
<li><strong>LuckyFrameWeb</strong></li>
<li><strong>Automagica</strong></li>
<li><strong>phoenixframe</strong></li>
<li><strong>TestMP</strong></li>
<li><strong>sosotest</strong></li>
<li><strong>EasyTest</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Playwright</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_Playwright/</url>
    <content><![CDATA[<p>Playwright是由微软公司2020年初发布的新一代自动化测试工具，相较于目前最常用的Selenium，本文就详细的介绍一下快速上手指南，对新手有一定的帮助，感兴趣的可以了解一下<br><a href="https://playwright.bootcss.com/docs/installation" title="Installation | Playwright 中文文档 | Playwright 中文网">Installation | Playwright 中文文档 | Playwright 中文网</a></p>
<h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ul>
<li><ol>
<li>为什么选择Playwright</li>
</ol>
<ul>
<li>1.1 Playwright的优势</li>
<li>1.2 已知局限性</li>
</ul>
</li>
<li><ol start="2">
<li>Playwright使用</li>
</ol>
</li>
<li>2.1 安装</li>
<li>2.2 自动录制</li>
<li>2.3 定制化编写</li>
<li>2.4 网络拦截（Mock接口），示例如下：</li>
<li>2.6 异步执行，示例如下：</li>
<li>2.7 Pytest结合，示例如下：</li>
<li>2.8 移动端操作，示例如下：</li>
<li><ol start="3">
<li>总结<br>Playwright是由微软公司2020年初发布的新一代自动化测试工具，相较于目前最常用的Selenium，它仅用一个API即可自动执行Chromium、Firefox、WebKit等主流浏览器自动化操作。作为针对 Python 语言纯自动化的工具，在回归测试中可更快的实现自动化。<h2 id="1-为什么选择Playwright"><a href="#1-为什么选择Playwright" class="headerlink" title="1. 为什么选择Playwright"></a>1. 为什么选择Playwright</h2><h3 id="1-1-Playwright的优势"><a href="#1-1-Playwright的优势" class="headerlink" title="1.1 Playwright的优势"></a>1.1 Playwright的优势</h3>（1） Selenium需要通过WebDriver操作浏览器；Playwright通过开发者工具与浏览器交互，安装简洁，不需要安装各种Driver。<br>（2） Playwright几乎支持所有语言，且不依赖于各种Driver，通过调用内置浏览器所以启动速度更快。<br>（3） Selenium基于HTTP协议（单向通讯），Playwright基于Websocket（双向通讯）可自动获取浏览器实际情况。<br>（4） Playwright为自动等待。</li>
</ol>
</li>
<li>等待元素出现（定位元素时，自动等待30s，等待时间可以自定义，单位毫秒）</li>
<li>等待事件发生<h3 id="1-2-已知局限性"><a href="#1-2-已知局限性" class="headerlink" title="1.2 已知局限性"></a>1.2 已知局限性</h3>（1） Playwright不支持旧版Microsoft Edge或IE11。支持新的Microsoft Edge（在Chromium上）；所以对浏览器版本有硬性要求的项目不适用。<br>（2） 需要SSL证书进行访问的网站可能无法录制，该过程需要单独定位编写。<br>（3） 移动端测试是通过桌面浏览器来模拟移动设备（相当于自带模拟器），无法控制真机。<h2 id="2-Playwright使用"><a href="#2-Playwright使用" class="headerlink" title="2. Playwright使用"></a>2. Playwright使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3>（1）安装Playwright依赖库（Playwright支持Async\Await语法，故需要Python3.7+）<table>
<thead>
<tr>
<th>1</th>
<th><code>pip install playwright</code></th>
</tr>
</thead>
</table>
</li>
</ul>
<p>（2）安装Chromium、Firefox、WebKit等浏览器的驱动文件（内置浏览器）</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>python ``-``m playwright install</code></th>
</tr>
</thead>
</table>
<h3 id="2-2-自动录制"><a href="#2-2-自动录制" class="headerlink" title="2.2 自动录制"></a>2.2 自动录制</h3><p>（1）命令行键入 –help 看到所有可后接选项</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>python ``-``m playwright codegen ``-``-``help</code></th>
</tr>
</thead>
</table>
<p>（2）从起始页为xingzheai.cn开始录制</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>python ``-``m playwright codegen https:``/``/``xingzheai.cn``/</code></th>
</tr>
</thead>
</table>
<p>（3）打开xingzheai.cn，用Chromium驱动，将结果保存为my.py的python文件</p>
<table>
<thead>
<tr>
<th>1</th>
<th><code>python ``-``m playwright codegen ``-``-``target python ``-``o ``&#39;my.py&#39;</code> <code>-``b chromium https:``/``/``xingzheai.cn``/</code></th>
</tr>
</thead>
</table>
<p> -target：规定生成脚本的语言，有JS和Python两种，默认为Python<br>-b：指定浏览器驱动<br>-o：将录制的脚本保存到一个文件</p>
<h3 id="2-3-定制化编写"><a href="#2-3-定制化编写" class="headerlink" title="2.3 定制化编写"></a>2.3 定制化编写</h3><p>（1）元素定位</p>
<ul>
<li>选择单个元素：querySelector(engine&#x3D;body)</li>
<li>选择多个元素：querySelectorAll(engine&#x3D;body)</li>
<li>选择单个元素，并且自动等待：waitForSelector(engine&#x3D;body)<br>By的8种定位方式，实际为4种</li>
<li>id、name、tag name、class name（java和pythona将该4种都归为CSS）</li>
<li>xpath、link text、partial link text、css selector<br>W3C标准规定的webDriver协议为5种定位方式</li>
<li>CSS、Link text、Partial link text、Tag name、XPath<br>Playwright将选择器汇总为3种</li>
<li>CSS、XPATH（支持逻辑表达式和函数）、TEXT<br>（2）选择器规则</li>
<li>CSS： ID选择器、类选择器、元素选择器、属性选择器、通配选择器、层次选择器。</li>
<li>XPath： XML路径语言，通过“路径标识符”，导航XML文档的，在类XML种（HTML）也可以使用。</li>
<li>Text： 结构化内容（html，xml，json）使用模糊匹配（忽略大小写，忽略前后空格，搜索子字符串）及精确匹配、非结构化内容使用正则匹配。<br>（3）元素常用操作</li>
<li>下拉选择框：selectOpion、value、labei、index</li>
<li>文件上传：setInputFiles、单个文件、多个文件、拖放上传</li>
<li>鼠标点击：click、dbclick</li>
<li>鼠标拖动：down、up</li>
<li>鼠标移动：move</li>
<li>触摸屏幕：tag</li>
<li>键盘按键：press</li>
<li>截屏、录屏：screenshot、recordVideo<h3 id="2-4-网络拦截（Mock接口），示例如下：2-5-同步执行，示例如下："><a href="#2-4-网络拦截（Mock接口），示例如下：2-5-同步执行，示例如下：" class="headerlink" title="2.4 网络拦截（Mock接口），示例如下：2.5 同步执行，示例如下："></a>2.4 网络拦截（Mock接口），示例如下：2.5 同步执行，示例如下：</h3><blockquote>
<p>page &#x3D; context.newPage()<br>def Whether_intercept() -&gt; bool:<br>return True  #进行拦截</p>
<h6 id="return-False-不进行拦截"><a href="#return-False-不进行拦截" class="headerlink" title="# return False #不进行拦截"></a># return False #不进行拦截</h6><p>def handler(route:Route):<br>print(route.request.url)<br>#正常访问<br># route.continue_()<br>#拒绝访问<br># route.abort(“网络拦截”)<br># 重定向到非目标地址<br>route.fulfill(<br>    status&#x3D;302,<br>    headers&#x3D;{<br>        ‘Location’ : “<a href="https://xingzheai.cn/&quot;">https://xingzheai.cn/&quot;</a><br>    }<br>)<br>page.route(Whether_intercept,handler)</p>
</blockquote>
</li>
</ul>
<h3 id="2-5-同步执行，示例如下："><a href="#2-5-同步执行，示例如下：" class="headerlink" title="2.5 同步执行，示例如下："></a>2.5 同步执行，示例如下：</h3><blockquote>
<p>#依次打开三个浏览器，前往行者官网，截图后退出。<br>from playwright import sync_playwright with sync_playwright() as p:<br>    for browser_type in [p.chromium, p.firefox, p.webkit]:<br>         # 指定为有头模式，Ture为无头模式<br>        browser &#x3D; browser_type.launch(headless&#x3D;False)<br>        page &#x3D; browser.newPage()<br>        page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>        # 等待页面加载完全后截图<br>        page.waitForSelector(“text&#x3D;智能内容审核”)<br>        page.screenshot(path&#x3D;f’example-{browser_type.name}.png’)<br>        browser.close()</p>
</blockquote>
<h3 id="2-6-异步执行，示例如下："><a href="#2-6-异步执行，示例如下：" class="headerlink" title="2.6 异步执行，示例如下："></a>2.6 异步执行，示例如下：</h3><blockquote>
<p>#同时进行三个浏览器操作<br>import asyncio<br>from playwright import async_playwright<br>async def main():<br> async with async_playwright() as p:<br>     for browser_type in [p.chromium, p.firefox, p.webkit]:<br>          browser &#x3D; await browser_type.launch()<br>         page &#x3D; await browser.newPage()<br>         await page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>          await page.waitForSelector(“text&#x3D;智能内容审核”)<br>          await page.screenshot(path&#x3D;f’example-{browser_type.name}.png’)<br>          await browser.close()<br>         asyncio.get_event_loop().run_until_complete(main())</p>
</blockquote>
<h3 id="2-7-Pytest结合，示例如下："><a href="#2-7-Pytest结合，示例如下：" class="headerlink" title="2.7 Pytest结合，示例如下："></a>2.7 Pytest结合，示例如下：</h3><p>安装：<code>pip install pytest-playwright</code></p>
<blockquote>
<p>def test_playwright(page):<br>    page.goto(“<a href="https://xingzheai.cn/&quot;">https://xingzheai.cn/&quot;</a>)<br>    with page.expect_popup() as popup_info:<br /> page.click(‘text&#x3D;”智能内容审核”‘)<br />    assert “智能内容审核” &#x3D;&#x3D; element.textContent()</p>
</blockquote>
<h3 id="2-8-移动端操作，示例如下："><a href="#2-8-移动端操作，示例如下：" class="headerlink" title="2.8 移动端操作，示例如下："></a>2.8 移动端操作，示例如下：</h3><p>目前支持模拟机型较少， 参照：仿真设备列表</p>
<blockquote>
<p>from time import sleep<br>from playwright import sync_playwright<br />with sync_playwright() as p:<br>    GalaxyS5 &#x3D; p.devices[‘Galaxy S5’]<br>    browser &#x3D; p.chromium.launch(headless&#x3D;False)<br>    context &#x3D; browser.newContext(**GalaxyS5)<br>    page &#x3D; context.newPage()<br>    page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>    page.click(‘text&#x3D;”智能内容审核”‘)<br>    # 截图<br>    # page.screenshot(path&#x3D;’colosseum-GalaxyS5.png’)<br>    sleep(10)<br>    browser.close()</p>
</blockquote>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Playwright作为新一代自动化测试工具，相较于Selenium不论是易用性，还是实用性都得到了全方位的提升。做到了简约而不简单，相信使用该工具可以帮助我们提升做自动化的工作效率。<br>到此这篇关于Playwright快速上手指南(入门教程)的文章就介绍到这了,更多相关Playwright入门内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>PlayWright教程(一)</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/06_PlayWright%E6%95%99%E7%A8%8B(%E4%B8%80)/</url>
    <content><![CDATA[<p>PlayWright的核心概念包括：</p>
<ul>
<li><a href="https://playwright.dev/python/docs/core-concepts#browser" title="Browser">Browser</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#browser-contexts" title="Browser contexts">Browser contexts</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#pages-and-frames" title="Pages and frames">Pages and frames</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#selectors" title="Selectors">Selectors</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#auto-waiting" title="Auto-waiting">Auto-waiting</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#execution-contexts-playwright-and-browser" title="Execution contexts: Playwright and Browser">Execution contexts: Playwright and Browser</a></li>
<li><a href="https://playwright.dev/python/docs/core-concepts#evaluation-argument" title="Evaluation Argument">Evaluation Argument</a><h1 id="1-Browser"><a href="#1-Browser" class="headerlink" title="1. Browser"></a>1. Browser</h1>一个Browser是一个Chromium, Firefox 或 <a href="https://so.csdn.net/so/search?q=WebKit&spm=1001.2101.3001.7020">WebKit</a>（plarywright支持的三种浏览器）的实例plarywright脚本通常以启动浏览器实例开始，以关闭浏览器结束。浏览器实例可以在headless（没有 GUI）或head模式下启动。Browser实例创建：<pre><code class="python">from playwright.sync_api import sync_playwright
with sync_playwright() as p:
  browser = p.chromium.launch(headless=False)
  browser.close()
</code></pre>
启动browser实例是比较耗费资源的，plarywright做的就是如何通过一个browser实例最大化多个BrowserContext的性能。<br>API:</li>
<li><a href="https://playwright.dev/python/docs/api/class-browser" title="Browser">Browser</a><h1 id="2-BrowserContext"><a href="#2-BrowserContext" class="headerlink" title="2.BrowserContext"></a>2.BrowserContext</h1>一个BrowserContex就像是一个独立的匿名模式会话（session），非常轻量，但是又完全隔离。<br>（译者注：每个browser实例可有多个BrowserContex，且完全隔离。比如可以在两个BrowserContext中登录两个不同的账号，也可以在两个 context 中使用不同的代理。 ）<br>context创建：<pre><code class="python">browser = playwright.chromium.launch()
context = browser.new_context()
</code></pre>
context还可用于模拟涉及移动设备、权限、区域设置和配色方案的多页面场景，如移动端context创建：<pre><code class="python">from playwright.sync_api import sync_playwright
with sync_playwright() as p:
  iphone_11 = p.devices[&#39;iPhone 11 Pro&#39;]
  browser = p.webkit.launch(headless=False)
  context = browser.new_context(
      **iphone_11,
      locale=&#39;de-DE&#39;,
      geolocation=&#123; &#39;longitude&#39;: 12.492507, &#39;latitude&#39;: 41.889938 &#125;,
      permissions=[&#39;geolocation&#39;]
  )
  browser.close()
</code></pre>
API:</li>
<li><a href="https://playwright.dev/python/docs/api/class-browsercontext" title="BrowserContext">BrowserContext</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-browser#browser-new-context" title="browser.new_context(**kwargs)">browser.new_context(**kwargs)</a></li>
</ul>
<h1 id="3-Page-和-Frame"><a href="#3-Page-和-Frame" class="headerlink" title="3. Page 和 Frame"></a>3. Page 和 <a href="https://so.csdn.net/so/search?q=Frame&spm=1001.2101.3001.7020">Frame</a></h1><p> 一个BrowserContext可以有多个page，每个page代表一个tab或者一个弹窗。page用于导航到URL并与page内的内容交互。<br>创建page:</p>
<pre><code class="python">page = context.new_page()
# Navigate explicitly, similar to entering a URL in the browser.
page.goto(&#39;http://example.com&#39;)
# Fill an input.
page.fill(&#39;#search&#39;, &#39;query&#39;)
# Navigate implicitly by clicking a link.
page.click(&#39;#submit&#39;)
# Expect a new url.
print(page.url)
# Page can navigate from the script - this will be picked up by Playwright.
# window.location.href = &#39;https://example.com&#39;
</code></pre>
<p> 一个page可以有多个frame对象，但只有一个主frame，所有page-level的操作(比如click），都是作用在主frame上的。page的其他frame会打上<code>iframe</code> HTML标签，这些frame可以在内部操作实现访问。</p>
<pre><code class="python"># 通过name属性获取frame
frame = page.frame(&#39;frame-login&#39;)

# 通过URL获取frame
frame = page.frame(url=r&#39;.*domain.*&#39;)

# 通过其他选择器(selector)获取frame
frame_element_handle = page.query_selector(&#39;.frame-class&#39;)
frame = frame_element_handle.content_frame()

# 与frame交互
frame.fill(&#39;#username-input&#39;, &#39;John&#39;)
</code></pre>
<p>在录制模式下，会自动识别是否是frame内的操作，不好定位frame时，那么可以使用录制模式来找。</p>
<p>API：</p>
<ul>
<li><a href="https://playwright.dev/python/docs/api/class-page" title="Page">Page</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-frame" title="Frame">Frame</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-page#page-frame" title="page.frame(**kwargs)">page.frame(**kwargs)</a></li>
</ul>
<h1 id="4-Selector"><a href="#4-Selector" class="headerlink" title="4. Selector"></a>4. <a href="https://so.csdn.net/so/search?q=Selector&spm=1001.2101.3001.7020">Selector</a></h1><p> playwright可以通过 CSS selector, XPath selector, HTML 属性（比如 <code>id</code>, <code>data-test-id）或者是文本内容</code>定位元素。</p>
<p>除了xpath selector外，所有selector默认都是指向shadow DOM，如果要指向常规DOM，可使用*:light。不过通常不需要。</p>
<pre><code class="python"># Using data-test-id= selector engine
page.click(&#39;data-test-id=foo&#39;)

# CSS and XPath selector engines are automatically detected
page.click(&#39;div&#39;)
page.click(&#39;//html/body/div&#39;)

# Find node by text substring
page.click(&#39;text=Hello w&#39;)

# Explicit CSS and XPath notation
page.click(&#39;css=div&#39;)
page.click(&#39;xpath=//html/body/div&#39;)

# Only search light DOM, outside WebComponent shadow DOM:
page.click(&#39;css:light=div&#39;)

# 不同的selector可组合使用，用 &gt;&gt;连接
# Click an element with text &#39;Sign Up&#39; inside of a #free-month-promo.
page.click(&#39;#free-month-promo &gt;&gt; text=Sign Up&#39;)

# Capture textContent of a section that contains an element with text &#39;Selectors&#39;.
section_text = page.eval_on_selector(&#39;*css=section &gt;&gt; text=Selectors&#39;, &#39;e =&gt; e.textContent&#39;)
</code></pre>
<p>详细：</p>
<p><a href="https://playwright.dev/python/docs/selectors/" title="Element selectors | Playwright Python">Element selectors | Playwright Python</a></p>
<h1 id="5-Auto-waiting"><a href="#5-Auto-waiting" class="headerlink" title="5.  Auto-waiting"></a>5.  Auto-waiting</h1><p>playwright在执行操作之前对元素执行一系列可操作性检查，以确保这些行动按预期运行。它会自动等待（auto-wait）所有相关检查通过，然后才执行请求的操作。如果所需的检查未在给定的范围内通过<code>timeout</code>，则操作将失败并显示<code>TimeoutError</code></p>
<p>如 <a href="https://playwright.dev/python/docs/api/class-page#page-click" title="page.click(selector, **kwargs)">page.click(selector, **kwargs)</a> 和 <a href="https://playwright.dev/python/docs/api/class-page#page-fill" title="page.fill(selector, value, **kwargs)">page.fill(selector, value, **kwargs)</a> 这样的操作会执行auto-wait ，等待元素变成可见（visible）和 可操作（ <a href="https://playwright.dev/python/docs/actionability" title="actionable">actionable</a>）。例如，click将会:</p>
<ul>
<li>等待selectorx选定元素出现在 DOM 中</li>
<li>待它变得可见（visible）：有非空的边界框且没有 <code>visibility:hidden</code></li>
<li>等待它停止移动：例如，等待 css 过渡（css transition）完成</li>
<li>将元素滚动到视图中</li>
<li>等待它在动作点接收点事件：例如，等待元素不被其他元素遮挡</li>
<li>如果在上述任何检查期间元素被分离，则重试</li>
</ul>
<pre><code class="python"># Playwright waits for #search element to be in the DOM
page.fill(&#39;#search&#39;, &#39;query&#39;)

# Playwright waits for element to stop animating
# and accept clicks.
page.click(&#39;#search&#39;)

#也可显示执行等待动作

# Wait for #search to appear in the DOM.
page.wait_for_selector(&#39;#search&#39;, state=&#39;attached&#39;)
# Wait for #promo to become visible, for example with `visibility:visible`.
page.wait_for_selector(&#39;#promo&#39;)

# Wait for #details to become hidden, for example with `display:none`.
page.wait_for_selector(&#39;#details&#39;, state=&#39;hidden&#39;)
# Wait for #promo to be removed from the DOM.
page.wait_for_selector(&#39;#promo&#39;, state=&#39;detached&#39;)
</code></pre>
<p> API:</p>
<ul>
<li><a href="https://playwright.dev/python/docs/api/class-page#page-click" title="page.click(selector, **kwargs)">page.click(selector, **kwargs)</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-page#page-fill" title="page.fill(selector, value, **kwargs)">page.fill(selector, value, **kwargs)</a></li>
<li><a href="https://playwright.dev/python/docs/api/class-page#page-wait-for-selector" title="page.wait_for_selector(selector, **kwargs)">page.wait_for_selector(selector, **kwargs)</a></li>
</ul>
<h1 id="6-Execution-context"><a href="#6-Execution-context" class="headerlink" title="6. Execution context"></a>6. Execution context</h1><p>API <a href="https://playwright.dev/python/docs/api/class-page#page-evaluate" title="page.evaluate(expression, **kwargs)">page.evaluate(expression, **kwargs)</a> 可以用来运行web页面中的 JavaScript函数，并将结果返回到plarywright环境中。浏览器的<a href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">全局变量</a>，如 <code>window</code> 和 <code>document，</code> 可用于 <code>evaluate。</code></p>
<pre><code class="python">href = page.evaluate(&#39;() =&gt; document.location.href&#39;)

# if the result is a Promise or if the function is asynchronous evaluate will automatically wait until it&#39;s resolved

status = page.evaluate(&quot;&quot;&quot;async () =&gt; &#123;
  response = fetch(location.href)
  return response.status
&#125;&quot;&quot;&quot;)
</code></pre>
<h2 id="7-Evaluation-Argument"><a href="#7-Evaluation-Argument" class="headerlink" title="7. Evaluation Argument"></a>7. Evaluation Argument</h2><p>  <a href="https://playwright.dev/python/docs/api/class-page#page-evaluate" title="page.evaluate(expression, **kwargs)">page.evaluate(expression, **kwargs)</a> 方法接收单个可选参数。此参数可以是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description" title="Serializable">Serializable</a>值和<a href="https://playwright.dev/python/docs/api/class-jshandle" title="JSHandle">JSHandle</a>或<a href="https://playwright.dev/python/docs/api/class-elementhandle" title="ElementHandle">ElementHandle</a>实例的混合。句柄会自动转换为它们所代表的值</p>
<pre><code class="python">result = page.evaluate(&quot;([x, y]) =&gt; Promise.resolve(x * y)&quot;, [7, 8])
print(result) # prints &quot;56&quot;


print(page.evaluate(&quot;1 + 2&quot;)) # prints &quot;3&quot;
x = 10
print(page.evaluate(f&quot;1 + &#123;x&#125;&quot;)) # prints &quot;11&quot;


body_handle = page.query_selector(&quot;body&quot;)
html = page.evaluate(&quot;([body, suffix]) =&gt; body.innerHTML + suffix&quot;, [body_handle, &quot;hello&quot;])
body_handle.dispose()


# A primitive value.
page.evaluate(&#39;num =&gt; num&#39;, 42)

# An array.
page.evaluate(&#39;array =&gt; array.length&#39;, [1, 2, 3])

# An object.
page.evaluate(&#39;object =&gt; object.foo&#39;, &#123; &#39;foo&#39;: &#39;bar&#39; &#125;)

# A single handle.
button = page.query_selector(&#39;button&#39;)
page.evaluate(&#39;button =&gt; button.textContent&#39;, button)

# Alternative notation using elementHandle.evaluate.
button.evaluate(&#39;(button, from) =&gt; button.textContent.substring(from)&#39;, 5)

# Object with multiple handles.
button1 = page.query_selector(&#39;.button1&#39;)
button2 = page.query_selector(&#39;.button2&#39;)
page.evaluate(&quot;&quot;&quot;o =&gt; o.button1.textContent + o.button2.textContent&quot;&quot;&quot;,
    &#123; &#39;button1&#39;: button1, &#39;button2&#39;: button2 &#125;)

# Object destructuring works. Note that property names must match
# between the destructured object and the argument.
# Also note the required parenthesis.
page.evaluate(&quot;&quot;&quot;
    (&#123; button1, button2 &#125;) =&gt; button1.textContent + button2.textContent&quot;&quot;&quot;,
    &#123; &#39;button1&#39;: button1, &#39;button2&#39;: button2 &#125;)

# Array works as well. Arbitrary names can be used for destructuring.
# Note the required parenthesis.
page.evaluate(&quot;&quot;&quot;
    ([b1, b2]) =&gt; b1.textContent + b2.textContent&quot;&quot;&quot;,
    [button1, button2])

# Any non-cyclic mix of serializables and handles works.
page.evaluate(&quot;&quot;&quot;
    x =&gt; x.button1.textContent + x.list[0].textContent + String(x.foo)&quot;&quot;&quot;,
    &#123; &#39;button1&#39;: button1, &#39;list&#39;: [button2], &#39;foo&#39;: None &#125;)
</code></pre>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>PlayWright教程(二)</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/07_PlayWright%E6%95%99%E7%A8%8B(%E4%BA%8C)/</url>
    <content><![CDATA[<h2 id="页面基本操作"><a href="#页面基本操作" class="headerlink" title="页面基本操作"></a><strong>页面基本操作</strong></h2><p><a href="https://playwright.bootcss.com/docs/navigations" title="Navigations | Playwright 中文文档 | Playwright 中文网">Navigations | Playwright 中文文档 | Playwright 中文网</a></p>
<p>按照官网文档，调用 page.goto(url) 后页面加载过程：</p>
<ol>
<li>设定 url</li>
<li>通过网络加载解析页面</li>
<li>触发 page.on(“domcontentloaded”) 事件</li>
<li>执行页面的 js 脚本，加载静态资源</li>
<li>触发 page.on(“laod”) 事件</li>
<li>页面执行动态加载的脚本</li>
<li>当 500ms 都没有新的网络请求的时候，触发 networkidle 事件<br><code>page.goto(url)</code> 会跳转到一个新的链接。默认情况下 Playwright 会等待到 load 状态。如果我们不关心加载的 CSS 图片等信息，可以改为等待到 domcontentloaded 状态，如果页面是 ajax 加载，那么我们需要等待到 networkidle 状态。如果 networkidle 也不合适的话，可以采用 page.wait_for_selector 等待某个元素出现。不过对于 click 等操作会自动等待。<pre><code class="python">page.goto(url, referer=&quot;&quot;, timeout=30, wait_until=&quot;domcontentloaded|load|networkidle&quot;)
// Navigate and wait until network is idle
await page.goto(&#39;https://example.com&#39;, &#123; waitUntil: &#39;networkidle&#39; &#125;);
</code></pre>
</li>
</ol>
<p>Playwright 会自动等待元素处于可操作的稳定状态。当然也可以用 <code>page.wait_for_*</code> 函数来手工等待：</p>
<pre><code class="python">page.wait_for_event(&quot;event&quot;, event_predict, timeout)
page.wait_for_function(js_function)
page.wait_for_load_state(state=&quot;domcontentloaded|load|networkidle&quot;, timeout)
page.wait_for_selector(selector, timeout)
page.wait_for_timeout(timeout)  # 不推荐使用
</code></pre>
<p>对页面的操作方法主要有：</p>
<pre><code class="python"># selector 指的是 CSS 等表达式
page.click(selector)
page.fill(selector, value)  # 在 input 中填充值

# 例子
page.click(&quot;#search&quot;)
</code></pre>
<p>获取页面中的数据的主要方法有：</p>
<pre><code class="python">page.url  # url
page.title()  # title
page.content()  # 获取页面全文
page.inner_text(selector)  # element.inner_text()
page.inner_html(selector)
page.text_content(selector)
page.get_attribute(selector, attr)

# eval_on_selector 用于获取 DOM 中的值
page.eval_on_selector(selector, js_expression)
# 比如：
search_value = page.eval_on_selector(&quot;#search&quot;, &quot;el =&gt; el.value&quot;)

# evaluate 用于获取页面中 JS 中的数据，比如说可以读取 window 中的值
result = page.evaluate(&quot;([x, y]) =&gt; Promise.resolve(x * y)&quot;, [7, 8])
print(result) # prints &quot;56&quot;
</code></pre>
<h3 id="选择器表达式"><a href="#选择器表达式" class="headerlink" title="选择器表达式"></a><strong>选择器表达式</strong></h3><p>在上面的代码中，我们使用了 CSS 表达式（比如<code>#button</code>）来选取元素。实际上，Playwright 还支持 XPath 和自己定义的两种简单表达式，并且是自动识别的。</p>
<pre><code class="python"># 通过文本选择元素，这是 Playwright 自定义的一种表达式
page.click(&quot;text=login&quot;)

# 直接通过 id 选择
page.click(&quot;id=login&quot;)

# 通过 CSS 选择元素
page.click(&quot;#search&quot;)
# 除了常用的 CSS 表达式外，Playwright 还支持了几个新的伪类
# :has 表示包含某个元素的元素
page.click(&quot;article:has(div.prome)&quot;)
# :is 用来对自身做断言
page.click(&quot;button:is(:text(&#39;sign in&#39;), :text(&#39;log in&#39;))&quot;)
# :text 表示包含某个文本的元素
page.click(&quot;button:text(&#39;Sign in&#39;)&quot;)  # 包含
page.click(&quot;button:text-is(&#39;Sign is&#39;)&quot;)  # 严格匹配
page.click(&quot;button:text-matches(&#39;\w+&#39;)&quot;)  # 正则
# 还可以根据方位匹配
page.click(&quot;button:right-of(#search)&quot;)  # 右边
page.click(&quot;button:left-of(#search)&quot;)  # 左边
page.click(&quot;button:above(#search)&quot;)  # 上边
page.click(&quot;button:below(#search)&quot;)  # 下边
page.click(&quot;button:near(#search)&quot;)  # 50px 之内的元素

# 通过 XPath 选择
page.click(&quot;//button[@id=&#39;search&#39;])&quot;)
# 所有 // 或者 .. 开头的表达式都会默认为 XPath 表达式
</code></pre>
<p>对于 CSS 表达式，还可以添加前缀<code>css=</code>来显式指定，比如说 <code>css=.login</code> 就相当于 <code>.login</code>.</p>
<p>除了上面介绍的四种表达式以外，Playwright 还支持使用 <code>&gt;&gt;</code> 组合表达式，也就是混合使用四种表达式。</p>
<pre><code class="python">page.click(&#39;css=nav &gt;&gt; text=Login&#39;)
</code></pre>
<h2 id="复用-Cookies-等认证信息"><a href="#复用-Cookies-等认证信息" class="headerlink" title="复用 Cookies 等认证信息"></a><strong>复用 Cookies 等认证信息</strong></h2><p>在 Puppeteer 中，复用 Cookies 也是一个老大难问题了。这个是 Playwright 特别方便的一点，他可以直接导出 Cookies 和 LocalStorage, 然后在新的 Context 中使用。</p>
<pre><code class="python"># 保存状态
import json
storage = context.storage_state()
with open(&quot;state.json&quot;, &quot;w&quot;) as f:
    f.write(json.dumps(storage))

# 加载状态
with open(&quot;state.json&quot;) as f:
    storage_state = json.loads(f.read())
context = browser.new_context(storage_state=storage_state)
</code></pre>
<h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a><strong>监听事件</strong></h2><p>通过 page.on(event, fn) 可以来注册对应事件的处理函数：</p>
<pre><code class="python">def log_request(intercepted_request):
    print(&quot;a request was made:&quot;, intercepted_request.url)
page.on(&quot;request&quot;, log_request)
# sometime later...
page.remove_listener(&quot;request&quot;, log_request)
</code></pre>
<p>其中比较重要的就是 request 和 response 两个事件</p>
<h3 id="拦截更改网络请求"><a href="#拦截更改网络请求" class="headerlink" title="拦截更改网络请求"></a><strong>拦截更改网络请求</strong></h3><p>可以通过 page.on(“request”) 和 page.on(“response”) 来监听请求和响应事件。</p>
<pre><code class="python">from playwright.sync_api import sync_playwright as playwright

def run(pw):
    browser = pw.webkit.launch()
    page = browser.new_page()
    # Subscribe to &quot;request&quot; and &quot;response&quot; events.
    page.on(&quot;request&quot;, lambda request: print(&quot;&gt;&gt;&quot;, request.method, request.url))
    page.on(&quot;response&quot;, lambda response: print(&quot;&lt;&lt;&quot;, response.status, response.url))
    page.goto(&quot;https://example.com&quot;)
    browser.close()

with playwright() as pw:
    run(pw)
</code></pre>
<p>其中 request 和 response 的属性和方法，可以查阅文档：<a href="https://link.zhihu.com/?target=https://playwright.dev/python/docs/api/class-request" title="https://playwright.dev/python/docs/api/class-request">https://playwright.dev/python/docs/api/class-request</a></p>
<p>通过 context.route, 还可以伪造修改拦截请求等。比如说，拦截所有的图片请求以减少带宽占用：</p>
<pre><code class="python">context = browser.new_context()
page = context.new_page()
# route 的参数默认是通配符，也可以传递编译好的正则表达式对象
context.route(&quot;**/*.&#123;png,jpg,jpeg&#125;&quot;, lambda route: route.abort())
context.route(re.compile(r&quot;(\.png$)|(\.jpg$)&quot;), lambda route: route.abort())
page.goto(&quot;https://example.com&quot;)
browser.close()
</code></pre>
<p>其中 route 对象的相关属性和方法，可以查阅文档：<a href="https://link.zhihu.com/?target=https://playwright.dev/python/docs/api/class-route" title="https://playwright.dev/python/docs/api/class-route">https://playwright.dev/python/docs/api/class-route</a></p>
<h3 id="灵活设置代理"><a href="#灵活设置代理" class="headerlink" title="灵活设置代理"></a><strong>灵活设置代理</strong></h3><p>Playwright 还可以很方便地设置代理。Puppeteer 在打开浏览器之后就无法在更改代理了，对于爬虫类应用非常不友好，而 Playwright 可以通过 Context 设置代理，这样就非常轻量，不用为了切换代理而重启浏览器。</p>
<pre><code class="python">context = browser.new_context(
    proxy=&#123;&quot;server&quot;: &quot;http://example.com:3128&quot;, &quot;bypass&quot;: &quot;.example.com&quot;, &quot;username&quot;: &quot;&quot;, &quot;password&quot;: &quot;&quot;&#125;
)
</code></pre>
<h2 id="杀手级功能：录制操作直接生成代码"><a href="#杀手级功能：录制操作直接生成代码" class="headerlink" title="杀手级功能：录制操作直接生成代码"></a><strong>杀手级功能：录制操作直接生成代码</strong></h2><p>Playwright 的命令行还内置了一个有趣的功能：可以通过录制你的点击操作，直接生成 Python 代码。</p>
<pre><code class="python">python -m playwright codegen http://example.com/
</code></pre>
<p>Playwright 还有很多命令行功能，比如生成截图等等，可以通过 <code>python -m playwright -h</code> 查看。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><p>除此之外，Playwright 还支持处理页面弹出的窗口，模拟键盘，模拟鼠标拖动（用于滑动验证码），下载文件等等各种功能，请查看官方文档吧，这里不赘述了。对于写爬虫来说，Playwright 的几个特性可以说是秒杀 Puppeteer&#x2F;Pyppeteer:</p>
<ol>
<li>官方同步版本的 API</li>
<li>方便导入导出 Cookies</li>
<li>轻量级设置和切换代理</li>
<li>支持丰富的选择表达式</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>接口自动化</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/08_%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[<ol>
<li>自动化测试具体怎么做的（流程怎么样的？）<ol>
<li>？？？？？<ol>
<li>用什么做的？</li>
<li>需要注意什么？核心关键是什么？</li>
<li>具体步骤是怎样的？</li>
</ol>
</li>
<li>接口自动化这块，我们当时用的 python+requests 库来写脚本的，例外，也会用到其他的一些库像ddt,unittest,xlrd,json,re,pymysql,htmlreport 等另外的话，我觉得做接口自动化，最关键的还是’用例数据的准备’，’请求数据的组装’，’及请求发送’， 和对’响应数据的提取处理’，与’判断校验&#x2F;做断言’。当然要做自动化，首先就是要搭建好自动化测试环境，之后就准备好用例数据嘛，像用例数据这块的话，公司统一要求用 excel 表格来管理的，这里面主要就是用例标题，url,请求方式，请求头，请求参数，用来做断言的响应数据。其实主要目的就是起到数据与脚本的分离方便后期的管理。数据准备好了之后，然后就开始写脚本，首先把相关的包导入进来，之后调用封装好的函数来读取excel表格中的用例数据，数据返回出来是一个列表形式。然后就是定义个类，去继承unittest.TestCase 基类,并重写其中 setUp,tearDown方法，在setUp方法中主要就是做一些初始化的准备工作，tearDown 中主要完成一些回收工作，比如，像连接数据库可以放在setUp方法中，在 tearDown 方法关闭数据库的连接然后实现用例函数，用例函数必须要以 test开头，这里的话，用例函数中主要就是实现请求数据的组装，还有就是调用 requests库中的get或 post方法发请求，把相关的参数传进去，请求参数这块我们需要用到 ddt 模型，去引用前面提取出来的 list 中的额数据这边请求发送之后会返回一个响应对象，这里面接下来其实最主要的就是对响应对象中的数据进行提取处理，并判断校验并做断言。断言这块这一块的话，主要就是关注几个点，一个就是状态码，还有就是响应信息，不过，这里面最重要的是响应的正文内容的判断。主要就是判断这几个块与结构文档是否一致。对于响应的正文内容，可能会比较麻烦一点，因为一般后台会返回两种格式的数据，一种是 json 格式的数据，其实对于 json 格式的数据我们需要把它转化为字典形式，治理其实主要就是调用response.json()函数就已经转为字典，然后去提取其中的一些核心信息去做断言判断就可以了。例外，如果返回的是 html 格式的数据，我们需要用到一个 re 库，并调用其中的一个函数 findall 结合正则表达式提取关键信息做断言判断。断言的一些函数，其实都是调用 unittest 框架中的函数实现,像assertEqual，assertIn,以及做全量对标的话，需要用到 assertListEuqal,assertDictEqual 主要就是这些。脚本这块差不多就是这么写的，最后我们需要引入一个 htmlreport 库去自动生成自动化报告，然后就是对报告进行分析，报告这一块的话，主要有通过，异常，失败几种请情况，如果如果错误的话，基本一般都是脚本问题，这个时候我们需要去重新调试我们的脚本，如果是失败的话，一般来说，我都会先检查自己的脚本是否有问题，如果没有问题基本就可以提 Bug了。接口自动化我们当时就这么做的。</li>
</ol>
</li>
<li><h3 id="request框架有哪些方法？"><a href="#request框架有哪些方法？" class="headerlink" title="request框架有哪些方法？"></a><strong>request</strong>框架有哪些方法？</h3><ol>
<li>像用来发送请求的一般都是调用以下方法<br> reponse &#x3D; requests.get()<br> reponse &#x3D; requests.post()<br> 获取响应数据一般都是调用以下方法<br> reponse.status_code<br> reponse.reason<br> reponse.text reponse.json()<br> reponse.headers<br> reponse.cookies</li>
</ol>
</li>
<li><h3 id="接口自动化用过哪些库？"><a href="#接口自动化用过哪些库？" class="headerlink" title="接口自动化用过哪些库？"></a>接口自动化用过哪些库？</h3><ol>
<li>Requests 库   这个里面主要封装了各种发送请求处理请求的方法<br> Json 库           这个库主要用来将 json 格式转化为字典，或者将字典转化为 json 格式数据<br> Re 库             这个库当时是针对后台返回的是 html 格式，用来提取html 格式中的数据的<br> Xlrd库            这个库当时主要用来读取 excel 表格数据的<br> Ddt 库           这个库主要用来实现数据驱动的<br> Pymysql库     这个库主要就是用来读取数据库，操作数据库的。差不多当时好像这些库都是有用过的吧。</li>
</ol>
</li>
<li><h3 id="如果要传递请求头如何处理？"><a href="#如果要传递请求头如何处理？" class="headerlink" title="如果要传递请求头如何处理？"></a>如果要传递请求头如何处理？</h3><ol>
<li>传递请求头，其实还是比较简单的，首先要搞清楚这个接口需要传递哪些请求求参数，然后订制一个请求头，一般都是组装成一个字典，然后在调用 post 或 get 方法发请求的时候，在这两个函数中有一个参数headers，这个参数就是用来传递请求头的，把组装好的请求头通过headers 参数进行传递就可以了。</li>
</ol>
</li>
<li><h3 id="你们做接口自动化，用例数据是怎么组织，管理的？"><a href="#你们做接口自动化，用例数据是怎么组织，管理的？" class="headerlink" title="你们做接口自动化，用例数据是怎么组织，管理的？"></a>你们做接口自动化，用例数据是怎么组织，管理的？</h3><ol>
<li>用例数据这块，当时公司要求使用 excel 表格来进行管理，其实这里主要也是为了实现数据与脚本的分离，提高整个工程后期的维护与优化，这里把数据封装到 excel 表格之后<br> 我们在脚本中通过调用封装好的读取 excel 表格的数据函数，然后利用 ddt 模型来引用这些数据组织请求参数或头，发请求。<br> 对 excel 表格中的用例数据，我们是这么组织的，会有以下几个字段像用例标题，请求地址， 请求方式，请求头，请求参数，响应结果，这个几个部分，对于请求头跟请求参数，因为<br> 脚本中发请求都是通过组装成字典的形式来发送的，所以这里我们也是通过类似于字典的形式文本格式来进行组织，主要就是方便后期脚本的提取与引用。<br> 其实我觉得，这样去处理的好处就是，后期如果用例数据有变动，或者需要增加或删除部分用例直接针对excel 表格数据进行操作就可以了，不需要改动脚本。<br> 这也就方便整个项目工程的管理与维护了。</li>
</ol>
</li>
<li><h3 id="接口自动化的用例又是怎么管理的？"><a href="#接口自动化的用例又是怎么管理的？" class="headerlink" title="接口自动化的用例又是怎么管理的？"></a>接口自动化的用例又是怎么管理的？</h3><ol>
<li>自动化用例这块，我们利用 unittest 框架来编写的，然后利用unittest 帮我们去统一加载执行用例。如果要全量执行的话， 通过调用 unittest 里面提供的 defaultTestLoader.discover()这个函数来加载test_case目录下的所有用例执行即可， 如果某条用例没有通过， 需要单独调试， 可以通过unittest.TestLoader()来创建一个加载器，加载具体的某条用例进行执行，调试即可。最后就是结合HTMLReport 这个库最终会自动帮我们生成报告。</li>
</ol>
</li>
<li><h3 id="对于返回的数据，你怎么检查校验？"><a href="#对于返回的数据，你怎么检查校验？" class="headerlink" title="对于返回的数据，你怎么检查校验？"></a>对于返回的数据，你怎么检查校验？</h3><ol>
<li>这块的话，首先我们一定得搞清楚后台返回的到底是什么格式的数据，一般都是两种情况，一种就是json格式的数据，一种就是 html格式的数据，关注几个点一般有以下几个点，1.  状态码   2.  响应信息对不对     3.也是最重要的就是响应内容，如果正文内容是 json 格式的数据，我们就使用 response.json()函数来提取就可以了，如果是正文内容 html格式的数据，我们就使用 response.text来提取，然后利用re 库中 findall函数结合正则表达式来提取核心字段进行校验。对于响应内容，我们需要根据接口文档的说明， 去检查一些核心的字段信息，去判断就行了。例外，如果有些接口需要检查数据库的话，那我们去连接数据库，查询对应数据，然后去判断校验,断言这块我当时就是这么做的。</li>
</ol>
</li>
<li><h3 id="对于接口响应数据，你是怎么做断言的？"><a href="#对于接口响应数据，你是怎么做断言的？" class="headerlink" title="对于接口响应数据，你是怎么做断言的？"></a>对于接口响应数据，你是怎么做断言的？</h3><ol>
<li>我首先确定需要检查的键是否存在，assertIn 去判断键是否存在，如果键存在，然后根据键去获取其中的值，如果值是变化的，有可能有，有可能没有，或者值本身在发生变化，这里需要读取数据库中的实际对应的字段值，然后判断返回结果中的对应字段的值与数据库中读取出来的值是否一致。</li>
</ol>
</li>
<li><h3 id="你写了多少接口自动化用例"><a href="#你写了多少接口自动化用例" class="headerlink" title="你写了多少接口自动化用例"></a>你写了多少接口自动化用例</h3><ol>
<li>自动化用例，也没有具体数过，当时我负责的所有模块的接口的自动用例都是我这边独立完成的，有模块的用例会多一点，有些会少一点，这具体看接口的参数有多少，参数多限制条件多的，一般用例会比较多一点，我负责的模块大概有 100多条用例是有的吧！</li>
</ol>
</li>
<li><h3 id="你们接口自动化用例是怎么跑的？"><a href="#你们接口自动化用例是怎么跑的？" class="headerlink" title="你们接口自动化用例是怎么跑的？"></a>你们接口自动化用例是怎么跑的？</h3><ol>
<li>一般正常我们都是全量跑的，如果要全量跑，我们一般都是加载用例目录也就是 testcase下的所有用例文件这里主要就是调用unittest.defaultTestLoader.discover(用例目录的路径，匹配规则)函数进行加载所有用例文件。有时候如果只是某个模块的用例执行不通过，需要单独执行调试某个模块的用例。这里可以先创建一个套件，调用 unittest.testsuite()来进行创建然后调用  unittest.testLoader()函数来创建一个加载器然后在加载具体某个模块的具体用例去执行调试。如果要定时全量跑所有的用例，一般我们都是在每周五下午会定时全量跑所有的用例，然后周一过来看报告分析报告，这里就需要用到持续集成，我们当时用的 jenkins，从 SVN上检出自动化脚本，然后让jenkins自动帮我们去跑。</li>
</ol>
</li>
<li><h3 id="有没有了解过数据驱动？"><a href="#有没有了解过数据驱动？" class="headerlink" title="有没有了解过数据驱动？"></a>有没有了解过数据驱动？</h3><ol>
<li>数据驱动就是把用例数据与脚本代码进行分离，把用例数据进行独立出来嘛，它的好处就在于方便后台的管理维护。这样的话，如果数据后期发生变化，只要维护修改 excel 表格中的数据就可以，比如，需要增加数据或者需要删除某条用例数据，或者修改数据就变得比较方便。<br> 对于自动化用例数据我们公司当时要求放在 Excel 表格中来管理的，然后保存在工程中的 data 目录下，之后就是通过调用封装好的函数去读取数据，然后利用 ddt 模型来实现数据的驱动，对于 ddt 模型， 它所采用的就是 python 装饰器的原理来引用数据的。<br> 例外，对于一些其他的一些常量数据，比如：文件的路径，用例的路径，邮件的配置信息，数据库的一些配置信息，我们都是通过配置文件来管理的，我们会在工程中创建一个 config目录，然后把配置文件都是放在这个目录下的。<br> 当时数据驱动这块就是这么来实现的。</li>
</ol>
</li>
<li><h3 id="有没有自己封装过函数"><a href="#有没有自己封装过函数" class="headerlink" title="有没有自己封装过函数]()?"></a><strong>有没有自己封装过函数]()</strong>?</h3><ol>
<li>也有自己封装过，但是不很多，大部分都调用公司&#x2F;老大封装好的函数来进行实现的像当时那个数据操作的相关模块这边是我封装，例外，像读取 Excel 表格数据的模块<br> 也是我这边封装，除了这个之外，还封装过一些其他函数，比如获取 cookie 值，获取手机验证码的函数等，这边都是有封装过的……</li>
<li><img src="/assets/1/image-20211203223308-nfhjajx.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211203223328-08gzxth.png" alt="image.png"></li>
</ol>
</li>
<li><h3 id="接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？"><a href="#接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？" class="headerlink" title="接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？"></a>接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？</h3><ol>
<li>报告这一块，我们当时是用那个htmlreport 这个库去生成的？首先主要关注运行结果，看有多少用例通过了，有多少执行失败，有多少执行错误。一般报告上都会详细说明，我们主要看失败用例以及错误用例，对于失败的用例跟错误的用例一般在报告上都会有详细细节说明，到底哪里执行没有通过。对于执行错误的用例，一般都是自己的脚本编写有问题，这个我一般会找到对应用例代码去调试查看。<br> 对于失败用例，我一般首先怀疑自己的脚本，先检查自己的脚本有没有问题，如果不是自己脚本问题导致的，那这就说明这条用例真的执行失败了，一般就提 BUG 就可以了。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>06_第六章自动化测试</category>
        <category>999_自动化测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Monkey使用</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_Monkey%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>一、Monkey压力测试的原理</strong><br><strong>1. adb shell monkey的运行机制</strong><br><strong>实际上是执行手机中&#x2F;system&#x2F;bin&#x2F;monkey这个脚本；</strong><br><strong>2. Monkey事件注入机制Monkey注入系统事件是通过 framework 层的 hidenApi (如：activemanager,inputmanager,windowmanager) 获取系统服务。</strong><br><strong>Monkey中有11种事件，这些事件在MonkeyEventSource中对事件之间的比例进行设置。</strong><br><strong>Monkey事件根据类型比例生成事件队列，循环查找事件。</strong><br><strong>a.触摸事件(inputmanager)：包括屏幕以及物理键的触摸，滑动，点击事件</strong><br><strong>b.Activity事件(activemanager):是指我们调用Android系统组件的事件。</strong><br><strong>c.Window事件(windowmanager)：是指操作Window的事件，例如转屏</strong><br><strong>3.Monkey核心类</strong><br><strong>a. Monkey.java, 程序的入口，根据参数选择合适的MonkeyEventSource，并适时触发MonkeyEvent；</strong><br><strong>b. MonkeyEventSource.java,MonkeyEvent的工厂，是一个接口；</strong><br><strong>c. MonkeyEvent.java，各种事件的具体实现。</strong><br><strong>二、查找手机上的安装包包名</strong><br><strong>1.adb shell pm list package 查看手机上所有的安装包</strong><br><strong>2.adb shell pm list package -3 查看第三方安装包</strong><br><img src="/assets/1/image-20220312153216-8qt8k4z.png" alt="image.png"><br><strong>3.adb shell pm list packages -s 查看系统的包</strong><br><strong>4.adb shell pm list packages -e “要搜索的内容” 查看启动包中搜索的包</strong><br><img src="/assets/1/image-20220312153223-azw8vyc.png" alt="image.png"><br><strong>5.adb shell dumpsys window | findstr mCurrentFocus 后面的是当前启动的acivity）：获取当前打开的APP包名（前面的为包名，斜杠</strong><br><img src="/assets/1/image-20220312153229-ysknr4c.png" alt="image.png"><br><strong>三、Monkey 命令 基本参数的介绍注意：所有的参数都需要放在monkey和设置的次数之间，参数的顺序可以调整；若带了-p ，-p必须放在monkey之后，参数必须在-p和count之间：</strong><br><strong>adb shell monkey -p 包名 –throttle 100 –ignore-crashes –ignore-timeouts –ignore-security-exceptions –ignore-native-crashes –monitor-native-crashes -v -v -v –s 1540475754297 100</strong><br><strong>1.-p ，此命令用于指定包，若不指定则在整个系统中执行</strong><br><strong>a.指定一个包执行10次：adb shell monkey -p包名 10，如下出现事件执行次数和所耗时间，则算是执行成功；</strong><br><img src="/assets/1/image-20220312153237-5ve4t6y.png" alt="image.png"><br><strong>b.指定多个包执行10次：adb shell monkey -p 包名–p包名10，</strong><br><img src="/assets/1/image-20220312153242-oe4tten.png" alt="image.png"><br><strong>2.-v ，用于反馈日志的详细程度级别</strong><br><strong>Level 0:adb shell monkey -p 包名 -v 10&#x2F;&#x2F; 默认级别，仅提供启动、测试完成和最终结果等少量信息</strong><br><strong>Level 1:adb shell monkey -p包名 -v-v 10&#x2F;&#x2F; 提供较为详细的日志，包括每个发送到Activity的事件信息</strong><br><strong>Level 2:adb shell monkey -p包名 -v-v-v 10 &#x2F;&#x2F; 提供最详细的日志，包括了测试中选中&#x2F;未选中的Activity信息</strong><br><strong>3.-s ，用于指定伪随机数生成器的seed值</strong><br><strong>命令：adb shell monkey -p 包名 –s seed值 执行次数</strong><br><strong>如果seed值相同，则两次Monkey测试所产生的事件序列也相同的，示例：</strong><br><strong>测试1：adb shell monkey -pcom.kugou.android –s 1540475754297 100</strong></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>05_第五章APP测试</category>
        <category>999_APP测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Monkey工具介绍</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_Monkey%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Monkey的概念：<br>“猴子测试”是指没有测试经验的人甚至对计算机根本不了解的人（就像猴子一样）不需要知道程序的任何用户交互方面的知识，如果给他一个程序，他就会针对他看到的界面进行操作，其操作是无目的的、乱点乱按的。<br>这种测试方式在产品周期中的早期阶段会找到很多很好的bug，为用户节省不少的时间。<br>Monkey的介绍<br>它是Android系统自带一个命令行工具，可以运行在模拟器里或者真是设备中运行。<br>monkey向系统发送伪随机的用户事件流，实现对正在开发的应用程序进行压力测试。<br>monkey包括很多选项，大致四大类：<br>1.基本配置选项，如设置尝试的事件数量。<br>2.运行约束选项，如设置只对单独的一个包进行测试。<br>3.事件类型和频率。<br>4.调试选项<br>monkey命令特性<br>不可能使用monkey来指定做一样测试，重复做很多次。因为monkey产生的是伪随机的事件流。但是我们可以通过添加命令选项将操作限制在一定的范围内。<br>一，首先你要先搭建环境<br>1.先下载jdk   具体安装流程请参考：<a href="https://blog.csdn.net/write6/article/details/79136388">https://blog.csdn.net/write6/article/details/79136388</a><br>2.再下载sdk  具体安装流程请参考：<a href="https://blog.csdn.net/u011541946/article/details/77142045">https://blog.csdn.net/u011541946/article/details/77142045</a><br>二，打开手机的开发者调试工具，用usb数据线链接你的手机；<br>三，monkey前的准备命令<br>1.windows+r 输入cmd进入dos命令行；<br>2.输入adb devices 下面出现类似下图的组合你就成功了；（<br><img src="/assets/1/image-20220312153527-miroy1y.png" alt="image.png"><br>3.获取包名（我常用的几种）<br>（1）输入 adb shell pm list packages    查看你的手机所有的安装包；输入 adb shell pm list packages -3 查看手机上所有的第三方安装包，看一眼差不多就知道哪一个是你要的安装包;<br>（2）使用uiaotumator之类的软件查看，<br><img src="/assets/1/image-20220312153538-c9b58oa.png" alt="image.png"><br>（3）DOS环境输入：adb shell logcat|findstr “Displayed”   ，打开待测试的APP；<br>红线1是包名，红线2是appActivity（自动化测试时能用到）<br><img src="/assets/1/image-20220312153549-tym78kw.png" alt="image.png"><br>这样可以尽快的找到想要的安装包名称；<br>四，首先用一个最简单的mokey去试着找哪个是你想要的安装包名称：<br>1.&#x2F; &#x2F; -p参数：表示指定测试的程序（空格后面跟安装包名字，拿刚才的第三方安装包一个个试）<br>  &#x2F; &#x2F;-v参数：表示查看monkey执行过程的信息(日志级别）（-v 越多越详细，最多三个）<br>  &#x2F; &#x2F;数字100:表示测试事件数为100<br> 指定一个包   adb shell monkey  -p  com.tencent.news  -v -v -v  100   （此时指定软件会被打开并开始乱点乱按）<br> 指定多个包   adb shell monkey -p com.tencent.news -p com.pdfreader -p com.widgets  -v 1000<br> 不指定包       adb shell monkey -v 1000<br> 结果如图：<br><img src="/assets/1/image-20220312153601-91xcpjd.png" alt="image.png"><br>Event percentages（事件百分比）:<br>0：触摸事件百分比，参数–pct-touch<br>1：滑动事件百分比，参数–pct-motion<br>2：缩放事件百分比，参数–pct-pinchzoom<br>3：轨迹球事件百分比，参数–pct-trackball<br>4：屏幕旋转事件百分比，参数–pct-rotation<br>5：暂时不知道这个是什么<br>6：基本导航事件百分比，参数–pct-nav<br>7：主要导航事件百分比，参数–pct-majornav<br>8：系统事件百分比，参数–pct-syskeys<br>9：Activity启动事件百分比，参数–pct-appswitch<br>10：键盘翻转事件百分比，参数–pct-flip<br>11：其他事件百分比，参数–pct-anyevent<br>2.尽管monkey产生是伪随机事件流，但是我们希望我们的操作有一定的规律性，即按键、触屏等各类事件操作有所偏重。<br>eg：（1）.对文本框操作，需要更多的按键操作。<br>        （2）.玩游戏，需要更多的点击和滑动操作。<br>3.–throttle  设定两个事件之间一个固定延迟，可以减缓monkey的执行速度。如果不指定，monkey将不会被延迟，事件将尽可能快地生成和发送消息。单位：毫秒<br>eg:adb shell monkey  –throttle  3000  -p com.tencent.news  100<br>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。<br>4.–pct-touch  （空格后加数字）设定触屏事件生成的百分比。触屏事件是一个有手指按下，抬起事件的手势。<br>eg:      adb shell monkey   –throttle  3000   –pct-touch  50  -p  com.tencent.news  100<br>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定触屏的事件占比为50%。<br>5.–pct-motion  设定滑动事件生成的百分比。滑动事件是一个先在某一个位置手指按下，滑动一段距离后再抬起手指的手势。<br>eg:       adb shell monkey   –throttle  3000 –pct-motion  50  -p  com.tencent.news  100<br>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定滑动的事件占比为50%。<br>6.–pct-trackball  设定轨迹球事件生成的百分比。轨迹球事件是包含一系列随机移动和单击事件的事件<br>eg:adb shell monkey –throttle  3000 –pct-trackball  50  -p  com.tencent.news  100<br>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定轨迹球的事件占比为50%。<br>7.–pct-nav  设定基本导航事件生成的百分比。基本导航事件是模拟方向性在设备上输入向上、向下、向左、向右的事件。<br>eg:adb shell monkey –throttle  3000 –pct-nav  40  -p  com.tencent.news  100<br>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定基本导航事件的占比为40%。<br>8.–pct-majornav  设定主要导航事件生成的百分比。主要导航事件通常会导致UI产生回馈信息，如单击Back键、Home键、Menu键等、<br>eg:     adb shell monkey  –throttle  3000   –pct-majornav  40  -p  com.tencent.news  100<br>向腾讯新闻发送1000次随机事件，每次事件间隔为3秒。其中设定主要导航事件的占比为40%。<br>9.–hprof<br>指定了该参数，Monkey会在发送事件序列的前、后，生成性能分析报告。通常会在data&#x2F;misc目录下生成一个5MB左右大小的文件<br>10.–ignore-crashes<br>通常情况下，monkey会在测试应用程序崩溃或者发生异常后停止运行，若指定了该参数，则monkey将会在产生异常后，继续向系统发送事件，直到指定事件全部运行完毕。<br>11.–ignore-timeouts<br>通常情况下，当应用程序发生任何超时错误（application  not  responding）时，monkey将停止运行。若指定了该参数，则monkey将会在产生错误信息后，继续向系统发送事件，直到指定事件全部运行完毕<br>12.–ignore-security-exceptions    通常情况下，指定应用程序发生许可错误时（如证书许可，网络许可等），monkey将停止运行。若指定了该参数，即使应用程序发生许可错误，monkey会继续向系统发送事件，直到指定事件全部运行完毕。<br>eg：adb shell monkey  –throttle  3000 –pct-trackball  50  -p  com.tencent.news  –ignore-security-exceptions  100<br>到这里简单的monkey就完了；</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>05_第五章APP测试</category>
        <category>999_APP测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的adb的命令操作</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_%E5%B8%B8%E7%94%A8%E7%9A%84adb%E7%9A%84%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>adb 其实就是 Android Debug Bridge, Android 调试桥的缩写，adb 是一个 <em>C&#x2F;S</em> 架构的命令行工具，用于通过电脑端与模拟器或者真实设备交互。在某些特殊的情况下进入不了系统，adb就派上用场啦！主要由 3 部分组成：<br>· 运行在 PC 端的 Client : 可以通过它对 Android 应用进行安装、卸载及调试<br>· 运行在 PC 端的 Service : 其管理客户端到 Android 设备上 adb 后台进程的连接<br>adb 服务启动后，Windows 可以在任务管理器中找到 adb.exe 这个进程<br>· 运行在 Android 设备上的 adb 后台进程<br>执行 adb shell ps | grep adbd ，可以找到该后台进程，windows 请使用 findstr 替代 grep<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155428238-1085192595.png"><img src="/assets/1/image-20211209002906-t3thtny.png" alt="image.png"></a><br><strong>通过adb<strong><strong>操作android</strong></strong>设备</strong><br>连接上数据线，然后把手机开发者模式打开，打开usb调试。<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155429039-1959136890.png"><img src="/assets/1/image-20211209002912-qu9x3ln.png" alt="image.png"></a></p>
<h3 id="adb-命令"><a href="#adb-命令" class="headerlink" title="adb 命令"></a>adb 命令</h3><p>在开发或者测试的过程中，我们可以通过 adb 来管理多台设备，其一般的格式为：</p>
<table>
<thead>
<tr>
<th>adb [-e | -d | -s &lt;设备序列号&gt;] &lt;子命令&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>在配好环境变量的前提下，在命令窗口当中输入 adb help 或者直接输入 adb ，将会列出所有的选项说明及子命令。</td>
</tr>
</tbody></table>
<h4 id="这里介绍一些里面常用的命令："><a href="#这里介绍一些里面常用的命令：" class="headerlink" title="这里介绍一些里面常用的命令："></a>这里介绍一些里面常用的命令：</h4><p><strong>1.adb devices</strong> , 获取设备列表及设备状态<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155429797-1825941225.png"><img src="/assets/1/image-20211209002919-iijez5g.png" alt="image.png"></a><br><strong>2.adb get-state</strong> , 获取设备的状态<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155430475-494564427.png"><img src="/assets/1/image-20211209002927-cz0moet.png" alt="image.png"></a><br>设备的状态有 3 钟，device , offline , unknown<br>device：设备正常连接<br>offline：连接出现异常，设备无响应<br>unknown：没有连接设备<br> <strong>3.</strong> <strong>安装卸载应用程序</strong><br>adb install <strong>用于安装</strong><br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155431186-1764437344.png"><img src="/assets/1/image-20211209002933-8fu1e6o.png" alt="image.png"></a><br>安装成功，返回成功提示 “Success”；<br>安装失败，会返回以下：<br>INSTALL_FAILED_ALREADY_EXISTS<br>此时需要用 -r 参数来重新安装。<br>INSTALL_FAILED_SIGNATURE_ERROR<br>应用的签名不一致，可能是发布版和调试版签名不同所致。也有可能是没卸载旧应用导致。<br>INSTALL_FAILED_INSUFFICIENT_STORAGE<br>存储空间不足，需要检查设备存储情况。<br><strong>adb uninstall</strong> 用于卸载<br>adb uninstall 后面带的是应用的包名，而不是应用名。<br>查看系统所有应用的包名：<br>adb shell pm list packages –f<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155432148-1001670330.png"><img src="/assets/1/image-20211209002941-sseqhpz.png" alt="image.png"></a><br> <strong>4</strong> <strong>．上传、下载文件</strong><br>adb push 命令将PC机上的文件推到 DLT-RK3288 机器上；<br>adb pull  命令将DLT-RK3288机器上的文件拉到PC机上；<br>例如：<br>adb push d:&#x2F;new.txt &#x2F;sdcard&#x2F;<br>将D盘下new.txt文件 推到内部存储器<br>adb pull &#x2F;sdcard&#x2F;new.txt    d:<br>将DLT-RK3288 内部存储器根目录下的new.txt 拉到D盘<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155433167-1446733020.png"><img src="/assets/1/image-20211209002948-6va6z60.png" alt="image.png"></a><br><strong>5. adb shell pm list package</strong><br>Package Manager , 可以用获取到一些安装在 Android 设备上得应用信息<br>-s：列出系统应用<br>-f：列出应用包名及对应的apk名及存放位置<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155433984-688635705.png"><img src="/assets/1/image-20211209002954-o4pcw6x.png" alt="image.png"></a><br><strong>过滤应用</strong><br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155434808-820533597.png"><img src="/assets/1/image-20211209003001-a9kavr6.png" alt="image.png"></a><br><strong>5.adb shell</strong><br>通过adb shell 命令，就可以进入设备或者模拟器的shell环境了，在这个Linux shell中，我们就可以执行各种Linux命令了。<br>如果只想执行一条shell命令，就可以采用：adb shell [shell_command]，在实际使用中，经常与grep或findstr一起使用，起到过滤作用，查看自己需要的关键信息。    exit ：  退出  shell状态<br> <strong>6.</strong> <strong>常见命令：</strong><br>如 ls, cd, rm, mkdir, touch, pwd, cp, mv, ifconfig, netstat, ping, ps, top等，进入adb shell即可执行，与linux相似<br><strong>7. adb logcat</strong><br> <strong>一.</strong> <strong>在cmd<strong><strong>窗口查看手机的Log</strong></strong>日志</strong><br>有时候我们在手机程序上的日志要在其他地方调试，然后要看里面的Log日志。在cmd窗口中输入如下命令：</p>
<table>
<thead>
<tr>
<th>&#x2F;&#x2F;格式1：打印默认日志数据<br />adb logcat<br />&#x2F;&#x2F;格式2：需要打印日志详细时间的简单数据<br />adb logcat -v time<br />&#x2F;&#x2F;格式3：需要打印级别为Error的信息<br />adb logcat *:E<br />&#x2F;&#x2F;格式4：需要打印时间和级别是Error的信息<br />adb logcat -v time *:E<br />&#x2F;&#x2F;格式5：将日志保存到电脑固定的位置，比如D:\log.txt<br />adb logcat -v time &gt;D:\log.txt<br /></th>
</tr>
</thead>
</table>
<p>这时手机日志更新什么日志，cmd窗口也会同步更新数据。<br>但是这样没有过滤条件，如果Log日志很多，很难找到我们想要的信息，<br>当然也可以复制cmd中的数据到一个文本中慢慢处理的，就是效率不高。<br>下面介绍adb logcat中的详细参数命令以及如何才能高效的打印日志，或者把日志保存到我们指定的位置。<br>二.adb logcat <strong>详解</strong><br>adb logcat如果用过，但是具体命令又不记得，可以输入adb logcat -help，查看一下一些简单的数据格式：<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155435688-2050217910.png"><img src="/assets/1/image-20211209003008-58zctpg.png" alt="image.png"></a><br><strong>日志过滤：adb logcat <tag>[:priority]</strong><br>tag表示标签，priority输出的级别，日志默认级别是V，如果错误日志我们选择E就可以。<br>Android 的日志分为如下几个优先级（priority）：<br>V —— Verbose（最低，输出得最多）<br>D —— Debug<br>I —— Info<br>W —— Warning<br>E —— Error<br>F —— Fatal<br>S —— Silent（最高，啥也不输出）<br>按某级别过滤日志则会将该级别及以上的日志输出。比如，命令：adb logcat <em>:W<br>其实</em>可以是某个tag，如果没有指明，就表示所有。<br>tag可以由多个 [:priority] 组成。比如，命令：<br>adb logcat ActivityManager:I MyApp:D <em>:S<br>表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。<br><strong>adb logcat选项解析</strong><br>–”-s”选项 : 设置输出日志</em>：s的标签, 只显示该标签的日志;<br>–”-f”选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;<br>–”-r”选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;<br>–”-n”选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;<br>–”-v”选项 : 设置日志的输出格式, 注意只能设置一项;<br>–”-c”选项 : 清空所有的日志缓存信息;<br>–”-d”选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;<br>–”-t”选项 : 输出最近的几行日志, 输出完退出, 不阻塞;<br>–”-g”选项 : 查看日志缓冲区信息;<br>–”-B”选项 : 以二进制形式输出日志;<br><strong>把日志信息保存到电脑中</strong><br>adb logcat最后添加” &gt; 保存文件的地址，比如需要将的信息保存到电脑中使用下面的命令： adb logcat -v time &gt; D:\log.txt<br><strong>8.monkey测试</strong><br><strong>一、Monkey测试简介</strong><br>Monkey测试是ndroid平台自动化测试的一种手段，通过Monkey程序模拟用户触摸屏幕、滑动Trackball、按键等操作来对设备上的程序进行压<br><strong>二、Monkey命令的简单帮助</strong><br>要获取Monkey命令自带的简单帮助，在CMD中执行命令：<br>adb shell monkey –help<br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155436837-2037617676.png"><img src="/assets/1/image-20211209003017-y9nul0y.png" alt="image.png"></a><br><strong>四、Monkey命令参数介绍</strong><br><a href="https://img2018.cnblogs.com/blog/465934/201906/465934-20190606155437967-241629749.png"><img src="/assets/1/image-20211209003024-qq7uae5.png" alt="image.png"></a><br>说明：第一个-s指定设备，如果只连接了一台设备，可不用该参数。<br>-p &lt;apk包名&gt;只允许系统启动指定的app，如果不指定，将允许系统启动设备中的所有app，也可指定多个包。<br>–throttle &lt;毫秒数&gt; 指定用户操作（事件）间的时延。<br>–ignore-crashes 指定当应用程序崩溃时，Monkey依然发送事件，直到事件计数完成。<br>–ignore-timeouts 当应用程序发生ANR错误时，Monkey依然会发送事件，直到事件计数完成。<br>第2个-s，用于指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。<br>-v 用于指定反馈信息级别，总共分为level 0、level 1、level 2三个级别，级别越高，输出的日志越详细。<br>日志级别 Level0 示例 adb shellmonkey -p com.amaker.mp –v 100<br>说明 缺省值，仅提供启动提示、测试完成和最终结果等少量信息<br>日志级别 Level 1 示例 adb shellmonkey -p com.amaker.mp –v -v 100<br>说明 提供较为详细的日志，包括每个发送到Activity的事件信息<br><strong>日志级别 Level 2</strong> 示例 adb shellmonkey -p com.amaker.mp –v -v –v 100<br>说明 最详细的日志，包括了测试中选中&#x2F;未选中的Activity信息<br>最后的数字（这里是500）：表示Monkey程序模拟500次随机用户操作事件。</p>
<blockquote>
<p>输出测试结果到D:\monkeylog.txt</p>
</blockquote>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>05_第五章APP测试</category>
        <category>999_APP测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>逍遥虚拟机</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>1、先进入逍遥模拟器安装目录（MEmu文件夹下），如：D:\Program Files\Microvirt\MEmu  （如果设置变量  不需要）<br>2、在CMD下输入：adb connect 127.0.0.1:21503<br>我输入后提示：already connected to 127.0.0.1:21503<br>3、查看是否连接到模拟器，输入命令：adb devices<br>我输入后提示以下两行：<br>List of devices attached<br>127.0.0.1:21503 device<br>4、OK，连接成功<br>5.查询模拟器信息：adb devices -l<br>6..dumpsys:查看包名和activity<br>（1）启动要查看的程序<br>（2）命令行输入：adb shell dumpsys window w |findstr / |findstr name&#x3D;<br> (3) 使用adb shell dumpsys window | findstr mCurrentFocus  命令查看当前运行的包名和Activity更清晰一些。</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>05_第五章APP测试</category>
        <category>999_APP测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>adb命令环境配置</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_adb%E5%91%BD%E4%BB%A4%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><strong>1、环境的安装</strong><br><strong>1.1 环境的准备</strong></p>
<ul>
<li>jdk1.6以上</li>
<li>android-sdk</li>
</ul>
<p><strong>1.2 jdk 安装</strong></p>
<ul>
<li>下载JDK后傻瓜式安装，<strong>注意：不要有中文路径和空格</strong></li>
<li><strong>配置环境变量：</strong></li>
</ul>
<p><strong>右击“我的电脑”–&gt;”属性”–&gt;”高级系统设置”–&gt;”高级”–&gt;”环境变量”</strong></p>
<ol>
<li>在系统变量里新建”JAVA_HOME”变量，变量值为：C:\Program Files\Java\jdk1.8.0_60（根据自己的jdk的安装路径填写）</li>
<li>在系统变量里新建”classpath”变量，变量值为：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar <strong>(注意最前面有一点)</strong></li>
<li>找到path变量（已存在不用新建）添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</li>
</ol>
<p><strong>1.3 安装Android的测试开发环境</strong></p>
<ol>
<li><strong>Android-SDK的安装：</strong> SDK manager.exe 双击打开下载<br><img src="/assets/1/image-20211205190359-2l4539b.png" alt="image.png"></li>
</ol>
<p><strong>2.android-sdk环境变量的配置</strong><br>具体操作步骤：</p>
<ul>
<li><strong>新建ANDROID_HOME</strong><br>路径为C:\Program Files (x86)\Android\android-sdk\</li>
<li><strong>在Path 变量中加入路径</strong><br>%ANDROID_HOME%\platform-tools 和 %ANDROID_HOME%\tools</li>
</ul>
<p><strong>3.检查adb 环境变量</strong><br><img src="/assets/1/image-20211205190406-lp0oe3n.png" alt="image.png"><br><strong>4.连接手机</strong><br>如果是真机，手机插上USB连接电脑，打开开发者模式，cmd输入adb devices<br>如果是模拟器，需要输入adb connect 127.0.0.1:62001或者52001连接，然后再输入adb devices</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>05_第五章APP测试</category>
        <category>999_APP测试文件</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>APP测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/01_APP%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<ol>
<li><h3 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h3><ol>
<li>功能测试：需求分析、测试准备阶段、冒烟测试、单元测试、联调、系统测试</li>
<li>兼容性测试： <ol>
<li>不同品牌的手机上能否正常安装、运行、卸载</li>
<li>不同的操作系统上（ios、Android）能否正常安装、运行、卸载</li>
</ol>
</li>
<li>网络测试：<ol>
<li>网络异常情况下（时断时连，慢）</li>
<li>不同网络环境（2g、3g、4g、5g、wifi）下应用运行</li>
<li>网络未连接，断网情况下应用处理</li>
</ol>
</li>
<li>UI测试：核对每个页面的布局、字体与UI进行对比</li>
<li>中断测试：运行APP的时候突然进行电话、短信、其他APP的提示等会不会对APP本身的运行造成影响</li>
<li>协议测试：测试服务器对于软件发来的请求有没有做校验</li>
<li>耗电量测试：<ol>
<li>前端运行</li>
<li>后端运行</li>
<li>挂机运行</li>
</ol>
</li>
<li>客户端性能测试：对cpu、内存、耗电量、流量的使用情况、还有安装耗时、启动耗时和卸载耗时</li>
</ol>
</li>
<li><h3 id="Web测试与-app测试区别？"><a href="#Web测试与-app测试区别？" class="headerlink" title="Web测试与 app测试区别？"></a>Web测试与 app测试区别？</h3><ol>
<li>其实功能这块，app 测试与 Web 测试基本是一样，没有什么区别。（需求分析-&gt;提炼测试点-&gt;编写测试用例-&gt;执行用例-&gt;提Bug-&gt;复测，回归）等等的 ；区别主要在于，web 端是 B&#x2F;S 架构的，App 是C&#x2F;S 架构的，由于架构的不同，所以 web端一般服务器更新的时候，客户端不需要更新，因为它是通过浏览器来访问的，服务器更新了，客户端也更新。app 服务端要更新，同时客户端软件要进行升级更新，才算是新的版本对于app 测试来讲，除了功能之外，更多的还要考虑一些’专项测试’，比如：web 测试是基于浏览器的所以不必考虑安装卸载。 而 app 是客户端的，则必须测试安装、更新、卸载。兼容性 稳定性 性能测试   弱网测试  交互性测试等等还有就是，对于兼容性这块，Web 端主要考虑是：不同的浏览器，不同的操作系统的兼容性接口。而对于 app 测兼容性更多的考虑：不同的品牌机型，不同操作系统，不同手机屏幕大小，屏幕分辨率性能方面也会有所不同：Web 端性能测试更多关注的后台的性能，app 的性能测试关注的是手机本身的资源的性能问题：比如：CPU,内存，电量，流量，页面加载响应时间，软件启动时间等等他们两个之间的区别差不多就这些吧。</li>
<li>app测试和web端测试基本一样，没什么区别（需求分析-编写测试用例-评审用例-执行用例）web基于浏览器测试，不必考虑安装卸载，APP必须考虑安装卸载更新，兼容性，弱网<br> web测试不同的浏览器，APP测试考虑cpu，内存，耗电量，不同的品牌机型，不同的系统，不同手机的屏幕大小，屏幕分辨率</li>
</ol>
</li>
<li><h3 id="app测试你具体怎么做的？"><a href="#app测试你具体怎么做的？" class="headerlink" title="app测试你具体怎么做的？"></a><strong>app</strong>测试你具体怎么做的？</h3><ol>
<li>对于 App 这块，我主要做功能，先保证功能过关是第一位。对于功能这块的话，基本都跟 Web 端是一样的。除了功能之外，公司还会做了一些专项测试，像：安装，卸载测试,兼容性测试,稳定性测试,性能测试,弱网测试,交互性测试都有测试过的。专项测试这块，不是我负责的，但是大致了解：兼容性测试,稳定性测试,性能测试,弱网测试,交互性测试这是我这边负责的。像兼容性测试，公司有提供了差不多了7-8 款的真机，像：华为，小米，三星，vivo,oppo 等这些主流的机型都在真机想有测试过。其他的机型，公司用的是云测，云测平台我们用的TestIn 这个平台，公司会给我们提供账号。稳定性测试这块，用的 Monkey 命令工具去测的，主要就是通过 monkey 模拟用户发送一些伪随机时间，看 app 是否有Crash,ANR,Exception等现象，一般都是在晚上的时候去执行monkey 命令，然后出报告，分析。性能测试，用的GT 工具结合 Android Studio 工具去检测 app 在手机上运行的时候的 CPU,内存，电量，流量，启动时间，安装，卸载时间以及页面的响应时间。弱网我们用的fiddler工具去进行模拟的，模拟 2G,3G,4G 等弱网场景，看 app 在弱网情况，功能是否能正常使用。交互性测试这块主要就是看 app 与其他应用程序之间的交互运行，以及与系统应用程序之间交互运行，来回进行前后台切换，看是否会出现闪退，数据丢失等现象。</li>
</ol>
</li>
<li><h3 id="adb命令环境配置-常用的adb的命令操作"><a href="#adb命令环境配置-常用的adb的命令操作" class="headerlink" title="adb命令环境配置  常用的adb的命令操作"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_adb%E5%91%BD%E4%BB%A4%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">adb命令环境配置</a>  <a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_%E5%B8%B8%E7%94%A8%E7%9A%84adb%E7%9A%84%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/">常用的adb的命令操作</a></h3><ol>
<li>adb connect 127.0.0.1:21503     连接<a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E9%80%8D%E9%81%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/">逍遥虚拟机</a></li>
<li>adb connect 127.0.0.1:62001    连接夜游神虚拟机</li>
<li>海马模拟器端口号：26944<br> MuMu模拟器端口号：7555<br> 天天模拟器端口号：6555</li>
<li>adb start-server   打开adb服务<br> adb kill-server     # 关闭服务<br> adb devices        # 查询设备号<br> adb version  # 查询adb版本号<br> aapt dump badging 文件路径（apk在电脑端的路径） # 查询文件包名<br> adb connect ip地址    # 添加设备<br> adb disconnect ip   # 新设备端口<br> adb -s 设备 ID install 路径&#x2F;包名.apk    # 安装apk文件<br> adb -s 设备 ID shell pm list packeages -3   # 查看所有应用的包名<br> adb shell dumpsys activity   # 查询应用的包入口<br> adb shell # 进入模拟器的shell模式<br> adb  uninstall com.baidu.BaiduMap # 卸载应用程序<br> adb -s 设备 ID push D:\路径\文件 &#x2F;sdcard&#x2F;路径&#x2F; #手机上的文件传输到电脑端<br> adb -s 设备 ID pull &#x2F;sdcard&#x2F;路径&#x2F;文件      # 获取模拟器中的文件<br> adb logcat         # 查看日志<br> adb logcat -d     #打印完所有的日志文件之后，退出 shell 终端<br> adb logcat -c      #清除手机系统运行生成的日志文件<br> adb logcat -v time   #需要打印日志详细时间的简单数据<br> adb logcat -d *:E           #需要打印级别为 Error 的信息<br> adb logcat -d *:E &gt; D:\hello.log<br> adb logcat -d *:I &gt; D:\hello555.log #打印 I以上级别的所有日志信息<br> adb logcat -d *:E | findstr cn.csdn.activity &gt;D:&#x2F;hello_error2.log</li>
</ol>
</li>
<li><h3 id="App兼容性测试怎么做的？"><a href="#App兼容性测试怎么做的？" class="headerlink" title="App兼容性测试怎么做的？"></a><strong>App</strong>兼容性测试怎么做的？</h3><ol>
<li>像兼容性这块当时，我们主要用真机测试为主，公司当时使用提供大概 7,8 款机型吧，<br> 我记得像’华为荣耀系列’两款，例外小米机型有选择2 款，还有就是像 vivo,oppo 当时都有测过的,哦,对了还有三星等这些系列机型上都有做过真机测试。真机这块，像系统版本主要覆盖的系统其中 6.0 7.0 8.0 为主 4.0 以下公司当时都不要求测对于其他的机型覆盖不到位，我们都是通过云测进行覆盖的，云测这边，我们公司用的 testin 这个云测平台，公司有提供账号给我们只要登录上去，然后把 apk 上传上去，之后选择机型要测试的机型，当时我们在云测测试有差不多有 60 款多款机型吧，主要是市面上流程的主流机型，每个系列都会选个几款，如果用真机测了的就不在选择了，然后做一些相关的配置，云测平台上主要帮我们做了智能遍历，安装，启动，   运行，卸载，初始化，Monkey 测试相关的测试，不过 monkey 一般都是通过真机测的，云测平台没有测过。配置好了之后，提交测试就可以了。一般提交测试之后，需要几个小时就会出报告。然后分报告，主看遍历，安装，启动，运行，卸载，初始化相关哪些机型有出问题，对于出问题的机型，一般会先补测一下，如果还有问题，我们项目组一般会向公司申请真机再真机进行复测，如果真机复测有问题，就通过利用 adb logcat 查看错误日志，分析具体的问题所在。其实我们做兼容性测试，主要就是看软件在不同机型，不同系统版本下能不能正常安装，   卸载是否能正常启动，运行，初始化，我们都把各个功能都进行运行一遍，主要就是跑下主流程，看有不有问题。例外，就是看软件在不同屏幕大小，不同的分辨率的手机下显示是否正常，有不有拉伸，显示不全，或者显不清晰的等问题。当时我们兼容性就这么做测。</li>
</ol>
</li>
<li><h3 id="App稳定怎么做的？Monkey怎么用（App稳定测试）？"><a href="#App稳定怎么做的？Monkey怎么用（App稳定测试）？" class="headerlink" title="App稳定怎么做的？Monkey怎么用（App稳定测试）？"></a><strong>App</strong>稳定怎么做的？<strong>Monkey</strong>怎么用（<strong>App</strong>稳定测试）？</h3><ol>
<li>Monkey<ol>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_Monkey%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/">Monkey工具介绍</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E7%AC%AC%E4%BA%94%E7%AB%A0APP%E6%B5%8B%E8%AF%95/999_APP%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_Monkey%E4%BD%BF%E7%94%A8/">Monkey使用</a></li>
</ol>
</li>
<li>稳定性这块，我们当时用的是 SDK 自动的一个 Monkey 工具进行测试的，其实 Monkey 工具主要通过模拟用户发送伪随机时间去操作软件，通过执行 Monkey 命令，它会自动出报告，执行测试大概在 10 万次，每个动作的间隔时间250ms，主要就是看软件长时间，随机乱操作的情况，是否会出现异常，闪退，崩溃等现象。一般我都是在下班的时间晚上时间执行 Monkey 命令，并把生成的报告导出到电脑端， 大概需要 6-7 小时，第二天早上看报告，分析报告。如果出现问题，一般利用上次执行的那个种子值，再进行执行命令进行复测一下。<br> 像 monkey 命令：<br> adb   shell   monkey<br />-p   com.xy.android.junit   -s   种子 值<br> –throttle 250<br> –ignore-crashes<br> –ignore-timeouts –monitor-native-crashes -v -v 100000 &gt;<br> E:\monkey_log\java_monkey_log.txt 这里主要关注几个点，1. 指定种子值， 2. 忽略一些异常，保证能正常执行完成 3. 设置间隔时间 4.配置一些时间比例 5.然后就是执行的次数。对于报告怎么分析这块，主要看有不有 CRASH（崩溃），ANR（超时无响应），Exception（异常）等的情况像看有不有空指针异常（NullPointException）啊，OOM 等现象啊等等， 找到 CRASH 崩溃 ANR 超时无响应Exception 异常的位置，看出现错误的上一个动作是什么，什么做了什么动作导致错误出现。异常信息会详细的指出哪个 Activity 出现了问题，甚至于哪个函数出问题了，具体哪个位置。然后把报告中出现的日志信息截图发给开发，开发修复完成之后，我们会根据种子值在进行复测一下。稳定性这块我们当时就是这么做的。</li>
</ol>
</li>
<li><h3 id="App弱网测试怎么做的？"><a href="#App弱网测试怎么做的？" class="headerlink" title="App弱网测试怎么做的？"></a><strong>App</strong>弱网测试怎么做的？</h3><ol>
<li>弱网测试这块我用的 fiddler 工具做的，通过 fiddler 实现延迟发送数据或接收的数据的时间来限制网络的下载速度和上传速度，从而达到模拟 2G,3G,4G,5G 的移动网络的弱网场景。具体操作，首先保证手机与电脑在同一个网络，然后在手机上，设置代理服务器，指定服务器为装了 fiddler 的电脑，端口为 8888，另外，手机端需要安装一个证书，主要为了实现对 https 包的抓取，然后就是在 fiddler 上设置上行，下行速率，实现对发送，接受数据的进行网络延迟。具体在 fiddler 的菜单上有一个 Rules-&gt;Customize Rules, 打开 Fiddler 的ScriptEditor 文件，在其中找到 m_SimulateMode 标志位。然后修改上行，下载的网络延迟时间即可。然后把 Rules-&gt;Performances-&gt;Simulate Modem Speeds 勾选上这样就可以了。弱网测试，看我们软件在弱网场景下是否会有丢包的现象，丢包率是否严重，页面是否能正常展示，是否有空白页，数据是否有丢失，页面加载速度是否会严重影响用户体验。</li>
<li>用fiddler工具<br> 通过 fiddler 实现延迟发送数据或接收的数据的时间来限制网络的下载速度和上传速度，从而达到模拟 2G,3G,4G,5G  的移动网络的弱网场景。具体操作，首先保证手机与电脑在同一个网络，然后在手机上，设置代理服务器，指定服务器为装了 fiddler 的电脑，端口为 8888，例外，手机端需要安装一个证书，主要为了实现对 https 包的抓取，然后就是在 fiddler 上设置上行，下行速率，实现对发送，接受数据的进行网络延迟。具体在 fiddler 的菜单上有一个 Rules-&gt;Customize Rules, 打开 Fiddler 的ScriptEditor 文件，在其中找到 m_SimulateMode 标志位。然后修改上行，下载的网络延迟时间即可。</li>
</ol>
</li>
<li><h3 id="App的性能测试怎么做的？"><a href="#App的性能测试怎么做的？" class="headerlink" title="App的性能测试怎么做的？"></a><strong>App</strong>的性能测试怎么做的？</h3><ol>
<li>App 性能这块，我们主要关注的是以下几个方面：<br> 一个就是我们应用程序的 CPU 占用率，内存使用情况，还有就是电量，流量的消耗， 帧率（FPS），另外，就是应用程序的启动耗时（冷启、热启），跟安装，卸载的时间除了以上两个方面之外，主要还有页面加载时间(响应时间)，页面的加载时间尤其是首页的加载   时间，页面切换响应时间，还有就是内存泄漏的一个检查。像应用程序的 CPU 占用率，内存使用情况，还有就是电量，流量的消耗，帧率（FPS）；</li>
<li>怎么操作的：<ol>
<li>我们用的是网易的 Emmagee 工具进行检查的。启动 Emmagee 之后–&gt;只要选择要测试的应用程序–&gt;开始测试–&gt;自动打开应用程序–&gt;随便操作应用程序。测试 30 分钟，自动生成测试报告，测试报告的形式.csv 格式。通过 excel 打开将数据转化为图标，进行分析。</li>
</ol>
</li>
<li>当时我主要检测了几个方面，<ol>
<li><ol>
<li>App 启动到页面加载完成这个过程的 Cpu，内存，电量， 流量，帧率（FPS）的情况 </li>
<li>在使用各个核心主要功能的过程中 Cpu，内存，电量，流量， 帧率（FPS）的情况，对他们进行分别统计分析的。一个应用程序不同的功能 Cpu，内存的消耗情况一般是不一样的，然后对不同场景的各个参数绘制成曲线图，进行详细的分析。我们当时对于 CPU 这块的指标要求是在 10-20%这个范围，像在使用一些基本的功能不是特别复杂的功能，CPU 的占有率要求在 10%左右，一些加载大批量数据，像图片，视频或其他大数据的复杂功能，要求 CPU 的占有率在 20%左右。而且当退出功能，应用程序在为操作的情况下 CPU 会有明显的下降。所以 CPU 一般是一个动态变化的一个曲线图！对于内存指标要求在 80M 以下，大数据处理的功能的内存指标要求在 200M 以下。</li>
<li>另外，对于内存这块最关键的是要注意内存泄漏的情况，如果在应用程序没有使用的情况下，或者说测试完成之后，手机内存应该要释放，这里需要检查内存是否释放完全。这个在测试前可以通过adb 命令查看手机内存的使用情况，通过 adb -s 127.0.0.1:62001   shell dumpsys meminfo 进行查看，测试完成之后再通过命令查看，看内存是否有释放。不过对于内存泄漏这块，我们开发那边会检查的比较细致一点，他们是通过 android studio 这个开发工具进行检查的，这个工具里面集成了对性能测试的一些插件，而且开发那边有源码包，他们会做详细的检查内存泄漏这块的问题。性能这块基本上就是这么测试的。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="App交互性怎么做的？"><a href="#App交互性怎么做的？" class="headerlink" title="App交互性怎么做的？"></a><strong>App</strong>交互性怎么做的？</h3><ol>
<li>交互性这块，主要从以下几个方面去考虑测试的是：<ol>
<li>看我们软件与其他应用软件的同时运行,来回切换是否有问题</li>
<li>看软件切换到后台一段时间，再切换到前台，或者前后台来回切换，软件是否会有异常，比如：进程被杀死，或者切换到前端页面出现问题，或者页面数据丢失等等。</li>
<li>看软件被在使用过程中被其他应用中断，或者其他意外情况中断，比如: 来电，来短信，闹铃，低电量测试等，还要注意手机端硬件上，如：待机，锁屏，插拔数据线，耳机等操作不会影响客户端。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="App弱网测试怎么做的？-1"><a href="#App弱网测试怎么做的？-1" class="headerlink" title="App弱网测试怎么做的？"></a><strong>App</strong>弱网测试怎么做的？</h3><ol>
<li>弱网测试这块我用的 fiddler工具做的，通过 fiddler实现延迟发送数据或接收的数据的时间来限制网络的下载速度和上传速度，从而达到模拟2G,3G,4G的移动网络的弱网场景。</li>
<li>具体操作，首先保证手机与电脑在同一个网络，然后在手机上，设置代理服务器，指定服务器为装了 fiddler 的电脑的 ip 地址，端口为8888，然后就是在 fiddler 上设置上行， 下行速率，实现对发送， 接受数据的进行网络延迟。具体在 fiddler 的菜单上有一个Rules-&gt;CustomizeRules,打开 Fiddler 的 ScriptEditor文件，在其中找到 m_SimulateMode 标志位。然后修改上行，下载的网络延迟时间即可，具体设置参数的值SE 那边有给到一个参考文档</li>
<li>然后把 Rules-&gt;Performances-&gt;Simulate Modem Speeds 勾选上这样就可以了。</li>
<li>弱网测试，看我们软件在弱网场景下是否会有丢包的现象，丢包率是否严重，页面是否能正常展示，是否有空白页，数据是否有丢失，页面加载速度是否会严重影响用户体验。</li>
</ol>
</li>
<li><h3 id="H5界面怎么测试"><a href="#H5界面怎么测试" class="headerlink" title="H5界面怎么测试"></a><strong>H5</strong>界面怎么测试</h3><ol>
<li>基本功能测试：（浏览器、微信内置浏览器）</li>
<li>登陆<ol>
<li>目前 H5 与 native 各个客户端都做了互通，所以大家在测试的时候要注意两点：<ol>
<li>A、若客户端已登录，那么进入 H5 后仍然是登录状态。</li>
<li>B、若客户端未登录，进入 H5，点击对应按钮 OR 链接，如果需要登录，须拉起 native登录。若取消登录，是否可再次拉起登录，或者停留在的页面是否有对应的登录提示。</li>
<li>ps：本次测试过程中就发现，第一次点击链接，可以拉起登录，第二次却不能。</li>
</ol>
</li>
</ol>
</li>
<li>翻页<ol>
<li>遇到翻页加载的页面，需要注意内容为 1 页或者多页的情况。</li>
<li>A、数据分页加载时，注意后续页面请求数据的正确。</li>
<li>ps：这个需要注意在快速操作场景中，请求页数是不是依次递增，快速操作（如第一页尚未 loading 出来的时候仍然继续上拉操作）时是否发出去对应的请求了。</li>
</ol>
</li>
<li>刷新与返回<ol>
<li>A、下拉刷新是否仍然处于当前页面。</li>
<li>B、用户主动点击刷新按钮是否仍然处于当前页面。</li>
<li>C、点击返回与 back<br> 键，回退页面是否是期望页面</li>
<li>ps：本次测试过程中就发现，mtop 接口请求成功，但是 data 内无数据时，返回到的就是个空白页面，无法正常发送请求。</li>
</ol>
</li>
<li>H5 适配相关<ol>
<li>H5 的适配其实比客户端的相对来说，要少一些，手机品牌之间的差异不大，所以不用太多关注，最容易出现问题的是 android2.3 系统，这个要特别关注下：<ol>
<li>A、大屏（如 720<em>1280，重点关注页面背景是否完全撑开页面，刷新是否有抖动）、小屏手机（如 320</em>480，重点关注下弹框样式和文案折行）</li>
<li>B、android2.3、android4.X 随机找一个即可。</li>
<li>C、ios5、ios6、ios7。体验相关</li>
</ol>
</li>
</ol>
</li>
<li>资源相关<ol>
<li>A、页面中有图片的话，淘宝那边建议图片一般不大于 50kb，本着一个原则，尽量缩小图片。</li>
<li>B、资源是否压缩、是否通过 CDN 加载。</li>
<li>C、如何保证二次发布后有效更新。</li>
</ol>
</li>
<li>流量<ol>
<li>A、对于一些不会变化的图片，如游戏动画效果相关图片，不需要每次都请求的东西，  做本地缓存。</li>
<li>B、数据较多时是否做了分页加载。</li>
</ol>
</li>
<li>页面展现时间<ol>
<li>A、关注页面首屏加载时间。</li>
</ol>
</li>
<li>页面提示<ol>
<li>A、弱网络下，数据加载较慢，是否有对应的loading 提示。</li>
<li>B、接口获取异常时，提示是否友好。</li>
<li>C、刷新页面或者加载新内容时页面是否有抖动。</li>
</ol>
</li>
<li>手机操作相关<ol>
<li>A、锁屏之后展示页面。</li>
<li>B、回退到后台之后，重新呼出在前台展示。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="小程序怎么测试（详细）"><a href="#小程序怎么测试（详细）" class="headerlink" title="小程序怎么测试（详细）"></a>小程序怎么测试（详细）</h3><ol>
<li>1, 小程序测试（多用第一人称，口语化表达，多讲一些，讲细一些，先宏观，在微观）参考 面试问题<br> STAR 法则我们原来主要测试，几个方面，界面测试，功能测试，交互性测试，兼容性测试，安全测试，易用性测试， 异常测试，权限测试界面测试，主要是测试跟界面的原型图是否一致，同时我也要考虑不同屏幕大小跟分辨率功能测试，跟所有的功能测试都是一样的，还有小程序有位置功能 ，检查下，微信小程序附近中是否能找到对应小程序，使用小程序是否记录，交互性测试，，要考虑跟微信的功能交互使用，比如说一些，卡包，支付等功能，考虑跟手机固有功能交互， 比如说来电，短信等，兼容性测试，考虑跟微信不同版本的兼容，还有同时还要考虑不同手机厂商跟手机型号兼容，还要考虑当微信清除缓存后，小程序还能否继续使用安全测试，测试数据加密，包括 sql，与 xss 脚本攻击这块易用性测试，考虑功能是否方便还用异常测试，考虑断网，手机重启，关键的情况权限测试，小程序继承微信权限，测试手机对微信权限，还要考虑微信对小程序授权，是否允许操作原来我们测试阶段，上传小程序到微信小程序平台，上传到开发版本里面，通过扫描二维码去下载小程序进行测试上线后，我们也要测试下，微信搜索小程序中能否搜索的到</li>
</ol>
</li>
<li><h3 id="Android跟-ios测试有什么区别？"><a href="#Android跟-ios测试有什么区别？" class="headerlink" title="Android跟 ios测试有什么区别？"></a><strong>Android</strong>跟 <strong>ios</strong>测试有什么区别？</h3><ol>
<li>Android 和 ios 测试的共同点都需要进行界面测试、功能测试、兼容性测试、网络测试、交互性测试、易用性专项测试、异常测试、安全专项测试以及权限测试。不同的是 Android 测试除了以上的测试之外还要用 monkey 进行稳定性专项测试以及用 emmagee 或者 gt 进行性能专项测试。Ios 是用 itools 工具对功能进行测试：安装、传输文件以及查看日志。从操作系统，安装卸载，按键操作，开发语言这几个方面去区分操作系统：android 操作系统较多，IOS 较少只能升级不能降级，并且新的版本的资源库不能完全兼容旧版中系统中的应用，如果低版本应用调用了高版本的资源库，可能会导致系统崩溃。安装卸载测试，应用发布后：下载安卓包的平台和渠道很多：豌豆荚、应用宝、360手机助手等；IOS 主要有 Appstore、iTunes，安全性会更高点本地测试：安卓手机可以通过扫码或者直接安卓 APK 包安装测试包；IOS要安装测试包必须绑定手机的 id（证书）才可以安装ipa 测试包按键操作测试：安卓手机针对每一款手机有不一样的操作；苹果手机操作习惯单一开发语言：虽然同样的业务安卓和 IOS的展示形式和业务一致，但是底层全完不一样。安卓的应用是有 java语言实现的;iOS用 OC实现</li>
<li>运行机制，安卓的的运行机制是虚拟的，ios的运行机制是沙盒<br> 后台机制，ios推送的是系统常住进程，安卓需要给每个应用机制在后台建立指令权限，ios的指令权限ui是最高权限，安卓是数据处理的指令具有最高权限<br> 安卓在应用商店里面下载，ios是在蒲公英上下载安装<br> 按键操作测试：安卓手机针对每一款手机有不一样的操作；苹果手机操作习惯单一<br> 本地测试：安卓手机可以通过扫码或者直接安卓 APK 包安装测试包；IOS 要安装测试包必须绑定手机的 id（证书）才可以安装ipa 测试包</li>
</ol>
</li>
<li><h3 id="app突然崩溃白屏是什么原因造成的"><a href="#app突然崩溃白屏是什么原因造成的" class="headerlink" title="app突然崩溃白屏是什么原因造成的"></a>app突然崩溃白屏是什么原因造成的</h3> 1：内存管理，这个主要就是后台应该程序过多造成的内存过低<br> 2：用户连接过多，系统响应不过来导致APP崩溃<br> 3:   APP兼容性问题，这个主要考虑换下手机的机型进行测试<br> 4：代码错误，代码没有测试导致系统崩溃</li>
<li><h3 id="APP测试分H5界面和原生态界面"><a href="#APP测试分H5界面和原生态界面" class="headerlink" title="APP测试分H5界面和原生态界面"></a>APP测试分H5界面和原生态界面</h3><ol>
<li>什么是H5界面：<ol>
<li>H5界面是HTML的一种语言，H5界面比较炫</li>
<li>h5页面是采用HTML5前端技术设计的页面，目前，HTML5的标准在很多移动端的浏览器都支持，所以很多移动站点采用HTML5技术开发，h5页面是也可以理解为移动端网页。</li>
</ol>
</li>
<li>原生态界面：<ol>
<li>可以通过以下“H5界面和原生态界面的区别”来了解</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="H5界面和原生态界面的区别"><a href="#H5界面和原生态界面的区别" class="headerlink" title="H5界面和原生态界面的区别"></a>H5界面和原生态界面的区别</h3> 1：断网的时候，看手机断点点击页面，如果可以正常显示的是原生态界面，显示404或者白屏的是H5界面<br> 2：看它的布局边界，打开手机里面有个开发者模式。里面有个查看布局，边界布局，显示密密麻麻的是H5界面，不显示的是原生态 的界面<br> 3：复制情况下，我们长时间按中选择的字体，显示复制，粘贴的就是H5界面，不显示的是原生态界面的<br> 4：加载方式，打开页面然后有个进度条，有的就是H5界面，没有就是原生态的<br> 5：观察APP顶部有没有关闭按钮，有的就是H5界面，没有就是原生态<br> 6：下拉页面的时候显示网址提供方的一定是H5<br> 我们测试一般用的是H5界面</li>
<li><h3 id="抓包你是怎么抓的？"><a href="#抓包你是怎么抓的？" class="headerlink" title="抓包你是怎么抓的？"></a>抓包你是怎么抓的？</h3><ol>
<li>首先保证移动端和PC端在一个局域网内，在移动端设置IP和端口号，设置完成后就可以抓包了</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>05_第五章APP测试</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>性能指标的标准2</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%A0%87%E5%87%862/</url>
    <content><![CDATA[<p>响应时间：<br>　　1.利用2-5-8原则去判定<br>吞吐量：<br>　　1.125<em>x kb&#x2F;s</em>0.5，若小于前面的数值为优，其中x为x Mb&#x2F;s，例如1 Mb&#x2F;s<br>每秒点击数：<br>　　1.指客户端每秒钟向服务器端提交的请求数量，如果客户端发出的请求数量越多，与之相对的平均吞吐量也应该越大<br>并发用户数：<br>　　1)、经典公式1：<br>  　　 一般来说，利用以下经验公式进行估算系统的平均并发用户数和峰值数据<br>  　　　　1）平均并发用户数为 C &#x3D; nL&#x2F;T<br> 　　　　 2）并发用户数峰值 C‘ &#x3D; C + 3<em>根号C<br>    　　　　C是平均并发用户数，n是login session的数量，L是login session的平均长度，T是值考察的时间长度<br>   　　　　 C’是并发用户数峰值<br>举例1，假设系统A，该系统有3000个用户，平均每天大概有400个用户要访问该系统（可以从系统日志从获得），对于一个典型用户来说，一天之内用户从登陆到退出的平均时间为4小时，而在一天之内，用户只有在8小时之内会使用该系统。<br>  那么，<br>  　　　　平均并发用户数为：C &#x3D; 400</em>4&#x2F;8 &#x3D; 200<br>  　　  　 并发用户数峰值为：C‘ &#x3D; 200 + 3<em>根号200 &#x3D; 243<br>举例2， 某公司为其170000名员工设计了一个薪酬系统，员工可进入该系统查询自己的薪酬信息，但并不是每个人都会用这个系统，假设只有50%的人会定期用该系统，这些人里面有70%是在每个月的最后一周使用一次该系统，且平均使用系统时间为5分钟。则一个月最后一周的平均并发用户数为（朝九晚五）：<br> 　　　　 n &#x3D; 170000</em>0.5<em>0.7&#x2F;5 &#x3D; 11900<br> 　　　　 C&#x3D; 11900</em>5&#x2F;60&#x2F;8 &#x3D; 124<br>  　　　　吞吐量计算为：F &#x3D; Vu * R &#x2F; T 单位为个&#x2F;s<br>   　　　　　 F为事务吞吐量，Vu为虚拟用户数个数，R为每个虚拟用户发出的请求数，T为处理这些请求所花费的时间<br>　　2)、通用公式2：<br>  　　对绝大多数场景，我们用（用户总量&#x2F;统计时间）<em>影响因子（一般为3）来进行估算并发量。<br>  　　比如，以乘坐地铁为例子，每天乘坐人数为5万人次，每天早高峰是7到9点，晚高峰是6到7点，根据8&#x2F;2原则，80%的乘客会在高峰期间乘坐地铁，则每秒 到达地铁检票口的人数为50000</em>80%&#x2F;（3<em>60</em>60）&#x3D;3.7，约4人&#x2F;S，考虑到安检，入口关闭等因素，实际堆积在检票口的人数肯定比这个要 大，假定每个人需要3秒才能进站，那实际并发应为4人&#x2F;s<em>3s&#x3D;12，当然影响因子可以根据实际情况增大！<br>　　3)、根据PV计算公式：<br> 　　 比如一个网站，每天的PV大概1000w，根据2&#x2F;8原则，我们可以认为这1000w pv的80%是在一天的9个小时内完成的（人的精力有限），那么TPS　　为：<br>  　　1000w</em>80%&#x2F;(9<em>3600)&#x3D;246.92个&#x2F;s,取经验因子3，则并发量应为：<br> 　　 246.92</em>3&#x3D;740<br>　　4)、根据TPS估计：<br>  　　 公式为 C &#x3D; (Think time + 1)*TPS<br>　　5)、根据系统用户数计算：<br>   　　并发用户数 &#x3D; 系统最大在线用户数的8%到12%<br>资源使用率：<br>　　1).平均事务响应时间<br>　　Average Transation Response Time优秀：&lt;2s<br>　　良好：2-5s<br>　　及格：6-10s<br>　　不及格：&gt;10s<br>　　2).每秒点击率<br>　　Hits per Second<br>　　当增大系统的压力(或增加并发用户数)时，吞吐率和TPS的变化曲线呈大体一致，则系统基本稳定若压力增大时，吞吐率的曲线增加到一定程度后出现变化缓慢，甚至平坦，很可能是网络出现带宽瓶颈.同理若点击率&#x2F;TPS曲线出现变化缓慢或者平坦，说明服务器开始出现.<br>　　3).请求响应时间<br>　　Time to Last Byte<br>　　4).每秒系统处理事务数<br>　　Transaction per second<br>　　5).吞吐量<br>　　Throughout<br>　　6).CPU利用率<br>　　Processor&#x2F;%Processor Time好：70%<br>　　坏：85%<br>　　很差：90%+<br>　　7).数据库操作消耗的CPU时间<br>　 　Processor&#x2F;%User Time如果该值较大，可以考虑是否能通过友好算法等方法降低这个值。如果该服务器是数据库服务器，Processor%User Time值大的原因很可能是数据库的排序或是函数操作消耗了过多的CPU时间，此时可以考虑对数据库系统进行优化。<br>　　8).核心态CPU平均利用率<br>　　Processor&#x2F;%Privileged Time如果该参数值和”Physical Disk”参数值一直很高，表明I&#x2F;O有问题。可考虑更换更快的硬盘系统<br>　　9).处理列队中的线程数<br>　 　Processor&#x2F;Processor Queue Length如果该值保持不变(&gt;&#x3D;2)个并且%Processor Time超过90%，那么可能存在处理器瓶颈。如果发现超过2，而处理器的利用率却一直很低，那么或许更应该去解决处理器阻塞问题，这里处理器一般不是瓶 颈。<br>　　10).文件系统缓存<br>　　Memory&#x2F;Cache Bytes 50%的可用物理内存<br>　　11).剩余的可用内存<br>　　Memory&#x2F;Avaiable Mbytes至少要有10%的物理内存值<br>　　12).每秒下载页数<br>　　Memory&#x2F;pages&#x2F;sec好：无页交换<br>　　坏：CPU每秒10个页交换<br>　　很差：更多的页交换<br>　　13).页面读取操作速率<br>　　Memory&#x2F;page read&#x2F;sec如果页面读取操作速率很低，同时%Disk Time和Avg.Disk Queue Length的值很高，则可能有磁盘瓶径。但是，如果队列长度增加的同时页面读取速率并未降低，则内存不足。<br>　　14).物理磁盘利用率<br>　　Physical Disk&#x2F;%Disk Time好：&lt;30%<br>　　坏：&lt;40%<br>　　很差：&lt;50%+<br>　　15).物理磁盘平均磁盘I&#x2F;O队列长度<br>　　Physical Disk&#x2F;Avg.Disk Queue Length该值应不超过磁盘数的1.5~2倍。要提高性能，可增加磁盘<br>　　16).网络吞吐量<br>　　Network Interface&#x2F;Bytes Total&#x2F;sec判断网络连接速度是否是瓶颈，可以用该计数器的值和目前网络的带宽，结果应该小于50%<br>　　17).数据高速缓存区命中率命中率应大于0.90最好<br>　　18).共享区库缓存区命中率命中率应大于0.99<br>　　19).监控SGA中字典缓冲区的命中率命中率应大于0.85<br>　　20)检测回滚段的争用小于1%<br>　　21).监控SGA中重做日志缓存区的命中率<br>　　应该小于1%<br>　　22).监控内存和硬盘的排序比率最好使它小于10%</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>04_第四章性能测试</category>
        <category>905_性能测试文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>有没有做过性能测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/06_%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E8%BF%87%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="jmeter-为性能测试提供了一下特色："><a href="#jmeter-为性能测试提供了一下特色：" class="headerlink" title="jmeter 为性能测试提供了一下特色："></a><strong>jmeter 为性能测试提供了一下特色：</strong></h3><p>jmeter 可以对测试静态资源（例如 js、html 等）以及动态资源（例如 php、jsp、ajax 等等）进行性能测试<br>jmeter 可以挖掘出系统最大能处理的并发用户数<br>jmeter 提供了一系列各种形式的性能分析报告<br><strong>使用 jmeter 一般用于以下两种类型的性能测试</strong><br>负载测试：通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。<br>压力测试：测试系统能承受的最大负载能力。目的在于发挖掘出目标服务系统可以处理的最大负载。</p>
<h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><p> 下面我们看下使用 jmeter 进行性能测试的基本过程<br><img src="/assets/1/image-20211209004611-ubgkfsm.png" alt="image.png"><br>对上图进行简要的说明<br><strong>新增线程组</strong><br>创建测试线程组，并设置线程数量及线程初始化启动方式。<br><strong>新增 JMeter 元组</strong><br>创建各种默认元组及测试元组，填入目标测试静态资源请求和动态资源请求参数及数据。<br><strong>新增监听器</strong><br>创建各种形式的结果搜集元组，以便在运行过程及运行结束后搜集监控指标数据。<br><strong>运行&amp;查看结果</strong><br>调试运行，分析指标数据，挖掘性能瓶颈、评估系统性能状态；<br>示例<br>下面我们以打开百度演示上述过程。<br>新增线程组<br>在 jmeter 的 bin 目录下双击 jmeter.bat或ApacheJMeter.jar 启动 jmeter，如下图：<br><img src="/assets/1/image-20211209004618-fiqfada.png" alt="image.png"><br>在左边操作栏中选择“测试计划”，右击新增一个线程组，如图所示：<br><img src="/assets/1/image-20211209004634-l377nn4.png" alt="image.png"><br>初始化线程组相关信息<br><img src="/assets/1/image-20211209004641-gclhau2.png" alt="image.png"><br>新增 JMeter 元组<br>添加默认配置元素，添加如下默认配置，如图<br><img src="/assets/1/image-20211209004648-qgtsoxh.png" alt="image.png"><br>各默认组件配置如图所示。HTTP Cache Manager<br><img src="/assets/1/image-20211209004655-3p9tuyj.png" alt="image.png"><br>HTTP Cookie 管理器<br><img src="/assets/1/image-20211209004701-41vyihu.png" alt="image.png"><br>HTTP 请求默认值<br><img src="/assets/1/image-20211209004708-2gryv4f.png" alt="image.png"><br>添加 HTTP Request 元组<br>在线程组上右击新增 HTTP 请求，如图：<br><img src="/assets/1/image-20211209004714-l6raanu.png" alt="image.png"><br>HTTP 请求设置如图：<br><img src="/assets/1/image-20211209004721-o8a3zz8.png" alt="image.png"><br>新增监听器<br>在这里我们添加如下监听器，如图所示<br><img src="/assets/1/image-20211209004727-k4cadnq.png" alt="image.png"><br>运行&amp;查看结果<br>如果启动运行 jmeter，可以单击添加的监听器查看运行过程中的监控指标数据，也可以等运行结束后，再查看。<br><img src="/assets/1/image-20211209004734-osigcbx.png" alt="image.png"><br>结果说明<br>下面我们就监听器所采集的结果图进行简要的说明：图形结果<br><img src="/assets/1/image-20211209004740-o2l0pz4.png" alt="image.png"><br>察看结果树<br><img src="/assets/1/image-20211209004747-1ff5ysa.png" alt="image.png"><br>用表格查看结果<br><img src="/assets/1/image-20211209004754-uhk341o.png" alt="image.png"><br>聚合报告<br><img src="/assets/1/image-20211209004800-177qcka.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>04_第四章性能测试</category>
        <category>905_性能测试文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/01_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<ol>
<li><h3 id="性能测试的定义-x2F-什么是性能测试？"><a href="#性能测试的定义-x2F-什么是性能测试？" class="headerlink" title="性能测试的定义&#x2F;什么是性能测试？"></a>性能测试的定义&#x2F;什么是性能测试？</h3><ol>
<li>涉及到大批量的并发时系统或软件的承载能力</li>
</ol>
</li>
<li><h3 id="性能测试的类型：压力测试和负载测试"><a href="#性能测试的类型：压力测试和负载测试" class="headerlink" title="性能测试的类型：压力测试和负载测试"></a>性能测试的类型：压力测试和负载测试</h3><ol>
<li>压力测试：系统软件能达到一个最大的峰值（峰值指：用户的访问量，用户的请求量）</li>
<li>负载测试：指系统或者软件能保持一定承载能力不变的情况下持续的最长时间，并负载一段时间的过程</li>
<li>并发测试：在同一时间段内服务器所能承受的最大并发量为多少，在同一时间内，服务器能处理的请求的最大数量是多少</li>
</ol>
</li>
<li><h3 id="为什么要做性能测试-x2F-性能测试的目的"><a href="#为什么要做性能测试-x2F-性能测试的目的" class="headerlink" title="为什么要做性能测试&#x2F;性能测试的目的"></a>为什么要做性能测试&#x2F;性能测试的目的</h3><ol>
<li>版本一<ol>
<li>验证系统软件的承载极限：比如承受多大的并发，在最大并发量的情况下能储蓄运行的最长的时间</li>
<li>验证是否能达到用户或产品组的性能要求</li>
<li>发现系统软件的瓶颈问题，找到是那些问题导致系统的性能上不去</li>
<li>找到系统软件的优化方向和性能目标</li>
</ol>
</li>
<li>版本二<ol>
<li>性能测试更关注系统的性能表现，也就是how fast和How much.做性能的测试就是排除系统瓶硕，使它表现的更好，更霸气，可以从以下几方面理解</li>
<li>①评估当前系统—了解你的产品</li>
<li>②寻找瓶颈，优化性能—优化你的产品</li>
<li>③预测未来性能—当用户数和业务量增加能否应对，如何调整</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="什么样的系统软件需要做性能测试"><a href="#什么样的系统软件需要做性能测试" class="headerlink" title="什么样的系统软件需要做性能测试"></a>什么样的系统软件需要做性能测试</h3><ol>
<li>用户量大的系统</li>
<li>业务比较繁忙的系统</li>
<li>动态类型的接口请求</li>
<li>查询类型的接口请求</li>
</ol>
</li>
<li>性能分层<ol>
<li>前端性能<ol>
<li>APP<ol>
<li>卡顿</li>
<li>流畅度</li>
<li>资源消耗</li>
<li>流量监控</li>
</ol>
</li>
<li>web<ol>
<li>页面渲染<ol>
<li>不同的浏览器</li>
</ol>
</li>
<li>js性能<ol>
<li>推荐工具：dynatrace ajax edition    <ol>
<li>可以搞定页面渲染的性能、以及js的性能</li>
<li>能定位到js源码的位置</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>服务器端性能<ol>
<li>协议</li>
<li>并发<ol>
<li>多线程</li>
</ol>
</li>
<li>模拟真实场景：业务角度</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="根据什么来做性能测试"><a href="#根据什么来做性能测试" class="headerlink" title="根据什么来做性能测试"></a>根据什么来做性能测试</h3><ol>
<li>性能需求，也叫性能指标</li>
<li>没有给出性能需求或给出不太明确的性能指标，要依据以往测试的真实的结果（压力值和负载值），在测试组内进行讨论，制定一个比较合适的指标，然后在进行测试</li>
</ol>
</li>
<li><h3 id="性能测试的核心方法"><a href="#性能测试的核心方法" class="headerlink" title="性能测试的核心方法"></a>性能测试的核心方法</h3><ol>
<li>逐步施压：（一步一步的慢慢的进行增加压力）看最后能不能达到性能的指标的要求，不管是负载方面的测试还是压力方面的测试都要采用逐步施压的方法</li>
</ol>
</li>
<li><h3 id="性能测试的原则"><a href="#性能测试的原则" class="headerlink" title="性能测试的原则"></a>性能测试的原则</h3><ol>
<li>尽可能的贴近真实的环境，尽可能的模拟用户操作</li>
</ol>
</li>
<li><h3 id="性能测试的过程"><a href="#性能测试的过程" class="headerlink" title="性能测试的过程"></a>性能测试的过程</h3><ol>
<li>对性能需求进行分析</li>
<li>设计性能测试的计划</li>
<li>性能测试的环境搭建（测试工具。测试数据（脚本）的准备）</li>
<li>执行测试（得出测试结果）</li>
<li>对测试结果进行分析，然后编写测试报告</li>
</ol>
</li>
<li><h3 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h3><ol>
<li><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/01_jmeter/">jmeter</a><br><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/16_jmeter%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">jmeter简单的性能测试</a></li>
<li>loadrunner<ol>
<li>LoadRunner，是一种预测系统行为和性能的负载测试工具。</li>
</ol>
</li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_locust/">locust</a><ol>
<li>开源</li>
<li>python语言</li>
<li>基于协程</li>
<li>高并发</li>
<li>性能自动化测试平台</li>
<li>requests</li>
</ol>
</li>
<li>jmeter 与loadrunner 的区别<ol>
<li>相同点<ol>
<li>jmeter 的架构跟loadrunner原理一样,都是通过中间代理,监控&amp;收集并发客户端发现的指令,把他们生成脚本,再发送到应用服务器,再监控服务器反馈的结果的一个过程.</li>
<li>分布式中间代理功能在Jmeter中也有,这个分布式分理是指可设置多台代理在不同PC中,通过远程进行控制,即通过使用多台机器运行所谓的 Agent 来分担 Load Generator 自身的压力，并借此来获取更大的并发用户数.loadrunner也有些功能．</li>
</ol>
</li>
<li>不同点：<ol>
<li>Jmeter 安装简单，只需要解压jmeter文件包到Ｃ盘上就可以了，其实是没有安装．要是你想执行调试测试脚本,前提是：装上jdk和netbean插件.而loadrunner安装包有１Ｇ多，在一台P3.0,1G内存的PC上安装要一个多小时.要是装过较旧的盗版还不能再装新版,解决办法倒是有,但麻烦且花时间.</li>
<li>Jmeter 没有IP欺骗功能,ＩＰ欺骗是指在一ＰＣ台上多个ＩＰ地址来分配给并发用户．这个功能对于模拟较真实的客户环境来说,是较有用.loadrunner有此功能.</li>
<li>Jmeter也提供了一个利用本地Proxy Server（代理服务器）来录制生成测试脚本的功能，但是这个功能并不好用,测试对象的个别参数却要手工增加上去,还得附带装个IE代理,如GoogleToolbarDownloader这些插件来捕捉参数.但是有一个工具bodboy，利用这个工具可以录制操作，然后选择将脚本保存为Jmeter脚本，然后利用Jmeter可以打开并修改脚本</li>
<li>jmeter的报表较少,对于要分析测试性能不足以作为依据.如要知道数据库服务器或应用程序服务的CPU,memory等参数,得在相关服务器上另外写脚本记录服务器的性能.</li>
<li>Jmeter做性能测试，主要是通过增加线程组的数目，或者是设置循环次数来增加并发用户，而loadrunner可以通过在场景中选择要设置什么样的场景，然后选择虚拟用户数。</li>
<li>jmeter可以通过逻辑控制器实现复杂的测试行为，相当于loadrunner中的测试场景</li>
<li>Jmeter可以做web程序的功能测试，利用jmeter中的样本，可以做灰盒测试，loadrunner主要用作性能测试</li>
<li>jmeter是开源的，但是使用的人较少，网络上相关资料不全面，需要自己去揣摩，而loadrunner是商业软件，如果是正版，有技术支持，同时，网络上的资料相当多。</li>
<li>jmeter的脚本修改，主要是对jmeter中各个部件的熟悉程度，已经相关的一些协议的掌握情况，而不依赖于编程，而loadrunner除了复杂的场景设置外，还需要掌握函数，修改脚本。</li>
</ol>
</li>
</ol>
</li>
<li><h1 id="QNET-网络测试工具"><a href="#QNET-网络测试工具" class="headerlink" title="QNET-网络测试工具"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_QNET-%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/">QNET-网络测试工具</a></h1></li>
</ol>
</li>
<li><h3 id="性能测试的作用及重要性"><a href="#性能测试的作用及重要性" class="headerlink" title="性能测试的作用及重要性"></a>性能测试的作用及重要性</h3><ol>
<li><h5 id="生活中的性能问题"><a href="#生活中的性能问题" class="headerlink" title="生活中的性能问题"></a>生活中的性能问题</h5><ol>
<li>案例1.最痛恨的12306（永流抢不到票）<br> 案例2.双十一抢购，系统繁忙其至报404错误<br> 案例3.上下班高峰期，怎一个堵字了得<br> 案例4：起市收银台永远不够用</li>
</ol>
</li>
<li>试问：什么样的系统需要做性转测试？<ol>
<li>案例1：做设使用word来编辑个1000多页的文档，该文档包含了丰富的图表，图片，需要等待系统花多少秒的时间进行处理<br> 案例2：某业务系统属于二次开发，之前没有做过性能测试。当并发达到100时会造成数据库服务器崩溃，这是很明显的性问题<br> 案例3：某企业内部信息系统.使用人数少，但并发时会出现重复的相同记录、这种场果很难在功能测试时出现，所以有时候性能测试并不是只能发现性能问题<br> 案例4：面响广互联网人群的网站，每天都要接受大量的访问请求，服务器压力大，这样的系统进行性能测试时十分必要的、现有系统大致分为单机系统.C&#x2F;S系统和B&#x2F;S系统.一般C&#x2F;S架构的应程序更关注系统资源的情况、数据库性能以及运行的配覆要求如内存，用户连接数、数据库死锁、数据库cache 命中率，运行的最低配置等；B&#x2F;S架构的应用程序，会再关注于web服务器相关指标如每秒点击数吞吐量，尝试连接数、事务成功率等</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="性能指标的要求"><a href="#性能指标的要求" class="headerlink" title="性能指标的要求"></a>性能指标的要求</h3><pre><code>[各项指标的计算方法](/01_测试初阶/02_测试理论/04_第四章性能测试/905_性能测试文件/03_各项指标的计算方法/)   
[性能指标的标准1](/01_测试初阶/02_测试理论/04_第四章性能测试/905_性能测试文件/04_性能指标的标准1/)    
[性能指标的标准2](/01_测试初阶/02_测试理论/04_第四章性能测试/905_性能测试文件/05_性能指标的标准2/)
</code></pre>
<ol>
<li>响应时间：90％的用户的响应时间不能超过8s．<br> 吞吐量：根据以前项目组内容自己进行设置<br> 平均点击率：（根据以前项目组内容自己进行设置）<br> 错误率：一般不超过3％<br> cpu占有率：一般不要超出90％．如果超出短时间内没问题，长时间不行<br> 磁盘占有率：一定要有空余＜如果没有空余，但是磁盘交互区swap使用率为0，说明刚好内存多用，磁盘交互区swap使用率为100％，一定会出现请求数据丢失）<br> Cpu负载值：    单个cpu负载值不能超过2.8s，2.8s以下表示为畅通  2.8s～5.0s短时间内没问题，5.0s以上会出现数据请求丢失</li>
</ol>
</li>
<li><h3 id="性能专测过程：压力测试"><a href="#性能专测过程：压力测试" class="headerlink" title="性能专测过程：压力测试"></a>性能专测过程：压力测试</h3><ol>
<li>当接到要求需要对系统进行性能测域的时候，首先根据已知的性专指标分析测试分析测式场景，使用Jmeter测域工具开始进行抓包录制请求，再对需要进行并发的请求进行改写比如设置<br> 参数化（包括请求参数的参数化和Cookie值的参数化），设置集合点，设置线程数和启动时间等，为了方便分析结果，再添加上聚合报告和查看结果树，改写完成之后，启动Jmter执行压力测试，通过逐步施压的方法。慢慢测试系统能承载的量大并发量，在达到规定的并发量的时候，观察一下对应的性能指标是否满足：比加当时在测试的时候，要求90％用户的响应时间不能超过85．错误率不能超过3％．cpu负载随不能超其2.8s等等  当时在测试时达到要求的并发量的时候响应时间超过了8s，性能测试未能通过．</li>
</ol>
</li>
<li><h3 id="jmeter负载测试总结"><a href="#jmeter负载测试总结" class="headerlink" title="jmeter负载测试总结"></a>jmeter负载测试总结</h3><ol>
<li>负载测试：当我们接到要求需要对系统进行性能测成的时候，首先根据已知的性能指标分析测试场景，使用Jmter 测试工具开始进行抓包录制请求，再对需要行并发的请求进行 改写，比如设置叁数化（包括请求参数的参数T化和cookie值的参数化）设置固定定时器，设置关联请求。设置线程数和循环次数等.在针对用户可能存在的不同操作分别进行录制改写完毕之后通过设置多个线程组分别模拟用尺的不同操作，同时启动进行负载方面的测试.</li>
</ol>
</li>
<li><h3 id="性能测试的优化方案"><a href="#性能测试的优化方案" class="headerlink" title="性能测试的优化方案"></a>性能测试的优化方案</h3><ol>
<li>数据库部分可以优化的方向<ol>
<li>表中设置主键和索引</li>
<li>列的属性使用字符类型比使用整型要节省时间</li>
<li>尽量减少多表联查</li>
<li>分库分表</li>
<li>使用内存库存储数据</li>
</ol>
</li>
<li>实现机制部分<ol>
<li>浏览器展示的时候，对页面进行分页处理</li>
<li>读取缓存</li>
<li>尽量采用静态页面</li>
<li>尽量多设置进程</li>
<li>设置多个服务器</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="有没有做过性能测试，具体怎么做的"><a href="#有没有做过性能测试，具体怎么做的" class="headerlink" title="有没有做过性能测试，具体怎么做的"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/06_%E6%9C%89%E6%B2%A1%E6%9C%89%E5%81%9A%E8%BF%87%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">有没有做过性能测试，具体怎么做的</a></h3><ol>
<li>没有做过性能测试，但是知道是怎么做的。不过我们那个项目的性能做得不多，公司要求也不严格。一般SE给我们相关的性能需求，首先我们需要对性能需求进行场景分析与设计，这里，其实主要就是确定并发数，考虑是否需求设置集合点，以及个业务场景的性能指标要求，根据以上的分析来编写性能测试用例。然后就开始着手去准备性能测试需要用到数据，以便后期做参数化，搭建好性能测试环境，然后就进行性能脚本的开发与执行。就拿当时做过的一个抢购活动的抢购活动的性能测试来讲吧。当时抢购活动的下单接口要求抢购1000 个商品，做一个并发压测，当时公司要求设定的并发数在：5000考虑到抢购下单接口，必须要先登录，所以，首先我会准备 5000 个用户数据（账号，密码），这边当时是通过存储过程来实现。然后把创建好的 5000 个用户账号，提取出来，保存在 csv 文件中。之后就是编写性能测试脚本了，这里主要就是首先建一个 SetUp 线程组添加一个登录接口的 http 请求，这里需要对用户数据进行参数化，我当时是把所有的 5000 用户数据存储在 CSV 文件中，然后用’CSV 数据文件设置’这个配置元件来实现数据的参数化，然后需要在登录接口的 http 请求中添加一个后置处理器的正则表示式提取器，来提取所用用户的cookie 值，并且通过调用 Beanshell 取样器结合_setProperty 这个函数，将所有 cookie 设定为全部变量， 考虑到是抢购活动，这里需要设置集合点，需要添加一个同步定时器，用来设置集合点的。然后就再创建线程组，并创建一个下单接口的 http 请求，并在查询接口的 http 请求中添加一个 http cookies 管理器， 把登录接口的 cookie 通过 http cookies 管理器传递到后台。然后添加一个响应断言，用来检查请求是成功，最后添加一个查看结果树和聚合报告用来查看性能指标。例外对于服务器资源的监控，像 CPU,内存，磁盘 IO,网络，这块当时用的nmon 工具来获取这些数据的， 我们需要在服务器上安装一个nmon 工具，并运行启动就可以了，最后把它转化为 excel 表格形式的图形化报告。最后对报告做一个简单的分析。当时我们就是这么做的</li>
</ol>
</li>
<li><h3 id="性能测试流程是怎么样的？"><a href="#性能测试流程是怎么样的？" class="headerlink" title="性能测试流程是怎么样的？"></a>性能测试流程是怎么样的？</h3><ol>
<li>例外一种问法：简单介绍下你们公司的性能测试流程是怎么样的？<br> 我们那个项目的性能做得不多，公司要求也不严格。<br> 对于流程这块，首先就要对整个系统进行详细的分析，确定基本的测试范围，看下系统的哪些业务是需要做性能测试的，还有就是做哪方面的性能测试，对于我们那个项目，当时就做了几个业务做了些简单的并发压测（稳定性）这块，像登录的，搜索查询，下单，还有就是购物车里面的几个接口都有做过。然后就是对各个业务场景进行详细的场景分析与设计，确定每个业务场景的并发数，是否需要设置集合点啊，压测时间是多长，还有各个业务场景的性能指标等等，场景设计这块基本上都是老大跟产品哪个一起弄的，我参与的不是太多。<br> 上面把个场景设置好了之后，提交给我们，我们就是根据老大设置好的那些场景编写了基本的性能测试用例。其实做性能测试，我觉得前期最关键的还是业务场景一定要设计好，后期我们主要的任务就是准备各自任务需要用到的一些测试数据，搭建好测试环境，还有就是测试脚本设计与开发，执行，并生出测试报告，对于测试结果我们一般会简单的做个分析，如果没有什么问题，基本后期就写一个性能测试报告。流程大概就是这样的。</li>
</ol>
</li>
<li><h3 id="你们性能观察哪些指标，大概指标范围是怎么样的。"><a href="#你们性能观察哪些指标，大概指标范围是怎么样的。" class="headerlink" title="你们性能观察哪些指标，大概指标范围是怎么样的。"></a>你们性能观察哪些指标，大概指标范围是怎么样的。</h3><ol>
<li>响应时间<br> 错误率<br> 吞吐量&#x2F;吞吐率cpu<br> 内存网络<br> 磁盘读写速度</li>
</ol>
</li>
<li><h3 id="性能测试计划有哪些内容"><a href="#性能测试计划有哪些内容" class="headerlink" title="性能测试计划有哪些内容"></a>性能测试计划有哪些内容</h3><ol>
<li>写过，主要是时间进度安排与工作安排，主要是环境，测试任务，测试需求，测试方法与策略，测试环境准备，测试通过的标准、比如说原来我们一个项目性能测试时做了 5 天，那我们计划是，测试策略与用例编写一天，测试准备需要1 天，测试执行 2 天，报告总结 1 天。</li>
</ol>
</li>
<li><h3 id="有没有写过性能测试报告，具体包括哪些内容"><a href="#有没有写过性能测试报告，具体包括哪些内容" class="headerlink" title="有没有写过性能测试报告，具体包括哪些内容"></a>有没有写过性能测试报告，具体包括哪些内容</h3><ol>
<li>性能测试报告，需要每次 jmeter 压测完成的 html 报告的数据跟 nmon 工具监控的数据，整理出一份性能测试报告，性能测试报告，主要包含<br> 1，测试资源（环境，测试数据，表里面需要多少数据，测试工具）<br> 2，测试设计（测试业务，测试类型，测试时间，并发用户数）<br> 3，测试分析（每一个场景都需要分析）<br> 4，测试结论（能不能上线，不上线的原因）<br> 5，优化和建议<br> 6，测试通过的标准，平均响应时间&lt;5s，资源利用率&lt;75%，事务失败率&lt;5%</li>
</ol>
</li>
<li><h3 id="什么是内存泄漏，什么是内存溢出"><a href="#什么是内存泄漏，什么是内存溢出" class="headerlink" title="什么是内存泄漏，什么是内存溢出"></a>什么是内存泄漏，什么是内存溢出</h3><ol>
<li>内存泄漏：<br> 是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。通常少次数的内存无法及时回收并不会到程序造成什么影响，但是如果在内存本身就比较少获取多次<br> 导致内存无法正常回收时，就会导致内存不够用，最终导致内存溢出。<br> 内存溢出：OOM<br> |-1.  指程序申请内存时，没有足够的内存供申请者使用1M     实际要占用 2M内存，就说分配的内存不够，导致内存溢出<br> |-2.  给了你一块存储<br> int类型数据的存储空间，但是你却存储long类型的数据，<br> |-3.  长期出现内存泄漏，导致系统内存越用越少，最终导致内存不够用，导致系统崩溃，出现<br> OOM</li>
</ol>
</li>
<li><h3 id="吞吐量与吞吐率跟负载有什么关系？"><a href="#吞吐量与吞吐率跟负载有什么关系？" class="headerlink" title="吞吐量与吞吐率跟负载有什么关系？"></a>吞吐量与吞吐率跟负载有什么关系？</h3><ol>
<li>吞吐量&#x2F;率和负载之间的关系：<br> ①上升阶段：吞吐量随着负载的增加而增加，吞吐量和负载成正比；<br> ②平稳阶段：吞吐量随着负载的增加而保持稳定，无太大变化或波动；<br> ③下降阶段：吞吐量随着负载的增加而下降，吞吐量和负载成反比； 总结：吞吐量&#x2F;率干不过负载！！！</li>
</ol>
</li>
<li><h3 id="当你服务器满了之后，你们吞吐量和响应时间怎么变化的"><a href="#当你服务器满了之后，你们吞吐量和响应时间怎么变化的" class="headerlink" title="当你服务器满了之后，你们吞吐量和响应时间怎么变化的"></a>当你服务器满了之后，你们吞吐量和响应时间怎么变化的</h3><ol>
<li>吞吐量会所有下降，响应时间会变长</li>
</ol>
</li>
<li><h3 id="你们的TPS的指标是什么估算的？"><a href="#你们的TPS的指标是什么估算的？" class="headerlink" title="你们的TPS的指标是什么估算的？"></a>你们的<strong>TPS</strong>的指标是什么估算的？</h3><ol>
<li>答：我们系统的 TPS 当时是根据PV 值来计算的，就是通过查看系统访问日志来获取每个业务功能每天高峰期的 PV 值（也就是每天高峰期的时间段，有多少服务器的客户请求）。<br> 当时的 PV 值大概在 5000 多<br> 然后按照二八原则，即 80％的业务在 20%的时间内完成，TPS&#x3D;（PV<em>80%)&#x2F;(时间</em>20%)。算出来大概在110kb&#x2F;s<br> 【具体的指标都是SE跟测试主管他们经过分析出来给到我们的。他们开会的时候大概跟我们说过估算方式，差不多是这样的          】</li>
</ol>
</li>
<li><h3 id="每人说一个项目接口，你设置多少并发"><a href="#每人说一个项目接口，你设置多少并发" class="headerlink" title="每人说一个项目接口，你设置多少并发"></a>每人说一个项目接口，你设置多少并发</h3><ol>
<li>答：就拿登录接口来讲吧。<br> 我们的并发数是根据注册用户数量及每天在线用户数综合来估算的，我们系统当时注册用户数量大概是在70多万的样子，不过这里其实有一些僵尸用户，真正的用户大概在 60%的样子，也就是差不多，46万多一点，通过查看系统访问日志，高峰期的时候每天在线数用户数量大概差不多在 52000多点吧，按 52000 估算，每个用户停留时间大概在 20分钟左右，大概平均每天同时在线用户数量在:2145多。其中登录业务的占比大概在 10%的样子，同时在登录的大概<br> 80%的比例计算，登录接口大概设置的并发数在 172多的样子，查询业务的占比大概在 30%，查询接口大概设置的并发数在 510的样子，下单业务大概占比在<br> 20%，下单接口的并发数设定在 345的样子。<br> 【具体的指标都是SE跟测试主管他们经过分析出来给到我们的。他们开会的时候大概跟我们说过估算方式，差不多是这样的          】</li>
</ol>
</li>
<li><h3 id="你们吞吐量是多少，响应时间是多少，你设置了多少并发"><a href="#你们吞吐量是多少，响应时间是多少，你设置了多少并发" class="headerlink" title="你们吞吐量是多少，响应时间是多少，你设置了多少并发"></a>你们吞吐量是多少，响应时间是多少，你设置了多少并发</h3><ol>
<li>登录：吞吐率大概在 95KB&#x2F;sec,响应时间&lt;1s，设置的并发数 180 个并发数。查询：吞吐率大概在 120&#x2F;sec,响应时间&lt;3s，设置的并发数 500 个并发数。下单：吞吐率大概在 115&#x2F;sec,响应时间&lt;3s，设置的并发数 350 个并发。</li>
</ol>
</li>
<li><h3 id="做并发你们一般cpu和内存是多少"><a href="#做并发你们一般cpu和内存是多少" class="headerlink" title="做并发你们一般cpu和内存是多少"></a>做并发你们一般<strong>cpu</strong>和内存是多少</h3><ol>
<li>cpu 大概在 60%多点，内存大概占比在 65%的样子。</li>
</ol>
</li>
<li>有没有做过稳定性测试<ol>
<li>部分接口有做过稳定性测试。<br> 稳定性测试主要就是看某个业务在高并发情况下是否能持续稳定运行嘛，当时大部分的核心业务都有做过稳定性的，这个需是把并发数设置为峰值，然后循环次数设置为永远，例外要开启调度器，调度器中的持续时间设定为 3600 秒，让它持续压测 1 个小时。看下接口的各项性能指标的变化，是否在预期的指标范围之内。</li>
</ol>
</li>
<li><h3 id="压测返回数据报错，你怎么去定位的"><a href="#压测返回数据报错，你怎么去定位的" class="headerlink" title="压测返回数据报错，你怎么去定位的"></a>压测返回数据报错，你怎么去定位的</h3> 1、如果是所有请求的数据报错，那肯定是脚本问题，认真检查脚本参数。<br> 2、如果只是部分请求报错，那估计是性能问题了。</li>
<li><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/02_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%AF%87/01_jmeter/999_%E5%B7%A5%E5%85%B7/17_Jmeter%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/">性能测试篇 ：Jmeter监控服务器性能</a></li>
<li><h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ol>
<li><strong>宕机（挂机）</strong></li>
</ol>
</li>
<li>性能测试<ol>
<li>分析方法<ol>
<li>结果比较法</li>
<li>最优化分析法</li>
</ol>
</li>
<li>调优方法<ol>
<li>应用程序诊断</li>
<li>系统调优</li>
</ol>
</li>
</ol>
</li>
<li>常见性能瓶颈<ol>
<li>硬件上的瓶颈<ol>
<li>一般指的是CPU\RAM的问题，分为服务器硬件瓶颈、网络瓶颈、操作系统瓶颈（参数配置）、中间件瓶颈（参数配置、数据库、web服务器等）</li>
</ol>
</li>
<li>应用软件上的瓶颈<ol>
<li>一般值得是应用服务器、web服务器等应用软件，还包括数据库系统</li>
</ol>
</li>
<li>应用程序上的性能瓶颈<ol>
<li>一般指的是开发人员新开发出来的应用程序</li>
</ol>
</li>
<li>操作系统上的 性能瓶颈<ol>
<li>一般指的是Linux windows  unix 等操作系统的某些配置</li>
</ol>
</li>
<li>网络设备上的性能瓶颈<ol>
<li>一般指的是防火墙、动态负载生成器、交换机等设备</li>
</ol>
</li>
</ol>
</li>
<li>地铁模型<br> 假设：<br> 某地铁站进站只有3个刷卡机。<br> 人少的情况下，每位乘客很快就可以刷卡进站，假设进站需要1s。<br> 乘客耐心有限，如果等待超过30min，就暴躁、唠叨，甚至放弃。<br> 场景一：只有1名乘客进站时，这名乘客可以在1s的时间内完成进站，且只利用了一台刷卡机，剩余2台等待着。<br> 场景二：只有2名乘客进站时，2名乘客仍都可以在1s的时间内完成进站，且利用了2台刷卡机，剩余1台等待着。<br> 场景三：只有3名乘客进站时，3名乘客还能在1s的时间内完成进站，且利用了3台刷卡机，资源得到充分利用。<br> 场景四：A、B、C三名乘客进站，同时D、E、F乘客也要进站，因为A、B、C先到，所以D、E、F乘客需要排队。<br> 那么，A、B、C乘客进站时间为1s，而D、E、F乘客必须等待1s，所以他们3位在进站的时间是2s。<br> 场景五：假设这次进站一次来了9名乘客，有3名的“响应时间”为1s，有3名的“响应时间”为2s（等待1s+进站1s）， 还有3名的“响应时间”为3s（等待2s+进站1s）。<br> 场景六：如果地铁正好在火车站，每名乘客都拿着大小不同的包，包太大导致卡在刷卡机堵塞，每名乘客的进站时 间就会又不一样。刷卡机有加宽的和正常宽度的两种类型，那么拿大包的乘客可以通过加宽的刷卡机快速进站（增 加带宽）。<br> 场景七：进站的乘客越来越多，3台刷卡机已经无法满足需求，为了减少人流的积压，需要再多开几个刷卡机，增 加进站的人流与速度（提升TPS、增大连接数）。<br> 场景八：到了上班高峰时间了，乘客数量上升太快，现有的进站措施已经无法满足，越来越多的人开始抱怨、 拥挤，情况越来越糟。单单增加刷卡机已经不行了，此时的乘客就相当于“请求”，乘客不是在地铁进站排队，就是 在站台排队等车，已经造成严重的“堵塞”，那么增加发车频率（加快应用服务器、数据库的处理速度）、增加车厢数量（增加内存、增大吞吐量）、增加线路（增加服务的线程）、限流、分流等多种措施便应需而生。 <br /></li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>04_第四章性能测试</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>QNET-网络测试工具</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/01_QNET-%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="一、什么是QNET"><a href="#一、什么是QNET" class="headerlink" title="一、什么是QNET"></a>一、什么是QNET</h3><p>QNET腾讯WeTest开放平台最近推出了一款针对移动应用的弱网测试工具QNET，解决了在Android设备上进行弱网络专项测试的痛点，QNET无需ROOT手机，无需连接数据线，以独立app的方式，为用户提供给快捷、可靠、功能完善的弱网络模拟服务。<br>另外QNET还有一个很好用的功能——TCP&#x2F;UDP网络协议抓包，帮助开发和测试人员进行网络流量分析，而不需要ROOT手机，使用tcpdump进行抓包。<br>QNET网络测试工具能够不借助PC或服务器，搭建一套完整的弱网测试环境，进行弱网络模拟测试，秩序在任意只能手机上安装QNET网络测试工具，即完成弱网络测试环境搭建工作，接下来根据需要选择不同场景进行测试即可，除此之外，还提供了网络数据包抓包功能，便于进行网络数据问题的分析。</p>
<h3 id="二、为什么要弱网测试"><a href="#二、为什么要弱网测试" class="headerlink" title="二、为什么要弱网测试"></a>二、为什么要弱网测试</h3><p>1、验证应用&#x2F;游戏在不同网络场景下表现是否符合预期，会不会触发未知的系统bug<br>2、提高不同网络场景下用户的体验<br>3、测试公用组件&#x2F;SDK在不同网络状态下的稳定性<br><strong>测试移动设备上进行弱网专项测试的方案主要有两种：</strong><br>1、通过Android设备连接到PC上进行弱网测试，比如Fiddler，Charles,NET-Simulator等。基本思路是在PC上装一个Fiddler网络抓包工具，然后再将Android设备的网络代理到PC上，通过PC的Fiddler在设置延时来进行弱网络模拟<br>2、在专有服务器上构建弱网络WI-FI，移动设备连接该Wi-Fi进行弱网测试，相关的技术方案有 Facebook的ATC和腾讯的WeTest-WiFi。<br><strong>以上两种方法都能够实现移动设备的弱网专项测试，也已经是比较成熟的方案，但都存在以下几点缺点：</strong><br>（1）需要额外的PC或者服务器，弱网环境构建成本高；<br>（2）需要安装、部署额外的工具，并且弱网络环境需要在PC上或者Web上进行配置，使用成本高；<br>（3）弱网络环境功能并不完善，比如Fiddler不支持丢包、抖动等弱网环境。</p>
<h3 id="三、工具使用介绍"><a href="#三、工具使用介绍" class="headerlink" title="三、工具使用介绍"></a>三、工具使用介绍</h3><p>具体查看官网：<a href="https://cdn.wetest.qq.com/qnet/files/QNET%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B72.0.pdf">https://cdn.wetest.qq.com/qnet/files/QNET网络测试工具2.0.pdf</a></p>
<h3 id="四、弱网功能详细介绍"><a href="#四、弱网功能详细介绍" class="headerlink" title="四、弱网功能详细介绍"></a>四、弱网功能详细介绍</h3><h4 id="1、自定义模板参数介绍"><a href="#1、自定义模板参数介绍" class="headerlink" title="1、自定义模板参数介绍"></a>1、自定义模板参数介绍</h4><p><img src="/assets/1/image-20220311173743-wnv5mqz.png" alt="image.png"><br>（1）网络模板<br>单位kbps，限制当前网络上下行最大的带宽容量，例如针对腾讯视频设置1024kbps限速后，下载速度 只能达到128KB&#x2F;s左右：<br>（2）网络延时<br>单位ms，当前网络的上下行延时约等于设置值，设置延时100ms,200ms,300ms<br>（3）延时抖动<br>对每个数据包以设置的概率进行抖动选择，延时范围在0~抖动值之间随时产生<br>（4）随机丢包<br>按设置的概率对每个包进行丢包<br>（5）周期弱网<br>按照放行时长、弱网时长设置交替切换，根据弱网类型进行弱网。<br>弱网类型：<br> <strong>【完全丢包】</strong> ：处于弱网时长的数据包直接丢包<br> <strong>【Burst】</strong> ：模拟路由或者底层硬件在判断当前网络连接不通时保存数据包，在网络通畅后爆发式的将 数据包推送出去，<br>（6）协议控制<br>支持对不同协议的弱网控制，协议类型包括TCP\UDP\ICMP\DNS；<br>（7）IP控制 可以针对IP进行弱网控制，多个IP以|分割。</p>
<h4 id="2、场景模板介绍"><a href="#2、场景模板介绍" class="headerlink" title="2、场景模板介绍"></a>2、场景模板介绍</h4><p><img src="/assets/1/image-20220311173751-5142qan.png" alt="image.png"><br>（1）网络选择<br>提供真实的省市间网络传递的数据参数、运营商数据、网络类型数据；<br>（2）场景选择<br>提供多个真实测量不同场景下的网络波形<br>接下来：<br>应用实际场景中<br>掌握基础知识</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>04_第四章性能测试</category>
        <category>905_性能测试文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<ol>
<li><h3 id="网络技术"><a href="#网络技术" class="headerlink" title="网络技术"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/01_%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></h3></li>
<li><h4 id="wireshark介绍"><a href="#wireshark介绍" class="headerlink" title="wireshark介绍"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/02_wireshark%E4%BB%8B%E7%BB%8D/">wireshark介绍</a></h4></li>
<li><h2 id="网络协议的定义："><a href="#网络协议的定义：" class="headerlink" title="网络协议的定义："></a>网络协议的定义：</h2><ol>
<li>通常地说网络协议就是网络之间交流的桥梁，只有相同的网络协议的计算机才能进行信息的沟通与交流，这就好比人与人之间的交流所使用的各种语言，只有使用相同的语言才能正常的顺利进行交流，从专业角度定义：网络协议是计算机在网络中实现通信时必须遵守的约定，也即通信协议，主要是对信息传输的速率，传输的代码 代码结构，传输控制步骤，出错控制等作出规定制定标准</li>
</ol>
</li>
<li><h2 id="TCP-x2F-ip-ipv4"><a href="#TCP-x2F-ip-ipv4" class="headerlink" title="TCP&#x2F;ip ipv4"></a>TCP&#x2F;ip ipv4</h2><ol>
<li><p>网络接口层：公网达到局域网后需要转化为对应的MAC地址，交换机解析判断数据要发给MAC地址对应的那台电脑，使用的是arp协议（地址解析协议）</p>
</li>
<li><p><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/03_%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>：寻找最佳网络路径（比如我们浏览其他的服务器会留下记录）</p>
</li>
<li><p><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/04_%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>：设备和设备之间进行传送比特流数据</p>
</li>
<li><p><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/05_%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>：应用层是所有用户做面向的应用程序的统称</p>
</li>
<li><p>FTP文件传输协议，有两个端口  20 用于传输数据   21 用于传输控制信息通常用FTP协议把网页或者程序传到web服务器上，由于FTP传输效率非常高，在网络上传输大的文件时一般也采用该协议</p>
<p> oracle数据库 默认端口号：1521</p>
<p> sqlserver数据库  默认端口号：1433</p>
<p> mysql数据库 默认端口号：3306</p>
</li>
</ol>
</li>
<li><h2 id="应用层有哪些协议："><a href="#应用层有哪些协议：" class="headerlink" title="应用层有哪些协议："></a>应用层有哪些协议：</h2><ol>
<li><p>http（80）   https（443） ftp(21)  ssh(22) telnet(23) tcp  udp  arp 等</p>
<p> ftp文件传输协议     </p>
<p> ssh    linux系统安全连接协议</p>
<p> http协议：超文本传输协议      </p>
<p> https协议：加密超文本传输协议</p>
</li>
</ol>
</li>
<li><h2 id="SSH（安全外壳协议）"><a href="#SSH（安全外壳协议）" class="headerlink" title="SSH（安全外壳协议）"></a>SSH（安全外壳协议）</h2><ol>
<li>ssh为建立在应用层基础上的安全协议，ssh是目前较可靠，专为远程登录回话和其他网络服务提供安全性协议，利用ssh协议可以有效防止远程管理过程中的信息泄露的问题，ssh最初始unix系统上的一个程序，后来又迅速扩展到其他操作平台，ssh在正确使用时可弥补网络中的罗东，ssh客户端使用于多种平台，数据  端口号 22</li>
</ol>
</li>
<li><h2 id="Telnet（远程登录协议）"><a href="#Telnet（远程登录协议）" class="headerlink" title="Telnet（远程登录协议）"></a>Telnet（远程登录协议）</h2><ol>
<li>telnet 协议是tcp&#x2F;ip协议族中的一员，是internet远程登录服务的标准协议和主要方式，它为用户提供了在本地计算机上完成远程主句工作的能录，在终端使用者的电脑上使用Telnet程序，用它连接到服务器，终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行就像直接在服务器的控制台上输入一样，可以在本地就能控制服务器，要开始一个telnet会晤，必须输入用户名和密码来登录服务器数据端口号23</li>
</ol>
</li>
<li><h2 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP(地址解析协议)"></a>ARP(地址解析协议)</h2><ol>
<li>通过一致的ip寻找主机的mac地址（物理地址）硬件地址用来定义网络设备的位置，一个主机只有一个mac地址</li>
<li>RARP是反向的地址解析协议，通过mac地址确定ip地址</li>
</ol>
</li>
<li><h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><ol>
<li>tcp是面向有链接的协议，提供可靠的报文传输和对上层应用的连接服务</li>
<li>udp是面向无链接的不可靠的传输协议，主要用于需要tcp的排序和流量 控制等功能的应用程序</li>
<li>tcp是一种可靠的传输协议，有请求有响应，规定接受端必须发回确认并且假如分组丢失，必须重新发送</li>
<li>udp则不具备这些，知识把数据包从客户端传输给服务端，至于服务端是否真实收到则不做判断</li>
</ol>
</li>
<li><h2 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI  七层协议"></a>OSI  七层协议</h2><ol>
<li><p>1.物理层   2.数据链路层  3.网络层  4. 传输层   5.会话层    6. 表示层   7.应用层</p>
<ol>
<li><p>物理层：两个硬件之间怎么进行通信，一个硬件发送比特流，另一个硬件成功进行接受</p>
<p> 物理层定义：定义物理层设备的标准比如光纤，网络，各种传输介质，出阿叔速度；</p>
<p> 主要关注：1和0之间的数模转换和模数转换（数模：用合适的数学模型，教数公式表达方便；魔术：设置一定的规则进行应用）</p>
</li>
<li><p>数据链路层：在数据的传输过程中识别传输比特流数据的正确性，</p>
<ol>
<li>主要关注：规范数据传输的格式，校验数据的正确性</li>
</ol>
</li>
<li><p>传输层：设备和设备之间进行传比特流数据</p>
<ol>
<li>tcp：面向有链接的协议请求，有请求有相应</li>
<li>udp：面向无链接的协议请求，有请求无响应</li>
</ol>
</li>
<li><p>网络层：寻找最佳网络路径（比如我们浏览其他的服务器会留下记录）</p>
</li>
<li><p>会话层：根据以上协议自动进行发送对应的数据</p>
</li>
<li><p>表示层：不同系统之间交互的通道（作用相当于我们的翻译）</p>
<ol>
<li>windows 运行软件  .exe</li>
<li>linux   运行软件   .sh</li>
</ol>
</li>
<li><p>应用层：贴近我们的日常生活，能够直观看到的</p>
<ol>
<li><img src="/assets/1/image-20211122140653-z9ls60r.png" alt="image.png"></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="osi-7层协议解释说明"><a href="#osi-7层协议解释说明" class="headerlink" title="osi 7层协议解释说明"></a>osi 7层协议解释说明</h2><ol>
<li>物理层（physical layer） 主要是处理机械的电器的过程的接口，以及物理层下的物理传输介质等</li>
<li>数据链路层（data link layer） 的任务是加强吴立成的功能 使其对网络层显示为一条无错的线路</li>
<li>网络层（network layer） 确定分组从源端到目的端的路由选择，路由可以选用网络中固定的静态路由表，也可以在每一次会化时决定，还可以根据当前的网络负载状态，灵活的为每一个分组分别决定</li>
<li>传输层（transport layer） 从会话层接受数据，并传给网络层，同时确保到达目的端的各段信息正确无误，而且使会话层不受硬件变化的影响</li>
<li>会话层（session layer） 允许不同的机器上的用户之间建立绘画关系，即可以进行类似传输层的数据传输，也可以被用于与远程登录到不同系统或者在两个机器间传递文件</li>
<li>表示层（presentation layer） 用于完成一些特定的功能，这些功能由于经常被请求，因人们希望有通用的解决方法，而不是由每个用户各自实现</li>
<li>应用层（application layer） 中包含了大量人们普遍需要的协议，如qq、浏览器等部分软件均在应用层</li>
</ol>
</li>
<li><h3 id="是否了解三次握手，四次挥手？"><a href="#是否了解三次握手，四次挥手？" class="headerlink" title="是否了解三次握手，四次挥手？"></a>是否了解三次握手，四次挥手？</h3><ol>
<li><h5 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h5><ol>
<li><p>第一次握手：建立连接时，客户端发送SYN包到服务器，并进入SYN-SEND（发送）状态，等待服务器确认。</p>
</li>
<li><p>第二次握手：服务器收到SYN包，必须确认客户的SYN，同时自己也发送一个syn包。即syn+ack（确认字符）包，此时服务器进入syn-recv（接受）状态</p>
</li>
<li><p>第三次握手：客户端收到服务器syn+ack包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入established（确认）状态，完成三次握手</p>
</li>
</ol>
</li>
<li><h5 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h5><ol>
<li><p>第一次挥手：客户端给服务器发送FIN包，用来关闭客户端到服务器的数据传送</p>
</li>
<li><p>第二次挥手：服务器收到FIN包，发送一个确认信号ACK</p>
</li>
<li><p>第三次挥手：服务器发送FIN包，请求关闭服务器到客户端的数据传送</p>
</li>
<li><p>第四次挥手：客户端收到服务器发送的FIN包之后，发回ACK包确认</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="长连接和短连接的区别"><a href="#长连接和短连接的区别" class="headerlink" title="长连接和短连接的区别"></a>长连接和短连接的区别</h2><ol>
<li><p>短连接：指socket连接后发送，接受完数据后马上断开（比如发短信）</p>
<pre><code> &lt;短连接：连接-数据传输-关闭连接（安全性比较高）&gt;
</code></pre>
<p> 长连接：指socket连接后不管是否传输都保持连接，单安全性比较低（比如打电话，视频通信）</p>
<pre><code> &lt;长连接：连接-数据传输-保持连接-数据传输-关闭连接（安全性比较低）&gt;
</code></pre>
</li>
</ol>
</li>
<li><h3 id="对协议这块是否熟悉了解，大概给我简单介绍下http协议？"><a href="#对协议这块是否熟悉了解，大概给我简单介绍下http协议？" class="headerlink" title="对协议这块是否熟悉了解，大概给我简单介绍下http协议？"></a>对协议这块是否熟悉了解，大概给我简单介绍下<strong>http</strong>协议？</h3><ol>
<li><p>对于协议这块，我们做接口测试一定要熟悉协议，而且我们所有接口都是 http 接口，所以对于 http 协议还算比较熟悉。</p>
<p> 其实http协议是一个超文本传输协议—- &gt;可以传输文字&#x2F;文本，图片，音频，视频等</p>
<p> HTTP<br> 是一个基于 TCP&#x2F;IP 通信协议来传递数据，目前有 1.0，1.1 两个版本，现在主要用的 1.1 版本协议。HTTP 协议工作于客户端-服务端架构为上一种协议。他的原理是这样的：浏览器作为 HTTP 客户端通过URL 向<br> HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p> 这个协议其实就是通过请求，响应的形式来进行数据传输的一种模式。</p>
<p> http 协议比较简单，传输速度比较快，例外，它是一种面向无状态，无连接的协议，同时支持<br> B&#x2F;S 及C&#x2F;S</p>
<p> 模式。它没有记忆能力，每次要获取数据都必须要重新发送请求。</p>
</li>
<li><p><img src="/assets/1/image-20211203174202-7p53c90.png" alt="image.png"></p>
</li>
</ol>
</li>
<li><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><ol>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/01_HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">HTTP协议详解</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/02_%E7%BC%93%E5%AD%98/">缓存</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/03_%E4%BB%A3%E7%90%86/">代理</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/04_%E7%8A%B6%E6%80%81%E7%A0%81/">状态码</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/05_cookie/">cookie</a></li>
</ol>
</li>
<li><h3 id="http协议的报文"><a href="#http协议的报文" class="headerlink" title="http协议的报文"></a><strong>http</strong>协议的报文</h3><ol>
<li><p>哦，对于 http 的报文，由于它是通过请求，响应的方式在客户端与服务端进行数据传输的模式，所以它的报文分为请求报文和响应报文。</p>
<p> Http 的请求报文包含以下 4 个部分：请求行，请求头，空行，请求数据&#x2F;参数。</p>
<p> 我们其实一般最关注的主要是请求头及请求数据&#x2F;参数。尤其在做接口测试的时候我们需要关注这两个部分。例外，对于请求行里面，一般包含有：请求方式，请求地址&#x2F;URL，端口，协议版本等信息。</p>
<p> 而 http 的响应报文包含以下 4 个部分：响应行，响应头，空行，响应的数据</p>
<p> 对于响应，我们一般重点关注的是：响应头，响应的数据。例外，响应行中包含有：协议版本，状态（本次数据传输的状态），提示信息。还有就是，请求头中也有些比较关键的信息，比如用来做鉴权的<br> cookie 或着 token 的值，我们后面可能会需要用到。 而响应具体数据中包含：错误码，具体数据内容，一般具体的数据内容的格式有：json,xml,html。对于 Web端一般传输的是 html格式，而 app端一般传输的<br> json 格式居多。</p>
<blockquote>
<p>POST</p>
<p><a href="http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWwucJRFNxUfImKSQTQAgTEpzCOgh">http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWw</a> <a href="http://localhost/fw/index.php?ctl=user&act=dologin&fhash=ZQuhzOKoGqHeoLtCHLxDqjWwucJRFNxUfImKSQTQAgTEpzCOgh">ucJRFNxUfImKSQTQAgTEpzCOgh </a>HTTP&#x2F;1.1 请求行</p>
<p>Host: localhost 请求头</p>
<p>Connection: keep-alive Content-Length: 169</p>
<p>Accept: application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01 Origin: <a href="http://localhost/">http://localhost</a></p>
<p>X-Requested-With: XMLHttpRequest</p>
<p>User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;73.0.3683.103 Safari&#x2F;537.36</p>
<p>Content-Type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8 Referer: <a href="http://localhost/fw/">http://localhost/fw/</a></p>
<p>Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q&#x3D;0.9</p>
<p>Cookie: PHPSESSID&#x3D;1995aff9a42398edb17cd80bb76a5a5f</p>
<p>空行</p>
<p>email&#x3D;jason&amp;user_pwd&#x3D;WVRnSk1kS1hneW9RYkNxVmpTR1VVQmN1bHN3SlR4ekdEQkVIYlFIRmlZUnFW</p>
<p>cHBSYWElMjV1NjVCOSUyNXU3RUY0emdwMTIzNDU2JTI1dThGNkYlMjV1NEVGNg%3D%3D&amp;auto_login&#x3D;0</p>
<p>&amp;ajax&#x3D;1 请求参数&#x2F;数据</p>
</blockquote>
<blockquote>
<p>HTTP&#x2F;1.1 200 OK 响应行</p>
<p>Date: Thu, 25 Apr 2019 05:45:21 GMT 响应头</p>
<p>Server: Apache&#x2F;2.2.11 (Win32) DAV&#x2F;2 mod_ssl&#x2F;2.2.11 OpenSSL&#x2F;0.9.8i PHP&#x2F;5.2.9 X-Powered-By: PHP&#x2F;5.2.9</p>
<p>Expires: Thu, 19 Nov 1981 08:52:00 GMT</p>
<p>Cache-Control: no-store, no-cache, must-revalidate, post-check&#x3D;0, pre-check&#x3D;0 Pragma: no-cache</p>
<p>Content-Length: 262</p>
<p>Keep-Alive: timeout&#x3D;5, max&#x3D;100 Connection: Keep-Alive</p>
<p>Content-Type: text&#x2F;html; charset&#x3D;utf-8</p>
<p>空行</p>
<p>{“status”:2,”info”:”\u672c\u7ad9\u9700\u7ed1\u5b9a\u7b2c\u4e09\u65b9\u6258\u7ba1\ u8d26\u6237\uff0c\u662f\u5426\u9a6c\u4e0a\u53bb\u7ed1\u5b9a”,”data”:null,”jump”:”</p>
<p>/fw/index.php”,”jump1”:”/fw/index.php?ctl&#x3D;collocation&amp;act&#x3D;CreateNewAcct&amp;user_</p>
<p>type&#x3D;0&amp;user_id&#x3D;33”}响应的具体内容</p>
</blockquote>
</li>
</ol>
</li>
<li><h3 id="常用的-http协议的状态码？"><a href="#常用的-http协议的状态码？" class="headerlink" title="常用的 http协议的状态码？"></a>常用的 http协议的状态码？</h3><ol>
<li><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<ol>
<li>1xx：指示信息–表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ol>
</li>
<li><p>200 OK服务器成功处理了请求（这个是我们见到最多的） </p>
<p> 301&#x2F;302 MovedPermanently（重定向）请求的URL已移走。Response中应该包含一个Location URL,说明资源现在所处的位置 </p>
<p> 304 Not Modified（未修改）客户的缓存资源是最新的，要客户端使用缓存</p>
<p> 404 Not Found未找到资源 </p>
<p> 401Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </p>
<p> 400 Bad Request客户端请求与语法错误，不能被服务器所理解 </p>
<p> 403Forbidden服务器收到请求，但是拒绝提供服务 </p>
<p> 500InternalServerError服务器发生了不可预期的错误 </p>
<p> 501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务 </p>
<p> 503 Server Unavailable服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
</li>
</ol>
</li>
<li><p><strong>http</strong>协议的请求方式，<strong>Get</strong>请求与 <strong>Post</strong>请求的区别？</p>
<ol>
<li><p>我们常用的请求方式一般是:get 请求，post 请求</p>
<ol>
<li>GET提交，请求的数据会附在<br> URL之后（就是把数据放置在 HTTP协议头中），以?分割 URL和传输数据，多个参数用&amp;连接；如果传输的数据是中文&#x2F;其他字符，一般则直接把字符串用 BASE64加密。</li>
</ol>
<p> POST 提交：把提交的数据放置在是 HTTP 包的包体中</p>
<p> 因此，GET 提交的数据会在地址栏中显示出来，而<br> POST 提交，地址栏不会改变</p>
<ol start="2">
<li>传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。</li>
</ol>
<p> 而在实际开发中存在的限制主要有：</p>
<p> GET:特定浏览器和服务器对 URL长度有限制，例如 IE对URL长度的限制是 2083字节(2K+35)。对于其他浏览器，如 Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系<br> 统的支持。</p>
<p> 因此对于 GET 提交时，传输数据就会受到 URL 长度的限制。</p>
<p> POST:由于不是通过URL 传值，理论上数据不受限。</p>
<ol start="3">
<li>POST的安全性要比 GET的安全性高。比如：通过 GET提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 GET<br> 提交数据还可能会造成Cross-siterequest<br> forgery攻击（数据篡改）</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="http协议与-https协议的区别"><a href="#http协议与-https协议的区别" class="headerlink" title="http协议与 https协议的区别"></a><strong>http</strong>协议与 <strong>https</strong>协议的区别</h3><ol>
<li><p>https 所用的端口号是 443 端口</p>
<p> http 所用的端口是 80 端口</p>
<p> HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用HTTP 协议传输隐私信息非常不安全， 为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p>
<p> https 通信的优点：</p>
<p> 1） 客户端产生的密钥只有客户端和服务器端能得到；</p>
<p> 2） 加密的数据只有客户端和服务器端才能得到明文；</p>
<p> 3） 客户端到服务端的通信是安全的。</p>
<p> 区别：</p>
<p> (1) https 协议需要ca 申请证书，并且大多数证书都是收费的。</p>
<p> (2) http 以明文的形式传输信息，https 则是具有安全性的ssl 加密传输协议。</p>
<p> (3) http 和https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80（有时是8080），后者是443。</p>
<p> (4) http 的连接简单，无状态；HTTPS 协议是在HTTP 协议的基础上，加上由SSL 层，构建的可进行加密传输、身份认证的网络协议，比http 协议安全。</p>
</li>
</ol>
</li>
<li><h4 id="tcp与udp的区别"><a href="#tcp与udp的区别" class="headerlink" title="tcp与udp的区别"></a>tcp与udp的区别</h4><ol>
<li><p>tcp是面向有链接的协议，提供可靠的报文传输和对上层应用的连接服务</p>
<p> udp是面向无链接的不可靠的传输协议，主要用于需要tcp的排序和流量 控制等功能的应用程序</p>
<p> tcp是一种可靠的传输协议，有请求有响应，规定接受端必须发回确认并且假如分组丢失，必须重新发送</p>
<p> udp则不具备这些，知识把数据包从客户端传输给服务端，至于服务端是否真实收到则不做判断</p>
</li>
</ol>
</li>
</ol>
<p>短连接：指socket连接后发送，接受完数据后马上断开（比如发短信）</p>
<pre><code>&lt;短连接：连接-数据传输-关闭连接（安全性比较高）&gt;
</code></pre>
<p>长连接：指socket连接后不管是否传输都保持连接，单安全性比较低（比如打电话，视频通信）</p>
<pre><code>&lt;长连接：连接-数据传输-保持连接-数据传输-关闭连接（安全性比较低）&gt;
</code></pre>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>locust</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/02_locust/</url>
    <content><![CDATA[<ol>
<li>locust特点<ol>
<li>开源</li>
<li>python语言</li>
<li>基于协程</li>
<li>高并发</li>
<li>性能自动化测试平台</li>
<li>requests</li>
</ol>
</li>
<li>进程与协程的区别<ol>
<li><img src="/assets/1/image-20211210201855-6ee3igb.png" alt="image.png"></li>
<li>对于操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元</li>
<li>协程，英文coroutines ，是一种比县城更加轻量级的存在<ol>
<li>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</li>
</ol>
</li>
</ol>
</li>
<li>协程的应用<ol>
<li>lua语言<ol>
<li>lua从5.0版本开始使用协程，通过扩展库coroutine来实现</li>
</ol>
</li>
<li>python语言<ol>
<li>正如刚才缩写的代码示例，python可以通过yield&#x2F;send 的方式实现协程，在python3.5以后，async&#x2F;await，可以更好的替代方案</li>
</ol>
</li>
<li>go语言<ol>
<li>go语言对协程的实现非常强大而简洁，可以轻松创建成百上千个协程并发执行</li>
</ol>
</li>
</ol>
</li>
<li>环境部署<ol>
<li>locust-windows<ol>
<li>((20211205191704-1smubww “安装python”))</li>
<li>((20211205191238-tb9h7p1 “安装pycharm”))（开发工具）</li>
</ol>
</li>
<li>locust-linux<ol>
<li>目前省略……</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>04_第四章性能测试</category>
        <category>905_性能测试文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>各项指标的计算方法</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_%E5%90%84%E9%A1%B9%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="响应时间：对请求作出响应所需要的时间"><a href="#响应时间：对请求作出响应所需要的时间" class="headerlink" title="响应时间：对请求作出响应所需要的时间"></a>响应时间：对请求作出响应所需要的时间</h4><pre><code>网络传输时间：N1+N2+N3+N4
应用服务器处理时间：A1+A3
数据库服务器处理时间：A2
响应时间=N1+N2+N3+N4+A1+A3+A2
</code></pre>
<h4 id="并发用户数的计算公式"><a href="#并发用户数的计算公式" class="headerlink" title="并发用户数的计算公式"></a>并发用户数的计算公式</h4><pre><code>系统用户数：系统额定的用户数量，如一个OA系统，可能使用该系统的用户总数是5000个，那么这个数量，就是系统用户数。
同时在线用户数：在一定的时间范围内，最大的同时在线用户数量。
同时在线用户数=每秒请求数RPS（吞吐量）+并发连接数+平均用户思考时间
平均并发用户数的计算：C=nL / T
其中C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session的平均时间），T是考察时间长度（一天内多长时间有用户使用系统）
并发用户数峰值计算：C^约等于C + 3*根号C
其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论。
</code></pre>
<h4 id="吞吐量的计算公式"><a href="#吞吐量的计算公式" class="headerlink" title="吞吐量的计算公式"></a>吞吐量的计算公式</h4><pre><code>指单位时间内系统处理用户的请求数
从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量
从网络角度看，吞吐量可以用：字节/秒来衡量
对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力
以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。
当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU * R /
其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间
</code></pre>
<h4 id="性能计数器"><a href="#性能计数器" class="headerlink" title="性能计数器"></a>性能计数器</h4><pre><code>是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。
资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用/总的资源可用量”形成资源利用率。
</code></pre>
<h4 id="思考时间的计算公式"><a href="#思考时间的计算公式" class="headerlink" title="思考时间的计算公式"></a>思考时间的计算公式</h4><pre><code>Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。
在吞吐量这个公式中F=VU * R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS
下面给出一个计算思考时间的一般步骤：
A、首先计算出系统的并发用户数
C=nL / T F=R×C
B、统计出系统平均的吞吐量
F=VU * R / T R×C = VU * R / T
C、统计出平均每个用户发出的请求数量
R=u*C*T/VU
D、根据公式计算出思考时间
TS=T/R
</code></pre>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>04_第四章性能测试</category>
        <category>905_性能测试文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>性能指标的标准1</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/905_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9A%84%E6%A0%87%E5%87%861/</url>
    <content><![CDATA[<p>对于性能测试,以上性能指标必须要有清楚的理解,自己总结如下:</p>
<ol>
<li>响应时间(RT)<br>　　是指系统对请求作出响应的时间。这个指标与人对软件性能的主观感受是一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。<br>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。<br>注意: 在性能测试中, 响应时间要做更细致划分<br><img src="/assets/1/image-20211209005950-u0io3qv.png" alt="image.png"></li>
<li>吞吐量(Throughput)<br>吞吐量是指系统在单位时间内处理完成的客户端请求的数量, 直接体现软件系统的性能承载能力。这是目前最常用的性能测试指标。对于服务器来讲,吞吐量越高越好.吞吐量是一个很宽泛的概念, 通常情况下，用“请求数&#x2F;秒”或者“页面数&#x2F;秒”来衡量。<br>体现:</li>
<li>业务角度: 业务数&#x2F;小时 或 访问人数&#x2F;天等</li>
<li>网络流量: 字节数&#x2F;小时 或 字节数&#x2F;天等</li>
<li>服务器性能处理能力(重点): TPS(每秒事务数) 和 QPS(每秒查询数):<br>对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。<br>对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。</li>
<li>TPS(Transactions Per Second,每秒事务数)<br> TPS是单位时间内处理事务的数量,从代码角度来说,一段代码或多段代码可以组成一个事务.单位时间内完成的事务数越多,服务器的性能越好<br><img src="/assets/1/image-20211209005958-jbk9wq2.png" alt="image.png"></li>
</ol>
<p>4.. QPS(Query Per Second,每秒查询数)<br>         QPS是单位时间内处理请求的数量,比TPS划分的更细致一些,因为一个事务可能会包含多个请求. 在一个事务当中, 假如只包含一个请求, 那么 QPS 就是指该请求过程中, 发起的数据查询总次数. 注意: 在 JMeter 当中, 把 TPS 和 QPS 简单的认为是同一个指标, 用来考察服务器性能好坏<br>TPS和QPS的区别?<br>TPS(transaction per second)是单位时间内处理事务的数量，QPS(query per second)是单位时间内请求的数量。TPS代表一个事务的处理，可以包含了多次请求。很多公司用QPS作为接口吞吐量的指标，也有很多公司使用TPS作为标准，两者都能表现出系统的吞吐量的大小，TPS的一次事务代表一次用户操作到服务器返回结果，QPS的一次请求代表一个接口的一次请求到服务器返回结果。当一次用户操作只包含一个请求接口时，TPS和QPS没有区别。当用户的一次操作包含了多个服务请求时，这个时候TPS作为这次用户操作的性能指标就更具有代表性了。<br>个人理解如下：<br>1、Tps即每秒处理事务数，包括了<br>1）用户请求服务器<br>2）服务器自己的内部处理<br>3）服务器返回给用户<br>这三个过程，每秒能够完成N个这三个过程，Tps也就是N；<br>2、Qps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。<br>例如：访问一个页面会请求服务器3次，一次访问，产生一个“T”，产生3个“Q”<br>5.并发数<br>         并发测试的用户数量, 指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。<br>         用户数概念划分:</p>
<ol>
<li>并发用户数: 同一时间内发送请求的用户数量(同一个请求&#x2F;非同一个请求)</li>
<li>在线用户数: 某段时间内在系统内的用户数量(不是所有在线用户都会发送请求)</li>
<li>系统用户数: 系统内注册的用户数量(存在一人拥有多个账号的情况)<br>结论: 系统用户数 &gt; 在线用户数 &gt; 并发用户数</li>
</ol>
<p>6.点击数HPS (每秒点击次数)<br>         是指发起请求时, 服务端对请求进行响应的页面资源对应的请求数量.<br>注意:</p>
<ol>
<li>日常操作中, 对页面的点击动作不是这里说的点击数</li>
<li>该指标只在 Web 项目中需要注意<br>例如,访问百度首页<br><img src="/assets/1/image-20211209010006-yv8nam9.png" alt="image.png"></li>
</ol>
<p>7.资源利用率<br>定义: 系统资源(CPU&#x2F;内存&#x2F;磁盘&#x2F;网络)使用占比(使用量&#x2F;总量*100%)<br>利用率指标:(没有特殊要求情况下)</p>
<ol>
<li>CPU 不超过 75%-85%</li>
<li>内存不超过 80%</li>
<li>硬盘不超过 90%(容量占有率&#x2F;读写时间比)</li>
</ol>
<p>8.错误率<br>定义: 错误率指系统在负载情况下，失败交易的概率。<br>错误率 ＝ (失败交易数&#x2F;交易总数)*100%<br>注意:</p>
<ol>
<li>大多系统都会要求无限接近于 100% 成功率, 因此, 错误率一般都非常低</li>
<li>相对稳定的系统产生的错误率又称超时率(由网络传输导致的)</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>04_第四章性能测试</category>
        <category>905_性能测试文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库其他连接工具</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/04_%E5%85%B6%E4%BB%96%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<pre><code>   工欲善其事，必先利其器。开发者在开发一个项目时，必定要选择一款合适的数据库，而数据库管理工具则可以帮助开发者轻松搞定很多难题。
   任何Web软件和应用程序都需要强大的数据库来做后盾，目前，网上有无数个数据库管理工具，而开发者选择一款适合自己的尤为重要。为大家介绍10款免费的数据库管理工具，开发者可以使用它们进行SQL操作、多链接、多数据库引擎操作等等。
</code></pre>
<ol>
<li>Open KeyVal<br> Open KeyVal是一款开源免费的键值数据库管理工具，基于Web，并且基于PHP开发，其目标是用最简单的方法来管理Web应用程序数据。用户只需发送一个POST请求就可以存储任何类型的数据，它是以JSON的格式来响应请求的。</li>
<li>DBV<br> DBV顾名思义，是数据库版本管理工具，基于PHP开发。用户在安装后，它可以自动跟踪记录，并且用户还可以把这些记录以SQL文件的形式导出。MySQL数据库默认情况下自动支持DBV，并且允许多用户连接。</li>
<li>DBeaver<br> DBeaver是一个通用的数据库管理工具和SQL客户端，支持MySQL、PostgreSQL、Oracle、DB2、MSSQL、Sybase、Mimer、HSQLDB、Derby以及其他兼容JDBC的数据库。基于Java开发。DBeaver提供一个图形界面用来查看数据库结构、执行SQL查询和脚本，浏览和导出数据，处理BLOB&#x2F;CLOB 数据，修改数据库结构等等。</li>
<li>DBNinja<br> DBNinja是一款基于Web的MySQL数据库管理工具，使用PHP开发，类似桌面应用的接口，可连接多个远程和本地的数据库。它支持所有的新功能包括：触发、事件、视图、存储程序和外键。</li>
<li>MyWebSQL<br> MyWebSql是一个基于Web的MySQL数据库管理客户端，支持多种语言。它除了操作表格数据外，MyWebSql 还可以对包括视图，存储过程，触发器和函数在内的对象进行控制。支持数据和查询结果的导入导出。MyWebSql还内置一个带语法着色功能的SQL编辑器。</li>
<li>Genghis<br> Genghis自称是单文件的MongoDB管理应用程序，它可以高效地管理多个数据库、甚至可以帮助用户收集、管理数据库和文档的服务器。</li>
<li>MyDB Studio<br> MyDB Studio是一个免费的MySQL数据库管理程序，它几乎拥有你所期望的所有功能特性。它可以同时连接没有数量限制的任意多的数据库。如果这些数据库位于防火墙后面或他们是本地数据库，该工具也提供SSH通道访问的支持来解决这些问题。</li>
<li>HeidiSQL<br> HeidiSQL是一款基于Windows的数据库管理软件，意味着它可以管理Microsoft SQL数据库和MySQL。它的功能非常强大，它可以浏览和编辑数据，创建和编辑表格、视图、存储过程、触发器和安排日程。另外，还可以导出结构和数据SQL文件。<br> 它是德国程序员Ansgar Becker和几个Delphi程序员开发的一个开源工具。要通过HeidiSQL来管理数据库，用户应该用有效地凭证登陆到MySQL服务器，创建一个会话。HeidiSQL最大的特色就是操作方便，界面设计合理，功能都是最实用的，尤其适合DBA，它更加强调了对MySQL运行时的参数设置和性能监控等。</li>
<li>SQLite Manager<br> SQLite Manager是开源的SQLite管理工具，用来管理本地电脑上的SQLite数据库，可以独立运行（以XULRunner方式），也可以作为Firefox、Thunderbird、Seamonkey、Songbird、Komodo、Gecko等的插件运行。</li>
<li>Sequel.js<br> Sequel.js是一个轻量级JavaScript库，使用它可以轻松进行SQL查询，它既可以在浏览器上运行，也可以在所有标准的SQL查询上运行。</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/05_%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<ol>
<li>索引底层原理<ol>
<li>语句：<ol>
<li><a href="../903_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/07_explain%E8%AF%A6%E8%A7%A3/">explain详解</a></li>
<li>explain +sql语句   查看读取数据的信息</li>
</ol>
</li>
<li>什么是索引<ol>
<li><a href="https://www.tutorialspoint.com/mysql/mysql-indexes.htm">MySQL - INDEXES (tutorialspoint.com)</a></li>
<li>A database index is a data structure that improves the speed of operations in a table</li>
</ol>
</li>
<li>怎么创建索引<ol>
<li>数据库管理工具-添加</li>
<li>命令行添加：create index index_name  on tablename;</li>
</ol>
</li>
<li>为什么需要索引<ol>
<li>能够改善数据库的性能瓶颈问题，体现在服务端的磁盘IO的消耗</li>
<li>减少存储引擎需要扫描的数据量</li>
<li>减少使用临时表的概率</li>
<li>将随机的IO转换成为顺序的IO</li>
</ol>
</li>
<li>索引的类型有哪些<ol>
<li>从存储结构上划分： BTree索引、Hash索引、全文索引、空间索引<ol>
<li>使用最多的为BTree索引</li>
</ol>
</li>
<li>从应用层次来划分： 普通索引（单列索引、多列索引）、唯一索引（具有唯一性，允许为空值）、复合索引（组合索引，多个列建立一个索引）</li>
<li>从表记录的排列顺序是否与索引的排列顺序是否一致：聚集索引、非聚集索引</li>
</ol>
</li>
<li>索引是怎么工作的<ol>
<li>内存、 <a href="../903_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/09_%E7%A3%81%E7%9B%98/">磁盘</a><ol>
<li>磁盘：硬盘、软盘– 保存数据信息的一个载体</li>
<li>读取磁盘IO 的时间：寻道时间（3-15ms，主流：5ms）+旋转延迟（1&#x2F;（7200&#x2F;60）&#x2F;2 &#x3D;4.17ms）+传输时间（0.n ms，忽略不计） &#x3D; 9ms</li>
<li>2.4GHZ:5亿条指令&#x2F;秒</li>
<li>解决磁盘IO消耗：<ol>
<li>系统自带的处理方式（按页读取-4kb，8kb，局部性原理）</li>
<li>降低了磁盘IO消耗的数量级：mysql存储引擎：innodb，  索引：B+Tree     eg： 传统查询无索引：逐条遍历<ol>
<li><img src="/assets/1/image-20211222164141-65arjxu.png" alt="image.png"></li>
</ol>
</li>
<li>B+tree  校验网址：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></li>
<li>查看表的索引情况<ol>
<li>show  index from  表名</li>
<li>其他： reset  query  cache<br><a href="../903_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/08_%E7%B4%A2%E5%BC%95%E6%96%87%E7%8C%AE/">索引文献</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>主键</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/06_%E4%B8%BB%E9%94%AE/</url>
    <content><![CDATA[<ul>
<li>数据的完整性<ul>
<li>数据的完整性指存储在数据库中的数据应该保持准确性和可靠性。</li>
<li>如出现学号相同的数据就是不准确的</li>
</ul>
</li>
<li>实体完整性<ul>
<li>实体完整性是对关系中的记录唯一性</li>
<li>定义表中的多有行能唯一的标识</li>
<li>表中主属性（字段）不能为Null且不能有相同值</li>
<li>一般用主键、唯一索引、unique关键字来实现</li>
<li>目的：在表中至少有一个唯一的标识，主属性字段中，不能为空，不能重复</li>
</ul>
</li>
<li>实体完整性–主键约束<ul>
<li>主键约束<ul>
<li>主关键字（primary key）是表中一个或者多个字段，它的值用于唯一地标识表中某一条记录</li>
<li>唯一，不重复，不能为空， primary key</li>
<li><ol>
<li>创建表的铜焊丝创建主键约束</li>
<li><img src="/assets/1/image-20220301110120-f1jylt6.png" alt="image.png"><br> a. CREATE  TABLE t_user（user_id INT（10） PRIMARY KEY）;<br> b. CREATE TABLE  t-user(user_id(user_id INT(10),user_name varchar(30),consttaint pk_id_name primary key(user_id,user_name));<br> c. CREATE TABLE t_user(user_id INT(10),PRIMARY KEY(USER_ID));</li>
<li>针对已存在的表，添加主键约束<ol>
<li>ALTER TABLE t_user MODIFY user_id INT(10) PRIMARY KEY;</li>
<li>ALTER TABLE t_user ADD  PRIMARY KEY(user_id);</li>
<li>ALTER TABLE t_user ADD  CONSTRAINT PK_ID PRIMARY KEY(user_id);</li>
</ol>
</li>
<li>删除主键约束<ol>
<li>ALTER TABLE t_user DROP PRIMARY KEY;</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>唯一约束</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>explain详解</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/07_explain%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p>
<pre><code>-- 实际SQL，查找用户名为Jefabc的员工
select * from emp where name = &#39;Jefabc&#39;;
-- 查看SQL是否使用索引，前面加上explain即可
explain select * from emp where name = &#39;Jefabc&#39;;
</code></pre>
<p><img src="https://images2018.cnblogs.com/blog/512541/201808/512541-20180803142201303-545775900.png"><br>expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra<br><strong>概要描述：</strong><br>id:选择标识符<br>select_type:表示查询的类型。<br>table:输出结果集的表<br>partitions:匹配的分区<br>type:表示表的连接类型<br>possible_keys:表示查询时，可能使用的索引<br>key:表示实际使用的索引<br>key_len:索引字段的长度<br>ref:列与索引的比较<br>rows:扫描出的行数(估算的行数)<br>filtered:按表条件过滤的行百分比<br>Extra:执行情况的描述和说明<br><strong>下面对这些字段出现的可能进行解释：</strong><br>一、 <strong>id</strong><br>SELECT识别符。这是SELECT的查询序列号<br><strong>我的理解是SQL执行的顺序的标识，SQL从大到小的执行</strong></p>
<ol>
<li>id相同时，执行顺序由上至下</li>
<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行<br>&#96;&#96;&#96;</li>
</ol>
<p>– 查看在研发部并且名字以Jef开头的员工，经典查询<br>explain select e.no, e.name from emp e left join dept d on e.dept_no &#x3D; d.no where e.name like ‘Jef%’ and d.name &#x3D; ‘研发部’;</p>
<pre><code>![](https://images2018.cnblogs.com/blog/512541/201808/512541-20180803143413064-173136748.png)
**二、select_type**
**      **示查询中每个select子句的类型****
(1) SIMPLE(简单SELECT，不使用UNION或子查询等)
(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
(3) UNION(UNION中的第二个或后面的SELECT语句)
(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)
(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)
(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)
(8) DERIVED(派生表的SELECT, FROM子句的子查询)
(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)
**三、table**
显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称
**四、type**
对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。
常用的类型有： ** ALL、index、range、 ref、eq_ref、const、system、** **NULL（从左到右，性能从差到好）**
ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
index: Full Index Scan，index与ALL区别为index类型只遍历索引树
range:只检索给定范围的行，使用一个索引来选择行
ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system
NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
**五、possible_keys**
**指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）**
该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。
如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询
**六、Key**
**key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中**
如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。
**七、key_len**
**表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）**
不损失精确性的情况下，长度越短越好** **
**八、ref**
**列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值**
**九、rows**
 **估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数**
**十、Extra**
**该列包含MySQL解决查询的详细信息,有以下几种情况：**
Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤
Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by
Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”
</code></pre>
<p>– 测试Extra的filesort<br>explain select * from emp order by name;</p>
<pre><code>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。
Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。
Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行
No tables used：Query语句中使用from dual 或不含任何from子句
</code></pre>
<p>– explain select now() from dual;</p>
<p>&#96;&#96;&#96;<br><strong>总结</strong>:<br><em>• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况<br>• EXPLAIN不考虑各种Cache<br>• EXPLAIN不能显示MySQL在执行查询时所作的优化工作<br>• 部分统计信息是估算的，并非精确值<br>• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</em><br>通过收集统计信息不可能存在结果</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>索引文献</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/08_%E7%B4%A2%E5%BC%95%E6%96%87%E7%8C%AE/</url>
    <content><![CDATA[<p><strong>一、引言</strong><br>对数据库索引的关注从未淡出我的们的讨论，那么数据库索引是什么样的？聚集索引与非聚集索引有什么不同？希望本文对各位同仁有一定的帮助。有不少存疑的地方，诚心希望各位不吝赐教指正，共同进步。[最近首页之争沸沸扬扬，也不知道这个放在这合适么，苦劳？功劳？……]<br> <strong>二、</strong> <strong>B-Tree</strong><br>我们常见的数据库系统，其索引使用的数据结构多是B-Tree或者B+Tree。例如，MsSql使用的是B+Tree，Oracle及Sysbase使用的是B-Tree。所以在最开始，简单地介绍一下B-Tree。<br>B-Tree不同于Binary Tree（二叉树，最多有两个子树），一棵M阶的B-Tree满足以下条件：<br>1）每个结点至多有M个孩子；<br>2）除根结点和叶结点外，其它每个结点至少有M&#x2F;2个孩子；<br>3）根结点至少有两个孩子（除非该树仅包含一个结点）；<br>4）所有叶结点在同一层，叶结点不包含任何关键字信息；<br>5）有K个关键字的非叶结点恰好包含K+1个孩子；<br>另外，对于一个结点，其内部的关键字是从小到大排序的。以下是B-Tree（M&#x3D;4）的样例：<br> <img src="/assets/1/wpsC22B.tmp-20211222153838-2v6kwd8.jpg"><br>对于每个结点，主要包含一个关键字数组Key[]，一个指针数组（指向儿子）Son[]。在B-Tree内，查找的流程是：使用顺序查找（数组长度较短时）或折半查找方法查找Key[]数组，若找到关键字K，则返回该结点的地址及K在Key[]中的位置；否则，可确定K在某个Key[i]和Key[i+1]之间，则从Son[i]所指的子结点继续查找，直到在某结点中查找成功；或直至找到叶结点且叶结点中的查找仍不成功时，查找过程失败。<br>接着，我们使用以下图片演示如何生成B-Tree（M&#x3D;4，依次插入1~6）：<br>从图可见，当我们插入关键字4时，由于原结点已经满了，故进行分裂，基本按一半的原则进行分裂，然后取出中间的关键字2，升级（这里是成为根结点）。其它的依类推，就是这样一个大概的过程。<br> <img src="/assets/1/wpsC22C.tmp-20211222153838-ib1g6d3.jpg"><br><strong>三、数据库索引</strong><br> <strong>1</strong> <strong>．什么是索引</strong><br>在数据库中，索引的含义与日常意义上的“索引”一词并无多大区别（想想小时候查字典），它是用于提高数据库表数据访问速度的数据库对象。<br>A）索引可以避免全表扫描。多数查询可以仅扫描少量索引页及数据页，而不是遍历所有数据页。<br>B）对于非聚集索引，有些查询甚至可以不访问数据页。<br>C）聚集索引可以避免数据插入操作集中于表的最后一个数据页。<br>D）一些情况下，索引还可用于避免排序操作。<br>当然，众所周知，虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要同时更新索引。<br> <strong>2.</strong> <strong>索引的存储</strong><br>一条索引记录中包含的基本信息包括：键值（即你定义索引时指定的所有字段的值）+逻辑指针（指向数据页或者另一索引页）。<br> <img src="/assets/1/wpsC22D.tmp-20211222153838-d0fj2jo.jpg"><br>当你为一张空表创建索引时，数据库系统将为你分配一个索引页，该索引页在你插入数据前一直是空的。此页此时既是根结点，也是叶结点。每当你往表中插入一行数据，数据库系统即向此根结点中插入一行索引记录。当根结点满时，数据库系统大抵按以下步骤进行分裂：<br>A）创建两个儿子结点<br>B）将原根结点中的数据近似地拆成两半，分别写入新的两个儿子结点<br>C）根结点中加上指向两个儿子结点的指针<br>通常状况下，由于索引记录仅包含索引字段值（以及4-9字节的指针），索引实体比真实的数据行要小许多，索引页相较数据页来说要密集许多。一个索引页可以存储数量更多的索引记录，这意味着在索引中查找时在I&#x2F;O上占很大的优势，理解这一点有助于从本质上了解使用索引的优势。<br> <strong>3</strong> <strong>．索引的类型</strong><br>A）聚集索引，表数据按照索引的顺序来存储的。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。<br>B）非聚集索引，表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致。<br>在一张表上只能创建一个聚集索引，因为真实数据的物理顺序只可能是一种。如果一张表没有聚集索引，那么它被称为“堆集”（Heap）。这样的表中的数据行没有特定的顺序，所有的新行将被添加的表的末尾位置。<br> <strong>4</strong> <strong>．聚集索引</strong><br>在聚集索引中，叶结点也即数据结点，所有数据行的存储顺序与索引的存储顺序一致。<br> <img src="/assets/1/wpsC22E.tmp-20211222153838-ulh98xw.jpg"><br>1）聚集索引与查询操作<br>如上图，我们在名字字段上建立聚集索引，当需要在根据此字段查找特定的记录时，数据库系统会根据特定的系统表查找的此索引的根，然后根据指针查找下一个，直到找到。例如我们要查询“Green”，由于它介于[Bennet,Karsen]，据此我们找到了索引页1007，在该页中“Green”介于[Greane, Hunter]间，据此我们找到叶结点1133（也即数据结点），并最终在此页中找以了目标数据行。<br>此次查询的IO包括3个索引页的查询（其中最后一次实际上是在数据页中查询）。这里的查找可能是从磁盘读取(Physical Read)或是从缓存中读取(Logical Read)，如果此表访问频率较高，那么索引树中较高层的索引很可能在缓存中被找到。所以真正的IO可能小于上面的情况。<br>2）聚集索引与插入操作<br>最简单的情况下，插入操作根据索引找到对应的数据页，然后通过挪动已有的记录为新数据腾出空间，最后插入数据。<br>如果数据页已满，则需要拆分数据页（页拆分是一种耗费资源的操作，一般数据库系统中会有相应的机制要尽量减少页拆分的次数，通常是通过为每页预留空间来实现）：<br>A）在该使用的数据段（extent）上分配新的数据页，如果数据段已满，则需要分配新段。<br>B）调整索引指针，这需要将相应的索引页读入内存并加锁。<br>C）大约有一半的数据行被归入新的数据页中。<br>D）如果表还有非聚集索引，则需要更新这些索引指向新的数据页。<br>特殊情况：<br>A）如果新插入的一条记录包含很大的数据，可能会分配两个新数据页，其中之一用来存储新记录，另一存储从原页中拆分出来的数据。<br>B）通常数据库系统中会将重复的数据记录存储于相同的页中。<br>C）类似于自增列为聚集索引的，数据库系统可能并不拆分数据页，页只是简单的新添数据页。<br>3）聚集索引与删除操作<br>删除行将导致其下方的数据行向上移动以填充删除记录造成的空白。<br>如果删除的行是该数据页中的最后一行，那么该数据页将被回收，相应的索引页中的记录将被删除。如果回收的数据页位于跟该表的其它数据页相同的段上，那么它可能在随后的时间内被利用。如果该数据页是该段的唯一一个数据页，则该段也被回收。<br>对于数据的删除操作，可能导致索引页中仅有一条记录，这时，该记录可能会被移至邻近的索引页中，原索引页将被回收，即所谓的“索引合并”。<br> <strong>5</strong> <strong>．非聚集索引</strong><br>非聚集索引与聚集索引相比：<br>A）叶子结点并非数据结点<br>B）叶子结点为每一真正的数据行存储一个“键-指针”对<br>C）叶子结点中还存储了一个指针偏移量，根据页指针及指针偏移量可以定位到具体的数据行。<br>D）类似的，在除叶结点外的其它索引结点，存储的也是类似的内容，只不过它是指向下一级的索引页的。<br>聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。<br>对于根与中间级的索引记录，它的结构包括：<br>A）索引字段值<br>B）RowId（即对应数据页的页指针+指针偏移量）。在高层的索引页中包含RowId是为了当索引允许重复值时，当更改数据时精确定位数据行。<br>C）下一级索引页的指针<br>对于叶子层的索引对象，它的结构包括：<br>A）索引字段值<br>B）RowId<br> <img src="/assets/1/wpsC23F.tmp-20211222153838-ccyibjj.jpg"><br>1）非聚集索引与查询操作<br>针对上图，如果我们同样查找“Green”，那么一次查询操作将包含以下IO：3个索引页的读取+1个数据页的读取。同样，由于缓存的关系，真实的IO实际可能要小于上面列出的。<br>2）非聚集索引与插入操作<br>如果一张表包含一个非聚集索引但没有聚集索引，则新的数据将被插入到最末一个数据页中，然后非聚集索引将被更新。如果也包含聚集索引，该聚集索引将被用于查找新行将要处于什么位置，随后，聚集索引、以及非聚集索引将被更新。<br>3）非聚集索引与删除操作<br>如果在删除命令的Where子句中包含的列上，建有非聚集索引，那么该非聚集索引将被用于查找数据行的位置，数据删除之后，位于索引叶子上的对应记录也将被删除。如果该表上有其它非聚集索引，则它们叶子结点上的相应数据也要删除。<br>如果删除的数据是该数所页中的唯一一条，则该页也被回收，同时需要更新各个索引树上的指针。<br>由于没有自动的合并功能，如果应用程序中有频繁的随机删除操作，最后可能导致表包含多个数据页，但每个页中只有少量数据。<br> <strong>6</strong> <strong>．索引覆盖</strong><br>索引覆盖是这样一种索引策略：当某一查询中包含的所需字段皆包含于一个索引中，此时索引将大大提高查询性能。<br>包含多个字段的索引，称为复合索引。索引最多可以包含31个字段，索引记录最大长度为600B。如果你在若干个字段上创建了一个复合的非聚集索引，且你的查询中所需Select字段及Where,Order By,Group By,Having子句中所涉及的字段都包含在索引中，则只搜索索引页即可满足查询，而不需要访问数据页。由于非聚集索引的叶结点包含所有数据行中的索引列值，使用这些结点即可返回真正的数据，这种情况称之为“索引覆盖”。<br>在索引覆盖的情况下，包含两种索引扫描：<br>A）匹配索引扫描<br>B）非匹配索引扫描<br>1）匹配索引扫描<br>此类索引扫描可以让我们省去访问数据页的步骤，当查询仅返回一行数据时，性能提高是有限的，但在范围查询的情况下，性能提高将随结果集数量的增长而增长。<br>针对此类扫描，索引必须包含查询中涉及的的所有字段，另外，还需要满足：Where子句中包含索引中的“引导列”（Leading Column），例如一个复合索引包含A,B,C,D四列，则A为“引导列”。如果Where子句中所包含列是BCD或者BD等情况，则只能使用非匹配索引扫描。<br>2）非配置索引扫描<br>正如上述，如果Where子句中不包含索引的导引列，那么将使用非配置索引扫描。这最终导致扫描索引树上的所有叶子结点，当然，它的性能通常仍强于扫描所有的数据页。<br> <strong>[</strong>  <strong>参考</strong> <strong>]</strong><br>[1]<a href="http://manuals.sybase.com/onlinebooks/group-asarc/asg1200e/aseperf/@Generic__BookTextView/3358">http:&#x2F;&#x2F;manuals.sybase.com&#x2F;onlinebooks&#x2F;group-asarc&#x2F;asg1200e&#x2F;aseperf&#x2F;@Generic__BookTextView&#x2F;3358</a><br>[2] <a href="http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.adref.doc/adref235.htm">http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.adref.doc/adref235.htm</a></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/09_%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<ol>
<li>硬盘基础知识<ol>
<li><img src="/assets/1/image-20211214105741-2bd570s.png" alt="image.png"><img src="/assets/1/image-20211214110050-dyzj8it.png" alt="image.png"><img src="/assets/1/image-20211214110131-aoec4ll.png" alt="image.png"><img src="/assets/1/image-20211214110109-jox8ouv.png" alt="image.png"></li>
<li>磁盘读响应时间<ol>
<li><img src="/assets/1/image-20211214110347-bnejtrz.png" alt="image.png"></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>网络技术</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/01_%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>网络技术（TCP&#x2F;UDP）</p>
<p>原理图</p>
<p><img src="/assets/1/image-20211120110955-m8jreyh.png" alt="image.png"></p>
<pre><code>课程目标
    osi 七层模型以及数据传输过程
    网络层协议重点协议--ARP，IP，路由协议
    传输层重点协议--TCP,UDP
    应用层重点协议--HTTP
    应用层重点协议--HTTPS
    抓包工具wireshark的使用  ：((20211120111353-joikthh &quot;安装&quot;))

        前期是为了实现两台机器互联，规范--同意标准实现通信
    ![image.png](assets/1/image-20211120112125-q8unjrt.png)
</code></pre>
<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><h2 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h2><p>通过定义各种应用协议规范数据格式：http协议，https协议，ftp协议，dns协议，smtp协议等等<br /></p>
<h2 id="表示层："><a href="#表示层：" class="headerlink" title="表示层："></a>表示层：</h2><p>翻译工作，提供一种公共语言，通信<br /></p>
<h2 id="会话层："><a href="#会话层：" class="headerlink" title="会话层："></a>会话层：</h2><p>1.可以从校验点继续恢复数据进行重传。2.自动收发包，自动寻址的功能	网络中大文件数据传输，相当于续传</p>
<h2 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h2><p>1.对发送数据进行封装，—TCP,UDP协议，一个一个按顺序依次发送2.两个应用程序（QQ–QQ0），定义端口的概念，寻找到对应程序，进行数据处理</p>
<h2 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h2><p>1.怎么知道对方的MAC地址—-ARP (ADDRESS RESOLUTION PROTOCOL),通过IP地址知晓MAC;–包<br>2.判断是否在同一个子网，—-IP协议</p>
<p>3.怎么选择最优路径 —- 一组协议 路由协议 静态路由 动态路由 （RIP,OSPF,BGP）。</p>
<h2 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h2><p>1.比特流进行处理：分组。8位一组–一个字节，依次按顺序发送数据—帧2.MAC地址。–网卡-身份证（唯一性）。寄件人地址+收件人地址</p>
<h2 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h2><p>互联物理链路，物理介质。网线（双绞线），光纤，无线电波–可实现基本连接<br>存在形式：计算机语言（010010101110001）二进制，–电信号–在网络中叫比特流</p>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>1.实现两台机器互联，及其与机器之间通信–物理层<br>2.0101010比特流其实是没有什么意义的数据，变成有意义的数据–数据链路层<br>3.主机A-B，C,D,E-主机F    – 路径有很多条，怎么选择最优路径，要怎么知道反对方的MAC地址–网络层<br>4.发送数据特别多，数据包很大，需要长时间，中间网络中断，重传？？ —传输层<br>5.断点续传功能—会话层实现<br>6.操作系统，windows10，macos，linux，语法是不一样的，不同的系统之间进行通信–表示层<br>7.字节流的格式，不好识别，不好操作，浏览器操作–应用层操作</p>
<p>TCP&#x2F;IP四层模型    VS    ISO七层模型<br>        <img src="/assets/1/image-20211120112647-ybjw1zn.png" alt="image.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code>数据传输过程
</code></pre>
<p><img src="/assets/1/image-20211120112150-l4p7m20.png" alt="image.png"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/03_%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<ul>
<li><p>ARP协议</p>
<ul>
<li><p>ARP–定义</p>
<ul>
<li>ARP–地址解析协议（Address Resolution Protocol），实现通过对方IP地址（域名）寻找对方的MAC地址– ARP的功能</li>
</ul>
</li>
<li><p>例</p>
<ul>
<li><img src="/assets/1/image-20211120113425-tvawmj4.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211120113433-gnbk314.png" alt="image.png"></li>
</ul>
</li>
<li><p>ARP协议的工作流程</p>
<ul>
<li>1.主机A首先查看自己的ARP表，如果找到了的主机B的MAC地址，则直接对IP数据包进行帧封装，发送给主机B</li>
<li>2.如果主机A在ARP表中找不到主机B的MAC地址，则将缓存改数据报文，然后以广播的方式发送一个ARP请求报文，ARP请求报文中带上源IP地址和MAC地址（主机A），目标IP地址和目标MAC地址为主机B的IP和全0的MAC地址。广播，该网段上的所有主机都可以接受到该请求，但只有被请求的主机（即主机B）会对该请求进行处理</li>
<li>3.主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中，之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MA地址。</li>
<li>4.主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li><p>电脑打开cmd</p>
<ul>
<li>arp-a        查看表中连接信息</li>
<li>arp -d *    删除ARP缓存列表的命令</li>
</ul>
</li>
<li><p>抓包</p>
<ul>
<li><p>wireshark    选中对应的网卡，点击开始抓包</p>
<ul>
<li><img src="/assets/1/image-20211120113803-tfdrmv8.png" alt="image.png"></li>
<li>fram 物理层<br>Ethernet II 数据链路层<br>address resolution protocol</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>IP协议</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>IP（Internet Protocol），分配给用户上网使用国际协议的设备的数字标签，分为两大类：IPV4 和IPV6</p>
</li>
<li><p>分别</p>
<ul>
<li><p>IPV4</p>
<ul>
<li>32位，<br>二进制:11000000.10101000.00000001.00000001，<br>十进制：192.168.1.1</li>
</ul>
</li>
<li><p>IPV6</p>
<ul>
<li>目的为了弥补IPV4地址池不够的缺陷–IPV4 数量有限<br>128位–有更多的IP地址<br>16进制:2001:ffdd:asdf:asde</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>IP地址的组成</p>
<ul>
<li>IP地址由32bit组成，分为4段并用，使用“.”分隔：192.168.1.1</li>
<li><img src="/assets/1/image-20211120114039-rhuojhj.png" alt="image.png"></li>
</ul>
</li>
<li><p>子网掩码</p>
<ul>
<li><p>前置</p>
<ul>
<li>IP 没有办法进行判断，不能确定子网掩码</li>
<li>子网掩码表示子网</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>用来标识子网，必须跟IP地址一起存在</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li>子网掩码跟IP地址一样，也是由连续的1和0组成，连续的1表示网络地址，连续的0表示主机地址，只有网络地址相同的主机在同一子网，才能直接通信</li>
</ul>
</li>
<li><p>表示方法</p>
<ul>
<li>255.255.255.0，或者&#x2F;24.</li>
<li>二进制   11111111.11111111.11111111.00000000</li>
</ul>
</li>
</ul>
</li>
<li><p>案例</p>
<ul>
<li><img src="/assets/1/image-20211120114205-k6z43al.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>路由协议</p>
<ul>
<li><p>前置   不在一个子网，怎么通信？–路由协议完成</p>
</li>
<li><p>定义</p>
<ul>
<li><p>路由协议（Routing protocol），指定数据包转送方式的网上协议</p>
</li>
<li><p>分类</p>
<ul>
<li><p>静态路由协议</p>
<ul>
<li>指定目的地址—指定下一跳<br>默认路由（0.0.0.0.0.0.0.0-匹配所有）（主机–默认网关–做详细的路由选择）</li>
</ul>
</li>
<li><p>动态路由协议（RIP（V1 V2）,OSPF,BGP）</p>
<ul>
<li>动态路由协议，配置之后，动态学习路由条目–路由表</li>
</ul>
</li>
</ul>
</li>
<li><p>cmd命令</p>
<ul>
<li>route print   打开路由表</li>
<li>网络目标   目的地址</li>
<li>网络掩码</li>
<li>网关     下一跳</li>
<li>接口</li>
<li>跃点数      路由的优先级   跳跃数越小优先级越高</li>
<li><img src="/assets/1/image-20211122191712-ani9owc.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark介绍</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/02_wireshark%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>wireshark的官方下载网站： <a href="http://www.wireshark.org/">http://www.wireshark.org/</a></p>
<p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。</p>
<p>wireshark是开源软件，可以放心使用。 可以运行在Windows和Mac OS上。</p>
<p>使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。</p>
<h1 id="Wireshark不能做的"><a href="#Wireshark不能做的" class="headerlink" title="Wireshark不能做的"></a><strong>Wireshark不能做的</strong></h1><p>为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p>
<h1 id="Wireshark-VS-Fiddler"><a href="#Wireshark-VS-Fiddler" class="headerlink" title="Wireshark VS Fiddler"></a><strong>Wireshark VS Fiddler</strong></h1><p>Fiddler是在windows上运行的程序，专门用来捕获HTTP，HTTPS的。</p>
<p>wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容</p>
<p>总结，如果是处理HTTP,HTTPS 还是用Fiddler,  其他协议比如TCP,UDP 就用wireshark</p>
<h1 id="同类的其他工具"><a href="#同类的其他工具" class="headerlink" title="同类的其他工具"></a><strong>同类的其他工具</strong></h1><p>微软的network monitor</p>
<p>sniffer</p>
<h1 id="什么人会用到wireshark"><a href="#什么人会用到wireshark" class="headerlink" title="什么人会用到wireshark"></a><strong>什么人会用到wireshark</strong></h1><ol>
<li>网络管理员会使用wireshark来检查网络问题</li>
<li>软件测试工程师使用wireshark抓包，来分析自己测试的软件</li>
<li>从事socket编程的工程师会用wireshark来调试</li>
<li>听说，华为，中兴的大部分工程师都会用到wireshark。</li>
</ol>
<p>总之跟网络相关的东西，都可能会用到wireshark.</p>
<h1 id="wireshark-开始抓包"><a href="#wireshark-开始抓包" class="headerlink" title="wireshark 开始抓包"></a><strong>wireshark 开始抓包</strong></h1><p>开始界面</p>
<p><img src="/assets/1/wps223.tmp-20211222150251-4msi772.jpg"></p>
<p>wireshark是捕获机器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要选择一个网卡。</p>
<p>点击Caputre-&gt;Interfaces.. 出现下面对话框，选择正确的网卡。然后点击”Start”按钮, 开始抓包</p>
<p><img src="/assets/1/wps224.tmp-20211222150251-8mp50nu.jpg"></p>
<h1 id="Wireshark-窗口介绍"><a href="#Wireshark-窗口介绍" class="headerlink" title="Wireshark 窗口介绍"></a><strong>Wireshark 窗口介绍</strong></h1><p><img src="/assets/1/wps225.tmp-20211222150251-8ptmq5c.jpg"></p>
<p>WireShark 主要分为这几个界面</p>
<ol>
<li>Display Filter(显示过滤器)，  用于过滤</li>
<li>Packet List Pane(封包列表)， 显示捕获到的封包， 有源地址和目标地址，端口号。 颜色不同，代表</li>
<li>Packet Details Pane(封包详细信息), 显示封包中的字段</li>
<li>Dissector Pane(16进制数据)</li>
<li>Miscellanous(地址栏，杂项)</li>
</ol>
<h1 id="Wireshark-显示过滤"><a href="#Wireshark-显示过滤" class="headerlink" title="Wireshark 显示过滤"></a><strong>Wireshark 显示过滤</strong></h1><p><img src="/assets/1/wps226.tmp-20211222150251-ih9fas3.jpg"></p>
<p>使用过滤是非常重要的， 初学者使用wireshark时，将会得到大量的冗余信息，在几千甚至几万条记录中，以至于很难找到自己需要的部分。搞得晕头转向。</p>
<p>过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。</p>
<p>过滤器有两种，</p>
<p>一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录</p>
<p>一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。 在Capture -&gt; Capture Filters 中设置</p>
<h1 id="保存过滤"><a href="#保存过滤" class="headerlink" title="保存过滤"></a><strong>保存过滤</strong></h1><p>在Filter栏上，填好Filter的表达式后，点击Save按钮， 取个名字。比如”Filter 102”,</p>
<p><img src="/assets/1/wps227.tmp-20211222150251-vuhqcm5.jpg"></p>
<p>Filter栏上就多了个”Filter 102” 的按钮。</p>
<p><img src="/assets/1/wps228.tmp-20211222150251-vqp495b.jpg"></p>
<h1 id="过滤表达式的规则"><a href="#过滤表达式的规则" class="headerlink" title="过滤表达式的规则"></a><strong>过滤表达式的规则</strong></h1><p>表达式规则</p>
<ol>
<li>协议过滤</li>
</ol>
<p>比如TCP，只显示TCP协议。</p>
<ol start="2">
<li>IP 过滤</li>
</ol>
<p>比如 ip.src &#x3D;&#x3D;192.168.1.102 显示源地址为192.168.1.102，</p>
<p>ip.dst&#x3D;&#x3D;192.168.1.102, 目标地址为192.168.1.102</p>
<ol start="3">
<li>端口过滤</li>
</ol>
<p>tcp.port &#x3D;&#x3D;80,  端口为80的</p>
<p>tcp.srcport &#x3D;&#x3D; 80,  只显示TCP协议的愿端口为80的。</p>
<ol start="4">
<li>Http模式过滤</li>
</ol>
<p>http.request.method&#x3D;&#x3D;”GET”,   只显示HTTP GET方法的。</p>
<ol start="5">
<li>逻辑运算符为 AND&#x2F; OR</li>
</ol>
<p>常用的过滤表达式</p>
<table>
<thead>
<tr>
<th>过滤表达式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>http</td>
<td>只查看HTTP协议的记录</td>
</tr>
<tr>
<td>ip.src &#x3D;&#x3D;192.168.1.102 or ip.dst&#x3D;&#x3D;192.168.1.102</td>
<td>源地址或者目标地址是192.168.1.102</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="封包列表-Packet-List-Pane"><a href="#封包列表-Packet-List-Pane" class="headerlink" title="封包列表(Packet List Pane)"></a><strong>封包列表(Packet List Pane)</strong></h1><p>封包列表的面板中显示，编号，时间戳，源地址，目标地址，协议，长度，以及封包信息。 你可以看到不同的协议用了不同的颜色显示。</p>
<p>你也可以修改这些显示颜色的规则，  View -&gt;Coloring Rules.</p>
<p><img src="/assets/1/wps229.tmp-20211222150251-4lpd7s0.jpg"></p>
<h1 id="封包详细信息-Packet-Details-Pane"><a href="#封包详细信息-Packet-Details-Pane" class="headerlink" title="封包详细信息 (Packet Details Pane)"></a><strong>封包详细信息 (Packet Details Pane)</strong></h1><p>这个面板是我们最重要的，用来查看协议中的每一个字段。</p>
<p>各行信息分别为</p>
<p>Frame:   物理层的数据帧概况</p>
<p>Ethernet II: 数据链路层以太网帧头部信息</p>
<p>Internet Protocol Version 4: 互联网层IP包头部信息</p>
<p>Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP</p>
<p>Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议</p>
<h1 id="wireshark与对应的OSI七层模型"><a href="#wireshark与对应的OSI七层模型" class="headerlink" title="wireshark与对应的OSI七层模型"></a><strong>wireshark与对应的OSI七层模型</strong></h1><p><img src="/assets/1/wps22A.tmp-20211222150252-f5a714s.jpg"></p>
<h1 id="TCP包的具体内容"><a href="#TCP包的具体内容" class="headerlink" title="TCP包的具体内容"></a><strong>TCP包的具体内容</strong></h1><p> 从下图可以看到wireshark捕获到的TCP包中的每个字段。</p>
<p><img src="/assets/1/wps22B.tmp-20211222150252-ful58qc.jpg"></p>
<h1 id="实例分析TCP三次握手过程"><a href="#实例分析TCP三次握手过程" class="headerlink" title="实例分析TCP三次握手过程"></a><strong>实例分析TCP三次握手过程</strong></h1><p>看到这， 基本上对wireshak有了初步了解， 现在我们看一个TCP三次握手的实例</p>
<p> 三次握手过程为</p>
<p><img src="/assets/1/wps22C.tmp-20211222150252-2d6j1q0.jpg"></p>
<p>这图我都看过很多遍了， 这次我们用wireshark实际分析下三次握手的过程。</p>
<p>打开wireshark, 打开浏览器输入 <a href="http://www.cnblogs.com/tankxiao">http://www.cnblogs.com/tankxiao</a></p>
<p>在wireshark中输入http过滤， 然后选中GET &#x2F;tankxiao HTTP&#x2F;1.1的那条记录，右键然后点击”Follow TCP Stream”,</p>
<p>这样做的目的是为了得到与浏览器打开网站相关的数据包，将得到如下图</p>
<p><img src="/assets/1/wps22D.tmp-20211222150252-oq4qbxm.jpg"></p>
<p>图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。</p>
<p>第一次握手数据包</p>
<p>客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图</p>
<p><img src="/assets/1/wps22E.tmp-20211222150252-ozixvlj.jpg"></p>
<p>第二次握手的数据包</p>
<p>服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1&#x3D;1, 如下图</p>
<p><img src="/assets/1/wps22F.tmp-20211222150252-6x3zq2e.jpg"></p>
<p>第三次握手的数据包</p>
<p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图:</p>
<p><img src="/assets/1/wps230.tmp-20211222150252-1xrltr9.jpg"></p>
<p> 就这样通过了TCP三次握手，建立了连接</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/04_%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<ul>
<li><p>TCP协议</p>
<ul>
<li><p>定义</p>
<ul>
<li>TCP（Transmission Control Protocol），传输控制协议，顾名思义，就是要对数据的传输进行一定的控制</li>
</ul>
</li>
<li><p>TCP协议头部组成部分</p>
<ul>
<li><p><img src="/assets/1/image-20211120135744-9acv70f.png" alt="image.png"></p>
</li>
<li><p>序号</p>
<ul>
<li>sequence number</li>
<li>编号：TCP数据包过大，需分段（10段）—（到达目的主机）按照顺序重组，</li>
</ul>
</li>
<li><p>确认号</p>
<ul>
<li><p>acknowledge number</p>
</li>
<li><p>服务器能否回应？—存在于确认消息里</p>
</li>
<li><p>跟序号有什么关系</p>
<ul>
<li>依据序号生成   序号+1    表示服务器期望收到你的下一个包的序号</li>
</ul>
</li>
</ul>
</li>
<li><p>状态控制码（code control flag）1 or 0（1表示打开，0表示关闭（表示数据包的类型））</p>
</li>
</ul>
</li>
<li><p>备注</p>
<ul>
<li>实现原理过程：HTTP,HTTPS协议—-基于TCP协议；client —百度服务器：TCP协议–交互和连接 —HTTP,HTTPS协议交互</li>
</ul>
</li>
<li><p>TCP协议连接</p>
<ul>
<li><p>TCP连接请求：TCP三次握手过程（新建连接），TCP四次挥手（断开连接）</p>
</li>
<li><p>TCP三次握手</p>
<ul>
<li><p><img src="/assets/1/image-20211120135957-moi5rq0.png" alt="image.png"></p>
</li>
<li><p>例</p>
<ul>
<li><img src="/assets/1/image-20211120140009-m2lc65n.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>TCP四次挥手</p>
<ul>
<li><p><img src="/assets/1/image-20211120140016-u5m759r.png" alt="image.png"></p>
</li>
<li><p>例</p>
<ul>
<li><img src="/assets/1/image-20211120140027-yydd5yd.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>抓包</p>
<ul>
<li>wireshark</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UDP协议</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>UDP（User Datageam Protocol）用户数据报协议</p>
</li>
<li><p><img src="/assets/1/image-20211120140103-wikw2g0.png" alt="image.png"></p>
</li>
<li><p>没有 序号，确认号（重传）标志 等</p>
</li>
<li><p>UDP协议不会建立连接–无连接传输协议-不可靠的协议，容易丢包</p>
</li>
<li><p>UDP场景</p>
<ul>
<li><p>1。不需要可靠机制，只要求速度快—UDP协议</p>
</li>
<li><p>2.流媒体，多媒体游戏，IP电话     </p>
<ul>
<li>UDP协议封装</li>
</ul>
</li>
<li><p>3.资源消耗特别小</p>
</li>
</ul>
</li>
<li><p>UDP应用协议</p>
<ul>
<li>DNS(域名解析协议),SNMP(简单网络管理协议)，DHCP(动态获取IP),RIP  –UDP协议</li>
</ul>
</li>
<li><p>TCP应用协议</p>
<ul>
<li>HTTP,HTTPS,FTP</li>
</ul>
</li>
<li><p>实操</p>
<ul>
<li><p>结合cmd+wireshark</p>
<ul>
<li>cmd：ping <a href="http://www.baidu,com/">www.baidu,com</a></li>
<li>wireshark: 抓取dns（UDP）包</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/assets/1/image-20211122192010-wrkiio4.png" alt="image.png"></p>
<ol>
<li>tcp是面向连接的，所有tcp三次握手和四次挥手的过程 —-|||—-udp无连接协议</li>
<li>tcp因为有可靠的连接机制&#x3D;&#x3D;&#x3D;可靠协议—-|||—-udp没有连接和确认机制&#x3D;&#x3D;会丢包会出错 不可靠的协议</li>
<li>tcp协议：数据量很大，防止丢包正确重传对数据的正确性很关心—-|||—-udp量小</li>
<li>速度：tcp协议速度很慢—-|||—-udp速度很快，传输效率很高</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/05_%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<ul>
<li><p>HTTP</p>
<ul>
<li><p>HTTP定义</p>
<ul>
<li>HTTP协议  （Hyper Text Transfer Protocol） 超文本传输协议</li>
<li>HTTP协议是基于TCP协议，默认是80端口—可靠的协议</li>
<li>功能：用来规定客户端和服务端的数据传输格式</li>
<li>特点：基于请求和响应模式的、无状态、无连接的应用层协议</li>
<li><img src="/assets/1/image-20211120140426-37e7idv.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP请求（基于请求和响应模式）</p>
<ul>
<li><p>请求行</p>
<ul>
<li><img src="/assets/1/image-20211120140500-njj9r9v.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP请求的方法</p>
<ul>
<li><img src="/assets/1/image-20211120140507-qxa6kew.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP请求头内容</p>
<ul>
<li><img src="/assets/1/image-20211120140514-odif7ya.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP响应行</p>
<ul>
<li><img src="/assets/1/image-20211120140522-1oq96m8.png" alt="image.png"></li>
</ul>
</li>
<li><p>HTTP响应头</p>
<ul>
<li><img src="/assets/1/image-20211120140528-ufuwkma.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议–无连接应用协议</p>
<ul>
<li><p>定义</p>
<ul>
<li>无状态应用协议解释：<br>1.对事物处理没有记忆功能，服务器不知道客户端是什么状态，给服务器发送http请求之后，服务器回应之后，不会有任何记录；<br>2.每次请求都是独立的<br>特点：服务器处理后续请求-前面的请求信息–重传</li>
<li>优点：释放了服务器的压力</li>
<li>缺点：数据重传–重复的内容，增大数据传输量，资源浪费</li>
<li>动态交互：淘宝：购物车功能–商品信息      登录：login–后续操作（充值）<br>—cookies<br>—session</li>
<li>限制每次连接只处理一个请求</li>
<li>服务器处理完客户的请求，并收到客户的应答后，即断开连接</li>
</ul>
</li>
<li><p>初衷</p>
<ul>
<li>用户量（十万、上百万）页面请求，单个用户间歇性大（突发性，瞬时性），数据没有关联性，—资源浪费&#x3D;&#x3D;&#x3D;设计：释放连接</li>
<li>问题：网页越来越复杂，–图片–效率低&#x3D;&#x3D;&#x3D;头部信息keep-alive 放在connection中</li>
</ul>
</li>
<li><p>keep-alive设置</p>
<ul>
<li><p>1。开启：connection：keep-alive ，会发起keep-alive的连接请求–长链接。http1.1-默认打开的</p>
<ul>
<li>不需要重新建立连接<br /></li>
</ul>
</li>
<li><p>2。关闭：在http请求头中设置connection：close，即可关闭</p>
</li>
<li><p>3。设置连接时间：</p>
<ul>
<li>在http header中设置keep-alive：timeout&#x3D;5，max&#x3D;1000<br>timeout是超时时间，单位秒，超过这个时间后就会断开–释放<br>max是最多的连接次数，若超过这个次数就强制断开连接<br /></li>
</ul>
</li>
</ul>
</li>
<li><p>cookies</p>
<ul>
<li>将前面请求信息保存成一个临时文件–cookies值，—存放在浏览器里，如淘宝购物车：写进入cookies；<br>登录：充值 先登录在充值，从login获取登录的账号信息保留到cookies值中</li>
<li>关闭浏览器会被删除</li>
<li>清除缓存会被删除</li>
</ul>
</li>
<li><p>session</p>
<ul>
<li>永久的ciikies值</li>
<li>session ID（会话编号）–保存在服务器上–传给客户端。客户端浏览器保存在内存里</li>
<li>问题：资源占用。设置session超时时间–可清除sessionID</li>
</ul>
</li>
<li><p>http协议问题</p>
<ul>
<li>发送数据都是明文，第三方窃听，窃取数据包，伪装客户端    对数据包进行篡改数据-服务器不知道<br>存在安全隐患<br>解决方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTPS</p>
<ul>
<li><p>概念：HTTPS（Hypertext Transfer Protocol Secure）超文本传输安全协议，是以安全为目的HTTP通道，简单讲是HTTP的安全版本。<br>它加密数据并确保其机密性–加密，数据密文；<br>可保护用户在与网站交互时免于窃取个人信息和计费信息数据–身份认证；<br>防止信息被篡改–完整性–安全保障</p>
</li>
<li><p><img src="/assets/1/image-20211120140837-24axt48.png" alt="image.png"></p>
<ul>
<li><p>http+加密+身份认证+完整性保护&#x3D;HTTPS</p>
<ul>
<li>过程原理（交互）</li>
<li><img src="/assets/1/image-20211120141019-dohg0nx.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211120141023-o1pbp6b.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211122192944-z4bp9fx.png" alt="image.png"></li>
</ul>
</li>
<li><p>wireshark实例</p>
<ul>
<li><p>追踪流-TLS流</p>
<ul>
<li>看到完整ssl交互的过程</li>
</ul>
</li>
<li><p>客户端加密套件（支持的列表）</p>
<ul>
<li><img src="/assets/1/image-20211120141054-sbng2g0.png" alt="image.png"></li>
</ul>
</li>
<li><p>服务端加密套件（支持的）</p>
<ul>
<li><img src="/assets/1/image-20211120141101-l8s4ytc.png" alt="image.png"></li>
</ul>
</li>
<li><p>服务端发送证书</p>
<ul>
<li><img src="/assets/1/image-20211120141111-mdx3djr.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><p>tls是ssl协议的版本</p>
<ul>
<li>sslv3，tls1.0，tls1.2</li>
</ul>
</li>
<li><p>加密：–秘钥+身份认证+证书（权威机构颁发（申请）&#x3D;&#x3D;双向认证）+完整性保护（哈希算法–计算一个hash值，验证消息的完整性）<br /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议VS  HTTPS 协议</p>
<ul>
<li><img src="/assets/1/image-20211120141142-x6tlrun.png" alt="image.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>代理</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/03_%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="什么是代理服务器"><a href="#什么是代理服务器" class="headerlink" title="什么是代理服务器"></a><strong>什么是代理服务器</strong></h1><p>Web代理（proxy）服务器是网络的中间实体。 代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。</p>
<p>HTTP的代理服务器即是Web服务器又是Web客户端。</p>
<p><img src="/assets/1/wpsDF5D.tmp-20211222151232-ddixl0r.jpg"></p>
<h1 id="Fiddler就是个典型的代理"><a href="#Fiddler就是个典型的代理" class="headerlink" title="Fiddler就是个典型的代理"></a><strong>Fiddler就是个典型的代理</strong></h1><p>Fiddler 是以代理web服务器的形式工作的,它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler退出的时候它会自动注销代理，这样就不会影响别的程序。</p>
<p><img src="/assets/1/wpsDF5E.tmp-20211222151232-3k0fozh.jpg"></p>
<p><img src="/assets/1/wpsDF5F.tmp-20211222151232-8omms3m.jpg"></p>
<h1 id="代理的作用一，-FQ"><a href="#代理的作用一，-FQ" class="headerlink" title="代理的作用一， FQ"></a><strong>代理的作用一， FQ</strong></h1><p>很多人都喜欢用Facebook， 看youTube。但是我们在天朝，天朝有The Great of Wall(长城防火墙)，屏蔽了这些好网站。  怎么办?   通过代理来跳墙，就可以访问了。</p>
<p>自己去寻找代理服务器很麻烦， 一般都是用FQ软件来自动发现代理服务器的。</p>
<p><img src="/assets/1/wpsDF60.tmp-20211222151232-96nhbdt.jpg"></p>
<h1 id="代理的作用二，-匿名访问"><a href="#代理的作用二，-匿名访问" class="headerlink" title="代理的作用二， 匿名访问"></a><strong>代理的作用二， 匿名访问</strong></h1><p>经常听新闻，说”某某某“在网络上发布帖子，被跨省追缉了。   假如他使用匿名的代理服务器，就不容易暴露自己的身份了。</p>
<p>http代理服务器的匿名性是指： HTTP代理服务器通过删除HTTP报文中的身份特性（比如客户端的IP地址， 或cookie,或URI的会话ID）， 从而对远端服务器隐藏原始用户的IP地址以及其他细节。 同时HTTP代理服务器上也不会记录原始用户访问记录的log(否则也会被查到)。</p>
<h1 id="代理的作用三，-通过代理上网"><a href="#代理的作用三，-通过代理上网" class="headerlink" title="代理的作用三， 通过代理上网"></a><strong>代理的作用三， 通过代理上网</strong></h1><p>比如局域网不能上网， 只能通过局域网内的一台代理服务器上网。</p>
<h1 id="代理的作用四，-通过代理缓存，加快上网速度"><a href="#代理的作用四，-通过代理缓存，加快上网速度" class="headerlink" title="代理的作用四， 通过代理缓存，加快上网速度"></a><strong>代理的作用四， 通过代理缓存，加快上网速度</strong></h1><p>大部分代理服务器都具有缓存的功能，就好像一个大的cache， 它有很大的存储空间，它不断将新取得数据存储到它本地的存储器上， 如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传给用户的浏览器，这样就能显著提高浏览速度。</p>
<h1 id="代理的作用五：儿童过滤器"><a href="#代理的作用五：儿童过滤器" class="headerlink" title="代理的作用五：儿童过滤器"></a><strong>代理的作用五：儿童过滤器</strong></h1><p>很多教育机构， 会利用过滤器代理来阻止学生访问成人内容。</p>
<p><img src="/assets/1/wpsDF61.tmp-20211222151232-ipw4fkt.jpg"></p>
<h1 id="IE代理设置：手动设置代理"><a href="#IE代理设置：手动设置代理" class="headerlink" title="IE代理设置：手动设置代理"></a><strong>IE代理设置：手动设置代理</strong></h1><p>IE浏览器可以手动设置代理， 很简单，指定一个IP地址和端口就可以了。 如下图。</p>
<p>工具 -＞ Internet选项 -&gt; 连接 -&gt; 局域网设置 （快捷键）</p>
<p><img src="/assets/1/wpsDF62.tmp-20211222151232-t1rz1e9.jpg"></p>
<p>假如代理服务器的IP地址改变了，或者端口号改变了。 难道要几百个客户端的浏览器去修改浏览器设置？ Impossable  这太难维护了。  下面还有一种更高级点的方法。</p>
<h1 id="IE代理设置：使用自动配置脚本（PAC）"><a href="#IE代理设置：使用自动配置脚本（PAC）" class="headerlink" title="IE代理设置：使用自动配置脚本（PAC）"></a><strong>IE代理设置：使用自动配置脚本（PAC）</strong></h1><p> 手动配置代理很简单，但是不灵活。 只能指定一个代理服务器，而且不支持故障转移。</p>
<p>在大公司里一般都使用PAC文件来配置。只需要指定PAC文件的URL就可以了， 如图：</p>
<p><img src="/assets/1/wpsDF63.tmp-20211222151232-0ylxvbu.jpg"></p>
<p>PAC（Proxy Auto Config）文件是一个小型的JavaScript程序的文本文件，后缀为.dat。</p>
<p>当浏览器访问网络的时候，会根据PAC文件中的JavaScript函数来选择恰当的代理服务器。</p>
<p>sample_pac.dat文件的内容</p>
<p><img src="/assets/1/wpsDF64.tmp-20211222151232-tfzfr8d.png"></p>
<p>function FindProxyForURL(url, host) {</p>
<pre><code>if (url.substring(0, 5) == &quot;http:&quot;) &#123;

    // 应该使用指定的代理

    return &quot;PROXY proxy:80&quot;;

&#125;

else if (url.substring(0, 4) == &quot;ftp:&quot;) &#123;

    return &quot;PROXY fproxy:80&quot;;

&#125;

else if (url.substring(0, 7) == &quot;gopher:&quot;) &#123;

    return &quot;PROXY gproxy&quot;;

&#125;

else if (url.substring(0, 6) == &quot;https:&quot;) &#123;

    return &quot;PROXY secproxy:8080&quot;;

&#125;

else &#123;

    // 直连，不经过任何代理

    return &quot;DIRECT&quot;;

&#125;
</code></pre>
<p>}</p>
<p><img src="/assets/1/wpsDF65.tmp-20211222151232-x67d5mc.png"></p>
<h1 id="IE代理设置：自动探测设置（WPAD）"><a href="#IE代理设置：自动探测设置（WPAD）" class="headerlink" title="IE代理设置：自动探测设置（WPAD）"></a><strong>IE代理设置：自动探测设置（WPAD）</strong></h1><p> 浏览器只要选中“自动检测设置”， 就可以使用WPAD协议， WPAD会自动找到PAC文件的URL。  WPAD会使用一系列的资源发现技术（DHCP,DNS等）去寻找PAC文件。</p>
<p><img src="/assets/1/wpsDF66.tmp-20211222151232-u1fechv.jpg"></p>
<h1 id="代理认证，和407状态码"><a href="#代理认证，和407状态码" class="headerlink" title="代理认证，和407状态码"></a><strong>代理认证，和407状态码</strong></h1><p>代理服务器也可以需要权限认证， HTTP定义了一种名为代理认证（Proxy authentication）的机制。 这种机制可以阻止对内容的请求。</p>
<p>当浏览器访问需要认证的代理时， 代理服务器会返回407 Authorization Required,告诉浏览器输入用户名和密码。</p>
<p>代理认证跟HTTP基本认证是一样的机制， 如需了解代理认证的机制，请看<a href="http://www.cnblogs.com/TankXiao/archive/2012/09/26/2695955.html">[HTTP协议基本认证]</a></p>
<p><img src="/assets/1/wpsDF67.tmp-20211222151232-n3wbdm6.jpg"></p>
<h1 id="使用代理服务器的安全问题"><a href="#使用代理服务器的安全问题" class="headerlink" title="使用代理服务器的安全问题"></a><strong>使用代理服务器的安全问题</strong></h1><p>代理服务器和抓包工具（比如Fiddler）都能看到http request中的数据。 如果我们发送的request中有敏感数据，比如用户名，密码，信用卡号码。这些信息都会被代理服务器看到。所以非常危险。 所以我们一般都是用HTTPS来加密Http request.  这样代理服务器就看不到里面的数据了。</p>
<h1 id="如何搭建代理服务器"><a href="#如何搭建代理服务器" class="headerlink" title="如何搭建代理服务器"></a><strong>如何搭建代理服务器</strong></h1><p>可以使用CCproxy, 和Squid 来搭建代理服务器。</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
        <category>06_http协议</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>状态码</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/04_%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h1 id="什么是HTTP状态码"><a href="#什么是HTTP状态码" class="headerlink" title="什么是HTTP状态码"></a><strong>什么是HTTP状态码</strong></h1><p>HTTP状态码的作用是：Web服务器用来告诉客户端，发生了什么事。</p>
<p>状态码位于HTTP Response 的第一行中，会返回一个”三位数字的状态码“和一个“状态消息”。 ”三位数字的状态码“便于程序进行处理， “状态消息”更便于人理解。</p>
<p>如下图，  当客户端请求一个不存在的URL的时候， Web服务器会返回 “HTTP&#x2F;1.1 404 Not Found” 告诉浏览器客户端。 服务器无法找到所请求的URL。</p>
<p><img src="/assets/1/wps58D2.tmp-20211222151316-t1cgk41.jpg"></p>
<h1 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a><strong>状态码分类</strong></h1><p>HTTP状态码被分为五大类， 目前我们使用的HTTP协议版本是1.1， 支持以下的状态码。随着协议的发展，HTTP规范中会定义更多的状态码。</p>
<p>小技巧：  假如你看到一个状态码518， 你并不知道具体518是什么意思。 这时候你只要知道518是属于（5XX，服务器错误就可以了）</p>
<table>
<thead>
<tr>
<th></th>
<th>已定义范围</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>100-101</td>
<td>信息提示</td>
</tr>
<tr>
<td>2XX</td>
<td>200-206</td>
<td>成功</td>
</tr>
<tr>
<td>3XX</td>
<td>300-305</td>
<td>重定向</td>
</tr>
<tr>
<td>4XX</td>
<td>400-415</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5XX</td>
<td>500-505</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<h1 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a><strong>常见的状态码</strong></h1><p>一般人只需要了解以下常见的状态码就够了， 如果你想了解更多， 请继续往下看。</p>
<table>
<thead>
<tr>
<th>200 OK 服务器成功处理了请求（这个是我们见到最多的）</th>
</tr>
</thead>
<tbody><tr>
<td>301&#x2F;302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td>
</tr>
<tr>
<td>304 Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存</td>
</tr>
<tr>
<td>404 Not Found 未找到资源</td>
</tr>
<tr>
<td>501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</td>
</tr>
</tbody></table>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="1XX-信息性状态码"><a href="#1XX-信息性状态码" class="headerlink" title="1XX 信息性状态码"></a><strong>1XX 信息性状态码</strong></h1><p>这些状态码是HTTP 1.1引入的。 对于这些状态码的价值还存在争论 （我个人从来没见过这些状态码， 也没有理解这些状态码。）</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue(继续)</td>
<td>收到了请求的起始部分，客户端应该继续请求</td>
<td></td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols（切换协议）</td>
<td>服务器正根据客户端的指示将协议切换成Update Header列出的协议</td>
<td></td>
</tr>
</tbody></table>
<h1 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a><strong>2XX 成功状态码</strong></h1><p>客户端发起请求时， 这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>服务器成功处理了请求（这个是我们见到最多的）</td>
<td><a href="#code200">HTTP协议详解-200</a></td>
</tr>
<tr>
<td>201</td>
<td>Created（已创建）</td>
<td>对于那些要服务器创建对象的请求来说，资源已创建完毕。</td>
<td></td>
</tr>
<tr>
<td>202</td>
<td>Accepted（已接受）</td>
<td>请求已接受，但服务器尚未处理</td>
<td></td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information（非权威信息）</td>
<td>服务器已将事务成功处理，只是实体Header包含的信息不是来自原始服务器，而是来自资源的副本。</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>No Content(没有内容)</td>
<td>Response中包含一些Header和一个状态行， 但不包括实体的主题内容（没有response body）</td>
<td><a href="#code204">状态码204</a></td>
</tr>
<tr>
<td>205</td>
<td>Reset Content(重置内容)</td>
<td>另一个主要用于浏览器的代码。意思是浏览器应该重置当前页面上所有的HTML表单。</td>
<td></td>
</tr>
<tr>
<td>206</td>
<td>Partial Content（部分内容）</td>
<td>部分请求成功</td>
<td><a href="#code206">状态码206</a></td>
</tr>
</tbody></table>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a><strong>3XX 重定向状态码</strong></h1><p>重定向状态码用来告诉浏览器客户端，它们访问的资源已被移动， Web服务器发送一个重定向状态码和一个可选的Location Header, 告诉客户端新的资源地址在哪。</p>
<p>浏览器客户端会自动用Location中提供的地址，重新发送新的Request。 这个过程对用户来说是透明的。</p>
<p>301和302 非常相似，  一个是永久转移，一个是临时转移。</p>
<p>（SEO中，搜索引擎如果碰到301， 比如网页A用301重定向到网页B，搜索引擎可以肯定网页A永久性改变地址，就会把网页B当做唯一有效目标）</p>
<p>302，303，307 是一样。  这是因为302是HTTP 1.0定义的， HTTP1.1中使用303,307. 同时又保留了302.  （但在现实中，我们还是用302，我是没见过303和307）</p>
<p>所以这一节， 我们只需要掌握302， 304 就可以了。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices（多项选择）</td>
<td>客户端请求了实际指向多个资源的URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望的选项了</td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently（永久移除)</td>
<td>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</td>
<td><a href="#code301">状态码301</a></td>
</tr>
<tr>
<td>302</td>
<td>Found（已找到）</td>
<td>与状态码301类似。但这里的移除是临时的。 客户端会使用Location中给出的URL，重新发送新的HTTP request</td>
<td><a href="#Found302">HTTP协议详解-302</a></td>
</tr>
<tr>
<td>303</td>
<td>See Other（参见其他）</td>
<td>类似302</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>Not Modified（未修改）</td>
<td>客户的缓存资源是最新的，要客户端使用缓存</td>
<td><a href="#lastModify">HTTP协议之缓存-304</a></td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy（使用代理）</td>
<td>必须通过代理访问资源，代理的地址在Response 的Location中</td>
<td></td>
</tr>
<tr>
<td>306</td>
<td>未使用</td>
<td>这个状态码当前没使用</td>
<td></td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect（临时重定向</td>
<td>类似302</td>
<td></td>
</tr>
</tbody></table>
<h1 id="4XX客户端错误状态码"><a href="#4XX客户端错误状态码" class="headerlink" title="4XX客户端错误状态码"></a><strong>4XX客户端错误状态码</strong></h1><p>有时客户端会发送一些服务器无法处理的东西，比如格式错误的Request, 或者最常见的是， 请求一个不存在的URL。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request（坏请求）</td>
<td>告诉客户端，它发送了一个错误的请求。</td>
<td><a href="#code400">状态码400</a></td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized（未授权）</td>
<td>需要客户端对自己认证</td>
<td><a href="#guocheng">HTTP协议之基本认证-401</a></td>
</tr>
<tr>
<td>402</td>
<td>Payment Required（要求付款）</td>
<td>这个状态还没被使用，保留给将来用</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>Forbidden（禁止）</td>
<td>请求被服务器拒绝了</td>
<td><a href="#code403">状态码403</a></td>
</tr>
<tr>
<td>404</td>
<td>Not Found（未找到）</td>
<td>未找到资源</td>
<td><a href="#code404">HTTP协议详解-404</a></td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed（不允许使用的方法）</td>
<td>不支持该Request的方法。</td>
<td><a href="#code405">状态码405</a></td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable（无法接受）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required(要求进行代理认证)</td>
<td>与状态码401类似， 用于需要进行认证的代理服务器</td>
<td><a href="#proxyAuth">HTTP协议之代理-407</a></td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout（请求超时）</td>
<td>如果客户端完成请求时花费的时间太长， 服务器可以回送这个状态码并关闭连接</td>
<td></td>
</tr>
<tr>
<td>409</td>
<td>Conflict（冲突）</td>
<td>发出的请求在资源上造成了一些冲突</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td>Gone（消失了）</td>
<td>服务器曾经有这个资源，现在没有了，与状态码404类似</td>
<td></td>
</tr>
<tr>
<td>411</td>
<td>Length Required（要求长度指示）</td>
<td>服务器要求在Request中包含Content-Length。</td>
<td><a href="#code411">状态码411</a></td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed（先决条件失败）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large（请求实体太大）</td>
<td>客户端发送的实体主体部分比服务器能够或者希望处理的要大</td>
<td><a href="#code413">状态码413</a></td>
</tr>
<tr>
<td>414</td>
<td>Request URI Too Long（请求URI太长）</td>
<td>客户端发送的请求所携带的URL超过了服务器能够或者希望处理的长度</td>
<td><a href="#code414">状态码414</a></td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type（不支持的媒体类型）</td>
<td>服务器无法理解或不支持客户端所发送的实体的内容类型</td>
<td></td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable（所请求的范围未得到满足）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed（无法满足期望）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><h1 id="5XX服务器错误状态码"><a href="#5XX服务器错误状态码" class="headerlink" title="5XX服务器错误状态码"></a><strong>5XX服务器错误状态码</strong></h1><p>有时候客户端发送了一条有效Request, Web服务器自身却出错了。 可能是Web服务器运行出错了， 或者网站都挂了。  5XX就是用来描述服务器错误的。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态消息</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error(内部服务器错误)</td>
<td>服务器遇到一个错误，使其无法为请求提供服务</td>
<td><a href="#code500">状态码500</a></td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented（未实现）</td>
<td>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码。</td>
<td><a href="#code501">状态码501</a></td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway（网关故障）</td>
<td>代理使用的服务器遇到了上游的无效响应</td>
<td><a href="#code502">状态码502</a></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable（未提供此服务）</td>
<td>服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</td>
<td></td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout（网关超时）</td>
<td>与状态吗408类似， 但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时</td>
<td></td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported（不支持的HTTP版本）</td>
<td>服务器收到的请求使用了它不支持的HTTP协议版本。 有些服务器不支持HTTP早期的HTTP协议版本，也不支持太高的协议版本</td>
<td><a href="#code505">状态码505</a></td>
</tr>
</tbody></table>
<h1 id="204-No-Content-没有内容"><a href="#204-No-Content-没有内容" class="headerlink" title="204 No Content(没有内容)"></a><strong>204 No Content(没有内容)</strong></h1><p>返回的Response中只有一些Header和一个状态行， 没有实体的主题内容（没有response body）</p>
<p>204状态码的作用在于： 1. 在不获取资源的情况下了解资源的情况（比如判断其类型）</p>
<ol start="2">
<li>通过查看Response中的状态码， 看看某个对象是否存在</li>
<li>通过查看Header, 测试资源是否被修改了。</li>
</ol>
<p>实例：先打开Fiddler, 然后启动浏览器访问ditu.google.cn,  你会捕获到很多204</p>
<p><img src="/assets/1/wps58E3.tmp-20211222151316-3psm9de.png"></p>
<h1 id="206-Partial-Content-部分内容"><a href="#206-Partial-Content-部分内容" class="headerlink" title="206 Partial Content(部分内容)"></a><strong>206 Partial Content(部分内容)</strong></h1><p>206状态码代表服务器已经成功处理了部分GET请求（只有发送GET 方法的request, web服务器才可能返回206），</p>
<p>应用场景：</p>
<ol>
<li>FlashGet, 迅雷或者HTTP下载工具都是使用206状态码来实现断点续传</li>
<li>将以个大文档分解为多个下载段同时下载 比如，在线看视频</li>
</ol>
<p>实例：　一些流媒体技术比如在线视频，可以边看边下载。　就是使用206来实现的。</p>
<p>打开Fiddler， 然后用浏览器打开“搜狐视频中的绿箭侠” <a href="http://tv.sohu.com/20121011/n354681393.shtml">http://tv.sohu.com/20121011/n354681393.shtml</a>    然后你在Fiddler中就能看到一堆的206</p>
<ol>
<li>浏览器发送一个Get 方法的request.  header中包含 Range: bytes&#x3D;5303296-5336063. (意思就是请求得到5303296-5336063这个范围的数据)。</li>
<li>Web服务器返回一个206 的Response. header中包含Content-Range: bytes 5303296-5336063&#x2F;12129376(表明这次返回的内容范围)</li>
</ol>
<p><img src="/assets/1/wps58E4.tmp-20211222151316-tq4eq8y.jpg"></p>
<h1 id="301-Moved-Permanently（永久移除"><a href="#301-Moved-Permanently（永久移除" class="headerlink" title="301 Moved Permanently（永久移除)"></a><strong>301 Moved Permanently（永久移除)</strong></h1><p>请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</p>
<p>例如：  1.  浏览器客户端访问 <a href="http://map.google.cn/">http://map.google.cn</a></p>
<ol start="2">
<li>Web服务器返回Response 301，Location&#x3D;<a href="http://titu.google.cn/">http://titu.google.cn</a>  （告诉客户端我们的资源位于这里， ）</li>
<li>浏览器客户端会自动再发送一个Request 去访问<a href="http://titu.google.cn/">http://titu.google.cn</a></li>
</ol>
<p><img src="/assets/1/wps58E5.tmp-20211222151316-23pq1a5.png"></p>
<h1 id="400-Bad-Request（坏请求"><a href="#400-Bad-Request（坏请求" class="headerlink" title="400 Bad Request（坏请求)"></a><strong>400 Bad Request（坏请求)</strong></h1><p>发送的Request中的数据有错误(比如：表单有错误，Cookie有错误)，  这个我们也经常见到。</p>
<p>实例： 还没想到， 想到了再贴个实例上来。</p>
<h1 id="403-Forbidden-禁止"><a href="#403-Forbidden-禁止" class="headerlink" title="403 Forbidden(禁止)"></a><strong>403 Forbidden(禁止)</strong></h1><p>Web客户端发送的请求被Web服务器拒绝了， 如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态码通常是服务器不想说明拒绝原因。</p>
<p>访问下面的URL， 会被服务器拒绝. 并且返回403状态码</p>
<p><a href="http://t2.baidu.com/it/u=1791561788,200960144&fm=0&gp=0.jpg">http://t2.baidu.com/it/u=1791561788,200960144&fm=0&gp=0.jpg</a></p>
<h1 id="404-Page-not-Found-请求的资源不存在"><a href="#404-Page-not-Found-请求的资源不存在" class="headerlink" title="404 Page not Found (请求的资源不存在)"></a><strong>404 Page not Found (请求的资源不存在)</strong></h1><p>这个大家都懂的， 值得一提的是：　腾讯把404页面做成了“寻找被拐儿童”</p>
<p><img src="/assets/1/wps58E6.tmp-20211222151316-qyq8gno.png"></p>
<h1 id="405-Method-Not-Allowed-不允许使用的方法"><a href="#405-Method-Not-Allowed-不允许使用的方法" class="headerlink" title="405 Method Not Allowed(不允许使用的方法)"></a><strong>405 Method Not Allowed(不允许使用的方法)</strong></h1><p>405是指Web服务器不支持Request中的方法。</p>
<p>我个人认为状态码405Method Not Allowed和501 Not Implemented 是一样的意思。都是不支持Request的方法。 （目前我还不知道这两个的区别）</p>
<p>实例:  发送一个是trace方法的Request 给<a href="http://www.google.com/">www.google.com</a></p>
<p><img src="/assets/1/wps58E7.tmp-20211222151316-g6wvu4u.png"></p>
<p><img src="/assets/1/wps58E8.tmp-20211222151316-5dizdq9.png"></p>
<h1 id="411-Length-Required（要求长度指示）"><a href="#411-Length-Required（要求长度指示）" class="headerlink" title="411 Length Required（要求长度指示）"></a><strong>411 Length Required（要求长度指示）</strong></h1><p>服务器要求在Request中包含Content-Length。</p>
<p>当浏览器使用Post方法，发送数据给Web服务器时， 必须要有Content-Length。这样Web服务器才知道你要发送多少数据，否则Web服务器会返回411状态码</p>
<p>实例： 发送一个Post方法的Request 给<a href="http://www.google.com/">www.google.com</a>.   Request中没有Content-Length</p>
<p><img src="/assets/1/wps58F9.tmp-20211222151316-iql1y7y.png"></p>
<p><img src="/assets/1/wps58FA.tmp-20211222151316-gdysfe6.png"></p>
<h1 id="413-Request-Entity-Too-Large（请求实体太大）"><a href="#413-Request-Entity-Too-Large（请求实体太大）" class="headerlink" title="413 Request Entity Too Large（请求实体太大）"></a><strong>413 Request Entity Too Large（请求实体太大）</strong></h1><p>作用：客户端发送的实体主体部分比服务器能够或者希望处理的要大。  一般情况下我们看不到这个状态码。 因为浏览器不会发送太大的数据给网站，但是机器人可能会。</p>
<p>实例: 用post方法发送一个大文件(100MB以上)给<a href="http://www.google.com/">www.google.com</a></p>
<p><img src="/assets/1/wps58FB.tmp-20211222151316-qtpckvt.png"></p>
<p><img src="/assets/1/wps58FC.tmp-20211222151316-fin7xes.png"></p>
<h1 id="414-Request-URI-Too-Long-请求URI太长"><a href="#414-Request-URI-Too-Long-请求URI太长" class="headerlink" title="414 Request URI Too Long(请求URI太长)"></a><strong>414 Request URI Too Long(请求URI太长)</strong></h1><p>就是说Request URI太长， 一般浏览器本身对URI的长度就会有限制，所以不会发送URI很长的Request. 我们平常是根本看不到414错误的。 但是机器人可以发送很长URI。</p>
<p>例如：我们用Fiddler Composer发送一个很长的URI给Google, 比如 “<a href="http://www.google.com/?q">www.google.com?q</a>&#x3D;asdfasdasf..”  q&#x3D;后面的参数很长。 就可以看到414了</p>
<p><img src="/assets/1/wps58FD.tmp-20211222151316-ai45r9x.png"></p>
<p><img src="/assets/1/wps58FE.tmp-20211222151316-k42ksdg.png"></p>
<h1 id="500-Internal-Server-Error-内部服务器错误"><a href="#500-Internal-Server-Error-内部服务器错误" class="headerlink" title="500 Internal Server Error(内部服务器错误)"></a><strong>500 Internal Server Error(内部服务器错误)</strong></h1><p>这个太常见了， 我们开发网站的时候，当我们的程序出错了时，就会返回500错误。</p>
<p>实例：ASP.NET 程序出错</p>
<p><img src="/assets/1/wps58FF.tmp-20211222151316-hapybyl.png"></p>
<p> <img src="/assets/1/wps5900.tmp-20211222151316-u3y9rl9.png"></p>
<h1 id="501-Not-Implemented-未实现"><a href="#501-Not-Implemented-未实现" class="headerlink" title="501 Not Implemented(未实现)"></a><strong>501 Not Implemented(未实现)</strong></h1><p>客户端发起的请求超出服务器的能力范围(比如，使用了服务器不支持的请求方法)时，使用此状态码）。  一般的Web服务器只支持GET和POST方法。</p>
<p>实例： 使用Fiddler Composer 给<a href="http://www.qq.com/">www.qq.com</a>,  发送一个OPTIONS 方法的Request.   服务器就能返回501了。</p>
<p><img src="/assets/1/wps5901.tmp-20211222151316-l7a5n1g.jpg"></p>
<p><img src="/assets/1/wps5902.tmp-20211222151316-jpgi2af.jpg"></p>
<h1 id="502-Bad-Gateway（网关故障）"><a href="#502-Bad-Gateway（网关故障）" class="headerlink" title="502 Bad Gateway（网关故障）"></a><strong>502 Bad Gateway（网关故障）</strong></h1><p>代理使用的服务器遇到了上游的无效响应。</p>
<p>Fiddler本身就是代理服务器。  当我们访问<a href="http://www.facebook.com,这网站被我们天朝屏蔽了./">www.facebook.com，这网站被我们天朝屏蔽了。</a> 所以我们可以得到502</p>
<p><img src="/assets/1/wps5903.tmp-20211222151316-xc9razj.png"></p>
<h1 id="505-HTTP-Version-Not-Supported-不支持的HTTP版本"><a href="#505-HTTP-Version-Not-Supported-不支持的HTTP版本" class="headerlink" title="505 HTTP Version Not Supported(不支持的HTTP版本)"></a><strong>505 HTTP Version Not Supported(不支持的HTTP版本)</strong></h1><p>表示Web服务器不支持此HTTP协议的版本。</p>
<p>众所周知我们现在使用的HTTP协议版本是HTTP&#x2F;1.1， 如果我们发送一个HTTP&#x2F;2.0 的request 给博客园， 博客园肯定不能支持HTTP&#x2F;2.0，所以会返回505</p>
<p>想要发送这样的request, 可以使用Fiddler工具中的Composer来发送自定义的request, 如下图。</p>
<p><img src="/assets/1/wps5904.tmp-20211222151316-986ruis.png"></p>
<p><img src="/assets/1/wps5905.tmp-20211222151316-egcdh5j.jpg"></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
        <category>06_http协议</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议详解</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/01_HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a><strong>什么是HTTP协议</strong></h1><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</p>
<p>目前我们使用的是HTTP&#x2F;1.1 版本</p>
<h1 id="Web服务器，浏览器-代理服务器"><a href="#Web服务器，浏览器-代理服务器" class="headerlink" title="Web服务器，浏览器,代理服务器"></a><strong>Web服务器，浏览器,代理服务器</strong></h1><p>当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？</p>
<p>实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示</p>
<p><img src="/assets/1/wps81FC.tmp-20211222150430-3fflmhm.png"></p>
<p>我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。</p>
<p>过程如下图所示</p>
<p><img src="/assets/1/wps820D.tmp-20211222150430-jrbyasx.jpg"></p>
<p>代理服务器就是网络信息的中转站，有什么功能呢？</p>
<ol>
<li>提高访问速度， 大多数的代理服务器都有缓存功能。</li>
<li>突破限制， 也就是FQ了</li>
<li>隐藏身份。</li>
</ol>
<h1 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a><strong>URL详解</strong></h1><p> URL(Uniform Resource Locator) 地址用于描述一个网络上的资源,  基本格式如下</p>
<p>schema:&#x2F;&#x2F;host[:port#]&#x2F;path&#x2F;…&#x2F;[?query-string][#anchor]</p>
<p>scheme               指定低层使用的协议(例如：http, https, ftp)</p>
<p>host                   HTTP服务器的IP地址或者域名</p>
<p>port#                 HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/">http://www.cnblogs.com:8080/</a></p>
<p>path                   访问资源的路径</p>
<p>query-string       发送给http服务器的数据</p>
<p>anchor-             锚</p>
<p>URL 的一个例子</p>
<p><img src="/assets/1/wps820E.tmp-20211222150430-vxxzzyy.png"></p>
<p><a href="http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff">http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</a></p>
<p>Schema:                 http<br>host:                   <a href="http://www.mywebsite.com/">www.mywebsite.com</a><br>path:                   &#x2F;sj&#x2F;test&#x2F;test.aspx<br>Query String:           name&#x3D;sviergn&amp;x&#x3D;true<br>Anchor:                 stuff</p>
<p><img src="/assets/1/wps820F.tmp-20211222150430-que97w7.png"></p>
<h1 id="HTTP协议是无状态的"><a href="#HTTP协议是无状态的" class="headerlink" title="HTTP协议是无状态的"></a><strong>HTTP协议是无状态的</strong></h1><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p>
<h1 id="打开一个网页需要浏览器发送很多次Request"><a href="#打开一个网页需要浏览器发送很多次Request" class="headerlink" title="打开一个网页需要浏览器发送很多次Request"></a><strong>打开一个网页需要浏览器发送很多次Request</strong></h1><ol>
<li>当你在浏览器输入URL <a href="http://www.cnblogs.com/">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com/">http://www.cnblogs.com</a> 的html.  服务器把Response发送回给浏览器.</li>
<li>浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。</li>
<li>浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。</li>
<li>等所有的文件都下载成功后。 网页就被显示出来了。</li>
</ol>
<h1 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a><strong>HTTP消息的结构</strong></h1><p>先看Request 消息的结构,   Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图</p>
<p><img src="/assets/1/wps8210.tmp-20211222150430-r1erjah.jpg"></p>
<p>第一行中的Method表示请求方法,比如”POST”,”GET”,  Path-to-resoure表示请求的资源， Http&#x2F;version-number 表示HTTP协议的版本号</p>
<p>当使用的是”GET” 方法的时候， body是为空的</p>
<p>比如我们打开博客园首页的request 如下</p>
<p>GET <a href="http://www.cnblogs.com/">http://www.cnblogs.com/</a> HTTP&#x2F;1.1<br>Host: <a href="http://www.cnblogs.com/">www.cnblogs.com</a></p>
<p>抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response.</p>
<p>下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息，   如下图</p>
<p><img src="/assets/1/wps8211.tmp-20211222150430-ey18q0p.jpg"></p>
<p>我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行,  结构如下图</p>
<p><img src="/assets/1/wps8212.tmp-20211222150430-vl2gmcd.jpg"></p>
<p>HTTP&#x2F;version-number表示HTTP协议的版本号，  status-code 和message 请看下节[<a href="#statecode">状态代码</a>]的详细解释.</p>
<p>我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息，   如下图</p>
<p><img src="/assets/1/wps8213.tmp-20211222150430-4yjwq5a.jpg"></p>
<h1 id="Get和Post方法的区别"><a href="#Get和Post方法的区别" class="headerlink" title="Get和Post方法的区别"></a><strong>Get和Post方法的区别</strong></h1><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息.</p>
<p>我们看看GET和POST的区别</p>
<ol>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456.  POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li>
</ol>
<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><strong>状态码</strong></h1><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
<p>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p>
<p>HTTP&#x2F;1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p>
<p>1XX  提示信息 - 表示请求已被成功接收，继续处理</p>
<p>2XX  成功 - 表示请求已被成功接收，理解，接受</p>
<p>3XX  重定向 - 要完成请求必须进行更进一步的处理</p>
<p>4XX  客户端错误 -  请求有语法错误或请求无法实现</p>
<p>5XX  服务器端错误 -   服务器未能实现合法的请求</p>
<p>看看一些常见的状态码</p>
<p>200 OK</p>
<p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p>
<p>如下图， 打开博客园首页</p>
<p><img src="/assets/1/wps8214.tmp-20211222150430-lm5mp15.jpg"></p>
<p>302 Found</p>
<p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request</p>
<p>例如在IE中输入， <a href="http://www.google.com/">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p>
<p><img src="/assets/1/wps8215.tmp-20211222150430-s198i48.jpg"></p>
<p>304 Not Modified</p>
<p>代表上次的文档已经被缓存了， 还可以继续使用，</p>
<p>例如打开博客园首页, 发现很多Response 的status code 都是304</p>
<p><img src="/assets/1/wps8216.tmp-20211222150430-xzo1alf.jpg"></p>
<p>提示：　如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面</p>
<p>400 Bad Request  客户端请求与语法错误，不能被服务器所理解</p>
<p>403 Forbidden 服务器收到请求，但是拒绝提供服务</p>
<p>404 Not Found</p>
<p>请求资源不存在（输错了URL）</p>
<p>比如在IE中输入一个错误的URL， <a href="http://www.cnblogs.com/tesdf.aspx">http://www.cnblogs.com/tesdf.aspx</a></p>
<p><img src="/assets/1/wps8217.tmp-20211222150430-14s4kkp.jpg"></p>
<p>500 Internal Server Error 服务器发生了不可预期的错误</p>
<p>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<h1 id="HTTP-Request-header"><a href="#HTTP-Request-header" class="headerlink" title="HTTP Request header"></a><strong>HTTP Request header</strong></h1><p>使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers  如下图所示.</p>
<p><img src="/assets/1/wps8218.tmp-20211222150430-dika77y.jpg"></p>
<p>header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p>
<h2 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a><strong>Cache 头域</strong></h2><p>If-Modified-Since</p>
<p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p>
<p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</p>
<p>实例如下图</p>
<p><img src="/assets/1/wps8229.tmp-20211222150430-tgwstoq.jpg"></p>
<p>If-None-Match</p>
<p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能</p>
<p>例如: If-None-Match: “03f2b33c0bfcc1:0”</p>
<p>实例如下图</p>
<p><img src="/assets/1/wps822A.tmp-20211222150430-hxee3yt.jpg"></p>
<p>Pragma</p>
<p>作用： 防止页面被缓存， 在HTTP&#x2F;1.1版本中，它和Cache-Control:no-cache作用一模一样</p>
<p>Pargma只有一个用法， 例如： Pragma: no-cache</p>
<p>注意: 在HTTP&#x2F;1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p>
<p>Cache-Control</p>
<p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p>
<p>Cache-Control:Public   可以被任何缓存所缓存（）</p>
<p>Cache-Control:Private     内容只缓存到私有缓存中</p>
<p>Cache-Control:no-cache  所有内容都不会被缓存</p>
<p>还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料</p>
<h2 id="Client-头域"><a href="#Client-头域" class="headerlink" title="Client 头域"></a><strong>Client 头域</strong></h2><p>Accept</p>
<p>作用： 浏览器端可以接受的媒体类型,</p>
<p>例如：  Accept: text&#x2F;html  代表浏览器可以接受服务器回发的类型为 text&#x2F;html  也就是我们常说的html文档,</p>
<p>如果服务器无法返回text&#x2F;html类型的数据,服务器应该返回一个406错误(non acceptable)</p>
<p>通配符 * 代表任意类型</p>
<p>例如  Accept: <em>&#x2F;</em>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p>
<p>Accept-Encoding：</p>
<p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;</p>
<p>例如： Accept-Encoding: gzip, deflate</p>
<p>Accept-Language</p>
<p>作用： 浏览器申明自己接收的语言。</p>
<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p>
<p>例如： Accept-Language: en-us</p>
<p>User-Agent</p>
<p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>
<p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p>
<p>例如： User-Agent: Mozilla&#x2F;4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident&#x2F;4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p>
<p>Accept-Charset</p>
<p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）；</p>
<p>例如：</p>
<h2 id="Cookie-x2F-Login-头域"><a href="#Cookie-x2F-Login-头域" class="headerlink" title="Cookie&#x2F;Login 头域"></a><strong>Cookie&#x2F;Login 头域</strong></h2><p>Cookie:</p>
<p>作用： 最重要的header, 将cookie的值发送给HTTP 服务器</p>
<h2 id="Entity头域"><a href="#Entity头域" class="headerlink" title="Entity头域"></a><strong>Entity头域</strong></h2><p>Content-Length</p>
<p>作用：发送给HTTP服务器数据的长度。</p>
<p>例如： Content-Length: 38</p>
<p>Content-Type</p>
<p>作用：</p>
<p>例如：Content-Type: application&#x2F;x-www-form-urlencoded</p>
<h2 id="Miscellaneous-头域"><a href="#Miscellaneous-头域" class="headerlink" title="Miscellaneous 头域"></a><strong>Miscellaneous 头域</strong></h2><p>Referer:</p>
<p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>
<p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p>
<h2 id="Transport-头域"><a href="#Transport-头域" class="headerlink" title="Transport 头域"></a><strong>Transport 头域</strong></h2><p>Connection</p>
<p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<p>Host（发送请求时，该报头域是必需的）</p>
<p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>
<p>例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html">http://www.guet.edu.cn/index.html</a></p>
<p>浏览器发送的请求消息中，就会包含Host请求报头域，如下：</p>
<p>Host：<a href="http://www.guet.edu.cn/">http://www.guet.edu.cn</a></p>
<p>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p>
<h1 id="HTTP-Response-header"><a href="#HTTP-Response-header" class="headerlink" title="HTTP Response header"></a><strong>HTTP Response header</strong></h1><p>同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers  如下图所示</p>
<p><img src="/assets/1/wps822B.tmp-20211222150430-rnrd88w.jpg"></p>
<p> 我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p>
<h2 id="Cache头域"><a href="#Cache头域" class="headerlink" title="Cache头域"></a><strong>Cache头域</strong></h2><p>Date</p>
<p>作用:  生成消息的具体时间和日期</p>
<p>例如：　Date: Sat, 11 Feb 2012 11:35:14 GMT</p>
<p>Expires</p>
<p>作用: 浏览器会在指定过期时间内使用本地缓存</p>
<p>例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</p>
<p>Vary</p>
<p>作用：</p>
<p>例如: Vary: Accept-Encoding</p>
<h2 id="Cookie-x2F-Login-头域-1"><a href="#Cookie-x2F-Login-头域-1" class="headerlink" title="Cookie&#x2F;Login 头域"></a><strong>Cookie&#x2F;Login 头域</strong></h2><p>P3P</p>
<p>作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</p>
<p>例如: P3P: CP&#x3D;CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p>
<p>Set-Cookie</p>
<p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p>
<p>例如: Set-Cookie: sc&#x3D;4c31523a; path&#x3D;&#x2F;; domain&#x3D;.acookie.taobao.com</p>
<p><img src="/assets/1/wps822C.tmp-20211222150430-bknlpw2.jpg"></p>
<h2 id="Entity头域-1"><a href="#Entity头域-1" class="headerlink" title="Entity头域"></a><strong>Entity头域</strong></h2><p>ETag</p>
<p>作用:  和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p>
<p>例如: ETag: “03f2b33c0bfcc1:0”</p>
<p>Last-Modified:</p>
<p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p>
<p>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p>
<p>Content-Type</p>
<p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,</p>
<p>例如:</p>
<p>Content-Type: text&#x2F;html; charset&#x3D;utf-8</p>
<p>Content-Type:text&#x2F;html;charset&#x3D;GB2312</p>
<p>Content-Type: image&#x2F;jpeg</p>
<p>Content-Length</p>
<p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。</p>
<p>例如: Content-Length: 19847</p>
<p>Content-Encoding</p>
<p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。</p>
<p>例如：Content-Encoding：gzip</p>
<p>Content-Language</p>
<p>作用： WEB服务器告诉浏览器自己响应的对象的语言者</p>
<p>例如： Content-Language:da</p>
<h2 id="Miscellaneous-头域-1"><a href="#Miscellaneous-头域-1" class="headerlink" title="Miscellaneous 头域"></a><strong>Miscellaneous 头域</strong></h2><p>Server:</p>
<p>作用：指明HTTP服务器的软件信息</p>
<p>例如:Server: Microsoft-IIS&#x2F;7.5</p>
<p>X-AspNet-Version:</p>
<p>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本</p>
<p>例如: X-AspNet-Version: 4.0.30319</p>
<p>X-Powered-By:</p>
<p>作用：表示网站是用什么技术开发的</p>
<p>例如： X-Powered-By: ASP.NET</p>
<h2 id="Transport头域"><a href="#Transport头域" class="headerlink" title="Transport头域"></a><strong>Transport头域</strong></h2><p>Connection</p>
<p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<h2 id="Location头域"><a href="#Location头域" class="headerlink" title="Location头域"></a><strong>Location头域</strong></h2><p>Location</p>
<p>作用： 用于重定向一个新的位置, 包含新的URL地址</p>
<p> 实例请看304状态实例</p>
<h1 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a><strong>HTTP协议是无状态的和Connection: keep-alive的区别</strong></h1><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p>
<p>从HTTP&#x2F;1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
        <category>06_http协议</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/02_%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="缓存的概念"><a href="#缓存的概念" class="headerlink" title="缓存的概念"></a><strong>缓存的概念</strong></h1><p>缓存这个东西真的是无处不在， 有浏览器端的缓存， 有服务器端的缓存，有代理服务器的缓存， 有ASP.NET页面缓存，对象缓存。 数据库也有缓存， 等等。</p>
<p>http中具有缓存功能的是浏览器缓存，以及缓存代理服务器。</p>
<p>http缓存的是指:当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。</p>
<h1 id="缓存的好处"><a href="#缓存的好处" class="headerlink" title="缓存的好处"></a><strong>缓存的好处</strong></h1><p>缓存的好处是显而易见的， 好处有，</p>
<ol>
<li>减少了冗余的数据传输，节省了网费。</li>
<li>减少了服务器的负担， 大大提高了网站的性能</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<h1 id="Fiddler可以方便地查看缓存的header"><a href="#Fiddler可以方便地查看缓存的header" class="headerlink" title="Fiddler可以方便地查看缓存的header"></a><strong>Fiddler可以方便地查看缓存的header</strong></h1><p>Fiddler中把header都分门别类的放在一起，这样方便查看。</p>
<p><img src="/assets/1/wpsE155.tmp-20211222151127-949mku1.png"></p>
<h1 id="如何判断缓存新鲜度"><a href="#如何判断缓存新鲜度" class="headerlink" title="如何判断缓存新鲜度"></a><strong>如何判断缓存新鲜度</strong></h1><p>Web服务器通过2种方式来判断浏览器缓存是否是最新的。</p>
<p>第一种， 浏览器把缓存文件的最后修改时间通过 header ”If-Modified-Since“来告诉Web服务器。</p>
<p>第二种， 浏览器把缓存文件的ETag, 通过header “If-None-Match”, 来告诉Web服务器。</p>
<h1 id="通过最后修改时间-来判断缓存新鲜度"><a href="#通过最后修改时间-来判断缓存新鲜度" class="headerlink" title="通过最后修改时间, 来判断缓存新鲜度"></a><strong>通过最后修改时间, 来判断缓存新鲜度</strong></h1><ol>
<li>浏览器客户端想请求一个文档，  首先检查本地缓存，发现存在这个文档的缓存，  获取缓存中文档的最后修改时间，通过： If-Modified-Since， 发送Request给Web服务器。</li>
<li>Web服务器收到Request，将服务器的文档修改时间（Last-Modified）: 跟request header 中的，If-Modified-Since相比较， 如果时间是一样的， 说明缓存还是最新的， Web服务器将发送304 Not Modified给浏览器客户端， 告诉客户端直接使用缓存里的版本。如下图。</li>
</ol>
<p><img src="/assets/1/wpsE156.tmp-20211222151127-4a40jej.jpg"></p>
<ol start="3">
<li>假如该文档已经被更新了。Web服务器将发送该文档的最新版本给浏览器客户端， 如下图。</li>
</ol>
<p><img src="/assets/1/wpsE157.tmp-20211222151127-uyh67po.jpg"></p>
<p>实例： 打开Fiddler, 然后打开博客园首页。然后F5刷新几次浏览器。 你会看到博客园首页也用了缓存。</p>
<p><img src="/assets/1/wpsE158.tmp-20211222151127-etqucwh.jpg"></p>
<h1 id="与缓存有关的header"><a href="#与缓存有关的header" class="headerlink" title="与缓存有关的header"></a><strong>与缓存有关的header</strong></h1><p>我们来看看每个header的具体含义。</p>
<p>Request</p>
<table>
<thead>
<tr>
<th>Cache-Control: max-age&#x3D;0</th>
<th>以秒为单位</th>
</tr>
</thead>
<tbody><tr>
<td>If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT</td>
<td>缓存文件的最后修改时间。</td>
</tr>
<tr>
<td>If-None-Match: “0693f67a67cc1:0”</td>
<td>缓存文件的Etag值</td>
</tr>
<tr>
<td>Cache-Control: no-cache</td>
<td>不使用缓存</td>
</tr>
<tr>
<td>Pragma: no-cache</td>
<td>不使用缓存</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Response</p>
<table>
<thead>
<tr>
<th>Cache-Control: public</th>
<th>响应被缓存，并且在多用户间共享，（<a href="#publicAndPrivate">公有缓存和私有缓存的区别，请看另一节</a>）</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control: private</td>
<td>响应只能作为私有缓存，不能在用户之间共享</td>
</tr>
<tr>
<td>Cache-Control:no-cache</td>
<td>提醒浏览器要从服务器提取文档进行验证</td>
</tr>
<tr>
<td>Cache-Control:no-store</td>
<td>绝对禁止缓存（用于机密，敏感文件）</td>
</tr>
<tr>
<td>Cache-Control: max-age&#x3D;60</td>
<td>60秒之后缓存过期（相对时间）</td>
</tr>
<tr>
<td>Date: Mon, 19 Nov 2012 08:39:00 GMT</td>
<td>当前response发送的时间</td>
</tr>
<tr>
<td>Expires: Mon, 19 Nov 2012 08:40:01 GMT</td>
<td>缓存过期的时间（绝对时间）</td>
</tr>
<tr>
<td>Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT</td>
<td>服务器端文件的最后修改时间</td>
</tr>
<tr>
<td>ETag: “20b1add7ec1cd1:0”</td>
<td>服务器端文件的Etag值</td>
</tr>
</tbody></table>
<p>如果同时存在cache-control和Expires怎么办呢？<br>浏览器总是优先使用cache-control，如果没有cache-control才考虑Expires</p>
<h1 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><strong>ETag</strong></h1><p>ETag是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。</p>
<p>ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。</p>
<p>为什么使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。</p>
<ol>
<li>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。</li>
<li>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</li>
<li>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</li>
</ol>
<p>实例， 打开Fiddler, 打开博客园首页。  你可以看到很多图片，或者CSS文件都是用了缓存。 这些都是通过比较ETag的值，来判断文件是否更新了。</p>
<p><img src="/assets/1/wpsE159.tmp-20211222151127-o57jc2l.jpg"></p>
<h1 id="浏览器不使用缓存"><a href="#浏览器不使用缓存" class="headerlink" title="浏览器不使用缓存"></a><strong>浏览器不使用缓存</strong></h1><p>CTRL+F5强制刷新浏览器，或者设置IE。  可以让浏览器不使用缓存。</p>
<ol>
<li>浏览器发送Http request, 给Web 服务器， header中带有Cache-Control: no-cache.   明确告诉Web服务器，客户端不使用缓存。</li>
<li>Web服务器将把最新的文档发送给浏览器客户端.</li>
</ol>
<p>实例:</p>
<p>打开Fiddler, 打开博客园首页， 然后按CTRL+F5强制刷新浏览器，你将看到</p>
<p><img src="/assets/1/wpsE15A.tmp-20211222151127-xzmycng.jpg"></p>
<p>Pragma: no-cache的作用和Cache-Control: no-cache一模一样。 都是不使用缓存。</p>
<p>Pragma: no-cache 是HTTP 1.0中定义的， 所以为了兼容HTTP 1.0. 所以会同时使用Pragma: no-cache和Cache-Control: no-cache</p>
<h1 id="直接使用缓存，不去服务器验证"><a href="#直接使用缓存，不去服务器验证" class="headerlink" title="直接使用缓存，不去服务器验证"></a><strong>直接使用缓存，不去服务器验证</strong></h1><p>按F5刷新浏览器和在地址栏里输入网址然后回车。 这两个行为是不一样的。</p>
<p>按F5刷新浏览器， 浏览器会去Web服务器验证缓存。</p>
<p>如果是在地址栏输入网址然后回车，浏览器会”直接使用有效的缓存”, 而不会发http request 去服务器验证缓存，这种情况叫做缓存命中，如下图</p>
<p><img src="/assets/1/wpsE15B.tmp-20211222151127-vlk8i3m.jpg"></p>
<p>实例： 比较第一次访问博客园主页和第二次博客园主页</p>
<ol>
<li>启动Fiddler, 用firefox打开博客园主页， 发现有50多个session。</li>
<li>按CTRL+X将Fiddler中的所有session删除。 关闭firefox,重新打开一个firefox，打开博客园主页。   发现只有30多个session.</li>
</ol>
<p>分析；  少了的session是因为firefox直接用了缓存，而没有发http request。</p>
<p><img src="/assets/1/wpsE15C.tmp-20211222151127-owy880x.jpg"></p>
<h1 id="如何设置IE不使用缓存"><a href="#如何设置IE不使用缓存" class="headerlink" title="如何设置IE不使用缓存"></a><strong>如何设置IE不使用缓存</strong></h1><p>打开IE。点击工具栏上的， 工具-&gt;Internet选项-&gt;常规-&gt;浏览历史记录 设置. 选择“从不”。然后保存。</p>
<p>然后点击“删除”  把Internet临时文件都删掉 （IE缓存的文件就是Internet临时文件）。</p>
<p><img src="/assets/1/wpsE15D.tmp-20211222151127-tnxmonf.jpg"></p>
<h1 id="公有缓存和私有缓存的区别"><a href="#公有缓存和私有缓存的区别" class="headerlink" title="公有缓存和私有缓存的区别"></a><strong>公有缓存和私有缓存的区别</strong></h1><p>Cache-Control: public 指可以公有缓存， 可以是数千名用户共享的。</p>
<p>Cache-Control: private 指只支持私有缓存， 私有缓存是单个用户专用的。</p>
<p><img src="/assets/1/wpsE16E.tmp-20211222151127-uql8c7i.jpg"></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
        <category>06_http协议</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/03_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/904_%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/06_http%E5%8D%8F%E8%AE%AE/05_cookie/</url>
    <content><![CDATA[<h1 id="Cookie是什么，有什么用，为什么要用到Cookie"><a href="#Cookie是什么，有什么用，为什么要用到Cookie" class="headerlink" title="Cookie是什么，有什么用，为什么要用到Cookie"></a><strong>Cookie是什么，有什么用，为什么要用到Cookie</strong></h1><p>请看Fish Li 写的【<a href="http://www.cnblogs.com/fish-li/archive/2011/07/03/2096903.html">细说<strong>Cookie】</strong></a></p>
<h1 id="Cookie的分类"><a href="#Cookie的分类" class="headerlink" title="Cookie的分类"></a><strong>Cookie的分类</strong></h1><p>可以大致把Cookie分为2类： 回话cookie和持久cookie</p>
<p>会话cookie: 是一种临时的cookie，它记录了用户访问站点时的设置和偏好，关闭浏览器，会话cookie就被删除了</p>
<p>持久cookie: 存储在硬盘上，（不管浏览器退出，或者电脑重启，持久cookie都存在）， 持久cookie有过期时间</p>
<h1 id="Cookie存在哪里"><a href="#Cookie存在哪里" class="headerlink" title="Cookie存在哪里"></a><strong>Cookie存在哪里</strong></h1><p>Cookie是存在硬盘上，  IE存cookie的地方和Firefox存cookie的地方不一样。  不同的操作系统也可能存cookie的地方不一样。</p>
<p>不同的浏览器会在各自的独立空间存放Cookie, 互不干涉</p>
<p>以我的windows7， IE8为例，  cookie存在这： C:\Users\xiaoj\AppData\Local\Microsoft\Windows\Temporary Internet Files</p>
<p>注意： 缓存文件和cookie文件，是存在一起的, 都在这个目录下。</p>
<p>你也可以这样找, 打开IE，点击Tools-&gt;Internet Options-&gt;General Tab下的-&gt;Browsing history下的Setting按钮，弹出的对话框中点击View files.</p>
<p><img src="/assets/1/wps7EA5.tmp-20211222151419-fbxtpyw.png"><img src="/assets/1/wps7EA6.tmp-20211222151419-olwgxkx.jpg"></p>
<p>不同的网站会有不同的cookie文件</p>
<p><img src="/assets/1/wps7EA7.tmp-20211222151419-qi8mr5o.png"><img src="/assets/1/wps7EA8.tmp-20211222151419-zru7a1f.jpg"></p>
<h1 id="使用和禁用Cookie"><a href="#使用和禁用Cookie" class="headerlink" title="使用和禁用Cookie"></a><strong>使用和禁用Cookie</strong></h1><p>IE:   工具-&gt;Internet 选项 -&gt; 隐私</p>
<p><img src="/assets/1/wps7EA9.tmp-20211222151419-ptu9ut9.png"><img src="/assets/1/wps7EAA.tmp-20211222151419-aop8gqr.jpg"></p>
<h1 id="Fiddler查看HTTP中的Cookie"><a href="#Fiddler查看HTTP中的Cookie" class="headerlink" title="Fiddler查看HTTP中的Cookie"></a><strong>Fiddler查看HTTP中的Cookie</strong></h1><p>浏览器把cookie通过HTTP Request 中的“Cookie: header”发送给Web服务器</p>
<p>Web服务器通过HTTP Response中的”Set-Cookie: header”把cookie发送给浏览器</p>
<p>使用Fiddler可以清楚地看到cookie在HTTP中传递。 Fiddler工具中可以清晰的看到Http Request 中的Cookie， 和Http Response中的cookie</p>
<p>实例： 启动Fiddler,  启动浏览器访问一些购物网站，就可以看到。</p>
<p><img src="/assets/1/wps7EAB.tmp-20211222151419-2d6q7ul.png"> <img src="/assets/1/wps7EAC.tmp-20211222151419-zvo47bs.jpg"></p>
<h1 id="网站自动登陆的原理"><a href="#网站自动登陆的原理" class="headerlink" title="网站自动登陆的原理"></a><strong>网站自动登陆的原理</strong></h1><p>我们以”博客园自动登陆“的例子，来说明cookie是如何传递的。</p>
<p>大家知道博客园是可以自动登陆的。 如下图，这个是什么原理呢?</p>
<p><img src="/assets/1/wps7EAD.tmp-20211222151419-onffgyw.png"><img src="/assets/1/wps7EAE.tmp-20211222151419-7eoj92p.jpg"></p>
<p>假如我已经在登陆页面输入了用户名，密码，选择了保存密码，登陆。</p>
<p>（这时候，其实在你的机器上保存好了登陆的cookie, 不信你可以按照上节介绍方法去你的电脑上找下博客园的cookie）</p>
<p>当我下次访问博客园流程如下。</p>
<ol>
<li>用户打开IE浏览器，在地址栏上输入<a href="http://www.cnblogs.com/">www.cnblogs.com</a>.</li>
<li>IE首先会在硬盘中查找关于cnblogs.com的cookie. 然后把cookie放到HTTP Request中，再把Request发给Web服务器。</li>
<li>Web服务器返回博客园首页（你会看到你已经登陆了）。</li>
</ol>
<p><img src="/assets/1/wps7EAF.tmp-20211222151419-vob6ewr.png"><img src="/assets/1/wps7EB0.tmp-20211222151419-w1gki0n.jpg"></p>
<h1 id="截获Cookie，冒充别人身份"><a href="#截获Cookie，冒充别人身份" class="headerlink" title="截获Cookie，冒充别人身份"></a><strong>截获Cookie，冒充别人身份</strong></h1><p>通过上面这个例子，可以看到cookie是很重要的，识别是否是登陆用户，就是通过cookie。  假如截获了别人的cookie是否可以冒充他人的身份登陆呢？  当然可以， 这就是一种黑客技术叫Cookie欺骗。</p>
<p>利用Cookie 欺骗， 不需要知道用户名密码。就可以直接登录，使用别人的账户做坏事。</p>
<p>我知道有两种方法可以截获他人的cookie，</p>
<ol>
<li>通过XSS脚步攻击， 获取他人的cookie. 具体原理可以看 [<a href="http://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html">Web安全性测试之XSS</a>]</li>
<li>想办法获取别人电脑上保存的cookie文件（这个比较难）</li>
</ol>
<p>拿到cookie后，就可以冒充别人的身份了。 这个过程我就不演示了。</p>
<h1 id="Cookie和文件缓存的区别"><a href="#Cookie和文件缓存的区别" class="headerlink" title="Cookie和文件缓存的区别"></a><strong>Cookie和文件缓存的区别</strong></h1><p>很多人会把cookie和文件缓存弄混淆， 这两个完全是不一样的东西。唯一的相同之处可能是它们俩都存在硬盘上，而且是存在同一个文件夹下。</p>
<p>关于HTTP缓存请看这 【<a href="http://www.cnblogs.com/TankXiao/archive/2012/11/28/2793365.html">HTTP协议之缓存</a>】</p>
<p>我们在IE中可以选择分别删除Cookie和缓存文件</p>
<p><img src="/assets/1/wps7EC1.tmp-20211222151419-9749lqa.png"> <img src="/assets/1/wps7EC2.tmp-20211222151419-x09ud12.jpg"></p>
<h1 id="Cookie-泄露隐私"><a href="#Cookie-泄露隐私" class="headerlink" title="Cookie 泄露隐私"></a><strong>Cookie 泄露隐私</strong></h1><p>2013年央视的315晚会上， 曝光了很多不法公司利用Cookie跟踪并采集用户的个人信息，并转卖给网络广告商，形成了一条窃取用户信息的灰色产业链。从而实现广告准确投放。严重干扰了用户的正常网络应用，侵害了个人的隐私和利益。</p>
<p>我经常就在门户网站上发现广告位上显示的是我在电商网站上流量过的商品。  这就是我的cookie被泄露了。</p>
<p>目前在欧洲， 已经对Cookie立法， 如果网站需要保存用户的cookie, 必须弹出一个对话框，要用户确认后才能保存Cookie.</p>
<h1 id="P3P协议"><a href="#P3P协议" class="headerlink" title="P3P协议"></a><strong>P3P协议</strong></h1><p>从上面看来， Cookie 是一个比较容易泄露用户隐私和危险的东西。  有没有办法保护个人用户隐私呢？    那就是P3P协议</p>
<p>P3P是一种被称为个人隐私安全平台项目（the Platform for Privacy Preferences）的标准，能够保护在线隐私权，使Internet冲浪者可以选择在浏览网页时，是否被第三方收集并利用自己的个人信息。如果一个 站点不遵守P3P标准的话，那么有关它的Cookies将被自动拒绝，并且P3P还能够自动识破多种Cookies的嵌入方式。p3p是由全球资讯联盟网 所开发的。</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>03_网络协议</category>
        <category>904_网络协议文件</category>
        <category>06_http协议</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库命令行操作</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/02_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="查看服务器mysql服务有没有开启"><a href="#查看服务器mysql服务有没有开启" class="headerlink" title="查看服务器mysql服务有没有开启:"></a>查看服务器mysql服务有没有开启:</h3><p>ps -ef | grep mysql<br><img src="/assets/1/image-20211120233959-4dpkuvo.png" alt="image.png"></p>
<hr>
<h3 id="登录到MySQL"><a href="#登录到MySQL" class="headerlink" title="登录到MySQL:"></a><strong>登录到MySQL:</strong></h3><p>mysql -h 主机名 -u 用户名 -p<br>-h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略;<br>-u : 所要登录的用户名;<br>-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。<br><img src="/assets/1/image-20211120234007-btx7xmn.png" alt="image.png"></p>
<hr>
<h2 id="一-查看数据库、表、数据字段、数据"><a href="#一-查看数据库、表、数据字段、数据" class="headerlink" title="一 查看数据库、表、数据字段、数据"></a>一 查看数据库、表、数据字段、数据</h2><h3 id="查看当前所有的数据库："><a href="#查看当前所有的数据库：" class="headerlink" title="查看当前所有的数据库："></a>查看当前所有的数据库：</h3><pre><code>  show  databases；
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/assets/1/image-20211120234015-huoyybn.png" alt="image.png"></h2><h3 id="选择（进入）-数据库："><a href="#选择（进入）-数据库：" class="headerlink" title="选择（进入） 数据库："></a>选择（进入） 数据库：</h3><pre><code> use   数据库名；
</code></pre>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/assets/1/image-20211120234022-bbmujsd.png" alt="image.png"></h2><h3 id="查看当前数据库所有的表："><a href="#查看当前数据库所有的表：" class="headerlink" title="查看当前数据库所有的表："></a>查看当前数据库所有的表：</h3><pre><code>show tables；
</code></pre>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/assets/1/image-20211120234028-ue71c2x.png" alt="image.png"></h2><h3 id="查看-某个表的字段结构-："><a href="#查看-某个表的字段结构-：" class="headerlink" title="查看 某个表的字段结构 ："></a>查看 某个表的字段结构 ：</h3><pre><code> desc  表名；
</code></pre>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="/assets/1/image-20211120234037-6qr8p92.png" alt="image.png"></h2><h3 id="查询表数据："><a href="#查询表数据：" class="headerlink" title="查询表数据："></a>查询表数据：</h3><pre><code> select * from  表名；
</code></pre>
<p><img src="/assets/1/image-20211120234046-g3smurz.png" alt="image.png"></p>
<pre><code>    SELECT user_qq AS &#39;玩家QQ&#39;,user_name AS &#39;玩家昵称&#39;  FROM users    //显示中文别名
    SELECT DISTINCT user_qq  FROM scores    //消除重复行
    SELECT * FROM users LIMIT 2,3           //从下标为2的记录开始，显示3条数据（3-5条数据）
</code></pre>
<hr>
<h2 id="二-新建数据库、数据表（表）、数据（添加数据）"><a href="#二-新建数据库、数据表（表）、数据（添加数据）" class="headerlink" title="二 新建数据库、数据表（表）、数据（添加数据）"></a>二 新建数据库、数据表（表）、数据（添加数据）</h2><h3 id="新建数据库："><a href="#新建数据库：" class="headerlink" title="新建数据库："></a>新建数据库：</h3><pre><code>create  database  数据库名；
</code></pre>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="/assets/1/image-20211120234057-lksi10b.png" alt="image.png"></h2><h3 id="新建表："><a href="#新建表：" class="headerlink" title="新建表："></a>新建表：</h3><pre><code>CREATE TABLE 表名 &lt;
    字段名字   数据类型  修饰,
    ...
 &gt;; 
</code></pre>
<p>注意至少要有一个字段 修饰与数据类型在这里不再详细说明 关键字大写 字段间用，隔开 最后一行不用<br><img src="/assets/1/image-20211120234057-lksi10b.png" alt="image.png"></p>
<hr>
<h3 id="添加数据："><a href="#添加数据：" class="headerlink" title="添加数据："></a>添加数据：</h3><pre><code>insert into 表名 valuse（值，值）；
</code></pre>
<h2 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="/assets/1/image-20211120234114-73elez8.png" alt="image.png"></h2><h2 id="三-修改数据表，修改数据"><a href="#三-修改数据表，修改数据" class="headerlink" title="三 修改数据表，修改数据"></a>三 修改数据表，修改数据</h2><h3 id="修改数据表："><a href="#修改数据表：" class="headerlink" title="修改数据表："></a>修改数据表：</h3><pre><code>alter table 表名 add 字段名 类型 修饰【加的列在表的最后面】
</code></pre>
<p><img src="/assets/1/image-20211120234120-uqqruem.png" alt="image.png"></p>
<pre><code>alter table 表名 add 字段名  类型 修饰 after 某列【把新列加在某列后面】
</code></pre>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="/assets/1/image-20211120234125-0wyw6yo.png" alt="image.png"></h2><h3 id="修改数据："><a href="#修改数据：" class="headerlink" title="修改数据："></a>修改数据：</h3><pre><code> update user set name=新值 where
</code></pre>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a><img src="/assets/1/image-20211120234131-u9lqob9.png" alt="image.png"></h2><h2 id="四-删除数据库，数据表，数据"><a href="#四-删除数据库，数据表，数据" class="headerlink" title="四 删除数据库，数据表，数据"></a>四 删除数据库，数据表，数据</h2><h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><pre><code>drop database 数据库名；
</code></pre>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a><img src="/assets/1/image-20211120234137-i3k1y62.png" alt="image.png"></h2><h3 id="删除数据表："><a href="#删除数据表：" class="headerlink" title="删除数据表："></a>删除数据表：</h3><pre><code> drop  table  表名;
</code></pre>
<h2 id="-9"><a href="#-9" class="headerlink" title=""></a><img src="/assets/1/image-20211120234143-v4gn8sk.png" alt="image.png"></h2><h3 id="删除列："><a href="#删除列：" class="headerlink" title="删除列："></a><strong>删除列：</strong></h3><pre><code>alter table 表名 drop 列名称;
</code></pre>
<h3 id="-10"><a href="#-10" class="headerlink" title=""></a><img src="/assets/1/image-20211120234151-ilexh3g.png" alt="image.png"></h3><hr>
<h3 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h3><pre><code> delete  from  表名 where；
</code></pre>
<h2 id="-11"><a href="#-11" class="headerlink" title=""></a><img src="/assets/1/image-20211120234158-ibmm67v.png" alt="image.png"></h2><h3 id="MySQL有三大类数据类型"><a href="#MySQL有三大类数据类型" class="headerlink" title="MySQL有三大类数据类型"></a>MySQL有三大类数据类型</h3><p>分别为 <strong>数字</strong> 、 <strong>日期\时间</strong> 、 <strong>字符串</strong> 。这三大类中又更细致的划分了许多子类型:<br><strong>整数:</strong> tinyint、smallint、mediumint、int、bigint<br>浮点数: float、double、real、decimal<br>日期和时间: date、time、datetime、timestamp、year<br>字符串: char、varchar<br><strong>文本:</strong> tinytext、text、mediumtext、longtext<br> <strong>二进制</strong> (可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob</p>
<hr>
<p><strong>End</strong></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库语句优化</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/03_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>在MySQL数据库怎么加快查询速度，优化查询效率，主要原则就是应尽量避免全表扫描，应该考虑在where及order by 涉及的列上建立索引。</li>
<li>建立索引不是建的越多越好，原则是：<ul>
<li>第一：一个表的索引不是越多越好，也没有一个具体的数字，根据以往的经验，一个表的索引最多不能超过6个，因为索引越多，对update和insert操作也会有性能的影响，涉及到索引的新建和重建操作。<br>　　第二：建立索引的方法论为：<br>　　多数查询经常使用的列；<br>　　很少进行修改操作的列；<br>　　索引需要建立在数据差异化大的列上<br>　　利用以上的基础我们讨论一下如何优化sql.<h3 id="1、MySQY语句模型结构优化指导"><a href="#1、MySQY语句模型结构优化指导" class="headerlink" title="1、MySQY语句模型结构优化指导"></a>1、MySQY语句模型结构优化指导</h3>　　　　a. ORDER BY + LIMIT组合的索引优化<br>　　　　　　如果一个SQL语句形如：SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort] LIMIT [offset],[LIMIT];<br>　　　　　　这个SQL语句优化比较简单，在[sort]这个栏位上建立索引即可。<br>　　　　b. WHERE + ORDER BY + LIMIT组合的索引优化<br>　　　　　　如果一个SQL语句形如：SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] &#x3D; [VALUE] ORDER BY [sort] LIMIT [offset],[LIMIT];<br>　　　　　　这个语句，如果你仍然采用第一个例子中建立索引的方法，虽然可以用到索引，但是效率不高。更高效的方法是建立一个联合索引(columnX,sort)<br>　　　　c. WHERE+ORDER BY多个栏位+LIMIT<br>　　　　　　 如果一个SQL语句形如：SELECT * FROM [table] WHERE uid&#x3D;1 ORDER x,y LIMIT 0,10;<br>　　　　　　 对于这个语句，大家可能是加一个这样的索引:(x,y,uid)。但实际上更好的效果是(uid,x,y)。这是由MySQL处理排序的机制造成的。<h3 id="2、复合索引-形如-x-y-uid-索引的索引"><a href="#2、复合索引-形如-x-y-uid-索引的索引" class="headerlink" title="2、复合索引(形如(x,y,uid)索引的索引)"></a>2、复合索引(形如(x,y,uid)索引的索引)</h3>　　　　先看这样一条语句这样的：select* from users where area &#x3D;’beijing’ and age&#x3D;22;<br>　　 　 如果我们是在area和age上分别创建索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果area，age两列上创建复合索引的话将带来更高的效率。<br>  　　  在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。<br>　　　 例如我们建立了一个这样的索引（area,age,salary），那么其实相当于创建了（area,age,salary）,(area,age),(area)三个索引，这样称为最佳左前缀特性。<h3 id="3、like语句优化"><a href="#3、like语句优化" class="headerlink" title="3、like语句优化"></a>3、like语句优化</h3>　　　　SELECT id FROM A WHERE name like ‘%abc%’<br> 　　　　　　由于abc前面用了“%”，因此该查询必然走全表查询，除非必要，否则不要在关键词前加%，优化成如下<br>　　　　SELECT id FROM A WHERE name like ‘abc%’<h3 id="4、where子句使用-！-x3D-或-lt-gt-操作符优化"><a href="#4、where子句使用-！-x3D-或-lt-gt-操作符优化" class="headerlink" title="4、where子句使用 ！&#x3D; 或 &lt;&gt; 操作符优化"></a>4、where子句使用 ！&#x3D; 或 &lt;&gt; 操作符优化</h3>　　　　　在where子句中使用 ！&#x3D; 或 &lt;&gt;操作符，索引将被放弃使用，会进行全表查询。<br> 　　　　如SQL:SELECT id FROM A WHERE ID !&#x3D; 5 优化成：SELECT id FROM A WHERE ID&gt;5 OR ID&lt;5<h3 id="5、where子句中使用-IS-NULL-或-IS-NOT-NULL-的优化"><a href="#5、where子句中使用-IS-NULL-或-IS-NOT-NULL-的优化" class="headerlink" title="5、where子句中使用 IS NULL 或 IS NOT NULL 的优化"></a>5、where子句中使用 IS NULL 或 IS NOT NULL 的优化</h3>　　　　在where子句中使用 IS NULL 或 IS NOT NULL 判断，索引将被放弃使用，会进行全表查询。<br>　　 　　如SQL:SELECT id FROM A WHERE num IS NULL 优化成num上设置默认值0，确保表中num没有null值，然后SQL为：SELECT id FROM A WHERE num&#x3D;0<h3 id="6、where子句使用or的优化"><a href="#6、where子句使用or的优化" class="headerlink" title="6、where子句使用or的优化"></a>6、where子句使用or的优化</h3>　　　　很多时候使用union all 或 nuin(必要的时候)的方式替换“or”会得到更好的效果。where子句中使用了or,索引将被放弃使用。<br>　　 　　如SQL:SELECT id FROM A WHERE num &#x3D;10 or num &#x3D; 20 优化成：SELECT id FROM A WHERE num &#x3D; 10 union all SELECT id FROM A WHERE num&#x3D;20<h3 id="7、where子句使用IN-或-NOT-IN的优化"><a href="#7、where子句使用IN-或-NOT-IN的优化" class="headerlink" title="7、where子句使用IN 或 NOT IN的优化"></a>7、where子句使用IN 或 NOT IN的优化</h3>　　　　in和not in 也要慎用，否则也会导致全表扫描。<br>　　 　　方案一：between替换in<br>　　 　　　　如SQL:SELECT id FROM A WHERE num in(1,2,3) 优化成：SELECT id FROM A WHERE num between 1 and 3<br>　　 　　方案二：exist替换in<br>　　 　　　　如SQL:SELECT id FROM A WHERE num in(select num from b ) 优化成：SELECT num FROM A WHERE num exists(select 1 from B where B.num &#x3D; A.num)<br>　　 　　方案三：left join替换in<br>　　　　　　如SQL:SELECT id FROM A WHERE num in(select num from B) 优化成：SELECT id FROM A LEFT JOIN B ON A.num &#x3D; B.num<h3 id="8、where子句中对字段进行表达式操作的优化"><a href="#8、where子句中对字段进行表达式操作的优化" class="headerlink" title="8、where子句中对字段进行表达式操作的优化"></a>8、where子句中对字段进行表达式操作的优化</h3>　　　　不要在where子句中的“&#x3D;”左边进行函数、算数运算或其他表达式运算，否则系统将可能无法正确使用索引。<br>　　 　　如SQL:SELECT id FROM A WHERE num&#x2F;2 &#x3D; 100 优化成：SELECT id FROM A WHERE num &#x3D; 100*2<br>　　 　　如SQL:SELECT id FROM A WHERE datediff(day,createdate,’2016-11-30’)&#x3D;0 优化成：SELECT id FROM A WHERE createdate&gt;&#x3D;’2016-11-30’ and createdate&lt;’2016-12-1’<br>　　 　　如SQL:SELECT id FROM A WHERE year(addate) &lt;2016 优化成：SELECT id FROM A where addate&lt;’2016-01-01’<h3 id="9、任何地方都不要用-select-from-table-，用具体的字段列表替换”-”，不要返回用不到的字段"><a href="#9、任何地方都不要用-select-from-table-，用具体的字段列表替换”-”，不要返回用不到的字段" class="headerlink" title="9、任何地方都不要用 select * from table ，用具体的字段列表替换”*”，不要返回用不到的字段"></a>9、任何地方都不要用 select * from table ，用具体的字段列表替换”*”，不要返回用不到的字段</h3><h3 id="10、使用“临时表”暂存中间结果"><a href="#10、使用“临时表”暂存中间结果" class="headerlink" title="10、使用“临时表”暂存中间结果"></a>10、使用“临时表”暂存中间结果</h3>　　　　采用临时表暂存中间结果好处：<br>　　　　　　（1）避免程序中多次扫描主表，减少程序执行“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。<br>　　　　　　（2）尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。<br>　　　　　　（3）避免频繁创建和删除临时表，以减少系统资源的浪费。<br>　　　　　　（4）尽量避免向客户端返回大数据量，若数据量过大，应考虑相应需求是否合理。<h3 id="11、limit分页优化"><a href="#11、limit分页优化" class="headerlink" title="11、limit分页优化"></a>11、limit分页优化</h3>　　　　　　总数据有500万左右，以下例子<br> 　　　　　　select * from wl_tagindex where byname&#x3D;’f’ order by id limit 300000,10 执行时间是 3.21s<br>　　　　　　优化后：<br>　　　　　　　　select * from (<br> 　　　　　　　　　　select id from wl_tagindex<br>　　　　　　　　　　where byname&#x3D;’f’ order by id limit 300000,10<br>　　　　　　　　) a<br>　　　　　　　　left join wl_tagindex b on a.id&#x3D;b.id<br> 　　　　　　执行时间为 0.11s 速度明显提升<br> 　　　　　　这里需要说明的是 我这里用到的字段是 byname ,id 需要把这两个字段做复合索引，否则的话效果提升不明显<h3 id="12、批量插入优化"><a href="#12、批量插入优化" class="headerlink" title="12、批量插入优化"></a>12、批量插入优化</h3>　　　　　　INSERT into person(name,age) values(‘A’,14)<br>　　　　　　INSERT into person(name,age) values(‘B’,14)<br>　　　　　　INSERT into person(name,age) values(‘C’,14)<br>　　　　可优化为：<br>　　　　　　INSERT into person(name,age) values(‘A’,14),(‘B’,14),(‘C’,14),<h3 id="13、利用limit-1-、top-1-取得一行，"><a href="#13、利用limit-1-、top-1-取得一行，" class="headerlink" title="13、利用limit 1 、top 1 取得一行，"></a>13、利用limit 1 、top 1 取得一行，</h3>　　　　但是需要注意的是，Top关键字只能在SQL Server数据库中可以使用，而在MySQL数据库中就要使用具有同样功能的LIMIT函数<br>　　　　有时要查询一张表时，你知道只需要看一条记录，你可能去查询一条特殊的记录。可以使用limit 1 或者 top 1 来终止数据库索引继续扫描整个表或索引。<br>　　　　如SQL：SELECT id FROM A LIKE ‘abc%’ 优化为：SELECT id FROM A LIKE ‘abc%’ limit 1<h3 id="14、尽量不要使用-BY-RAND-命令"><a href="#14、尽量不要使用-BY-RAND-命令" class="headerlink" title="14、尽量不要使用 BY RAND()命令"></a>14、尽量不要使用 BY RAND()命令</h3>　　　　BY RAND()是随机显示结果，这个函数可能会为表中每一个独立的行执行BY RAND()命令，这个会消耗处理器的处理能力。<br>　　　　如SQL：SELECT * FROM A order by rand() limit 10 优化为：SELECT * FROM A WHERE id &gt;&#x3D; ((SELECT MAX(id) FROM A)-(SELECT MIN(id) FROM A)) * RAND() + (SELECT MIN(id) FROM A) LIMIT 10<h3 id="15、排序的索引问题"><a href="#15、排序的索引问题" class="headerlink" title="15、排序的索引问题"></a>15、排序的索引问题</h3>　　 　Mysql查询只是用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求情况下不要使用排序操作；<br>　　　尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。<h3 id="16、尽量用-union-all-替换-union"><a href="#16、尽量用-union-all-替换-union" class="headerlink" title="16、尽量用 union all 替换 union"></a>16、尽量用 union all 替换 union</h3>　　　union和union all的差异主要是前者需要将两个（或者多个）结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的cpu运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用union all而不是union<h3 id="17、避免类型转换"><a href="#17、避免类型转换" class="headerlink" title="17、避免类型转换"></a>17、避免类型转换</h3>　　　这里所说的“类型转换”是指where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换。人为的上通过转换函数进行转换，直接导致mysql无法使用索引。如果非要转型，应该在传入参数上进行转换。<br> 　例如utime 是datetime类型，传入的参数是“2016-07-23”，在比较大小时通常是 date（utime）&gt;”2016-07-23”,可以优化为utime&gt;”2016-07-23 00：00：00”<h3 id="18、尽可能使用更小的字段"><a href="#18、尽可能使用更小的字段" class="headerlink" title="18、尽可能使用更小的字段"></a>18、尽可能使用更小的字段</h3>　　　　MySQL从磁盘读取数据后是存储到内存中的，然后使用cpu周期和磁盘I&#x2F;O读取它，这意味着越小的数据类型占用的空间越小，从磁盘读或打包到内存的效率都更好，但也不要太过执着减小数据类型，要是以后应用程序发生什么变化就没有空间了。<br>　　　　修改表将需要重构，间接地可能引起代码的改变，这是很头疼的问题，因此需要找到一个平衡点。<h3 id="19、Inner-join-和-left-join、right-join、子查询"><a href="#19、Inner-join-和-left-join、right-join、子查询" class="headerlink" title="19、Inner join 和 left join、right join、子查询"></a>19、Inner join 和 left join、right join、子查询</h3>　　第一：inner join内连接也叫等值连接是，left&#x2F;rightjoin是外连接。<br>　　　　 SELECT A.id,A.name,B.id,B.name FROM A LEFT JOIN B ON A.id &#x3D;B.id;<br>　　　　 SELECT A.id,A.name,B.id,B.name FROM A RIGHT JOIN ON B A.id&#x3D; B.id;<br>　　　　 SELECT A.id,A.name,B.id,B.name FROM A INNER JOIN ON A.id &#x3D;B.id;<br>　　 　　经过来之多方面的证实inner join性能比较快，因为inner join是等值连接，或许返回的行数比较少。但是我们要记得有些语句隐形的用到了等值连接，如：<br>　　　　SELECT A.id,A.name,B.id,B.name FROM A,B WHERE A.id &#x3D; B.id;<br>　　　　推荐：能用inner join连接尽量使用inner join连接<br>　　 第二：子查询的性能又比外连接性能慢，尽量用外连接来替换子查询。<br>　　　　Select* from A where exists (select * from B where id&gt;&#x3D;3000 and A.uuid&#x3D;B.uuid);<br>　　　　A表的数据为十万级表，B表为百万级表，在本机执行差不多用2秒左右，我们可以通过explain可以查看到子查询是一个相关子查询(DEPENDENCE SUBQUERY);Mysql是先对外表A执行全表查询，然后根据uuid逐次执行子查询，如果外层表是一个很大的表，我们可以想象查询性能会表现比这个更加糟糕。<br>　　一种简单的优化就是用innerjoin的方法来代替子查询，查询语句改为：<br>　　　Select* from A inner join B ON A.uuid&#x3D;B.uuid using(uuid) where b.uuid&gt;&#x3D;3000;  这个语句执行测试不到一秒；<br>　　第三：使用JOIN时候，应该用小的结果驱动打的结果（left join 左边表结果尽量小，如果有条件应该放到左边先处理，right join同理反向），同时尽量把牵涉到多表联合的查询拆分多个query (多个表查询效率低，容易锁表和阻塞)。如：<br>　　Select * from A left join B A.id&#x3D;B.ref_id where  A.id&gt;10;可以优化为：select * from (select * from A wehre id &gt;10) T1 left join B on T1.id&#x3D;B.ref_id;<br>　　20、exist 代替 in<br>SELECT * from A WHERE idin (SELECT id from B)<br>SELECT * from A WHERE id EXISTS(SELECT 1 from A.id&#x3D; B.id)<br>　　in 是在内存中遍历比较<br>　　exist 需要查询数据库，所以当B的数据量比较大时，exists效率优于in.<br>　　in()只执行一次，把B表中的所有id字段缓存起来，之后检查A表的id是否与B表中的id相等，如果id相等则将A表的记录加入到结果集中，直到遍历完A表的所有记录。<br>　　In 操作的流程原理如同一下代码<br>　　　　List resultSet&#x3D;{};<br>　　　　Array A&#x3D;(select * from A);<br>　　　　Array B&#x3D;(select id from B);<br>　　　　for(int i&#x3D;0;i&lt;A.length;i++) {<br>　　　　　　for(int j&#x3D;0;j&lt;B.length;j++) {<br>　　　　　　　　if(A[i].id&#x3D;&#x3D;B[j].id) {<br>　　　　　　　　　　resultSet.add(A[i]);<br>　　　　　　　　　　break;<br>　　　　　　　　}<br>　　　　　　}<br>　　　　}<br>　　　return resultSet;<br>　　可以看出，当B表数据较大时不适合使用in()，因为它会B表数据全部遍历一次<br>　　如：A表有10000条记录，B表有1000000条记录，那么最多有可能遍历10000<em>1000000次，效率很差。<br>　　再如：A表有10000条记录，B表有100条记录，那么最多有可能遍历10000</em>100次，遍历次数大大减少，效率大大提升。<br>　　结论：in()适合B表比A表数据小的情况<br>　　exist()会执行A.length()次，执行过程代码如下<br>　　　　List resultSet&#x3D;{};<br>　　　　Array A&#x3D;(select * from A);<br>　　　　for(int i&#x3D;0;i&lt;A.length;i++) {<br>　　　　　　if(exists(A[i].id) { &#x2F;&#x2F;执行select 1 from B where B.id&#x3D;A.id是否有记录返回<br>　　　　　　　　resultSet.add(A[i]);<br>　　　　　　}<br>　　　　}<br>　　　　return resultSet;<br>　　当B表比A表数据大时适合使用exists()，因为它没有那么多遍历操作，只需要再执行一次查询就行。<br>　　如：A表有10000条记录，B表有1000000条记录，那么exists()会执行10000次去判断A表中的id是否与B表中的id相等。<br>　　如：A表有10000条记录，B表有100000000条记录，那么exists()还是执行10000次，因为它只执行A.length次，可见B表数据越多，越适合exists()发挥效果。<br>　　再如：A表有10000条记录，B表有100条记录，那么exists()还是执行10000次，还不如使用in()遍历10000*100次，因为in()是在内存里遍历比较，而exists()需要查询数据库，<br>　　我们都知道查询数据库所消耗的性能更高，而内存比较很快。<br>　　结论：exists()适合B表比A表数据大的情况<br>　　 当A表数据与B表数据一样大时，in与exists效率差不多，可任选一个使用。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>接口测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/01_%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<ol>
<li><h3 id="什么情况下会进行接口测试"><a href="#什么情况下会进行接口测试" class="headerlink" title="什么情况下会进行接口测试"></a>什么情况下会进行接口测试</h3><ol>
<li>版本一：后台开发出来，但前端页面还没有完成，需要对后台开发出来的功能进行测试</li>
<li>版本二：一般有需求就会做，后台的接口开发好，就可以开始测。例外，如果增加了新需求，也要做接口测试，还有就是开发对后台的接口做了修改，交互逻辑发生变化，我们也要重新对接口进行测试。</li>
</ol>
</li>
<li><h2 id="接口测试的目的-x2F-为什么要进行接口测试"><a href="#接口测试的目的-x2F-为什么要进行接口测试" class="headerlink" title="接口测试的目的&#x2F; 为什么要进行接口测试"></a>接口测试的目的&#x2F; 为什么要进行接口测试</h2><ol>
<li>可以前置测试时间，减少测试成本，提高测试效率，能够今早的定位缺陷尽早修复</li>
</ol>
</li>
<li><h2 id="接口测试的主要辅助工具—-gt-lt-桩模块-gt"><a href="#接口测试的主要辅助工具—-gt-lt-桩模块-gt" class="headerlink" title="接口测试的主要辅助工具—&gt;&lt;桩模块&gt;"></a>接口测试的主要辅助工具—&gt;&lt;桩模块&gt;</h2><ol>
<li><a href="/05_测试工具/02_接口测试篇/02_postman/01_postman/" target="_blank">postman</a> <br/></li>
<li><a href="/05_测试工具/02_接口测试篇/01_jmeter/01_jmeter/" target="_blank">jmeter</a><br/></li>
<li><a href="/05_测试工具/02_接口测试篇/03_soapUI/01_soapUI/" target="_blank">soapUI</a></li>
<li>apipost：<a href="https://www.apipost.cn/">ApiPost - API 文档、调试、Mock、测试一体化协作平台</a></li>
<li>mock： 模拟数据，当前端开发出来，后端接口不能使用时可以模拟数据</li>
</ol>
</li>
<li><h2 id="什么是接口测试？"><a href="#什么是接口测试？" class="headerlink" title="什么是接口测试？"></a>什么是接口测试？</h2><ol>
<li>系统与系统，模块与模块之间数据的交互、调用</li>
<li>api是接口的通道，每个系统都有自己的格式</li>
<li>桩模块：模拟被测模块的上级模块，相当于镜子一样</li>
</ol>
</li>
<li><h2 id="接口的类型"><a href="#接口的类型" class="headerlink" title="接口的类型"></a>接口的类型</h2><ol>
<li>websever、MQ、scoket、http<ol>
<li>websever：通用型接口，主要用于网络的数据传输，格式xml</li>
<li>MQ：属于消息队列，适用于大型的软件架构，数据传输的速度快，量大，稳定   银行业务</li>
<li>scoket：既是接口类型又是协议，它可以自定义端到端的接口，采用的是tcp、udp通信协议</li>
<li>http：即是接口类型又是协议，属于超文本传输协议，他是开发定义好的，我们只是拿来直接使用<ol>
<li>http分为两个底层接口类型：soap、rest</li>
<li>soap：http中底层接口传输协议，格式xml，属于软件架构的风格</li>
<li>rest：http中底层接口传输协议，格式json，属于简单的访问对象</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口的格式"><a href="#接口的格式" class="headerlink" title="接口的格式"></a>接口的格式</h3><ol>
<li>json、xml、HTML、raw<ol>
<li>json表示：{}</li>
<li>xml表示：&lt;&gt;</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口的请求方式"><a href="#接口的请求方式" class="headerlink" title="接口的请求方式"></a>接口的请求方式</h3><ol>
<li><h4 id="get、post、delete、put、head"><a href="#get、post、delete、put、head" class="headerlink" title="get、post、delete、put、head"></a>get、post、delete、put、head</h4><ol>
<li>get：从服务器获取信息</li>
<li>post：先上传信息，再从服务器获取信息</li>
</ol>
</li>
<li><h4 id="get与post的区别"><a href="#get与post的区别" class="headerlink" title="get与post的区别"></a>get与post的区别</h4><ol>
<li>从服务器来讲:  get比post安全，get只是从服务器上面获取信息而post可以修改服务器的信息</li>
<li>从客户端来讲：post比get安全，因为get的请求数据是加在url后面，而post是附加在请求包体里面的</li>
<li>传参大小不一样，get有字节限制(1024&#x2F;2048)，而post在理论上是没有限制的</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="接口测试中职责的划分"><a href="#接口测试中职责的划分" class="headerlink" title="接口测试中职责的划分"></a>接口测试中职责的划分</h2><ol>
<li>测试的建立：开发人员、测试人员、数据库管理人员、系统的负责人</li>
<li>测试的执行：测试人员</li>
<li>测试结果的确认：开发组长、测试组长</li>
</ol>
</li>
<li><h2 id="接口测试的对象"><a href="#接口测试的对象" class="headerlink" title="接口测试的对象"></a>接口测试的对象</h2><ol>
<li>模块接口测试、web接口测试<br> web接口测试：服务器接口测试     外部接口测试<br> 模块接口测试：以单元测试为基础，适用于开发的异常的功能模块<br> 服务端接口测试：客户端、服务端、浏览器<br> 外部接口测试：调用第三方的接口</li>
</ol>
</li>
<li><h2 id="接口测试的原则："><a href="#接口测试的原则：" class="headerlink" title="接口测试的原则："></a>接口测试的原则：</h2><ol>
<li>不同的接口参数覆盖不同的业务场景</li>
<li>参数能被运用到不同的场景中</li>
<li>测试的数据要与业务进行分离</li>
<li>尽量统一共用测试环境</li>
<li>测试完成后删除不必要的测试数据</li>
</ol>
<p> <strong>注释：接口测试是最简单的测试，但又是最严格的测试；还可以把接口测试称之为没有界面的功能测试</strong></p>
</li>
<li><h2 id="接口测试流程"><a href="#接口测试流程" class="headerlink" title="接口测试流程"></a>接口测试流程</h2><ol>
<li>首先跟开发要接口文档，对文档进行分析并编写测试用例，和开发进行用例评审，使用公司中的接口测试工具进行测试，关注：接口的协议、IP、端口号、路径、以及请求方式、请求参数，然后执行测试，关注：接口返回的格式、字段名、字段值的内容是否和添加的参数内容相照应<br> <strong>注释：不能和项目结合着说、登录的接口不要说&lt;太简单&gt;</strong></li>
</ol>
</li>
<li><h1 id="postman中如何连接两个接口"><a href="#postman中如何连接两个接口" class="headerlink" title="postman中如何连接两个接口"></a>postman中如何连接两个接口</h1> 1、获取上一个接口的返回值<br> 2、用一个环境变量或全局变量来接受这个返回值<br> 3、用此环境变量或者全局变量作为下一个接口的参数</li>
<li><h3 id="你们接口测试具体怎么做？"><a href="#你们接口测试具体怎么做？" class="headerlink" title="你们接口测试具体怎么做？"></a>你们接口测试具体怎么做？</h3><ol>
<li>一般开发把接口开发出来之后，会给到我们一个接口文档，首先要搞清楚这个接口的功能，它的作用是什么，请求方式，有哪些参数。参数有什么限制，类型是什么，是否必填，对于参数有不清楚的， 一般我们会问下开发，通过以上几个点去设计用例。<br> 设计好用例之后，我们利用工具进行检测，我们公司当时用的是 JMeter 来做接口测试的。<br> 首先我们要建立一个线程组,然后添加取样器（http 请求），然后填写接口的协议，地址，端口，请求方式，<br> 路径，及根据用例填写请求参数，添加一个监听器去查看接口返回的数据，然后执行，然后依据接口文档对比返回的数据是否与预期结果一致，<br> 对于返回的响应的数据的检查，我们主要关注以下几个点：状态码，提示信息，具体的正文内容，看与接口文档说明的是否一致，如果有问题，我们先大概分析下，看是否能定位出具体原因，实在不行就直接提 Bug给开发，让开发修复，之后最回归复测。</li>
</ol>
</li>
<li><h3 id="两个接口有关联，JMeter具体怎么做"><a href="#两个接口有关联，JMeter具体怎么做" class="headerlink" title="两个接口有关联，JMeter具体怎么做"></a>两个接口有关联，<strong>JMeter</strong>具体怎么做</h3><ol>
<li>另外两种问法：上个接口的返回值是下个接口的请求参数，这种如何处理？动态关联有没有了解过？<ol>
<li>这个涉及到动态关联，首先要搞清楚后一个接口需要用到上一个接口的什么数据，例外要看数据是在哪里取的，是在 head 还是在 body 里，然后如果要取的数据是 json 格式我会在发请求用 json 提取器去取这个数据，如果是其他格式的就用边界提取器或正则表达式去取数据。就拿我当时做的那个下单接口来说吧，因为下单接口需要先登录，需要用到登录接口的 cookies来做鉴权，首先就是把登录接口调试通过，然后在登录接口的http请求中添加一个边界值提取器或者也可以用正则表示式提取器去提取登录接口的响应头中的 cookies值，然后在下单接口中需要添加一个http cookies管理器，在http cookies管理器中引用登录接口提取出来的 cookies，这样就可以了。</li>
<li>如果是不同的线程组的话，那在登录接口中还得添加一个 Beanshell 取样器，在 BeanShell 取样器中， 利用函数助手中的 SetProperty()函数把提取出来的 cookies 设置为全局变量。然后在下单接口的 http cookies 管理器中利用函数助手中的Property()函数引用登录接口中设置的全局变量，这样就可以了。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口测试的工作流程"><a href="#接口测试的工作流程" class="headerlink" title="接口测试的工作流程"></a>接口测试的工作流程</h3> 1，首先分析开发给到的接口文档<br> 2，接口文档分析完成，编写测试用例<br> 3，然后借助接口测试工具去测试执行测试用例<br> 4，发现bug 提交 bug,并跟进 bug 修复。</li>
<li><h3 id="给你一个新的接口，你怎么去设计用例？"><a href="#给你一个新的接口，你怎么去设计用例？" class="headerlink" title="给你一个新的接口，你怎么去设计用例？"></a>给你一个新的接口，你怎么去设计用例？</h3><ol>
<li>首先要对于每个要测的接口都要先搞清楚这个接口的功能，它的作用是什么，熟悉这个业务功能需要用到什么协议，请求方式是什么，接口有哪些参数。对于每个参数的作用都要搞清楚，像数的类型，是否有约束限制，是否为必填的，长度，其他的限制等等，如果两个参数之间有关联我们还要考虑参数的组合场景，对于参数不理解的，一般都会跟开发沟通下，然后考虑返回数据的类型，返回数据中的返回码和返回信息是什么，通过以上几个点去提炼测试点，设计用例。<br> 最好拿一个具体的例子进行说明      比如：在方维的项目中当时做过的一个注册接口来说，这个注册接口总共有用户名，手机号码，密码，确认密码，推荐人 5 个主要的参数，而其中用户名，手机号码，密码，确认密码这几个参数是必填的，用户名要求在 3-15个字符之间，密码限制要求在长度在6~16 之间，只能包含字符、数字和下划线。其他的参数没有限制约束，而密码与确认密码两个参数是有关联的，我们需要考虑他们的组合场景。分析好接口的具体情况之后，我主要是通过等价类，边界值，判定表等方法来设计用例。对于这个注册接口我当时从以下几个点来设计用例的：<br> 文本框: <ol>
<li><pre><code>首先是用户名我主要考虑的点有：
</code></pre>
</li>
<li>有效的用户名</li>
<li>无效的场景：	等价类用户名小于 3 个字符用户名大于 15 个字符用户名等于 3 个字符用户名等 15 个字符</li>
<li>重复的用户名</li>
<li>空值</li>
<li>敏感字符的用户名比如：中国共产党</li>
<li>对于密码这块我会从以下几个方面去考虑设计用例：</li>
<li>考虑密码与确认密码一致</li>
<li>密码与确认密码不一致有效：</li>
<li>正确的密码无效：</li>
<li>密码小于 6 个字符</li>
<li>密码大于 16 个字符</li>
<li>密码等于 6 个字符</li>
<li>密码等于 16 个字符</li>
<li>密码包含了除字符，数字，下划线以外的字符</li>
<li>空值3.手机号码：</li>
<li>正确的手机号码</li>
<li>错误的手机号码</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="接口文档主要包含哪些内容？"><a href="#接口文档主要包含哪些内容？" class="headerlink" title="接口文档主要包含哪些内容？"></a>接口文档主要包含哪些内容？</h3><ol>
<li>接口文档一般两种形式的，要不就是 word 版本的要不就是<br> html 的形式，具体内容<ol>
<li>URL（接口地址）</li>
<li>接口功能</li>
<li>请求方式：post</li>
<li>请求参数，以及接口中每个参数的详细说明，类型，是否为必填，约束条件啊等等</li>
<li>响应数据及格式， 返回码，返回码解释等等</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="你怎么去检查接口，分析接口"><a href="#你怎么去检查接口，分析接口" class="headerlink" title="你怎么去检查接口，分析接口"></a>你怎么去检查接口，分析接口</h3><ol>
<li>我们主要是根据入参情况，去看接口的返回值，对于返回值，我主要关注的几个点：1. 状态码 2. 提示信息 3.  返回数据的具体内容。根据接口文档的说明去检查这个 3 个点是否满足接口需求文档，4、有些如果要检查数据库的，就连接数据库获取数据与返回的数据做对比。如果不满足就是有问题，如果满足则通过。如果有Bug,我们会先大概分析下，是什么原因，并进行复测，如果还是有问题，提交Bug 给开发，让开发修复，之后再回归。</li>
</ol>
</li>
<li><h3 id="依赖于第三方的接口如何测试"><a href="#依赖于第三方的接口如何测试" class="headerlink" title="依赖于第三方的接口如何测试"></a>依赖于第三方的接口如何测试</h3> 1，需要第三方接口的，接口文档<br> 2，发送请求到第三方接口，检查第三方接口返回的数据是否正确<br> 3，不正确的时候，要跟第三方接口联调，看是请求问题，还是第三方接口返回数据有误<br> 这个我们公司的第三方接口，我们都是打通的，比如电商，我们通过调用微信接口等等都是打通的，比如要测试下单第三支付，我们自己开店，收款设置我们自己的账号，然后通过商品设计 1 分钱，去测试的如果不打通的话，基本也只能抓包，主要保证我们发送出去的数据符合需求文档就行，然后真正的上线之前，我们会在预生产环境做一个联调测试，把各自系统连在一起，做一个联调测试没有问题了<br> 我们就可以上线，基本就这么做的<br> 联调测试怎么做的：<br> 其实联调测试就是数据拉通测试，两个子系统，连在一起，形成一个完整的系统，然后从上游下数据，<br> 下游接到数据，看传过来的数据是否符合下游的系统要求然后下游做了操作，把数据返回给上游，通知上游说数据返回了，上游看返回的数据是否符合要求，如果没有问题，就这个数据就拉通成功这个都是按照用例来执行，上游和下游一起出一份用例，两边都评审通过，然后按照测试用例执行，每条用例测试通过那么联调测就完成了</li>
<li><h3 id="接口工具-jmeter用到哪些组件，具体作用"><a href="#接口工具-jmeter用到哪些组件，具体作用" class="headerlink" title="接口工具 jmeter用到哪些组件，具体作用"></a>接口工具 <strong>jmeter</strong>用到哪些组件，具体作用</h3><ol>
<li>取样器：<br> http请求                                                                                    #向服务器发http请求<br> JDBCRequst                                                                                          # 向数据库发请求<br> DebugSampler                                                                                     #调试，看执行过程<br> BeanShell取 样器                                            #把某个变量设置定位全局变量<br> 后置处理器：<br> 正则表达式提取器<br> #提取接口的响应内容或请求内容中的数据具体要提什么数据根据需求来，比如我们充值接口依赖登录接口，需要用到登录接口的cookie，需要提取cookie<br> 边界值提取器<br> JSON 提取器<br> BeanShellPostPrecessor                                                      #在请求结束之后需要做的某些事情，比如转码<br> 断言： #检验结果，验证本接口是否有问题响应断言<br> Json 断 言配置元件：<br> CSV<br> dataSetConfig                                                               # 读取 CSV文件，txt文件<br> JDBCConnectionConfiguration                                       # 连接数据库HTTPCookie管理器<br> HTTP信息头管理器用户定义的变量<br> 计数器定时器：同步定时器，主要用来设置集合点。监听器<br> 查看结果树</li>
</ol>
</li>
<li><h3 id="上传文件的接口用-JMeter怎么做"><a href="#上传文件的接口用-JMeter怎么做" class="headerlink" title="上传文件的接口用 JMeter怎么做"></a>上传文件的接口用 <strong>JMeter</strong>怎么做</h3><ol>
<li>例外一种问法：有没有做过文件上传的接口，具体怎么做？<br> 要测试上传文件的接口，在 JMeter 的http 请求这个组件中传递请求参数的栏目中专门提供了一个用来文件上传的，在这里面需要填写几个内容，一个就是文件的路径，还有一个就会参数名称，还有就是MIME 类型也就是指定要上传的文件的类型，这样就可以了。</li>
</ol>
</li>
<li><h3 id="对于POST请求，要求传递Json格式数据，JMeter怎么做"><a href="#对于POST请求，要求传递Json格式数据，JMeter怎么做" class="headerlink" title="对于POST请求，要求传递Json格式数据，JMeter怎么做"></a>对于<strong>POST</strong>请求，要求传递<strong>Json</strong>格式数据，JMeter怎么做</h3><ol>
<li>对于这个其实在 JMeter的 http请求这个组件中的参数配置栏目中，第二个栏目有一个消息体数据， 我们把需要上传的参数组装成 json格式，然后编写到 body data里面，然后，需要在http信息头管理其中，需要将数据格式设置为 json格式，这个就是设置 Content-Type为 application&#x2F;json;charset&#x3D;utf-8， 这样就可以了。</li>
</ol>
</li>
<li><h3 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h3></li>
</ol>
<ul>
<li>Charles  ，抓包   </li>
<li><a href="/02_测试理论/02_第二章接口测试05_测试工具/13_web安全测试工具/12_Charles/01_charles安装与使用/" target="_blank">Charles安装</a></li>
<li><a href="https://www.charlesproxy.com/documentation/welcome/">官方文档</a></li>
<li>Fiddler（windows好用） </li>
<li><a href="/02_测试理论/02_第二章接口测试05_测试工具/13_web安全测试工具/11_fiddler/01_Fiddler/" target="_blank">fiddler安装、配置与使用</a><ul>
<li>wireshark<ul>
<li><a href="https://wireshark.en.softonic.com/">官网1</a></li>
<li><a href="https://www.wireshark.org/download.html">官网2</a></li>
<li><a href="https://www.wireshark.org/">官网3</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="24">
<li><h3 id="没有接口文档的时候怎么做接口测试？"><a href="#没有接口文档的时候怎么做接口测试？" class="headerlink" title="没有接口文档的时候怎么做接口测试？"></a>没有接口文档的时候怎么做接口测试？</h3><ol>
<li>首先，做接口测试，有接口文档比没有接口文档的效率要高很多，所以在条件允许的情况下，还是尽可能的要搞一份接口文档出来。</li>
<li>其次，如果没有接口文档，但是系统已经集成接口，并且有UI界面，那么我们可以借助于抓包工具来抓取接口信息。启动并设置好抓包工具比如Fiddler，然后在UI界面进行操作，在Fiddler中就可以查看接口的请求和响应，根据请求和响应的相关信息，反推接口信息，比如请求的方法、地址、参数、响应报文等等。必要的时候，我们需要在UI界面做实验，以获取或者猜测接口信息。获取到接口信息后，就可以依据接口的要素信息设计测试用例，利用测试工具Jmeter等来对接口进行测试。这个过程相对来说多了一个收集接口信息的步骤，时间长，还可能出错，所以比有接口文档的测试效率，要低了很多。</li>
</ol>
</li>
<li><h3 id="postman-可直接下载安装"><a href="#postman-可直接下载安装" class="headerlink" title="postman  可直接下载安装"></a>postman  可直接下载安装</h3><ol>
<li><h6 id="官网"><a href="#官网" class="headerlink" title="官网"></a><a href="https://www.postman.com/">官网</a></h6></li>
<li>默认安装</li>
</ol>
</li>
<li><h2 id="jmeter是怎么安装的？"><a href="#jmeter是怎么安装的？" class="headerlink" title="jmeter是怎么安装的？"></a>jmeter是怎么安装的？</h2><ol>
<li>查看是否有jdk      打开cmd     输入java或者javac</li>
<li>没有则安装jdk</li>
<li>配置jdk环境变量</li>
<li>下载jmeter，解压，配置jmeter环境变量</li>
<li>打开bin 目录下的.bat文件运行jmeter</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>02_第二章接口测试</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/01_linux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ol>
<li><h2 id="Linux-在VMware安装步骤"><a href="#Linux-在VMware安装步骤" class="headerlink" title="Linux 在VMware安装步骤"></a><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/01_VMware/01_VMware/">Linux 在VMware安装步骤</a></h2></li>
<li><h2 id="对-linux熟不熟悉，具体怎么用的？"><a href="#对-linux熟不熟悉，具体怎么用的？" class="headerlink" title="对 linux熟不熟悉，具体怎么用的？"></a>对 <strong>linux</strong>熟不熟悉，具体怎么用的？</h2><ol>
<li>监控一些系统资源的情况</li>
<li>linux 的话，我们在测试中也会经常用到基本的一些命令，主要就是搭建部署环境这块，一般开发完成一个新的版本的时候，都会给我们提供一个可测版本的源码包，我们需要把源码包部署到测试环境中。例外，当我们测试过程中发现问题的时候，需要协助开发去定位，分析，帮助开发查找具体的问题原因。这里我们经常需要去查看项目的日志文件，像这块，我们用得比较多的就是文件查看，信息过滤相关的命令，比如：cat ,tail -f,grep等其他的话，我们有时候也需要实时去关注项目的进程，端口的一些资源情况，这个我们需要用到 ps-ef,ps -aux, netstat -anp 等相关的命令。</li>
</ol>
</li>
<li><h2 id="Xshell使用教程"><a href="#Xshell使用教程" class="headerlink" title="Xshell使用教程"></a><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/04_Linux%E7%9B%B8%E5%85%B3/02_Xshell/01_Xshell/">Xshell使用教程</a></h2></li>
<li><h2 id="Linux-的常用命令？"><a href="#Linux-的常用命令？" class="headerlink" title="Linux 的常用命令？"></a>Linux 的常用命令？</h2><ol>
<li>提示：可借助第三方工具连接使用，我们使用xshell学习</li>
<li>常用命令：<ol>
<li>ls 显示当前路径下的文件和文件夹（横向显示）<br> ll 显示当前路径下的文件和文件夹（竖向显示）<br> ls +空格+  -a  显示当前路径下的所有隐藏文件（a称为参数，a为所有的意思）<br> D  rwx rwx rwx<br />3   peng<ul>
<li>rw- rw- r–<br />1   peng<br> 首个D表示文件夹，第一个rwx 用户，第二组用户组，第三组表示其他<br> 首个 - 表示文件，文件类型，peng 用户，文件大小，日期，时间，文件名<br> Mkdir 新建文件夹<br> Mkdir + 空格 +新的文件夹名<br> Touch  新建文件<br> Touch + 空格 +新建的文件名<br> Clear  清除当前屏幕内容<br> Rm + 空格 + -f （r递归，f强制，-rf强制性递归删除）<br>  Cp+ 空格+ 文件名路径（复制文件）*表示所有<br> Mv移动<br> Head与cat的区别<br> 怎么查看日志</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/01_Linux%E5%91%BD%E4%BB%A4/">Linux命令</a></h4><h4 id="Linux命令实操"><a href="#Linux命令实操" class="headerlink" title="Linux命令实操"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/02_linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%93%8D/">Linux命令实操</a></h4></li>
<li><h2 id="测试环境你是怎么搭建的？"><a href="#测试环境你是怎么搭建的？" class="headerlink" title="测试环境你是怎么搭建的？"></a>测试环境你是怎么搭建的？</h2><ol>
<li>我上一家公司的项目后台使用 PHP开发，数据库这块用的 mysql，web网络服务器用的apache,所有我们搭建的 LAMP 的测试环境。对环境搭建主要就是安装一些软件，像安装 apache,安装 Mysql,安装PHP的运行环境，然后把开发给到我们的测试版本的源码包部署到我们 apache中。（项目是部署在<br> apache 的 www&#x2F;html目录下），启动相应的服务（mysql,apache,php），例外需要修改数据库的配置文件，还有就是开发防火墙的端口，像数据库的端口（3306），apache的端口（80）都要进行开发，这里需要修改防火墙的配置文件。<h2 id=""><a href="#" class="headerlink" title=""></a></h2></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>01_Linux系统</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/01_%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<ol>
<li><h2 id="数据库基础知识"><a href="#数据库基础知识" class="headerlink" title="数据库基础知识"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/01_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">数据库基础知识</a></h2></li>
<li><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><ol>
<li>数据库按时存放数据的仓库，只是以某种有组织存储方式储存数据的集合</li>
</ol>
</li>
<li><h2 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h2><ol>
<li>数据库分为关系型数据库和非关系型数据库<ol>
<li>关系型数据库：mysql、oracle、sqlserver、db2、past、gresql<ol>
<li>是数据库里面有存在一定的关系</li>
</ol>
</li>
<li>非关系型数据库：mogodb、redis、hbase、memchedb<ol>
<li>数据与数据之间没有任何关系，只有输入和输出</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="数据库命令行操作"><a href="#数据库命令行操作" class="headerlink" title="数据库命令行操作"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/02_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/">数据库命令行操作</a></h3><ol>
<li>快捷键： win+r   输入  cmd       打开dos窗口<br> 登录数据库命令：mysql  -h 主机ip      -u 用户名   -p   回车— 输入密码    回车<br> 退出：mysql &gt;exit;         或    mysql &gt;quit;           或      mysql &gt;\q;<br> show databases; 查看所有数据库<br> use +数据库名    使用数据库<br> show  tables;  查看数据库中表的信息</li>
<li>基础的增删改查命令操作：<ol>
<li>增：insert  into 表名（列名） values（列名对应的值）</li>
<li>删：delete from 表名  where 列名 &#x3D; 对应列名的值</li>
<li>改：update  表名  set 修改的列名 &#x3D; 对应的值   where  列名 &#x3D; 对应列名的值</li>
<li>查：select  查询内容  from  表名   where 列名 &#x3D; 对应列名的值</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="数据库连接工具"><a href="#数据库连接工具" class="headerlink" title="数据库连接工具"></a>数据库连接工具</h3><ol>
<li><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/01_navicat/01_navicat%E5%AE%89%E8%A3%85/">navicat安装</a></li>
<li><a href="/05_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/03_%E6%95%B0%E6%8D%AE%E5%BA%93/01_navicat/02_SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/">SQL语句练习</a><ol>
<li>增：inset  into 表名（列名） values（列名对应的值）</li>
<li>删：delete from 表名  where 列名 &#x3D; 对应列名的值</li>
<li>改：update  表名  set 修改的列名 &#x3D; 对应的值   where  列名 &#x3D; 对应列名的值</li>
<li>查：select  查询内容  from  表名   where 列名 &#x3D; 对应列名的值</li>
<li>运算符<ol>
<li>&lt;  小于号</li>
<li><blockquote>
<p>大于号</p>
</blockquote>
</li>
<li>&#x3D;  等于号</li>
<li>!&#x3D;   不等于</li>
<li>&lt;&gt;  不等于</li>
</ol>
</li>
<li>注释符<ol>
<li>–   +空格</li>
<li>井号</li>
<li>&#x2F;%      %&#x2F;</li>
</ol>
</li>
<li>精确查询：  条件用 &#x3D;</li>
<li>模糊查询：<ol>
<li>like   像</li>
<li>not  like    不像</li>
<li>%   代表一个或者多个字符</li>
<li>_   表示一个字符（占位符）</li>
</ol>
</li>
<li>同时查询两个条件：<ol>
<li>and   和&#x2F;且</li>
<li>or  或者</li>
<li>null  空的</li>
<li>distinct  去重</li>
<li>order by   排序   desc ：倒叙   asc  ：正序</li>
<li>group  by  分组</li>
<li>limit  n,m  n表示从n+1开始，m表示取值</li>
<li>between   and    在什么之间</li>
<li>not  between  and   不在什么之间</li>
<li>in  是什么的值</li>
<li>not  in   不是什么的值</li>
</ol>
</li>
<li>五大函数<ol>
<li>avg  平均值</li>
<li>max  最大值</li>
<li>min   最小值</li>
<li>sum   求和</li>
<li>count   统计</li>
</ol>
</li>
<li>嵌套<ol>
<li>SELECT  查询内容     FROM   表名      WHERE   列名  IN (SELECT  查询内容     FROM   表名      WHERE   列名 &#x3D; 对应列的值);</li>
</ol>
</li>
<li>多表联查<ol>
<li>SELECT 查询内容  FROM  表名1  JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</li>
<li>SELECT 查询内容  FROM  表名1  LEFT JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</li>
<li>SELECT 查询内容  FROM  表名1  RIGHT JOIN  表名2   ON  表名1.关联的列名&#x3D;表名2.关联的列名 WHERE 表名.列名 &#x3D; 列名对应的值;</li>
</ol>
</li>
<li>lianxi库:<ol>
<li>sql：<a href="assets/1/lianxi-20211206163641-2j5ye7z.sql">lianxi.sql</a></li>
<li>练习题</li>
</ol>
</li>
</ol>
</li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/03_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/">数据库语句优化</a></li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/04_%E5%85%B6%E4%BB%96%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7/">其他连接工具</a></li>
</ol>
</li>
<li><h2 id="mysql数据库的特点"><a href="#mysql数据库的特点" class="headerlink" title="mysql数据库的特点"></a>mysql数据库的特点</h2><ol>
<li>可以处理成千上万条记录的大型数据</li>
<li>支持常见的sql语句规范</li>
<li>可移植性高，安装简单小巧</li>
<li>良好的运行效率，丰富信息的网络支持</li>
<li>调试、管理、优化比较简单</li>
<li>开源免费，跨平台</li>
</ol>
</li>
<li><h2 id="索引与主键"><a href="#索引与主键" class="headerlink" title="索引与主键"></a>索引与主键</h2><ol>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/05_%E7%B4%A2%E5%BC%95/">索引</a><ol>
<li>优点： 加快查询速度<br> 特点：        1.大大加快数据的检查速度<br>           2.创建唯一性索引，保证数据库表中每行数据的唯一性<br>           3.加快了表与表之间的连接<br>           4.在使用分组和排序子句进行数据检查，可以明显减少查询中的分组和排序的时间<br> 缺点： 当对表进行新增，删除和修改的时候，索引也需要对修改的数据进行维护，降低了数据的维护速度</li>
</ol>
</li>
<li><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/06_%E4%B8%BB%E9%94%AE/">主键</a><ol>
<li>主关键字（primary key）是表中一个或者多个字段，它的值用于唯一标识表中某一条记录<br> 主键不能为空值，不可以重复，不可以修改<br> 主键不是必须的，在表中可以没有主键<br> 主键的特点：<br> 1.保证数据的完整性。<br> 2.加快数据的操作速度。<br> 3.在表中添加新纪录时，数据库会自动检查新纪录的主键，不允许更改值与其他记录的主键值重复<br> 4.数据库自动按照主键值得顺序显示记录，如果没有主键，则按照输入的记录顺序显示表中记录</li>
<li>外主键<ol>
<li>是主键的从属，表述了两个表之间的联系</li>
<li>作用：使用外键可以建立数据的关联，还可以避免冗余</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="oracle-mysql-SqlServer-的区别"><a href="#oracle-mysql-SqlServer-的区别" class="headerlink" title="oracle  mysql    SqlServer  的区别"></a>oracle  mysql    SqlServer  的区别</h4><ol>
<li>oracle 和 mysql 可以有命令登录   SqlServer 没有<br> oracle 属于大型数据库，而 mysql    SqlServer  属于中小型数据库<br />oracle 在增删改以后需要commit   而 mysql    SqlServer  不需要<br> oracle 支持并发大量访问  mysql    SqlServer   支持并发访问量没有oracle 大<br> oracle 安全性比 mysql    SqlServer  要高</li>
</ol>
</li>
<li><h4 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h4><ul>
<li>在sql中视图基于SQL语句的结果集的可视化类，视图包含行和列，就像一个真实的表，视图中的字段来源于数据库真实表的字段</li>
</ul>
</li>
<li><h2 id="什么时候查询数据库？"><a href="#什么时候查询数据库？" class="headerlink" title="什么时候查询数据库？"></a>什么时候查询数据库？</h2><ol>
<li>一般使用数据库时，我都需要数据库计算一些数据的百分比，查询一些数据库信息，还有我们小组人员要进行根性数据，方便以后的数据调用</li>
</ol>
</li>
<li><h2 id="表和视图的区别"><a href="#表和视图的区别" class="headerlink" title="表和视图的区别"></a>表和视图的区别</h2><ol>
<li>表是物理真实存在的，视图是虚拟的，表是真实的数据而视图不保存数据的</li>
</ol>
</li>
<li><h2 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h2><ol>
<li>定义<ol>
<li>MySQL 5.0 版本开始支持存储过程。</li>
<li>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</li>
<li>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</li>
<li>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</li>
</ol>
</li>
<li>优点<ol>
<li>重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。</li>
<li>减少网络流量：存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。</li>
<li>安全性：参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。</li>
</ol>
</li>
<li>缺点<ol>
<li>更改比较繁琐：如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则仍需要更新程序集中的代码以添加参数、更新 GetValue() 调用，等等，这时候估计比较繁琐。</li>
<li>可移植性差：由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如果应用程序的可移植性在您的环境中非常重要，则需要将业务逻辑封装在不特定于 RDBMS 的中间层中。</li>
</ol>
</li>
<li>操作<ol>
<li></li>
<li>定义存储过程（模板)<ol>
<li>DELIMITER&#x2F;&#x2F;</li>
<li>CREATE PROCEDURE 存储过程的名称()</li>
<li>BEGIN<br> –存储过程代码</li>
<li>END&#x2F;&#x2F;</li>
<li>DELIMITER;</li>
</ol>
</li>
<li>存储过程例子<br> DROP PROCEDURE  IF EXISTS get_maxsal()<br> DELIMITER&#x2F;&#x2F;<br> CREATE PROCEDURE get_maxsal()<br> BEGIN<br>      SELECT max(sal) from emp;<br> END&#x2F;&#x2F;<br> CALL get_maxsal(); –调整存储过程</li>
<li>在存储过程中声明并使用变量<br> DROP PROCEDURE  IF EXISTS get_sal；<br> DELIMITER&#x2F;&#x2F;<br> CREATE PROCEDURE get_sal()<br> BEGIN<br>     DECLARE avgsal INT;<br>     SELECT avg(sal) into avgsal  from   emp;<br>     SELECT ename,sal FROM emp WHERE sal &gt; avgsal;<br> END&#x2F;&#x2F;<br> CALL get_sal();</li>
<li>带参数的存储过程<ol>
<li>文字定义<ol>
<li>在MySQL中，参数有三种模式：IN, OUT,INOUT.</li>
<li>IN -是默认模式，在存储过程中定义IN参数时，调用存储过程时必须将参数传递给存储过程。另外IN参数的值被保护，也就是说IN参数的值在过程中不能被改变</li>
<li>OUT - 可以在存储过程中改变OUT 参数的值，并将其更改后的新值传递回调用程序。由于OUT 参数并没有被赋值，所有不能读取，只能复制</li>
<li>INOUT - INOUT参数是IN 和OUT 参数的组合，这意味着调用程序可以传递参数，并且存储过程可以修改INOUT参数并将心的值传递回调用程序。</li>
<li>语法：IN&#x2F;OUT&#x2F;INOUT  param_name param_type(param_size)<br> DROP PROCEDURE  IF EXISTS get_sal；<br> DELIMITER&#x2F;&#x2F;<br> CREATE PROCEDURE get_sal(IN empname VARTHAR(5),OUT  empsal INT)<br> BEGIN<br> SELECT  sal INTO empsal  from emp WHERE ename &#x3D; empname;<br> END&#x2F;&#x2F;</li>
</ol>
</li>
</ol>
<p> – 在存储过程中定义的参数，会在mysql中自动生成一下划线命名的参数<br> CALL get_sal(‘BLAKE’,@_empsal);<br> SELECT @_empsal;</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>测试概念总结</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/09_%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li><h3 id="你上家公司的测试流程是怎么样的？"><a href="#你上家公司的测试流程是怎么样的？" class="headerlink" title="你上家公司的测试流程是怎么样的？"></a>你上家公司的测试流程是怎么样的？</h3><ol>
<li>需求下来之后，我们会首先熟悉下，然后公司会做一个’需求交接’,这个过程中一般会开一个简单的’需求澄清会’,在会议上把自己对需求不清楚，不理解，或者有异议的地方都提出来，由产品给我们解答。澄清会结束然后就写测试计划，测试计划前期一般都是有我们主管写的，后期基本上是由我们各个测试人员轮流细的，测试计划主要就是安排进度以及任务的分配之后各自领取自己负责的模块，做需求分析，挖掘，同时写测试点，测试点写完后,就编写测试用例。’测试点，我们用的 xmind的写的，用例当时用的Excel 表格管理的’，等测试用例编写完，一般会有评审，对于评审，有时候就是简单组内评审下，如果大的功能可能会组织会议评审，如果是会议评审，相关的开发，跟产品基本都会到场，其实主要就是看下用例的覆盖率这块，例外就是看检查点有没有检查到位。评审了之后，然后会等项目版本出来，开发那边一般会先做单元测试(UT)，之后就开始提测，我们首先会搭建测试环境，做项目部署，之后做冒烟测试，然后去执行用例做系统测试，测试过程中发现 bug就指派给对应的开发，待开发修复完成之后，我们测试需要做复测，复测没有问题就关闭Bug,如果还是有问题，重新开启 Bug，直到改好了复测完没问题才可以关闭这个bug。<del>一般系统功能测试我们需要测试2-3轮</del>，保证所有Bug基本都修复完成，之后写测试报告，然后看是否达到上线标准，达到了上线标准的话，由 SE组织时间进行产品上线，上线之后我么会做一个做总结。</li>
<li><h3 id="产品如何上线？（标准，过程）"><a href="#产品如何上线？（标准，过程）" class="headerlink" title="产品如何上线？（标准，过程）"></a>产品如何上线？（标准，过程）</h3><ol>
<li><h4 id="上线标准"><a href="#上线标准" class="headerlink" title="上线标准"></a>上线标准</h4><ol>
<li>用例执行率 100%</li>
<li>1,2 级Bug 修复率100%</li>
<li>3,4 级Bug 修复率95%</li>
</ol>
</li>
<li><h4 id="上线时间"><a href="#上线时间" class="headerlink" title="上线时间"></a>上线时间</h4><ol>
<li>周二，周四晚上 一般都在 10 点之后 （用户少，影响不大） 产品，运维，开发，测试都要到场<br> SE 组织安排上时间，上线注意事项，人员等</li>
</ol>
</li>
<li><h4 id="上线的过程"><a href="#上线的过程" class="headerlink" title="上线的过程"></a>上线的过程</h4><ol>
<li>第一步：运维从 svn<br> 下载交付版本（测试好的版本）,部署到（线上&#x2F;生产环境）服务器上</li>
<li>第二步：部署完了，测试这个时候才扑上去执行测试，各自执行各自的用例（新需求，各自负责各自的模块都需要点一遍），这个时候发现问题，立马要修复，重新上线，（会不会执行用例？）还是会执行用例， 但是，主要执行主要用例，级别高的用例的。把每个功能模块的流程走一遍，保证没有问题</li>
<li>第三步：有问题？严重的，致命的，会影响客户使用的问题，一般要求当场修复，如果修复不了，第二天修复，直到修复为止，然后复测，再上线。一般的，普通，提示的问题，对于客户影响不大的，一般产品会决定，可以先上线，推迟到下一个版本在修复。能当场修复，修复完成重新上线</li>
<li>第四步：一般我们上线一周，会做一个简单的总结</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><pre><code> 1. 首先对需求进行评审，评审通过后，测试人员根据需求编写测试用例，再对用例进行评审，评审通过后，对测试版本进行测试，测试过程中发现bug提交给对应的开发人员进行修改，待开发修改完成后，我们进行返测，返测通过直接关闭，返测不通过打回让开发重新修改，直至项目中所有的bug关闭，编写写实报告，进行版本发布，编写测试总结
</code></pre>
</li>
<li><h3 id="用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？"><a href="#用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？" class="headerlink" title="用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？"></a>用例包含哪些部分，有哪些用例设计方法，你一般常用的有哪些方法？</h3><pre><code> 1. 用例包含哪些部分，你认为哪些比较重要？
     1. 用例编号，模块，用例标题，重要级别，前置条件，输入数据，操作步骤，预期结果
     2. 级别一定定得合理
     3. 标题一定要简明扼要的阐述清楚
     4. 预期结果一定要检查到位（不仅要考虑前端显示问题，还有相关模块的影响，以及后台数据库的考虑）
     5. 操作步骤要尽量详细（以便用例执行者能正常执行）
     6. 测试数据要正确合理，前置条件要准确。
 2. 用例设计方法有哪些
     1. 用例方法主要有：等价类  边界值  判定表  流程分析法 正交表 因果图 状态迁移 错误推断法，异常分析法。其实我一般用得比较多一点就是等价类  边界值  判定表  流程分析法这几个，有时候会用下错误推断法等来补充用例。
 3. ![image.png](assets/1/image-20211203153323-8cht73v.png)
</code></pre>
</li>
<li><h3 id="等价类与边界值怎么理解？"><a href="#等价类与边界值怎么理解？" class="headerlink" title="等价类与边界值怎么理解？"></a>等价类与边界值怎么理解？</h3><pre><code> 1. 等价类分为，有效等价类，无效等价类，有效等价类其实就从正向去考虑，正常的场景，无效等价类，就是站异常的场景角度去考虑用例。一般主要用在对文本编辑框的用例设计，比如：注册用户名，用户名规定在 3-15个字符之间，那么我们在设计用例的时候就要考虑有效等价类：3-15中随机取一个值，无效等价来就是：小于3,大于15。边界值其实是对等价类的一种补充，它其实不能当成主要的用例方法，但是一定要考虑，因为很多问题都发生在边上。边界值一般有上点，离点，内点，比如刚才说的用户名，边界值就要考虑 3,15,2,16这几个点。
 2. **注释：如果自己的项目中没有登录或者注册的用户名输入框，可以选择其他输入框，如商品名称、订单编号等**
</code></pre>
</li>
<li><h3 id="怎么保证用例的质量，保证覆盖度达到100"><a href="#怎么保证用例的质量，保证覆盖度达到100" class="headerlink" title="怎么保证用例的质量，保证覆盖度达到100%"></a><strong>怎么保证用例的质量，保证覆盖度达到</strong>100%</h3><pre><code> 1. 仔细分析需求，仔细阅读需求文档，有可能 se需求文档里面的一个图片，需求文档里面的一个提示都是需求点，前期多和 SE沟通，把需求吃透特别隐含的需求，和这个需求关联模块啊，一般出问题都是些隐含需求和相关模块没有分析出来,另外最好能站在用户的角度多考虑一些其他场景。保证用例的覆盖度。
 2. 分析完成，我会核对我罗列的需求点是否覆盖需求文档的需求点，这个一条一条过，这样基本问题不大了，不会有需求遗漏，再组内评审下，更能保证质量
 3. 必须要熟悉业务，比如说，查询订单，订单接口输入参数数据都来源于订单表，如果不熟悉来源哪些表，订单有哪些状态，这些，你就不好分析执行，多考虑业务流程上的测试点，以及相关模块的测试点
 4. 用例这块，检查结果要覆盖每一个检查点，像数据库检查，相关模块检查都要覆盖到位，用例必须需要经过评审
 5. 后期不停的完善，添加，补充用例，以保证用例的覆盖度。
</code></pre>
</li>
<li><h3 id="你们用例是怎么评审的，评审过程中主要关注什么问题？"><a href="#你们用例是怎么评审的，评审过程中主要关注什么问题？" class="headerlink" title="你们用例是怎么评审的，评审过程中主要关注什么问题？"></a>你们用例是怎么评审的，评审过程中主要关注什么问题？</h3><ol>
<li>主要还是看项目大小和复杂程度，我们公司一般都是会议评审，一般提前预定会议室，把产品、开发同事都叫上，一起会议室评审用例，假如有时候只有简单业务，就简单的组内评审就可以了。</li>
<li>主要是关注用例覆盖是不是完整，有已没有漏测的用例，另外就是预期结果是否合理，检查到不到位。</li>
</ol>
</li>
<li><h2 id="用例评审的目的"><a href="#用例评审的目的" class="headerlink" title="用例评审的目的"></a>用例评审的目的</h2><ol>
<li>评审有歧义，有冲突，有问题，目的是查漏补缺</li>
</ol>
</li>
<li><h3 id="你的测试用例是怎样管理的？"><a href="#你的测试用例是怎样管理的？" class="headerlink" title="你的测试用例是怎样管理的？"></a>你的测试用例是怎样管理的？</h3><ol>
<li>我们公司的用例都是用的禅道 来管理的，一般会把用例情况，包括通过率、执行率、阻塞率、未执行数量、已执行数量都做好记录，方便后续查看，也方便修改。</li>
<li>另外也要注意用例的及时更新，不需要的用例可以备注隐藏，以免后续要再次使用的时候可以不必重复编写用例。</li>
</ol>
</li>
<li><h3 id="如何保证软件质量"><a href="#如何保证软件质量" class="headerlink" title="如何保证软件质量"></a>如何保证软件质量</h3><ol>
<li>需求要吃透，多问，多去了解</li>
<li>严格按照测试流程去执行： 引入合适的测试用例设计方法、进行用例评审机制。</li>
<li>要有良好的测试执行：要求用例执行率达到 100%，多次的测试轮次、引入测试工具，让测试可以做得更深入（通过查看日志，查数据库）</li>
<li>有良好的缺陷写作和过 Bug 机制、引入合适的缺陷管理工具和缺陷管理流程，有良好的测试流程， 引入更合适的测试流程和测试方法，采用更多的非功能测试，不能把非功能忽略测试。</li>
<li>多进行评审，完善大家的测试思维点。</li>
<li>进行交叉测试，可以多个人，不同测试考虑点。</li>
</ol>
</li>
<li><h3 id="提（bug）单工具"><a href="#提（bug）单工具" class="headerlink" title="提（bug）单工具"></a>提（bug）单工具</h3><ol>
<li>禅道，jira，qc，bugfree，bugzilla</li>
<li>((20211203111708-liwjzmp “禅道介绍”))      ((20211203112034-mzpktpu ‘禅道介绍-提交bug’))</li>
<li>注释： <a href="http://192.168.1.2/object/zentaopms/www/index.php">禅道链接</a></li>
</ol>
</li>
<li><h3 id="bug流程"><a href="#bug流程" class="headerlink" title="bug流程"></a>bug流程</h3><ol>
<li>版本一：发现bug以后，先截图，详细记录重现步骤，通过bug工具提交给对应的开发人员，等待开发解决以后我们进行返测，通过就关闭，不通过打回去重现修改，直到项目中所得bug关闭</li>
<li>版本二：原来 bug 是用 禅道来管理的，原来我们公司 bug，提交 bug 直接给对应的开发人员，对应开发人员修复完成，交给测试复测，复测通过关闭 bug，不通过打回给对应开发重新修改</li>
</ol>
</li>
<li><h3 id="提交bug包含哪些内容"><a href="#提交bug包含哪些内容" class="headerlink" title="提交bug包含哪些内容"></a>提交<strong>bug</strong>包含哪些内容</h3><ol>
<li>所属产品，所属模块，所属项目，影响版本，指派人员,截止日期，严重程度，优先级，bug 类型，bug 环境，Bug 标题，重现步骤，附件</li>
</ol>
</li>
<li><h3 id="bug的状态"><a href="#bug的状态" class="headerlink" title="bug的状态"></a>bug的状态</h3><ol>
<li>提交-开发人员：已激活未确认-开发进行确认，状态变成已激活，已确认，开发修复完成-标注状态是已修复，测试人员复测通过，已关闭，打回给对应开发，已经激活</li>
</ol>
</li>
<li><h3 id="bug的级别"><a href="#bug的级别" class="headerlink" title="bug的级别"></a>bug的级别</h3><ol>
<li>致命、严重、一般、建议      1   2    3   4</li>
<li>定义<ol>
<li>致命：对业务有至关重要的影响，业务系统完全散失业务功能，工作无法再继续进行，或业务系统丢失了业务数据且无法恢复，影响公司运营的重要业务数据出错</li>
<li>严重：对业务有严重的影响，业务系统已经丧失可部分的重要的业务功能，或业务系统丢失了业务数据且可以恢复，一般业务数据出错。</li>
<li>一般：对业务有较小的影响，业务系统丧失了较少的业务，功能。例如：界面错误，打印或显示格式错误。</li>
<li>建议：对业务没有影响，不影响业务过程正常进行，例如：辅助说明描述不清楚，提示不明确的错误提示</li>
</ol>
</li>
<li><h4 id="致命Bug跟严重-Bug的区别？"><a href="#致命Bug跟严重-Bug的区别？" class="headerlink" title="致命Bug跟严重 Bug的区别？"></a>致命<strong>Bug</strong>跟严重 <strong>Bug</strong>的区别？</h4><ol>
<li>致命 Bug:导致系统崩溃，数据丢失，卡死，闪退，数据库死锁，一般这种类型的，我们都会标注为致命 Bug</li>
<li>严重 Bug:功能没有实现，主流程走不通，功能有严重问题不能正常使用，这种，我们一般会标注为严重 Bug</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="bug的优先级"><a href="#bug的优先级" class="headerlink" title="bug的优先级"></a>bug的优先级</h3><ol>
<li>优先，高、中、低         &#x2F;      禅道中对应为 1、2、3、4</li>
<li>优先级别高的不一定优先处理，但是bug级别高的一定优先处理的</li>
</ol>
</li>
<li><h3 id="提-Bug需要注意哪些问题？"><a href="#提-Bug需要注意哪些问题？" class="headerlink" title="提 Bug需要注意哪些问题？"></a>提 <strong>Bug</strong>需要注意哪些问题？</h3><ol>
<li>不要急着提交，先做一下复现，进行证实，如果需要的话，也可以使用不用的版本测试对比一下</li>
<li>简单明了的概括 bug 标题，清晰的描述 bug 重现步骤，分析bug 和预期正确结果，附加 bug 的截图或者日志。描述 bug 的时候。</li>
<li>在不能确认该情况是否为bug 的时候，可以请教其他人。</li>
<li>提交完bug 以后，后面还要跟进bug。</li>
<li>bug单内容注意的地方:<ol>
<li>Bug标题要简明扼要的表述清楚</li>
<li>Bug的级别（严重级别，优先级别）</li>
<li>内容:操作步骤（一定要描述清楚，以便开发可以复现）,预期结果，实际结果</li>
<li>最好，把截图，日志相关的信息一并的提交（方便开发定位）</li>
<li>测试环境（如：浏览器google,华为手机上）</li>
<li>属于哪个产品，模块的</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="测试过程中bug比较多的原因"><a href="#测试过程中bug比较多的原因" class="headerlink" title="测试过程中bug比较多的原因"></a>测试过程中bug比较多的原因</h3><ol>
<li>开发的经验不足</li>
<li>需求的不明确</li>
<li>程序本身的错误</li>
<li>人与人之间交流不够</li>
<li>需求的不断变化</li>
<li>工期紧、任务重、时间压力大</li>
<li>参与人员的过度自信</li>
</ol>
</li>
<li><h3 id="如果系统快上线了，临时发现了一个bug怎么处理？"><a href="#如果系统快上线了，临时发现了一个bug怎么处理？" class="headerlink" title="如果系统快上线了，临时发现了一个bug怎么处理？"></a>如果系统快上线了，临时发现了一个bug怎么处理？</h3><ol>
<li>首先看bug级别，如果不严重，影响不到项目功能的，先于组长沟通，等上线了再优化</li>
<li>如果是一个严重的bug 赶紧找自己的领导，让领导去找项目经理看项目经理的决定</li>
</ol>
</li>
<li><h3 id="在工作中遇到棘手的问题是怎么解决的？"><a href="#在工作中遇到棘手的问题是怎么解决的？" class="headerlink" title="在工作中遇到棘手的问题是怎么解决的？"></a>在工作中遇到棘手的问题是怎么解决的？</h3><ol>
<li>需求不完整：找产品进行确认需求，让他完善需求</li>
<li>bug不能被开发承认：先从需求中找证据，证明是一个bug，如果开发还是不承认，这时候再找产品确认（拉上产品与开发对接），还是不承认，反馈给测试组长</li>
</ol>
</li>
<li><h3 id="你提交的-Bug开发不认可的话，如何解决？提皮球，扯皮！"><a href="#你提交的-Bug开发不认可的话，如何解决？提皮球，扯皮！" class="headerlink" title="你提交的 Bug开发不认可的话，如何解决？提皮球，扯皮！"></a>你提交的 <strong>Bug</strong>开发不认可的话，如何解决？提皮球，扯皮！</h3><ol>
<li>首先我要了解开发不认可的原因，如果是需求理解不一致的问题，首先我会再看需求文档，是不是我的理解有误，如果是我对需求理解错的话我就去关闭 bug，如果还是觉得没有问题，那就找产品确认需求，然后再与开发沟通</li>
<li>如果是其他问题，一般会再去让身边的同看看听下他们的意见，然后自己先再三去复测，并且保存好截图和日志，确定这是一个 bug之后我就去跟开发说明白，并且给他看bug 重现的截图以及日志。如果开发还是不认可的话我就跟产品或项目经理说明白情况</li>
</ol>
</li>
<li><h3 id="和开发是怎么沟通的"><a href="#和开发是怎么沟通的" class="headerlink" title="和开发是怎么沟通的"></a>和开发是怎么沟通的</h3><ol>
<li>一般我在提 bug 的时候跟开发沟通最多，比如有一些不清晰的内容会去问开发，还有提完 bug 后会跟踪 bug 的进度，提醒开发尽快修复 bug，还有测接口的时候去找开发拿接口文档，其实我们的工作跟开发都是息息相关的所以都经常都会有沟通的</li>
</ol>
</li>
<li><h3 id="系统上线了发现了一个严重的bug怎么办？"><a href="#系统上线了发现了一个严重的bug怎么办？" class="headerlink" title="系统上线了发现了一个严重的bug怎么办？"></a>系统上线了发现了一个严重的bug怎么办？</h3><ol>
<li>回滚上个版本，再对这个版本进行测试，测试通过再发布</li>
</ol>
</li>
<li><h3 id="线上环境发现bug你们是怎么处理的"><a href="#线上环境发现bug你们是怎么处理的" class="headerlink" title="线上环境发现bug你们是怎么处理的"></a>线上环境发现<strong>bug</strong>你们是怎么处理的</h3><ol>
<li>第一步需要到测试环境里面重现一下，看下是环境配置不一致的问题，还是代码漏提交了，需要要到客户的操作场景和数据分析这个 bug的严重级别，影响范围，bug 比较严重，立马修复，修改后，测试回归验证通过，打补丁，bug影响不大，放到下一个版本修改</li>
</ol>
</li>
<li><h3 id="软件终止的标准"><a href="#软件终止的标准" class="headerlink" title="软件终止的标准"></a>软件终止的标准</h3><ol>
<li>公司倒闭</li>
<li>达到了规定的时间</li>
<li>开发过程中偏离了需求的定位</li>
<li>预算超出了规定的值</li>
<li>执行完了所有的测试用例</li>
</ol>
</li>
<li><h3 id="测试中有哪些风险（如何把控风险）"><a href="#测试中有哪些风险（如何把控风险）" class="headerlink" title="测试中有哪些风险（如何把控风险）"></a>测试中有哪些风险（如何把控风险）</h3><ol>
<li>测试人员需求理解上面有偏差</li>
<li>测试人员水平不够，测试人员覆盖点不全</li>
<li>测试人员时间不够，导致测试完不成</li>
<li>测试环境上面不足，导致测试点不能完全测试完成</li>
</ol>
</li>
<li><h3 id="测试计划主要包含哪些内容"><a href="#测试计划主要包含哪些内容" class="headerlink" title="测试计划主要包含哪些内容"></a>测试计划主要包含哪些内容</h3><ol>
<li>内容<ol>
<li>目的和范围</li>
<li>规程</li>
<li>测试方案和方法</li>
<li>测试的准入和准出</li>
<li>测试计划(流程、时间安排、对应人员)</li>
<li>测试的环境配置和人员安排</li>
<li>交付件</li>
</ol>
</li>
<li>例外一种回答：<ol>
<li>我们公司之前按照考核要求写过测试计划，不过后面老大觉得太耽误工作进度，后面一般都不再写测试计划，而是写版本计划。这个在版本计划， 每个人的任务列出来，负责人列出来，自己根据自己的情况分配时间，然后汇总，大家一起开个小会评审就可以了</li>
</ol>
</li>
<li>测试的范围，测试目标，人员分配，环境配置，里程碑，测试周期，测试策略，风险分析</li>
</ol>
</li>
<li><h3 id="测试计划制定"><a href="#测试计划制定" class="headerlink" title="测试计划制定"></a><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/">测试计划制定</a></h3></li>
<li><h3 id="有没有写过测试报告，测试报告主要包含哪些内容"><a href="#有没有写过测试报告，测试报告主要包含哪些内容" class="headerlink" title="有没有写过测试报告，测试报告主要包含哪些内容?"></a>有没有写过测试报告，测试报告主要包含哪些内容?</h3><ol>
<li>没有写过测试报告的，一般就是把整个测试过程的数据统计出来，做成报告，包括用例执行的情况，测试了哪些模块，用了多少用例，自动化用例的通过率，自动化跑了多少模块， 执行的用例是否全部通过，发现了多少 bug，bug 的严重程度，是否遗漏 bug，测试结论是什么这些。注意用例的执行要全部做完， 报告数据简洁明了，结论要描述全面。</li>
</ol>
</li>
<li><h3 id="开发怎么转测"><a href="#开发怎么转测" class="headerlink" title="开发怎么转测"></a>开发怎么转测</h3><ol>
<li>我们这边的话，是按模块的优先级来的，优先级高的先提测，首先开发做单元测试，测试通过后会把测试报告给我们，同时将源码上传到 SVN，我们确认单元报告没问题，再从 SVN 检出来，进行一轮冒烟测试，冒烟测试通过，就开始全量测试。</li>
</ol>
</li>
<li><h3 id="如果时间比较紧的话，你怎么安排你的工作"><a href="#如果时间比较紧的话，你怎么安排你的工作" class="headerlink" title="如果时间比较紧的话，你怎么安排你的工作"></a>如果时间比较紧的话，你怎么安排你的工作</h3><ol>
<li>首先要评估下风险，比如说，可能我根本做不完，风险太大，那么这个我首先要把风险提出来，给对应的领导，那么我会要求有人协助我完成，需要多少人力来完成</li>
<li>如果只是说，正常时间完不成，那么我可以提下加班，看加班这个时间段能否完成，如果可以，我会和老大商量，提出加班计划</li>
<li>如果是其他的，比如说我只需要把优先级高的工作完成，其他工作可以安排到下一个版本去做，那么我就做个计划，把计划给老大说</li>
</ol>
</li>
<li><h3 id="测试如何在各个阶段保证软件质量"><a href="#测试如何在各个阶段保证软件质量" class="headerlink" title="测试如何在各个阶段保证软件质量"></a>测试如何在各个阶段保证软件质量</h3><ol>
<li>需求分析阶段：<ol>
<li>需求要吃透，多问，多去了解</li>
<li>我们要做测试需求分析，并应用相对应的方法论，还要进行需求串讲</li>
<li>测试需求分析的方法：分解功能点，然后对每一个功能点进行需求规则的分析。分析的方法有：<ol>
<li>输入划分</li>
<li>质量模型分析（功能、性能、安全、易用性、稳定性等各个维度）</li>
<li>功能交互分析</li>
<li>用户关联图分析</li>
</ol>
</li>
</ol>
</li>
<li>测试计划<br>计划影响的是执行，计划需要根据实际情况来做，计划一旦制定就需要尽量的按照这个计划执行。</li>
<li>用例设计<ol>
<li>所有功能点和需求规则都要被覆盖，</li>
<li>应多考虑业务层面的测试用例，安全、性能等各种非功能层面也应该考虑。</li>
<li>多考虑测试场景与结果检查</li>
<li>应对测试用例进行评审</li>
</ol>
</li>
<li>测试准备：<ol>
<li>测试环境应该要尽可能的接近真实环境</li>
<li>测试环境应该能够包含各种测试场景</li>
<li>测试数据应该尽可能真实，也包含了各种能够覆盖场景的测试数据</li>
</ol>
</li>
<li>测试执行：<ol>
<li>用例要 100%的执行，不能够放过任何一个测试用例或测试场景</li>
<li>测试的轮次安排，应安排</li>
<li>轮测试。每一轮测试重点应该不一样。</li>
<li>引用缺陷管理工具，标准化缺陷管理流程，规范开发与测试对缺陷的管理</li>
<li>及时跟踪Bug</li>
</ol>
</li>
<li>测试管理相关：<ol>
<li>编写测试日报，定期向团队汇报测试进展以及问题及风险</li>
<li>为了让文档的管理变得更规范，应引入SVN进行配置管理</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="你怎样快速上手公司的项目"><a href="#你怎样快速上手公司的项目" class="headerlink" title="你怎样快速上手公司的项目"></a>你怎样快速上手公司的项目</h3><ol>
<li>熟悉数据流的走向</li>
<li>业务的逻辑</li>
<li>数据的验证</li>
</ol>
</li>
<li><h3 id="质量体系：cmmi模型，衡量公司级别"><a href="#质量体系：cmmi模型，衡量公司级别" class="headerlink" title="质量体系：cmmi模型，衡量公司级别"></a>质量体系：cmmi模型，衡量公司级别</h3><ol>
<li>初始级</li>
<li>可管理级</li>
<li>已定义级</li>
<li>量化管理级</li>
<li>优化管理级<br> 一般公司都在3级，5级一般都是买的</li>
</ol>
</li>
<li><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ol>
<li>公司中一次性开发的功能点比较多的时候，会分批次进行开发，这样的开发模式成为迭代</li>
<li>迭代的周期：1-2周&lt;小迭代&gt;   2-3月&lt;大迭代&gt;</li>
<li><h2 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h2><ol>
<li><h5 id="螺旋模型："><a href="#螺旋模型：" class="headerlink" title="螺旋模型："></a>螺旋模型：</h5><ol>
<li><img src="/assets/1/image-20211122114847-u3g4kke.png" alt="image.png"></li>
<li>1、需求开始，2、确认方案，3、支出风险并解决，4、评估方案，5、本阶段开发测试，6、计划下一阶段，7、进入下一阶段</li>
</ol>
</li>
<li><h5 id="V模型："><a href="#V模型：" class="headerlink" title="V模型："></a>V模型：</h5><ol>
<li><img src="/assets/1/image-20211203161103-lhdu2tl.png" alt="image.png"></li>
</ol>
</li>
<li><h5 id="瀑布模型以及其他：-迭代模型"><a href="#瀑布模型以及其他：-迭代模型" class="headerlink" title="瀑布模型以及其他： 迭代模型"></a>瀑布模型以及其他： <a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B/">迭代模型</a></h5></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="敏捷测试"><a href="#敏捷测试" class="headerlink" title="敏捷测试"></a>敏捷测试</h3><ol>
<li>快速迭代，产品通过短期的迭代互通不断迭代产品</li>
<li>快速尝试，避免长时间的需求调研和分析</li>
<li>快速改进，产品上线后根据用户反馈的问题，进行快速的改进</li>
<li>充分交流：每天早上有一个简短的战略会，沟通一下工作的进展和安排</li>
<li>简化流程：丢掉一些形式的东西，使用简单应用的工具开始工作</li>
</ol>
</li>
<li><h3 id="软件架构：b-x2F-s-c-x2F-s"><a href="#软件架构：b-x2F-s-c-x2F-s" class="headerlink" title="软件架构：b&#x2F;s    c&#x2F;s"></a>软件架构：b&#x2F;s    c&#x2F;s</h3><ol>
<li><h5 id="b-x2F-s架构"><a href="#b-x2F-s架构" class="headerlink" title="b&#x2F;s架构"></a>b&#x2F;s架构</h5><ol>
<li>b表示浏览器；s表示服务器、展示以www形式</li>
<li>在浏览器中打开，不占用客户的资源</li>
<li>升级为自动升级</li>
<li>可以跨平台</li>
</ol>
</li>
<li><h5 id="c-x2F-s架构"><a href="#c-x2F-s架构" class="headerlink" title="c&#x2F;s架构"></a>c&#x2F;s架构</h5><ol>
<li>c表示客户端；s表示服务器   以图标形式展示</li>
<li>在电脑桌面中打开，占用客户的资源</li>
<li>升级为手动升级</li>
<li>不可以跨平台，只能在windows系统使用</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="测试分为三轮："><a href="#测试分为三轮：" class="headerlink" title="测试分为三轮："></a>测试分为三轮：</h3><ol>
<li>第一轮：初级测试(冒烟测试)：针对开发出来的前端页面的主功能测试</li>
<li>第二轮：系统测试：细测，性能，安全，兼容性</li>
<li>第三轮：回归测试：对稳定性的测试；最后一个阶段bug相对比较少</li>
</ol>
</li>
<li><h3 id="是否了解SVN"><a href="#是否了解SVN" class="headerlink" title="是否了解SVN"></a>是否了解SVN</h3><ol>
<li>SVN管理项目中产生的所有文档：<ol>
<li>开发的代码，测试计划，测试用例，产品需求，bug单，测试报告，测试总结，（一个人一个账号，根据权限显示对应的内容）</li>
</ol>
</li>
<li>SVN的作用：数据的迁入迁出</li>
</ol>
</li>
<li><h3 id="抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler"><a href="#抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler" class="headerlink" title="抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler"></a>抓包怎么判断是前台还是后台的问题？–学习抓包工具fiddler</h3><ol>
<li>对于某些难以定位的一些问题，一般我利用 fiddler 的抓包工具，去抓取前后台的数据交互的过程， 通过分析请求的数据来判断是前端还是后台的问题</li>
<li>首先看发的请求是否有问题，请求的接口 url 是否有错误，参数是否有错误，如果 url 或传参有问题那就是前端 Bug</li>
<li>如果请求没有问题，看下后台返回的数据是否有问题，状态码 5 开头的基本都是后台问题，状态码为200，响应数据与预期不一致，那也是后台Bug。</li>
<li>返回的数据没有问题，请求参数，url 也没有问题，那可能是前端代码是否转换有问题，那就是前端 Bug。</li>
</ol>
</li>
<li><h3 id="你们上家公司的测试策略是怎么样的？"><a href="#你们上家公司的测试策略是怎么样的？" class="headerlink" title="你们上家公司的测试策略是怎么样的？"></a>你们上家公司的测试策略是怎么样的？</h3><ol>
<li>上一家公司的测试策略基本是这样的，系统已经做好的模块功能，要全测，先测优先级高的用例，上午发现的 bug，下午就要修改完成，回归通过，下午发现的bug，第二天上午就得回归通过,时间挺紧的， 而且第一轮测试还要把所有用例执行完，（如果有自动化，第一轮还要用自动化覆盖所有老用例，在测试环境上执行，而且自动化通过率至少要 90%以上）</li>
<li>第二轮测试呢，要把上轮测试未通过的，补充的用例重新测试，确认所有的缺陷都已经改正才行，然后就要把上一轮bug最多的功能再测一遍，自动化也要重新跑一遍，在测试环境上执行，通过率必须 100%， 就这么多了</li>
</ol>
</li>
<li>对于测试环境实际进行的测试内容为：<br> a.DEV环境：  Development environment   主体是开发厂商自己进行，包括了单元测试+接口集成测试+业务模块功能点的系统测试。<br> b.SIT环境：  SystemIntegrationTesting     可以是整体集成商牵头进行，包括接口集成测试+系统测试，但是全为黑盒测试。<br> c.UAT环境：  UserAcceptanceTesting      以甲方用户牵头进行，也是只进行系统测试，以端到端流程和业务场景驱动进行测试。<br> d.PRD&#x2F;PROD环境：线上环境，生产环境</li>
<li><h2 id="在工作中接触的文档"><a href="#在工作中接触的文档" class="headerlink" title="在工作中接触的文档"></a>在工作中接触的文档</h2><ol>
<li>需求文档   详设文档  测试用例   测试大纲  bug单   测试报告  测试总结  测试计划</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代模型</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/10_%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a><strong>软件的生命周期</strong></h2><p>软件生命周期是软件的产生直到报废或停止使用的生命周期<br>软件生命周期内有问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等阶段。<br>软件开发模型<br><img src="/assets/1/wpsA7E5.tmp-20211120152251-qp0stk4.jpg"><br>瀑布模型是最早的开发模型<br>优点：有利于大型软件开发过程当中人员的组织与管理，提高软件开发的质量与效率<br>缺点：模型是线性的，增加开发的风险，例如需求分析时，已经出现错误，一直没有测试阶段，直到测试阶段才能发现问题。问题修改起来成本增加。另外 用户需求变化太快，前期调研在完善也抵不住用户的需求变更，跟不上市场变化的速度<br>衍生出敏捷开发<br><img src="/assets/1/wpsA7E6.tmp-20211120152251-x8q273s.jpg"><br>看板<br><img src="/assets/1/wpsA7E7.tmp-20211120152251-wbf6fok.jpg"><br>测试模型<br><img src="/assets/1/wpsA7E8.tmp-20211120152251-uf1al0p.jpg"><br>需求分析：首先要做的事，开发 测试 要做什么，分析<br>概要设计：架构的实现，开发做的事，搭建产品的架构<br>详细设计：在概要设计的基础上在每个模块内部实现的逻辑和方法在这个阶段设计好，<br>编码：<br>单元测试：最小测试单元进行测试<br>集成测试；<br>系统测试<br>验收测试<br>（中小型企业使用）<br><img src="/assets/1/wpsA7E9.tmp-20211120152251-xxg84iu.jpg"><br>W模型，在需求设计阶段增加了测试活动，开发测试同步进行（大型企业使用，对人员要求比较高）<br><img src="/assets/1/wpsA7EA.tmp-20211120152251-6i27xmg.jpg"><br>产品迭代，适合小型迭代，测试流程完全独立出来，测试就绪点，测试准入准则<br>一般小型企业使用，项目人员要了解整体情况<br>系统测试流程<br><img src="/assets/1/wpsA7EB.tmp-20211120152251-49ld7zq.jpg"><br>Bug管理流程<br><img src="/assets/1/wpsA7EC.tmp-20211120152251-2ssrp2b.jpg"><br>软件测试流程的价值<br>提高测试效率<br>提高产品质量<br>加强项目成员之间的沟通</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本命令</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/01_Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ol>
<li><p>常用的linux命令：</p>
<ol>
<li><p>ls 显示当前路径下的文件和文件夹（横向显示）</p>
</li>
<li><p>ll 显示当前路径下的文件和文件夹（纵向显示）</p>
</li>
<li><p>ls + 空格+ -a  显示当前路径下的所有隐藏文件</p>
<ol>
<li>-a  称为参数   a 为所有的意思</li>
</ol>
</li>
<li><p>mkdir + 文件夹名    新建文件夹</p>
</li>
<li><p>touch + 文件名   新建文件</p>
</li>
<li><p>clear  清除当前屏幕内容</p>
</li>
<li><p>rm  -rf     （-rf ：  r 递归    f  强制       - rf   强制性递归删除）</p>
</li>
<li><p>cp + 文件名 +路径    复制文件</p>
</li>
<li><p>mv+ 文件（文件夹）名  路径    移动文件&#x2F;文件夹</p>
</li>
<li><p>mv + 文件（文件夹）名  + 文件（文件夹）新名   修改文件名</p>
</li>
<li><p>pwd   查看当前文件夹路径</p>
</li>
<li><p>tar  -cvf    新建文件名（.tar） 要打压缩的文件</p>
</li>
<li><p>tar -xvf    解压的文件</p>
</li>
<li><p>tar  -zcvf    新建文件名（.tar.gz） 要打压缩的文件</p>
</li>
<li><p>tar -zxvf    解压的文件</p>
</li>
<li><p>zip     新建文件名（.zip） 要打压缩的文件</p>
</li>
<li><p>unzip 要解压的文件</p>
</li>
<li><p>vi  + 文件名    进入文件（且为命令状态）</p>
<ol>
<li><p>vi  进入文件命令模式</p>
</li>
<li><p>a    i    进入编辑模式</p>
</li>
<li><p>命令模式：</p>
<ol>
<li>x  小写x删除光标所在字符</li>
<li>X  大写X 删除光标所在字符位置前一个字符</li>
<li>s  小写s  删除光标所在位置并进入编辑状态</li>
<li>S  大写S 删除光标所在行并进入编辑状态</li>
<li>o  小写o 在当前光标所在行的下一行插入空的行，进入编辑状态</li>
<li>O  大写O  在当前光标所在行的上一行插入空的行，进入编辑状态</li>
<li>r  小写r 是替换当前光标所在字符</li>
<li>R 大写R 可以一直替换操作</li>
<li>backspace   键  可以进行返回替换操作， u 是退回上一步操作</li>
<li>dd  删除一行（不要删除直接按u就返回了）</li>
<li>set+nu 设置行号</li>
<li>shift：&#x2F;  esc    进入命令状态</li>
<li>wq！  强制保存退出   w 保存   q 退出   ！ 强制</li>
</ol>
</li>
</ol>
</li>
<li><p>cat  查看小的文件</p>
</li>
<li><p>find   -name   +文件&#x2F;文件夹名    查找文件&#x2F;文件夹</p>
</li>
<li><p>| grep  要过滤的字符</p>
</li>
<li><p>more 查看大的文件</p>
</li>
<li><p>less  查看文件</p>
</li>
<li><p>chmod  修改权限</p>
<ol>
<li><p>u 表示该用户拥有者</p>
</li>
<li><p>g  所属组</p>
</li>
<li><p>o 其他</p>
</li>
<li><p>a 表示以上三个都有</p>
</li>
<li><p>“-” 没有权限</p>
</li>
<li><p>r 表示可读</p>
</li>
<li><p>x表示可执行</p>
</li>
<li><p>w 表示可写</p>
<ol>
<li>chmod a +rwx  文件名   直接添加所有</li>
<li>chmod o - w    文件名   减权限</li>
<li>chmod a - rwx 文件名  直接减所有</li>
</ol>
</li>
<li><p>r 可读  4     w 可写  2     x可执行  1      -  没有权限  0</p>
<ol>
<li>chmod  42-    加权限</li>
</ol>
</li>
</ol>
</li>
<li><p>tail  查看动态日志</p>
<ol>
<li>tail  - 20 文件名   显示从末尾到20行</li>
</ol>
</li>
<li><p>head  查看静态日志</p>
<ol>
<li>head  -n 文件名</li>
</ol>
</li>
<li><p>ps 查看进程</p>
<ol>
<li>ps  查看所有用户的进程</li>
<li>ps -ef 查看所有用户的进程</li>
<li>ps   - aux 查看详细进程</li>
<li>ps - ef | grep       过虑</li>
</ol>
</li>
<li><p>kill -9  id  （进程的id）   不能用，真的删除了</p>
</li>
<li><p>netstat   - an   查看端口号</p>
</li>
<li><p>df  查看分区</p>
<ol>
<li>df  - h  以G的形式查看</li>
</ol>
</li>
<li><p>top 查看动态资源占有率</p>
</li>
<li><p>vmstat  查看静态资源占有率</p>
</li>
<li><p>su  切换用户</p>
</li>
<li><p>du  查看文件夹大小</p>
</li>
<li><p>du   - h    以G的形式显示</p>
</li>
<li><p>find   -name  查找文件</p>
</li>
<li><p>free  查看运行内存和交互内存</p>
</li>
<li><p>rz  从windows 上传文件到linux</p>
</li>
<li><p>sz  从linux下载文件到windows</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>01_Linux系统</category>
        <category>902_课中_linux文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础知识</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/02_%E6%95%B0%E6%8D%AE%E5%BA%93/903_%E8%AF%BE%E4%B8%AD_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E4%BB%B6/01_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>查询语句的执行过程<br><img src="/assets/1/image-20211214111304-o4w9uqm.png" alt="image.png"><br>专业术语<br><img src="/assets/1/image-20211214111328-gt0i4os.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>02_数据库</category>
        <category>903_课中_数据库文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令实操</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C/01_Linux%E7%B3%BB%E7%BB%9F/902_%E8%AF%BE%E4%B8%AD_linux%E6%96%87%E4%BB%B6/02_linux%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<ol>
<li><p>find 基本语法参数如下：</p>
<ol>
<li><pre><code> find [PATH] [option] [action]

 # 与时间有关的参数：
 -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；
 -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；
 -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；
 -newer file : 列出比file还要新的文件名
 # 例如：
 find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件

 # 与用户或用户组名有关的参数：
 -user name : 列出文件所有者为name的文件
 -group name : 列出文件所属用户组为name的文件
 -uid n : 列出文件所有者为用户ID为n的文件
 -gid n : 列出文件所属用户组为用户组ID为n的文件
 # 例如：
 find /home/hadoop -user hadoop # 在目录/home/hadoop中找出所有者为hadoop的文件

 # 与文件权限及名称有关的参数：
 -name filename ：找出文件名为filename的文件
 -size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件
 -tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、
              目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；
 -perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；
 -perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示
 -perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示
 # 例如：
 find / -name passwd # 查找文件名为passwd的文件
 find . -perm 0755 # 查找当前目录中文件权限的0755的文件
 find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte
</code></pre>
<p>  使用截图：</p>
<p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504211338122-1598976431.png"></p>
<p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504211629560-1737782460.png"></p>
<p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160504212137576-1297477565.png"></p>
<ol start="2">
<li>ls 命令，展示文件夹内内容，参数如下：</li>
</ol>
<pre><code>-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ 
-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ 
-d ：仅列出目录本身，而不是列出目录内的档案数据 
-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) 
-F ：根据档案、目录等信息，给予附加数据结构，例如： 
*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； 
-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； 
-i ：列出 inode 位置，而非列出档案属性； 
-l ：长数据串行出，包含档案的属性等等数据； 
-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) 
-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； 
-R ：连同子目录内容一起列出来； 
-S ：以档案容量大小排序！ 
-t ：依时间排序 
--color=never ：不要依据档案特性给予颜色显示； 
--color=always ：显示颜色 
--color=auto ：让系统自行依据设定来判断是否给予颜色 
--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 
--time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) 
而非内容变更时间 (modification time)  

例如：
ls [-aAdfFhilRS] 目录名称 
ls [--color=&#123;none,auto,always&#125;] 目录名称 
ls [--full-time] 目录名称  
</code></pre>
<p>  使用截图：</p>
<p> <img src="/assets/1/image-20211122224052-hv2w7p5.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20211122224059-f0xzfu9.png" alt="image.png"></p>
<ol start="3">
<li>cd 命令：</li>
</ol>
<pre><code>cd /root/Docements # 切换到目录/root/Docements
cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  
cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录
</code></pre>
<p> <img src="/assets/1/image-20211122224108-677n1g7.png" alt="image.png"></p>
<ol start="4">
<li>tree命令，显示树形的层级目录结构，非原生命令，需要安装tree</li>
</ol>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224115-492g23a.png" alt="image.png"></p>
<ol start="5">
<li>cp 命令，作用复制，参数如下：</li>
</ol>
<pre><code>-a ：将文件的特性一起复制
-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份
-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行
-r ：递归持续复制，用于目录的复制行为
-u ：目标文件与源文件有差异时才会复制
</code></pre>
<p>  编辑示例：</p>
<p> <img src="/assets/1/image-20211122224122-kvzer3g.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20211122224130-xstggsr.png" alt="image.png"></p>
<ol start="6">
<li>rm命令作用为删除，参数：</li>
</ol>
<pre><code>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息
-i ：互动模式，在删除前会询问用户是否操作
-r ：递归删除，最常用于目录删除，它是一个非常危险的参数
</code></pre>
<p>  使用示例：</p>
<p> <img src="/assets/1/image-20211122224137-i3kptwv.png" alt="image.png"></p>
<ol start="7">
<li>mv命令作用为移动文件：</li>
</ol>
<pre><code>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖
-i ：若目标文件已经存在，就会询问是否覆盖
-u ：若目标文件已经存在，且比目标文件新，才会更新
</code></pre>
<p> <img src="/assets/1/image-20211122224143-iuk9wzn.png" alt="image.png"></p>
<ol start="8">
<li>pwd命令，作用为查看”当前工作目录“的完整路径</li>
</ol>
<pre><code>pwd -P # 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径
</code></pre>
<p> 使用截图：</p>
<p> <img src="/assets/1/image-20211122224150-p71ji8z.png" alt="image.png"></p>
<ol start="9">
<li>tar命令，用于压缩解压：</li>
</ol>
<pre><code>-c ：新建打包文件
-t ：查看打包文件的内容含有哪些文件名
-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中
-j ：通过bzip2的支持进行压缩/解压缩
-z ：通过gzip的支持进行压缩/解压缩
-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来
-f filename ：filename为要处理的文件
-C dir ：指定压缩/解压缩的目录dir
</code></pre>
<p> 缩略版…</p>
<pre><code>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称
查询：tar -jtv -f filename.tar.bz2
解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录
</code></pre>
<ol start="10">
<li>mkdir命令创建目录：</li>
</ol>
<pre><code>mkdir [选项]... 目录... 
 -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask
 -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; 
 -v, --verbose  每次创建新目录都显示信息
</code></pre>
<p> <img src="/assets/1/image-20211122224158-z6hvsot.png" alt="image.png"></p>
<ol start="11">
<li>rmdir 命令删除目录：</li>
</ol>
<pre><code>rmdir [选项]... 目录...
-p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 
-v --verbose  显示指令执行过程 
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224205-ho83tya.png" alt="image.png"></p>
<ol start="12">
<li>gzip 命令压缩文件或文件夹为 .gz文件：</li>
</ol>
<pre><code> gzip[参数][文件或者目录]
-a or --ascii 　使用ASCII文字模式。 
-c or --stdout or --to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 
-d or --decompress or ----uncompress 　解开压缩文件。 
-f or --force 　强行压缩文件。不理会文件名称 or 硬连接是否存在以及该文件是否为符号连接。 
-h or --help 　在线帮助。 
-l or --list 　列出压缩文件的相关信息。 
-L or --license 　显示版本与版权信息。 
-n or --no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 
-N or --name 　压缩文件时，保存原来的文件名称及时间戳记。 
-q or --quiet 　不显示警告信息。 
-r or --recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 
-S&lt;压缩字尾字符串&gt; or ----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 
-t or --test 　测试压缩文件是否正确无误。 
-v or --verbose 　显示指令执行过程。 
-V or --version 　显示版本信息。 
-num 用指定的数字num调整压缩的速度，-1 or --fast表示最快压缩方法（低压缩比），-9 or --best表示最慢压缩方法（高压缩比）。系统缺省值为6。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224214-u5sy61x.png" alt="image.png"></p>
<p> <strong>二. 进程相关命令：</strong></p>
<ol start="13">
<li>ps 命令显示运行的进程，还会显示进程的一些信息如pid, cpu和内存使用情况等：</li>
</ol>
<pre><code>-A ：所有的进程均显示出来
-a ：不与terminal有关的所有进程
-u ：有效用户的相关进程
-x ：一般与a参数一起使用，可列出较完整的信息
-l ：较长，较详细地将PID的信息列出
</code></pre>
<p>  使用示例：</p>
<p> <img src="/assets/1/image-20211122224220-7x3b7a0.png" alt="image.png"></p>
<ol start="14">
<li>kill 命令用于终止进程，参数：</li>
</ol>
<pre><code>kill -signal PID

1：SIGHUP，启动被终止的进程
2：SIGINT，相当于输入ctrl+c，中断一个程序的进行
9：SIGKILL，强制中断一个进程的进行
15：SIGTERM，以正常的结束进程方式来终止进程
17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224228-nl950hz.png" alt="image.png"></p>
<ol start="15">
<li>killall 命令和参数：</li>
</ol>
<pre><code>killall [-iIe] [command name]

-i ：交互式的意思，若需要删除时，会询问用户
-e ：表示后面接的command name要一致，但command name不能超过15个字符
-I ：命令名称忽略大小写
# 例如：
killall -SIGHUP syslogd # 重新启动syslogd
</code></pre>
<p>  使用示例：</p>
<p> <img src="/assets/1/image-20211122224234-v7au6zb.png" alt="image.png"></p>
<ol start="16">
<li>crontab命令是启动linux定时任务的服务</li>
</ol>
<pre><code>service cron start # 启动cronjob
service cron stop # 停止cronjob
service cron restart #  重启cronjob
crontab -e # 编辑cronjob任务
</code></pre>
<p> 使用示例：打开crontab -e后通过vi方式编辑任务列表</p>
<p> <img src="/assets/1/image-20211122224241-dq8lpqb.png" alt="image.png"></p>
<ol start="17">
<li>free 命令用于显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer：</li>
</ol>
<pre><code>free [参数]
-b 　以Byte为单位显示内存使用情况。 
-k 　以KB为单位显示内存使用情况。 
-m 　以MB为单位显示内存使用情况。
-g   以GB为单位显示内存使用情况。 
-o 　不显示缓冲区调节列。 
-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 
-t 　显示内存总和列。 
-V 　显示版本信息。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224250-pjnkr61.png" alt="image.png"></p>
<ol start="18">
<li>top 命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器：</li>
</ol>
<pre><code>top [参数]
-b 批处理
-c 显示完整的治命令
-I 忽略失效过程
-s 保密模式
-S 累积模式
-i&lt;时间&gt; 设置间隔时间
-u&lt;用户名&gt; 指定用户名
-p&lt;进程号&gt; 指定进程
-n&lt;次数&gt; 循环显示的次数
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224256-wshssr0.png" alt="image.png"></p>
<p> <strong>三. 权限相关命令：</strong></p>
<ol start="19">
<li>chmod命令：</li>
</ol>
<pre><code>chmod [-R] xyz 文件或目录
-R：进行递归的持续更改，即连同子目录下的所有文件都会更改
</code></pre>
<pre><code>#同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改，编号是各种权限的数字代码，示例：
chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x
chmod g+w file # 向file的文件权限中加入用户组可写权限
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224304-fl7x0xb.png" alt="image.png"></p>
<ol start="20">
<li>chown命令改变文件所有者：</li>
</ol>
<pre><code>chown [para]... [owner][:[group]] file...
</code></pre>
<p>   -c 显示更改的部分的信息</p>
<p> 　-f 忽略错误信息</p>
<p> 　-h 修复符号链接</p>
<p> 　-R 处理指定目录以及其子目录下的所有文件</p>
<p> 　-v 显示详细的处理信息</p>
<p> 　-deference 作用于符号链接的指向，而不是链接文件本身</p>
<p>  使用示例：</p>
<p> <img src="/assets/1/image-20211122224310-6w1fr7l.png" alt="image.png"></p>
<ol start="21">
<li>chgrp命令，改变文件所属组：</li>
</ol>
<pre><code>-c 当发生改变时输出调试信息
-f 不显示错误信息
-R 处理指定目录以及其子目录下的所有文件
-v 运行时显示详细的处理信息
--dereference 作用于符号链接的指向，而不是符号链接本身
--no-dereference 作用于符号链接本身
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224318-udazx56.png" alt="image.png"></p>
<ol start="22">
<li>useradd 命令建立用户账号：</li>
</ol>
<pre><code>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号] 

    -c #&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。　
　　-d #&lt;登入目录&gt; 　指定用户登入时的启始目录。
　　-D #　变更预设值．
　　-e # &lt;有效期限&gt; 　指定帐号的有效期限。
　　-f # &lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。
　　-g # &lt;群组&gt; 　指定用户所属的群组。
　　-G # &lt;群组&gt; 　指定用户所属的附加群组。
　　-m # 自动建立用户的登入目录。
　　-M # 不要自动建立用户的登入目录。
　　-n # 取消建立以用户名称为名的群组．
　　-r # 建立系统帐号。
　　-s # 指定用户登入后所使用的shell。
　　-u # 指定用户ID。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224326-axrl6j6.png" alt="image.png"></p>
<ol start="23">
<li>usermod 修改用户信息：</li>
</ol>
<pre><code>usermod -h
usermod [options] LOGIN
</code></pre>
<p>  -c #后面接账号的说明，即&#x2F;etc&#x2F;passwd第五栏的说明栏，可以加入一些账号的说明<br>  -d #后面接账号的家目录，即修改&#x2F;etc&#x2F;passwd的第六栏<br>  -e #后面接日期，格式是YYYY-MM-DD也就是在&#x2F;etc&#x2F;shadow内的第八栏<br>  -f #后面接天数，修改shadow的第七栏<br>  -g #后面接主群组，修改&#x2F;etc&#x2F;passwd的第四个字段，即是GID的字段<br>  -G #后面接附加群组，修改这个使用者能够支持的群组，修改的是&#x2F;etc&#x2F;group<br>  -a #与 -G 合用，可增加附加群组的支持而非设定<br>  -l #后面接账号名称。修改账号名称，&#x2F;etc&#x2F;passwd的第一栏<br>  -s #后面接Shell的文件，例如&#x2F;bin&#x2F;bash或&#x2F;bin&#x2F;csh等等<br>  -u #后面接 UID 数字，修改用户的UID &#x2F;etc&#x2F;passwd第三栏<br>  -L #暂时将用户的密码冻结，让他无法登入。其实就是在&#x2F;etc&#x2F;shadow的密码栏前面加上了“!”<br>  -U #将&#x2F;etc&#x2F;shadow 密码栏的“!”去掉</p>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224335-lrs0c06.png" alt="image.png"></p>
<ol start="24">
<li>userdel 删除用户：</li>
</ol>
<pre><code>userdel [options] LOGIN
-f # 强制删除，包括用户的一切相关内容，这个参数是危险的参数，不建议大家使用。详细说明看MAN
-r # 删除用户的家目录和用户的邮件池
</code></pre>
<p> <img src="/assets/1/image-20211122224341-3cqfuie.png" alt="image.png"></p>
<ol start="25">
<li>groupadd　命令用于将新组加入系统：</li>
</ol>
<pre><code>groupadd [－g gid] [－o]] [－r] [－f] groupname

－g gid：指定组ID号。
－o：允许组ID号，不必惟一。
－r：加入组ID号，低于499系统账号。
－f：加入已经有的组时，发展程序退出。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224347-bl46p38.png" alt="image.png"></p>
<ol start="26">
<li>groupdel　命令删除组：</li>
</ol>
<pre><code>＃　用于删除不再需要的组，如果指定的组中包含用户，则必须先删除组里面的用户&gt;以后，才能删除组
groupdel [options] GROUP
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224353-2gftldo.png" alt="image.png"></p>
<ol start="27">
<li>sudo 用来以其他身份来执行命令，预设的身份为root:</li>
</ol>
<pre><code>sudo(选项)(参数)

-b：在后台执行指令；
-h：显示帮助；
-H：将HOME环境变量设为新身份的HOME环境变量；
-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。
-l：列出目前用户可执行与无法执行的指令；
-p：改变询问密码的提示符号；
-s：执行指定的shell；
-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；
-v：延长密码有效期限5分钟；
-V ：显示版本信息。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224353-2gftldo.png" alt="image.png"></p>
<ol start="28">
<li>passwd 设置用户的密码：</li>
</ol>
<pre><code>passwd [OPTION...] &lt;accountName&gt;
-k, --keep-tokens       keep non-expired authentication tokens
-d, --delete            delete the password for the named account (root only)
-l, --lock              lock the named account (root only)
-u, --unlock            unlock the named account (root only)
-f, --force             force operation
-x, --maximum=DAYS      maximum password lifetime (root only)
-n, --minimum=DAYS      minimum password lifetime (root only)
-w, --warning=DAYS      number of days warning users receives before password expiration (root only)
-i, --inactive=DAYS     number of days after password expiration when an account becomes disabled (root only)
-S, --status            report password status on the named account (root)
</code></pre>
<p> <img src="/assets/1/image-20211122224406-25bth2a.png" alt="image.png"></p>
<ol start="29">
<li>groups 显示用户所属组：</li>
</ol>
<pre><code>groups # 默认显示当前用户的组

groups hadoop2 # 显示hadoop2用户的组
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224412-5vhacar.png" alt="image.png"></p>
<p> <strong>四. 文本查看编辑等命令</strong></p>
<ol start="30">
<li>vi&#x2F;vim 是使用vi编辑器的命令：</li>
</ol>
<pre><code>vi /var/log/aa.log # 打开 /var/log/aa.log文件并编辑
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224419-x1zt9xw.png" alt="image.png"></p>
<p> vi的操作命令比较复杂，就不在这里详细展开了。</p>
<ol start="31">
<li>cat　用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。</li>
</ol>
<pre><code> cat [选项] [文件]...
-A, --show-all           等价于 -vET
-b, --number-nonblank    对非空输出行编号
-e                       等价于 -vE
-E, --show-ends          在每行结束处显示 $
-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号
-s, --squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行 
-t                       与 -vT 等价
-T, --show-tabs          将跳格字符显示为 ^I
-u                       (被忽略)
-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224426-8n5q9cp.png" alt="image.png"></p>
<ol start="32">
<li>more 命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能：</li>
</ol>
<pre><code>more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 
命令参数：
+n 从笫n行开始显示
-n 定义屏幕大小为n行
+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 
-c 从顶部清屏，然后显示
-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能
-l 忽略Ctrl+l（换页）字符
-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
-s 把连续的多个空行显示为一行
-u 把文件内容中的下画线去掉
常用操作命令：
Enter 向下n行，需要定义。默认为1行
Ctrl+F 向下滚动一屏
空格键 向下滚动一屏
Ctrl+B 返回上一屏
= 输出当前行的行号
：f 输出文件名和当前行的行号
V 调用vi编辑器
!命令 调用Shell，并执行命令 
q 退出more
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224434-a522j9k.png" alt="image.png"></p>
<ol start="33">
<li>less　命令用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</li>
</ol>
<pre><code> less [参数]  文件 
-b &lt;缓冲区大小&gt; 设置缓冲区的大小
-e 当文件显示结束后，自动离开
-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-g 只标志最后搜索的关键词
-i 忽略搜索时的大小写
-m 显示类似more命令的百分比
-N 显示每行的行号
-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来
-Q 不使用警告音
-s 显示连续空行为一行
-S 行过长时间将超出部分舍弃
-x &lt;数字&gt; 将“tab”键显示为规定的数字空格
/字符串：向下搜索“字符串”的功能
?字符串：向上搜索“字符串”的功能
n：重复前一个搜索（与 / 或 ? 有关）
N：反向重复前一个搜索（与 / 或 ? 有关）
b 向后翻一页
d 向后翻半页
h 显示帮助界面
Q 退出less 命令
u 向前滚动半页
y 向前滚动一行
空格键 滚动一行
回车键 滚动一页
[pagedown]： 向下翻动一页
[pageup]： 向上翻动一页
</code></pre>
<p> 使用示例：</p>
<p> <img src="https://images2015.cnblogs.com/blog/947313/201605/947313-20160507155949515-2041094265.png"></p>
<p> <img src="/assets/1/image-20211122224448-1w68car.png" alt="image.png"></p>
<ol start="34">
<li>tail 命令</li>
</ol>
<pre><code>#从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示
在屏幕上,并且不但刷新,使你看到最新的文件内容. 
tail[必要参数][选择参数][文件]   

-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c&lt;数目&gt; 显示的字节数
-n&lt;行数&gt; 显示行数
--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. 
-q, --quiet, --silent 从不输出给出文件名的首部 
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224455-m4rxv5g.png" alt="image.png"></p>
<ol start="35">
<li>head 命令用于显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行：</li>
</ol>
<pre><code>head [参数]... [文件]...  
-q 隐藏文件名
-v 显示文件名
-c&lt;字节&gt; 显示字节数
-n&lt;行数&gt; 显示的行数
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224502-vj0dcek.png" alt="image.png"></p>
<ol start="36">
<li>diff 命令用于比较两个文件或目录的不同：</li>
</ol>
<pre><code> diff[参数][文件1或目录1][文件2或目录2]

# diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定
比较的是目录的的时候，diff 命令会比较两个目录下名字相同的
# 文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。

-a or --text 　#diff预设只会逐行比较文本文件。
-b or --ignore-space-change 　#不检查空格字符的不同。
-B or --ignore-blank-lines 　#不检查空白行。
-c 　#显示全部内文，并标出不同之处。
-C or --context 　#与执行&quot;-c-&quot;指令相同。
-d or --minimal 　#使用不同的演算法，以较小的单位来做比较。
-D or ifdef 　#此参数的输出格式可用于前置处理器巨集。
-e or --ed 　#此参数的输出格式可用于ed的script文件。
-f or -forward-ed 　#输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。
-H or --speed-large-files 　#比较大文件时，可加快速度。
-l or --ignore-matching-lines 　#若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符 or 字符串，则不显示这两个文件的差异。
-i or --ignore-case 　#不检查大小写的不同。
-l or --paginate 　#将结果交由pr程序来分页。
-n or --rcs 　#将比较结果以RCS的格式来显示。
-N or --new-file 　#在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。
-p 　#若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。
-P or --unidirectional-new-file 　#与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。
-q or --brief 　#仅显示有无差异，不显示详细的信息。
-r or --recursive 　#比较子目录中的文件。
-s or --report-identical-files 　#若没有发现任何差异，仍然显示信息。
-S or --starting-file 　#在比较目录时，从指定的文件开始比较。
-t or --expand-tabs 　#在输出时，将tab字符展开。
-T or --initial-tab 　#在每行前面加上tab字符以便对齐。
-u,-U or --unified= 　#以合并的方式来显示文件内容的不同。
-v or --version 　#显示版本信息。
-w or --ignore-all-space 　#忽略全部的空格字符。
-W or --width 　#在使用-y参数时，指定栏宽。
-x or --exclude 　#不比较选项中所指定的文件 or 目录。
-X or --exclude-from 　#您可以将文件 or 目录类型存成文本文件，然后在=中指定此文本文件。
-y or --side-by-side 　#以并列的方式显示文件的异同之处。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224509-vbbhrfp.png" alt="image.png"></p>
<p> <img src="/assets/1/image-20211122224514-2y6th4o.png" alt="image.png"></p>
<p> <strong>网络相关命令：</strong></p>
<ol start="37">
<li>ping 用于确定主机与外部连接状态：</li>
</ol>
<pre><code>ping [参数] [主机名或IP地址]
-d 使用Socket的SO_DEBUG功能。
-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。
-n 只输出数值。
-q 不显示任何传送封包的信息，只显示最后的结果。
-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。
-R 记录路由过程。
-v 详细显示指令的执行过程。
&lt;p&gt;-c 数目：在发送指定数目的包后停止。
-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。
-I 网络界面：使用指定的网络界面送出数据包。
-l 前置载入：设置在送出要求信息之前，先行发出的数据包。
-p 范本样式：设置填满数据包的范本样式。
-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。
-t 存活数值：设置存活数值TTL的大小。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224521-kf8ed1z.png" alt="image.png"></p>
<ol start="38">
<li>ssh 命令用于远程登录上Linux主机：</li>
</ol>
<pre><code>ssh [-l login_name] [-p port] [user@]hostname
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224527-ohj9izq.png" alt="image.png"></p>
<ol start="39">
<li>scp 命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的：</li>
</ol>
<pre><code>scp [参数] [原路径] [目标路径]

-1 强制scp命令使用协议ssh1 
-2 强制scp命令使用协议ssh2 
-4 强制scp命令只使用IPv4寻址 
-6 强制scp命令只使用IPv6寻址 
-B 使用批处理模式（传输过程中不询问传输口令或短语） 
-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） 
-p 保留原文件的修改时间，访问时间和访问权限。 
-q 不显示传输进度条。 
-r 递归复制整个目录。 
-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 
-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 
-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 
-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 
-l limit 限定用户所能使用的带宽，以Kbit/s为单位。 
-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， 
-P port 注意是大写的P, port是指定数据传输用到的端口号 
-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224534-eahegc7.png" alt="image.png"></p>
<ol start="40">
<li>telnet 命令用来远程登录操作：</li>
</ol>
<pre><code> telnet[参数][主机]

-8 允许使用8位字符资料，包括输入与输出。
-a 尝试自动登入远端系统。
-b&lt;主机别名&gt; 使用别名指定远端主机名称。
-c 不读取用户专属目录里的.telnetrc文件。
-d 启动排错模式。
-e&lt;脱离字符&gt; 设置脱离字符。
-E 滤除脱离字符。
-f 此参数的效果和指定&quot;-F&quot;参数相同。
-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。
-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。
-K 不自动登入远端主机。
-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。
-L 允许输出8位字符资料。
-n&lt;记录文件&gt; 指定文件记录相关信息。
-r 使用类似rlogin指令的用户界面。
-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。
-x 假设主机有支持数据加密的功能，就使用它。
-X&lt;认证形态&gt; 关闭指定的认证形态。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224540-7uvwxi6.png" alt="image.png"></p>
<ol start="41">
<li>wget 是从远程下载的工具：</li>
</ol>
<pre><code>wget [参数] [URL地址]

启动参数：
-V, –version 显示wget的版本后退出
-h, –help 打印语法帮助
-b, –background 启动后转入后台执行
-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc

记录和输入文件参数：
-o, –output-file=FILE 把记录写到FILE文件中
-a, –append-output=FILE 把记录追加到FILE文件中
-d, –debug 打印调试输出
-q, –quiet 安静模式(没有输出)
-v, –verbose 冗长模式(这是缺省设置)
-nv, –non-verbose 关掉冗长模式，但不是安静模式
-i, –input-file=FILE 下载在FILE文件中出现的URLs
-F, –force-html 把输入文件当作HTML格式文件对待
-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀
–sslcertfile=FILE 可选客户端证书
–sslcertkey=KEYFILE 可选客户端证书的KEYFILE
–egd-file=FILE 指定EGD socket的文件名

下载参数：
–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)
-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).
-O –output-document=FILE 把文档写到FILE文件中
-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀
-c, –continue 接着下载没下载完的文件
–progress=TYPE 设定进程条标记
-N, –timestamping 不要重新下载文件除非比本地文件新
-S, –server-response 打印服务器的回应
–spider 不下载任何东西
-T, –timeout=SECONDS 设定响应超时的秒数
-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒
–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒
–random-wait 在下载之间等待0…2*WAIT秒
-Y, –proxy=on/off 打开或关闭代理
-Q, –quota=NUMBER 设置下载的容量限制
–limit-rate=RATE 限定下载输率

目录参数：
-nd –no-directories 不创建目录
-x, –force-directories 强制创建目录
-nH, –no-host-directories 不创建主机目录
-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…
–cut-dirs=NUMBER 忽略 NUMBER层远程目录

HTTP 选项参数：
–http-user=USER 设定HTTP用户名为 USER.
–http-passwd=PASS 设定http密码为 PASS
-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)
-E, –html-extension 将所有text/html文档以.html扩展名保存
–ignore-length 忽略 `Content-Length’头域
–header=STRING 在headers中插入字符串 STRING
–proxy-user=USER 设定代理的用户名为 USER
–proxy-passwd=PASS 设定代理的密码为 PASS
–referer=URL 在HTTP请求中包含 `Referer: URL’头
-s, –save-headers 保存HTTP头到文件
-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION
–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)
–cookies=off 不使用 cookies
–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie
–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中

FTP 选项参数：
-nr, –dont-remove-listing 不移走 `.listing’文件
-g, –glob=on/off 打开或关闭文件名的 globbing机制
–passive-ftp 使用被动传输模式 (缺省值).
–active-ftp 使用主动传输模式
–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)

递归下载参数：
-r, –recursive 递归下载－－慎用!
-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)
–delete-after 在现在完毕后局部删除文件
-k, –convert-links 转换非相对链接为相对链接
-K, –backup-converted 在转换文件X之前，将之备份为 X.orig
-m, –mirror 等价于 -r -N -l inf -nr
-p, –page-requisites 下载显示HTML文件的所有图片

递归下载中的包含和不包含(accept/reject)：
-A, –accept=LIST 分号分隔的被接受扩展名的列表
-R, –reject=LIST 分号分隔的不被接受的扩展名的列表
-D, –domains=LIST 分号分隔的被接受域的列表
–exclude-domains=LIST 分号分隔的不被接受的域的列表
–follow-ftp 跟踪HTML文档中的FTP链接
–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表
-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表
-H, –span-hosts 当递归时转到外部主机
-L, –relative 仅仅跟踪相对链接
-I, –include-directories=LIST 允许目录的列表
-X, –exclude-directories=LIST 不被包含目录的列表
-np, –no-parent 不要追溯到父目录
wget -S –spider url 不下载只显示过程
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224550-6wlept6.png" alt="image.png"></p>
<ol start="42">
<li>ifconfig　命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置：</li>
</ol>
<pre><code> ifconfig [网络设备] [参数]

up 启动指定网络设备/网卡。
down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。
arp 设置指定网卡是否支持ARP协议。
-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包
-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包
-a 显示全部接口信息
-s 显示摘要信息（类似于 netstat -i）
add 给指定网卡配置IPv6地址
del 删除指定网卡的IPv6地址
&lt;硬件地址&gt; 配置网卡最大的传输单元
mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)
netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。
tunel 建立隧道
dstaddr 设定一个远端地址，建立点对点通信
-broadcast&lt;地址&gt; 为指定网卡设置广播协议
-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议
multicast 为网卡设置组播标志
address 为网卡设置IPv4地址
txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224557-cjhqx1y.png" alt="image.png"></p>
<ol start="43">
<li>route</li>
</ol>
<pre><code> route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 
-c  # 显示更多信息
-n  # 不解析名字
-v  # 显示详细的处理信息
-F  # 显示发送信息
-C # 显示路由缓存
-f  # 清除所有网关入口的路由表。 
-p # 与 add 命令一起使用时使路由具有永久性。
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224604-4lniowf.png" alt="image.png"></p>
<p> <strong>五. 搜索文件：</strong></p>
<ol start="44">
<li>whereis 命令：</li>
</ol>
<pre><code># whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 

 whereis [-bmsu] [BMS 目录名 -f ] 文件名
</code></pre>
<p> 　-b 定位可执行文件。<br> 　-m 定位帮助文件。<br> 　-s 定位源代码文件。<br> 　-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。<br> 　-B 指定搜索可执行文件的路径。<br> 　-M 指定搜索帮助文件的路径。<br> 　-S 指定搜索源代码文件的路径。</p>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224612-awkb0rj.png" alt="image.png"></p>
<ol start="45">
<li>locate　命令</li>
</ol>
<pre><code>＃　locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)

Locate [选择参数] [样式]
-e   将排除在寻找的范围之外。
-1  如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。
-f   将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。
-q  安静模式，不会显示任何错误讯息。
-n 至多显示 n个输出。
-r 使用正规运算式 做寻找的条件。
-o 指定资料库存的名称。
-d 指定资料库的路径
-h 显示辅助讯息
-V 显示程式的版本讯息
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224620-3i0tc39.png" alt="image.png"></p>
<ol start="46">
<li>which 会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果：</li>
</ol>
<pre><code>which 可执行文件名称 
-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-p 　与-n参数相同，但此处的包括了文件的路径。
-w 　指定输出时栏位的宽度。
-V 　显示版本信息
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224626-1ptxl30.png" alt="image.png"></p>
<p> <strong>六. 其他：</strong></p>
<ol start="47">
<li>grep命令</li>
</ol>
<p> 该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，比如可以加在ps, tail, cat后面</p>
<p> 它的简单语法为</p>
<pre><code>grep [-acinv] [--color=auto] &#39;查找字符串&#39; filename
</code></pre>
<p>  使用示例：</p>
<p> <img src="/assets/1/image-20211122224632-20ikszh.png" alt="image.png"></p>
<ol start="48">
<li>clear 命令用于清除终端屏幕上现有的文字内容，将之上滚：</li>
</ol>
<p>  额，这条不需要啥示例，非常简单…用了以后就没有了…</p>
<ol start="49">
<li>date 命令用于显示或设定时间：</li>
</ol>
<pre><code>date [参数]... [+格式]

必要参数:
%H 小时(以00-23来表示)。 
%I 小时(以01-12来表示)。 
%K 小时(以0-23来表示)。 
%l 小时(以0-12来表示)。 
%M 分钟(以00-59来表示)。 
%P AM或PM。 
%r 时间(含时分秒，小时以12小时AM/PM来表示)。 
%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 
%S 秒(以本地的惯用法来表示)。 
%T 时间(含时分秒，小时以24小时制来表示)。 
%X 时间(以本地的惯用法来表示)。 
%Z 市区。 
%a 星期的缩写。 
%A 星期的完整名称。 

%b 月份英文名的缩写。 
%B 月份的完整英文名称。 
%c 日期与时间。只输入date指令也会显示同样的结果。 
%d 日期(以01-31来表示)。 
%D 日期(含年月日)。 
%j 该年中的第几天。 
%m 月份(以01-12来表示)。 
%U 该年中的周数。 
%w 该周的天数，0代表周日，1代表周一，异词类推。 
%x 日期(以本地的惯用法来表示)。 
%y 年份(以00-99来表示)。 
%Y 年份(以四位数来表示)。 
%n 在显示时，插入新的一行。 
%t 在显示时，插入tab。 
MM 月份(必要) 
DD 日期(必要) 
hh 小时(必要) 
mm 分钟(必要)
ss 秒(选择性) 

选择参数:
-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。 
-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。 
-u 　显示GMT。 
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224640-37cec89.png" alt="image.png"></p>
<ol start="50">
<li>ln 命令是为某一个文件在另外一个位置建立一个同步的链接</li>
</ol>
<pre><code>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。

软链接：
1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
2.软链接可以 跨文件系统 ，硬链接不可以
3.软链接可以对一个不存在的文件名进行链接
4.软链接可以对目录进行链接

硬链接:
1.硬链接，以文件副本的形式存在。但不占用实际空间。
2.不允许给目录创建硬链接
3.硬链接只有在同一个文件系统中才能创建

ln [参数][源文件或目录][目标文件或目录]

必要参数:
-b 删除，覆盖以前建立的链接
-d 允许超级用户制作目录的硬链接
-f 强制执行
-i 交互模式，文件存在则提示用户是否覆盖
-n 把符号链接视为一般目录
-s 软链接(符号链接)
-v 显示详细的处理过程

选择参数:
-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”
-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”
</code></pre>
<p> 使用示例：</p>
<p> <img src="/assets/1/image-20211122224646-p8ocp5y.png" alt="image.png"></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>03_第三章操作</category>
        <category>01_Linux系统</category>
        <category>902_课中_linux文件</category>
      </categories>
      <tags>
        <tag>课前</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试执行</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/07_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试报告</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/08_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>测试用例设计</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/05_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<ul>
<li><a href="../03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">黑盒测试</a></li>
<li>测试用例是什么样的<br><img src="/assets/1/image-20211203142629-2n42d14.png" alt="测试用例是什么样的"></li>
<li>目的<ul>
<li>绕不过的面试题</li>
<li>测试人员必备技能</li>
</ul>
</li>
<li>测试用例<ul>
<li>测试用例是为了发现软件存在的问题编写的一组包含测试输入、执行条件以及预期结果的文档，用来核实软件产品是否满需求</li>
<li><img src="/assets/1/image-20211120151028-c13v85v.png" alt="image.png"></li>
</ul>
</li>
<li>测试用例的目的<ul>
<li>理清思路，避免漏测和重测</li>
<li>提高测试效率</li>
<li>跟进测试进度</li>
<li>告诉领导做过什么</li>
<li>跟进重复性工作</li>
<li>更好的记录问题，发现问题，复现问题</li>
</ul>
</li>
<li>测试用例的组成<ul>
<li>用例编号<br>模块<br>测试标题<br>前置条件<br>操作步骤<br>预期结果<br>实际结果</li>
</ul>
</li>
<li>测试用例编写工具<ul>
<li>ximnd：思维导图工具<br>插入子主题：tab<br>插入兄弟主题（后面）：enter<br>插入兄弟主题（前面）：shift+enter</li>
<li>Excel</li>
</ul>
</li>
<li>测试用例编写方法<ul>
<li>划分功能模块<br>正向功能验证：正确的操作功能是否实现<br>单个功能项验证：正向+异常<br>功能之间交互验证：模块之间的数据传递<br>隐形需求：熟悉业务</li>
</ul>
</li>
<li>输入项设计要点<ul>
<li>数据长度验证<br>数据类型验证<br>是否必填项验证<br>限制约束验证</li>
</ul>
</li>
<li><a href="../06_%E7%99%BB%E5%BD%95/">实战：登录</a></li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>登录</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><p>需求</p>
<ul>
<li><img src="/assets/1/image-20211120214210-0675h05.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211120214217-er5hgua.png" alt="image.png"></li>
</ul>
</li>
<li><p>xmind编写</p>
<ul>
<li>关闭按钮</li>
<li>账号密码登录<ul>
<li>正向功能验证<ul>
<li>正确的手机号+正确的密码+点击登录      登陆成功</li>
<li>正确的邮箱+正确的密码+点击登录        登陆成功</li>
</ul>
</li>
<li>头像<ul>
<li>展示<ul>
<li>账号空白时    展示默认头像</li>
<li>输入修改头像的已注册账号时     展示自定义头像</li>
<li>输入未注册账号时  展示默认头像</li>
<li>输入未修改头像已注册账号时  展示默认头像</li>
</ul>
</li>
</ul>
</li>
<li>账号<ul>
<li>手机号<ul>
<li>账号输入10位数字，输入符合要求的密码，点击登录 提示：手机号错误</li>
<li>账号输入12位数字，输入符合要求的密码，点击登录    提示：手机号错误</li>
<li>账号输入11位包含非数字，输入符合要求的密码，点击登录   提示：用户名或者密码错误</li>
<li>输入未注册的手机号+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li>
<li>输入空值+输入符合要求的密码+点击登录 提示：账号不能为空</li>
</ul>
</li>
<li>邮箱<ul>
<li>输入错误的邮箱格式+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li>
<li>输入没有注册的邮箱+输入符合要求的密码+点击登录 提示：用户名或者密码错误</li>
</ul>
</li>
</ul>
</li>
<li>密码<ul>
<li>输入正确的账号+输入5位密码+点击登录   登录按钮置灰不可点击</li>
<li>输入正确的账号+输入7位密码+点击登录   提示：用户名或者密码错误</li>
</ul>
</li>
<li>忘记密码？</li>
<li>登录<ul>
<li>弱网    展示正在加载图标</li>
<li>断网      断网提示</li>
<li>频点登录    提示：频繁登录</li>
</ul>
</li>
<li>验证码快捷登录</li>
<li>海外手机号登录</li>
</ul>
</li>
<li>验证码快捷登录</li>
<li>第三方登录</li>
<li>海外手机号登录</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>windows与linux的区别</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/03_windows%E4%B8%8Elinux%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Windows和Linux是完全不同的两种操作系统。 Windows是微软公司出的商业操作系统，在全球90%以上的电脑用的都是Windows的操作系统。 Linux是一款开源免费的操作系统，不用掏钱就能用。全球好多服务器用的是这个操作系统。</p>
<p>做为个人电脑使用，这两种系统对比有什么优缺点呢？ 首先说说Windows。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><img src="/assets/1/image-20211122224703-cy1k2rz.png" alt="image.png"></p>
<p>Windows 做为全球使用量第一的操作系统，要说没有优点那是不可能的。 不但有优点，而且还有很多优点，有些优点还是其他操作系统无论如何也追不上的。</p>
<h3 id="1-不用安装"><a href="#1-不用安装" class="headerlink" title="1. 不用安装"></a>1. 不用安装</h3><p>这个不用安装并不是说不用安装操作系统，而是除了Mac之外，99%以上的个人电脑都是在出厂的时候就安装好了Windows系统， 电脑到手直接使用就行，不用再担心还要安装系统的问题。</p>
<h3 id="2-容易维修"><a href="#2-容易维修" class="headerlink" title="2. 容易维修"></a>2. 容易维修</h3><p>正是因为Windows是全球使用量第一的操作系统， 所以几乎所有的电脑店里面都是以维修Windows电脑为主。 如果系统出的问题，基本随便到一个电脑店都能解决。</p>
<h3 id="3-软件和游戏数量极大"><a href="#3-软件和游戏数量极大" class="headerlink" title="3. 软件和游戏数量极大"></a>3. 软件和游戏数量极大</h3><p>Windows全球使用量第一，所以全球开发者数量也很高。 这就造成了Windows上面的软件数量非常非常之大，这点是Linux无论如何也追不上的。 像我们国内常用的QQ，微信等在Linux上就没有， 更不要说像英雄联盟，绝地求生这些游戏了。 在Linux中虽然也能通过Wine安装Windows软件， 但大部分软件都是不兼容的， 而且安装了Wine以后整个系统都不稳定了。</p>
<h3 id="4-硬件兼容性好"><a href="#4-硬件兼容性好" class="headerlink" title="4. 硬件兼容性好"></a>4. 硬件兼容性好</h3><p>很多硬件的驱动在Windows能很方便的安装，但在Linux的根本就没有。 比如我用的笔记本，在使用Windows系统，WiFi，蓝牙，各种硬件都正常， 但使用Linux系统WiFi是不能用的， 还要自己编译安装驱动程序。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><img src="/assets/1/image-20211122224710-34agwn3.png" alt="image.png"></p>
<p>Linux做为开源免费的操作系统，也有些优点是Windows无论如何也赶不上的。</p>
<h3 id="1-不用花钱"><a href="#1-不用花钱" class="headerlink" title="1. 不用花钱"></a>1. 不用花钱</h3><p>正版的Windows系统是要花钱购买的，而且价钱还不低（买笔记本带Windows系统其实系统钱是包含在里面的）。 而Linux是开源免费的，任何人不用花钱都可以下载使用，而且有多个发行版可供选择。</p>
<h3 id="2-稳定性-x2F-流畅度高"><a href="#2-稳定性-x2F-流畅度高" class="headerlink" title="2. 稳定性&#x2F;流畅度高"></a>2. 稳定性&#x2F;流畅度高</h3><p>使用Windows系统时不时会出现卡顿，不稳定的问题，但Linux不会。选择一个好的发行版做为个人电脑系统使用的话一般不会出现卡顿的情况。 而且Windows系统长时间使用的话要重启一下，不然可能就没有开机时流畅了。</p>
<p>在Windows中由于空间不够用都会安装一款清理垃圾文件的软件，Windows系统本身会占用很大的空间，随便安装几个软件系统盘也许就满了。 但在Linux中一般不需要，因为Linux系统本身不会占用多大的磁盘空间，安装软件也都是规范的位置，系统临时目录重启时会自动清理，不会占用大量的磁盘空间。</p>
<p>在我的使用体验中，Linux的流畅度是比Windows高的。比如我使用的编程软件IDEA，同一台电脑同一块硬盘，在Windows上打开一个项目要3到5秒， 但在Linux（Ubuntu 18.04）中打开同一个项目只要不到1秒。</p>
<h3 id="4-安全性高"><a href="#4-安全性高" class="headerlink" title="4. 安全性高"></a>4. 安全性高</h3><p>在Windows系统中是一定要安装杀毒软件的。就算你不安装，Windows系统自带的也会启动。但在Linux中不用，因为Linux是一个有严格权限控制的系统，平常使用的时候一般不会使用root用户，就算有恶意脚本也不至于对系统造成大破坏。而且Linux的病毒数量也极少。</p>
<h3 id="5-可定制性高"><a href="#5-可定制性高" class="headerlink" title="5. 可定制性高"></a>5. 可定制性高</h3><p>由于Linux系统是开源的， 所以每个人都可以下载其源代码进行定制。就算是已经存在的发行版桌面环境也都是可以换的。如果你有能力，可以把Linux系统改的它亲爹都不认识。</p>
<h3 id="6-性能高"><a href="#6-性能高" class="headerlink" title="6. 性能高"></a>6. 性能高</h3><p>Linux的开发都可能比使用者还要多，这就意味着Linux从内核到软件都是经过多次的优化的。性能高自然也是不奇怪。这个性能不仅表现在软件性能，现在还表现在游戏性能上，我在同一台电脑上在Windows系统中玩我的世界不限制帧率能跑800多帧，但在Linux里面使用同一个显卡，加载同一个游戏，同一个场景，能跑1000多帧。</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>01_计算机基础</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>进制之间的转换</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04_%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>进制也就是进制位，对于接触过电脑的人来说应该都不陌生，我们常用的进制包括：二进制、八进制、十进制与十六进制，它们之间区别在于数运算时是逢几进一位。比如二进制是逢2进一位，十进制也就是我们常用的0-9是逢10进一位。具体的用法小编今天不着重解释，主要针对他们之间的转换加以讨论（今天只讲整数）。</p>
<p><img src="/assets/2/image-20220428225141-xd3txhw.png" alt="image.png"></p>
<h2 id="二进制与十进制之间的转换"><a href="#二进制与十进制之间的转换" class="headerlink" title="二进制与十进制之间的转换"></a>二进制与十进制之间的转换</h2><ol>
<li><p>十进制转二进制</p>
<p> 方法为：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。</p>
<p> （具体用法如下图）</p>
<p> <img src="/assets/2/image-20220428225151-3s3iy9r.png" alt="image.png"></p>
</li>
<li><p>二进制转十进制</p>
<p> 方法为：把二进制数按权展开、相加即得十进制数。</p>
<p> （具体用法如下图）</p>
<p> <img src="/assets/2/image-20220428225159-alui8ym.png" alt="image.png"></p>
<p> <strong>END</strong></p>
</li>
</ol>
<h2 id="二进制与八进制之间的转换"><a href="#二进制与八进制之间的转换" class="headerlink" title="二进制与八进制之间的转换"></a>二进制与八进制之间的转换</h2><ol>
<li><p>二进制转八进制</p>
<p> 方法为：3位二进制数按权展开相加得到1位八进制数。（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。</p>
<p> （具体用法如下图）</p>
<p> <img src="/assets/2/image-20220428225207-lce45tr.png" alt="image.png"></p>
</li>
<li><p>八进制转成二进制</p>
<p> 方法为：八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。</p>
<p> （具体用法如下图）</p>
<p> <img src="/assets/2/image-20220428225215-u4peqze.png" alt="image.png"></p>
<p> <strong>END</strong></p>
</li>
</ol>
<h2 id="二进制与十六进制之间的转换"><a href="#二进制与十六进制之间的转换" class="headerlink" title="二进制与十六进制之间的转换"></a>二进制与十六进制之间的转换</h2><ol>
<li><p>二进制转十六进制</p>
<p> 方法为：与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。</p>
<p> （具体用法如下图）</p>
<p> <img src="/assets/2/image-20220428225221-r5nv7v3.png" alt="image.png"></p>
</li>
<li><p>十六进制转二进制</p>
<p> 方法为：十六进制数通过除2取余法，得到二进制数，对每个十六进制为4个二进制，不足时在最左边补零。</p>
<p> （具体用法如下图）</p>
<p> <img src="/assets/2/image-20220428225230-lf3027z.png" alt="image.png"></p>
<p> <strong>END</strong></p>
</li>
</ol>
<h2 id="十进制与八进制与十六进制之间的转换"><a href="#十进制与八进制与十六进制之间的转换" class="headerlink" title="十进制与八进制与十六进制之间的转换"></a>十进制与八进制与十六进制之间的转换</h2><ol>
<li><p>十进制转八进制或者十六进制有两种方法</p>
<p> 第一：间接法—把十进制转成二进制，然后再由二进制转成八进制或者十六进制。这里不再做图片用法解释。</p>
</li>
<li><p>第二：直接法—把十进制转八进制或者十六进制按照除8或者16取余，直到商为0为止。</p>
<p> （具体用法如下图）</p>
<p> <img src="/assets/2/image-20220428225237-kzmbzuc.png" alt="image.png"></p>
</li>
<li><p>八进制或者十六进制转成十进制</p>
<p> 方法为：把八进制、十六进制数按权展开、相加即得十进制数。</p>
<p> （具体用法如下图）</p>
<p> <img src="/assets/2/image-20220428225243-ukbidlm.png" alt="image.png"></p>
<p> <strong>END</strong></p>
</li>
</ol>
<h2 id="十六进制与八进制之间的转换"><a href="#十六进制与八进制之间的转换" class="headerlink" title="十六进制与八进制之间的转换"></a>十六进制与八进制之间的转换</h2><ol>
<li><p>1<br> 八进制与十六进制之间的转换有两种方法</p>
<p> 第一种：他们之间的转换可以先转成二进制然后再相互转换。</p>
<p> 第二种：他们之间的转换可以先转成十进制然后再相互转换。</p>
<p> 这里就不再进行图片用法解释。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>01_计算机基础</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>测试计划</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p><img src="/assets/1/image-20211120225648-gfkhwjd.png" alt="image.png"></p>
<h1 id="软件测试人员如何编写测试计划"><a href="#软件测试人员如何编写测试计划" class="headerlink" title="软件测试人员如何编写测试计划"></a>软件测试人员如何编写测试计划</h1><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><ul>
<li>每个公司的测试计划都不尽相同，但每个测试计划包含的主要内容又只有这几点，那我们一起研究一下测试计划的主要内容有哪些？<h2 id="测试计划概念"><a href="#测试计划概念" class="headerlink" title="测试计划概念"></a><strong>测试计划概念</strong></h2></li>
</ul>
<p><strong>测试计划（Testing plan）的定义：</strong></p>
<ul>
<li>描述了要进行的测试活动的范围、方法、资源和进度的文档；</li>
<li>是对整个信息系统应用软件组装测试和确认测试。</li>
<li>它确定测试项、被测特性、测试任务、谁执行任务、各种可能的风险。</li>
<li>测试计划可以有效预防计划的风险，保障计划的顺利实施。</li>
</ul>
<p><strong>测试计划的目的</strong></p>
<ul>
<li>（1）为测试各项活动制定一个现实可行的、综合的计划，包括每项测试活动的对象、范围、方法、进度和预期结果。</li>
<li>（2）为项目实施建立一个组织模型，并定义测试项目中每个角色的责任和工作内容。</li>
<li>（3）开发有效的测试模型，能正确地验证正在开发的软件系统。</li>
<li>（4）确定测试所需要的时间和资源，以保证其可获得性、有效性。</li>
<li>（5）确立每个测试阶段测试完成以及测试成功的标准、要实现的目标。</li>
<li>（6）识别出测试活动中各种风险，并消除可能存在的风险，降低由不可能消除的风险所带来的损失。<br>编写测试计划，就是为了达到这些目的。<br>通过测试计划可以宏观的指导测试的后续工作</li>
</ul>
<p><strong>测试计划由谁编写</strong><br>测试计划属于管理型文档，是由测试经理、测试主管或测试组长进行编写。</p>
<p><strong>测试计划编写的6个要素</strong></p>
<ul>
<li>1）why——为什么要进行这些测试；</li>
<li><ol start="2">
<li>what—测试哪些方面，不同阶段的工作内容；</li>
</ol>
</li>
<li><ol start="3">
<li>when—测试不同阶段的起止时间；</li>
</ol>
</li>
<li><ol start="4">
<li>where—相应文档，缺陷的存放位置，测试环境等；</li>
</ol>
</li>
<li><ol start="5">
<li>who—项目有关人员组成，安排哪些测试人员进行测试</li>
</ol>
</li>
<li><ol start="6">
<li>how—如何去做，使用哪些测试工具以及测试方法进行测试。</li>
</ol>
</li>
</ul>
<h2 id="测试计划主要内容"><a href="#测试计划主要内容" class="headerlink" title="测试计划主要内容"></a><strong>测试计划主要内容</strong></h2><p><strong>1.项目简介</strong><br>项目简介分为项目背景和编写目的。<br>主要描述项目实施的背景和为什么要编写测试计划的目的。<br><strong>2.参考文档</strong><br>描述编写测试计划时的依据。可以用列表的形式梳理出来。<br>参考文档 备注<br>详细设计<br>概要设计<br>UI原型图<br>接口文档<br><strong>3.测试范围</strong><br>描述本次测试活动的测试范围。<br>可以分为总体的测试范围和主要测试的功能点二个部分。<br>例如，本次测试范围为登录模块和注册模块，其中以注册模块为主要测试功能模块。<br><strong>4.时间进度安排</strong><br>首先描述测试活动的总体时间。<br>再描述测试活动的每个不同阶段需要多长时间，具体可以以表格的形式输出。<br>例如<br>测试阶段 计划开始时间 计划完成时间 备注<br>需要分析 2017-11-10 2017-11-13<br>需要评审 2017-11-14 2017-11-15<br>…… …… ……<br><strong>5.资源</strong><br>描述本次测试活动需要的人力资源和软硬件资源。<br><img src="/assets/1/image-20211120225709-3ou6vsb.png" alt="image.png"><br><strong>6.风险评估</strong><br>描述本次测试活动中有可能会产生的风险和解决方案。<br>在风险评估中确定风险级别最高的测试对象，优先测试，同时需要考虑的要点有：<br>重要性、严重性、原因、可能性<br><strong>7.测试交付件</strong><br>描述本次测试活动完成后测试部需要输出的文档。<br>例如：测试计划，测试方案，用例执行情况表，缺陷，总结测试报告等等<br>以上七点在测试计划中需要完全包含，测试计划中包含的主要内容是七点，但由于每个公司的项目和业务都不相同，故测试计划中的实质性内容也不一样，虽然说测试计划可以理解为填空题，但是每个空的答案都不是一样的。<br>测试策略在测试计划中可有可无，一般来说测试策略是写测试方案中。这里列出了包含进测试计划的测试策略。<br>图片为测试策略包含的主要内容<br><img src="/assets/1/image-20211120225717-b9ur7v7.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试的分类</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>目前，软件测试已经形成一个完整的、体系庞大的学科，不同的测试领域都有不同的测试方法、技术与名称，有很多读者可能也听过类似的黑盒测试、白盒测试、冒烟测试、单元测试等，其实它们是按照不同的分类方法而产生的测试名称。按照不同的分类标准，可以将软件测试分为很多不同的种类，下面我们详细介绍这些软件测试行业的专业名词。</p>
<h2 id="按照测试阶段分类"><a href="#按照测试阶段分类" class="headerlink" title="按照测试阶段分类"></a><strong>按照测试阶段分类</strong></h2><p>按照测试阶段可以将软件测试分为单元测试、冒烟测试、集成测试、系统测试与验收测试。这种分类方式与软件开发过程相契合，是为了检验软件开发各个阶段是否符合要求。</p>
<p><strong>(1) 单元测试</strong></p>
<p>单元测试是软件开发的第一步测试，目的是为了验证软件单元是否符合软件需求与设计。单元测试大多是开发人员进行的自测。</p>
<p><strong>(2) 冒烟测试</strong></p>
<p>冒烟测试最初是从电路板测试得来的，当电路板做好以后，首先会加电测试，如果电路板没有冒烟再进行其他测试，否则就必须重新设计后再次测试。后来这种测试理念被引入到软件测试中。在软件测试中，冒烟测试是指软件构建版本建立后，对系统的基本功能进行简单的测试，这种测试重点验证的是程序的主要功能，而不会对具体功能进行深入测试。如果测试未通过，需要返回给开发人员进行修正;如果测试通过则再进行其他测试。因此，冒烟测试是对新构建版本软件进行的最基本测试。</p>
<p><strong>(3) 集成测试</strong></p>
<p>集成测试是冒烟测试之后进行的测试，它是将已经测试过的软件单元组合在一起测试它们之间的接口，用于验证软件是否满足设计需求。</p>
<p><strong>(4) 系统测试</strong>———————–把系统看成一个整体进行的测试<br>    * 功能测试<br>    * 兼容性测试<br>    * 性能测试<br>    * 安全测试</p>
<p>系统测试是将经过测试的软件在实际环境中运行，并与其他系统的成分(如数据库、硬件和操作人员等)组合在一起进行的测试。</p>
<p><strong>(5) 验收测试</strong></p>
<p>验收测试主要是对软件产品说明进行验证，逐行逐字地按照说明书的描述对软件产品进行测试，确保其符合客户的各项要求。</p>
<h2 id="按照测试技术分类"><a href="#按照测试技术分类" class="headerlink" title="按照测试技术分类"></a>按照测试技术分类</h2><p>按照使用的测试技术可以将软件测试分为黑盒测试与白盒测试。</p>
<p><strong>(1)<a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">黑盒测试</a></strong></p>
<p>黑盒测试就是把软件(程序)当作一个有输入与输出的黑匣子，它把程序当作一个输入域到输出域的映射，只要输入的数据能输出预期的结果即可，不必关心程序内部是怎么样实现的，下图所示。</p>
<p><img src="/assets/2/image-20220515154753-0m7737r.png" alt="image.png"></p>
<p><strong>(2)白盒测试</strong></p>
<p>白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程，如下图所示。</p>
<p><img src="/assets/2/image-20220515154759-jcs045j.png" alt="image.png"></p>
<p>相对于黑盒测试来说，白盒测试对测试人员的要求会更高一点，他要求测试人员具有一定的编程能力，而且要熟悉各种脚本语言。但是在软件公司里，黑盒测试与白盒测试并不是界限分明的，在测试一款软件时往往是黑盒测试与白盒测试相结合对软件进行完整全面的测试。</p>
<h2 id="按照软件质量特性分类"><a href="#按照软件质量特性分类" class="headerlink" title="按照软件质量特性分类"></a>按照软件质量特性分类</h2><p>按照软件质量特性可以将软件测试分为功能测试与性能测试。</p>
<p><strong>(1)功能测试</strong></p>
<p>功能测试就是测试软件的功能是否满足客户的需求，包括准确性、易用性、适合性、互操作性等。</p>
<p><strong>(2)性能测试</strong></p>
<p>性能测试就是测试软件的性能是否满足客户的需求，性能测试包括负载测试、压力测试、兼容性测试、可移植性测试和健壮性测试。</p>
<h2 id="按照自动化程度分类"><a href="#按照自动化程度分类" class="headerlink" title="按照自动化程度分类"></a>按照自动化程度分类</h2><p>按照自动化程度可以将软件测试分为手工测试与自动化测试。</p>
<p><strong>(1)手工测试</strong></p>
<p>手工测试是测试人员一条一条地执行代码完成测试工作。手工测试比较耗时费力，而且测试人员如果是在疲惫状态下，则很难保证测试的效果。</p>
<p><strong>(2)自动化测试</strong></p>
<p>自动化测试是借助脚本、自动化测试工具等完成相应的测试工作，它也需要人工的参与，但是它可以将要执行的测试代码或流程写成脚本，执行脚本完成整个测试工作。</p>
<h2 id="按照测试类型分类"><a href="#按照测试类型分类" class="headerlink" title="按照测试类型分类"></a>按照测试类型分类</h2><p>软件测试类型有多种，包括界面类测试、功能测试、性能测试、安全性测试、文档测试等，其中功能测试与性能测试前面已经介绍，下面主要介绍其他几种测试。</p>
<p><strong>(1)界面类测试</strong></p>
<p>界面类测试是验证软件界面是否符合客户需求，包括界面布局是否美观、按钮是否齐全等。</p>
<p><strong>(2)安全性测试</strong></p>
<p>安全性测试是测试软件在没有授权的内部或外部用户的攻击或恶意破坏时如何进行处理，是否能保证软件与数据的安全。</p>
<p><strong>(3)文档测试</strong></p>
<p>文档测试以需求分析、软件设计、用户手册、安装手册为主，主要验证文档说明与实际软件之间是否存在差异。</p>
<h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a><strong>其他分类</strong></h2><p>还有一些软件测试无法具体归到哪一类，但在测试行业中也会经常进行这些测试，如α测试、β测试、回归测试等，具体介绍如下。</p>
<p><strong>(1) α测试</strong></p>
<p>α测试是指对软件最初版本进行测试。软件最初版本一般不对外发布，在上线之前，由开发人员和测试人员或者用户协助进行测试。测试人员记录使用过程中出现的错误与问题整个测试过程是可控的。</p>
<p><strong>(2) β测试</strong></p>
<p>β测试是指对上线之后的软件版本进行测试，此时软件已上线发布，但发布的版本中可能会存在较轻微的Bug，由用户在使用过程中发现错误与问题并进行记录，然后反馈给开发人员进行修复。</p>
<p><strong>(3)回归测试</strong></p>
<p>当测试人员发现缺陷以后，会将缺陷提交给开发人员，开发人员对程序进行修改，修改之后，测试人员会对修改后的程序重新进行测试，确认原有的缺陷已经消除并且没有引入新的缺陷，这个重新测试的过程就叫作回归测试。回归测试是软件测试工作中非常重要的一部分，软件开发的各个阶段都会进行多次回归测试。</p>
<p><strong>(4)随机测试</strong></p>
<p>随机测试是没有测试用例、检查列表、脚本或指令的测试，它主要是根据测试人员的经验对软件进行功能和性能抽查。随机测试是根据测试用例说明书执行测试用例的重要补充手段，是保证测试覆盖完整性的有效方式和过程。</p>
<p><strong>(5)探索性测试</strong>    </p>
<p>随机测试的升级版，测试的一种思维方式，强调遇到问题之后，改变测试策略，能够发现更加深入的问题，是未来测试发展的一个领域</p>
<p><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%88%92%E5%88%86/">测试种类划分</a><br><a href="/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%8416%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B/">软件测试的16种测试类型</a></p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>测试种类划分</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>软件测试方法种类繁多，记忆起来混乱， 如果把软件测试方法进行分类, 就会清晰很多。 我参考一些书籍和网上的资料， 把常用的软件测试方法列出来， 让大家对软件测试行业有个总体的看法。</p>
<h1 id="从测试设计方法分类"><a href="#从测试设计方法分类" class="headerlink" title="从测试设计方法分类"></a><strong>从测试设计方法分类</strong></h1><table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Black box黑盒测试</td>
<td>把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试.</td>
</tr>
<tr>
<td>White box白盒测试</td>
<td>设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。</td>
</tr>
<tr>
<td>Gray box.灰盒测试</td>
<td>介于黑盒和白盒之间</td>
</tr>
</tbody></table>
<p>总结：   实际工作中，对系统的了解越多越好。目前大多数的测试人员都是做黑盒测试，很少有做白盒测试的。 因为白盒测试对软件测试人员的要求非常高，需要有很多编程经验。做.NET程序的白盒测试你要能看得懂.NET代码。做JAVA程序的测试，需要你能看懂JAVA的代码。 如果你都能看懂了，你还会做测试么</p>
<h1 id="从测试是手动还是自动上分类"><a href="#从测试是手动还是自动上分类" class="headerlink" title="从测试是手动还是自动上分类"></a><strong>从测试是手动还是自动上分类</strong></h1><table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Manual Test手动测试</td>
<td>测试人员用鼠标去手动测试（测试GUI）</td>
</tr>
<tr>
<td>Automation自动化测试</td>
<td>用程序测试程序（测试API）</td>
</tr>
</tbody></table>
<p>对于项目来说， 手动测试和自动化测试同等重要，都是保障软件质量的方法。 目前大部分的项目组都是手动测试和自动化测试相结合。因为很多测试无法做成自动化，很多复杂的业务逻辑也很难自动化， 所以自动化测试无法取代手动测试。<br>对于软件测试人员个人发展来说， 做自动化测试是个挑战，也是测试人员发展的一个方向，  需要测试人员学习大量的开发知识（开发的知识真是学无止境啊）。 从长远角度来看，自动化测试肯定是越来越吃香的。<br>而手动测试比较适合刚工作不久的人，手动测试最大的缺点就是技术含量低，单调乏味，容易废人。<br>总的来说，手工测试胜在测试业务逻辑，而自动化测试胜在测试底层架构。<br>如果被测试的程序可测试性比较好， 很有必要做成自动化测试。 能做自动化的尽量做成自动化， 下面这些情形是可以做自动化的</p>
<ol>
<li>测试存储过程。  例如用C#去测试存储过程</li>
<li>测试Web servies. 例如： 用SoupUI工具，或者C#,Java 去测试Web servies。</li>
<li>界面和业务逻辑分离的系统，比如，MVC，MVP架构， 或者WPF 程序。 可以用测试脚本去测试这些程序的API。</li>
</ol>
<h1 id="从测试的目的分类"><a href="#从测试的目的分类" class="headerlink" title="从测试的目的分类"></a><strong>从测试的目的分类</strong></h1><p>功能测试<br>测试的范围从小到大，从内到外， 从程序开发人员（单元测试）到测试人员，到一般用户Alpha&#x2F;Beta测试</p>
<table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Unit Test 单元测试</td>
<td>在最低的功能&#x2F;参数上验证程序的准确性,比如测试一个函数的正确性(开发人员做的)</td>
</tr>
<tr>
<td>Functional Test功能测试</td>
<td>验证模块的功能（测试人员做的）</td>
</tr>
<tr>
<td>Integration Test集成测试</td>
<td>验证几个互相有依赖关系的模块的功能（测试人员做的）</td>
</tr>
<tr>
<td>Scenario Test场景测试</td>
<td>验证几个模块是否能完成一个用户场景（测试人员做的）</td>
</tr>
<tr>
<td>System Test系统测试</td>
<td>对于整个系统功能的测试（测试人员做的）</td>
</tr>
<tr>
<td>Alpha测试</td>
<td>软件测试人员在真实用户环境中对软件进行全面的测试（测试人员做的）</td>
</tr>
<tr>
<td>Beta测试</td>
<td>真实的用户在真实的用户环境中进行的测试, 也叫公测   （最终用户做的）</td>
</tr>
</tbody></table>
<p>非功能测试<br>一个软件除了基本功能之外，还有很多功能之外的特性，这些叫“Quality of Service requirement”服务质量需求。没有软件的功能，这些特性都无从表现出来，因此，我们要在软件开发的适当阶段-基本功能完成后做这些测试。</p>
<table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Stress test压力测试</td>
<td>验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃</td>
</tr>
<tr>
<td>Load test负载测试</td>
<td>测试软件在负载情况下能否正常工作</td>
</tr>
<tr>
<td>Performance test性能测试</td>
<td>测试软件的效能，是否提供满意的服务质量</td>
</tr>
<tr>
<td>Accessibility test</td>
<td>软件辅助功能测试-测试软件是否向残疾用户提供足够的辅助功能</td>
</tr>
<tr>
<td>Localization&#x2F;Globalization</td>
<td>本地化&#x2F;全球化测试</td>
</tr>
<tr>
<td>Compatibility Test</td>
<td>兼容性测试</td>
</tr>
<tr>
<td>Configuration Test</td>
<td>配置测试-测试软件在各种配置下能否正常工作</td>
</tr>
<tr>
<td>Usability Test</td>
<td>可用性测试–测试软件是否好用</td>
</tr>
<tr>
<td>Security Test</td>
<td>软件安全性测试</td>
</tr>
</tbody></table>
<p>性能测试<br>性能测试要求测试人员熟练性能测试工具，比如QTP, LoadRunner, Jmeter。  Visual Studio也提供了很多性能测试的工具. 要求测试人员对低层协议非常理解和编写脚本<br>性能测试非常有技术含量， 很有发展前途， 是软件测试人员的一个职业发展方向。<br>安全性测试<br>安全性测试的内容很广， 非常有难度啊。 我只接触过XSS（跨站脚本攻击）和SQL注入攻击。<br>安全性测试非常有技术含量， 我认为也是软件测试人员的一个职业发展方向<br>按测试的时机和作用分类<br>在开发软件的过程中，不少测试起着“烽火台”的作用，它们告诉我们软件开发的流程是否畅通。</p>
<table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Smoke Test</td>
<td>“冒烟”–如果测试不通过，则不能进行下一步工作</td>
</tr>
<tr>
<td>Build Verification Test（BVT）</td>
<td>验证构建是否通过基本测试。</td>
</tr>
<tr>
<td>Acceptance Test</td>
<td>验收测试，为了全面考核某功能&#x2F;特性而做的测试</td>
</tr>
</tbody></table>
<p>BVT测试是一种Smoke Test, 指Build生成好之后，自动运行的自动化测试脚本来检查这个Build的基本功能。 如果BVT测试失败了，需要开发人员马上修改，重新生成Build<br>按测试测策略分类。</p>
<table>
<thead>
<tr>
<th>测试名称</th>
<th>测试内容</th>
</tr>
</thead>
<tbody><tr>
<td>Regression Test回归测试</td>
<td>对一个新的版本，重新运行以往的测试用例，看看新版本和已知的版本相比是否有退化(regression)</td>
</tr>
<tr>
<td>Ad hoc Test探索性测试</td>
<td>随机进行的，探索性的测试。</td>
</tr>
<tr>
<td>Sanity Test</td>
<td>粗略的测试，只需要执行部分的测试用例</td>
</tr>
</tbody></table>
<p>Regression Test 回归测试：　　<br>对软件测试人员来说就是重复测试，所以回归测试最好是自动化的，　否则测试人员就要一遍又一遍地重复测试，　</p>
<ol>
<li>开发人员做些小改动，就需要测试人员做回归测试。确保现有的功能没有被破坏</li>
<li>Bug Fix 也需要回归测试，确保新的代码修复了Fix, 也确保现有的功能没有被破坏</li>
<li>项目后期，需要做一个完整回归测试， 确保所有的功能都是好的<br>Ad hoc Test 探索性测试：<br>平常我最喜欢做随机测试了， 抛开test case.  自己按照自己的思路，随便点点。 如果测试GUI，Ad hoc能发现大量的bug.</li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>黑盒测试</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li>定义：</li>
<li>目的</li>
<li>优点</li>
<li>测试用例<h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3></li>
<li>定义<ul>
<li>黑盒测试是从一种从软件外部对软件实施的测试，也成功能测试</li>
<li>不考虑内部结构，只考虑输入与输出的测试</li>
<li><img src="/assets/1/image-20211120150914-c5nxlpa.png" alt="image.png"></li>
</ul>
</li>
<li>目的<ul>
<li>黑盒测试是从用户观点出发的测试，其目的是尽可能发现软件的外部行为错误。在已知软件产品功能的基础上：<br>检测软件功能能否按照需求文档的规定正常工作，是否有功能遗漏；<br>检测是否有人机交互错误，是否有数据结构和外部数据库访问错误，是否能恰当地接收数据并保持外部信息等的完整性<br>检测行为、性能等特性是否满足要求等；<br>检测程序初始化和终止方面的错误等；</li>
</ul>
</li>
<li>优点<ul>
<li>黑盒测试与软件具体实现无关，所以如果软件实现发生了变化，测试用例仍然可以使用；</li>
<li>设计黑盒测试用例可以和软件实现同时进行，因此可以压缩项目总的开发时间</li>
</ul>
</li>
<li>测试用例<ul>
<li>测试用例概念<ul>
<li>测试用例（testcase）是指对一项特定的软件进行测试任务的描述、体现测试方案、方法、技术和策略</li>
<li>简单地认为，测试用例是为了发现软件存在的问题编写的一组包含测试输入、执行条件以及预期结果的文档，用来核实软件产品是否满需求</li>
<li><img src="/assets/1/image-20211120151028-c13v85v.png" alt="image.png"></li>
</ul>
</li>
<li>测试用例的作用<ul>
<li>指导测试的实施</li>
<li>规划测试数据的准备</li>
<li>编写测试脚本的“设计规格说明书”</li>
<li>评估测试结果的度量基准</li>
<li>分析缺陷的标准<ul>
<li>bug</li>
</ul>
</li>
</ul>
</li>
<li>使用测试用例的好处<ul>
<li>避免盲目测试并提高测试效率</li>
<li>令软件测试的实施重点突出、目的明确</li>
<li>软件版本更新后只需修正少部分的测试用例便可展开测试工作</li>
<li>测试用例的通用化和复用化则会使软件测试易于开展</li>
</ul>
</li>
<li>测试用例的内容<ul>
<li>版本号<br>项目名称<br>模块名称<br>用例编号<br>用例名称<br>用例级别<br>前置条件<br>测试步骤<br>期望结果<br>测试结果<br>测试时间<br>测试人员</li>
</ul>
</li>
<li>((20211203110629-z3n01go “测试用例简介”))</li>
<li>输入内容的分类：字母+数字+特殊字符+汉字   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;   字符</li>
<li>常见黑盒测试用例设计方法<ul>
<li>等价类<ul>
<li>定义：等价类是指输入域的某个互不相交的子集集合，所有等价类的并集便是整个输入域</li>
<li>分类<ul>
<li>有效等价类      符合需求说明，合理地输入数据集合</li>
<li>无效等价类      不符合需求说明，无意义的输入数据的集合</li>
<li><img src="/assets/1/image-20211120151741-y3xtcn5.png" alt="image.png"></li>
</ul>
</li>
<li>等价类划分方法<ul>
<li>输入条件规定了取值范围或值的个数：确定一个有效等价类和两个无效等价类</li>
<li>输入条件规定了输入值的集合：确定一个有效等价类和一个无效等价类<ul>
<li>只允许输入汉字<ul>
<li>有效等价类：汉字</li>
<li>无效等价类：字母、数字、特殊字符</li>
</ul>
</li>
</ul>
</li>
<li>输入条件是一个布尔值：可以确定一个有效等价类和一个无效等价类   True&#x2F;FALSE（真&#x2F;假）</li>
<li>输入条件规定必须遵循某种规则：确定一个有效等价类和若干个无效等价类</li>
<li>在规定了输入数据的一组值（假定N个），并且程序要对每个输入值分别处理：可以确立N个有效等价类和一个无效等价类——-先不理解</li>
</ul>
</li>
<li>等价类划分用例设计步骤<ul>
<li>为每一个等价类规定一个唯一的编号</li>
<li>设计一个心得测试用例，尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步，直到测试用例覆盖了所有的有效等价类</li>
<li>设计一个新的测试用例，使其覆盖并只覆盖一个没有被覆盖的无效等价类。重复这一步，直至测试用例覆盖了所有的无效等价类</li>
</ul>
</li>
<li>练习<ul>
<li>问题：两位整数加法计数器<br>第一个数和第二个数都只能输入-99到99之间的整数<br>对于输入小于-99得数据或者大于99的数据，系统应该给出明确提示<br>对于输入小数、字符等非法数据，系统应该给出明确提示</li>
<li><img src="/assets/1/image-20211120151946-pg5vfr8.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211120151957-ot0ftmq.png" alt="image.png"></li>
<li><img src="/assets/1/image-20211120152002-7y5g4a5.png" alt="image.png"></li>
</ul>
</li>
</ul>
</li>
<li>边界值<ul>
<li>定义：大量的软件测试时间证明，故障往往出现在定义域或值域的边界上，而不是在其内部</li>
<li>边界：是一些特殊情况，程序在处理大量中间数值时都是正确，但是在边界处可能出现错误，边界条件就是软件计划的操作界限所在的边缘条件</li>
<li>边界值选取方法<ul>
<li>选取正好等于、刚刚大于或者刚刚小于等价类边界值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据</li>
<li><img src="/assets/1/image-20211120152045-xkqwjfz.png" alt="image.png"></li>
</ul>
</li>
<li>边界值分析测试<ul>
<li>最小值（min）</li>
<li>稍大于最小值（min+）</li>
<li>域内任意值（nom）</li>
<li>稍小于最大值（max-）</li>
<li>最大值（max）</li>
</ul>
</li>
<li>健壮性边界值测试<ul>
<li>健壮性测试是边界值分析的一种扩展</li>
<li>变量除了取min、min+、nom、max-、max五个边界值外，还要考虑采用一个略超过最大值（max+）以及一个略小于最小值（min-）的取值，看看超过极限值时系统会出现什么情况</li>
</ul>
</li>
<li>边界值分析原则<ul>
<li>如果输入条件对取值范围进行了限定，则应以边界内部以及刚刚超出范围边界外的值作为测试用例</li>
<li>对于输入条件，同样可以应用上面提到的两条原则来进行测试用例设计</li>
<li>如果程序规格说明书中指明输入或者输出域是一个有序的集合，如顺序文件、表格等，则应注意选取有序集合中的第一个和最后一个元素作为测试用例</li>
</ul>
</li>
</ul>
</li>
<li>错误推断法<ul>
<li>定义： 指利用直觉和经验猜测出出错的可能类型，有针对性的列举出程序中所有可能的错误和容易发生错误的情况</li>
<li>列举出可能犯的错误或错误容易发生的清单，然后根据清单编写测试用例</li>
</ul>
</li>
<li>场景分析法</li>
<li>因果图</li>
<li>判定表</li>
<li>正交法</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>902_测试理论</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02_Linux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="linux简介："><a href="#linux简介：" class="headerlink" title="linux简介："></a>linux简介：</h3><p>Linux 是一种自由和开放源码的类 UNIX 操作系统。<br>Linux 英文解释为 Linux is not Unix。<br>Linux 是在 1991 由林纳斯·托瓦兹在赫尔辛基大学上学时创立的，主要受到 Minix 和 Unix 思想的启发。<br>本教程，我们将为大家介绍如何使用 Linux。</p>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。<br>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。<br>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h3 id="Linux-的发行版"><a href="#Linux-的发行版" class="headerlink" title="Linux 的发行版"></a>Linux 的发行版</h3><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。</p>
<p><img src="/assets/1/image-20211120104622-naz095z.png" alt="image.png"></p>
<h3 id="Linux-vs-Windows"><a href="#Linux-vs-Windows" class="headerlink" title="Linux vs Windows"></a>Linux vs Windows</h3><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>Windows</th>
<th>Linux</th>
</tr>
</thead>
<tbody><tr>
<td>界面</td>
<td>界面统一，外壳程序固定所有Windows程序菜单几乎一致，快捷键也几乎相同</td>
<td>图形界面风格依发布版不同而不同，可能互不兼容。GNU&#x2F;Linux的终端机是从UNIX传承下来，基本命令和操作方法也几乎一致。</td>
</tr>
<tr>
<td>驱动程序</td>
<td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的Windows下的驱动，也会比较头痛。</td>
<td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td>
</tr>
<tr>
<td>使用</td>
<td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td>
<td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td>
</tr>
<tr>
<td>学习</td>
<td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td>
<td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td>
</tr>
<tr>
<td>软件</td>
<td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td>
<td>大部分软件都可以自由获取，同样功能的软件选择较少。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>01_计算机基础</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li><h3 id="练习打字：要求1000字的文章，平均一分钟35字"><a href="#练习打字：要求1000字的文章，平均一分钟35字" class="headerlink" title="练习打字：要求1000字的文章，平均一分钟35字"></a>练习打字：要求1000字的文章，平均一分钟35字</h3></li>
<li><h3 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h3> <!-- 1. [windows快捷键](/01_测试初阶/02_测试理论/01_第一章基础/901_文件/01_计算机基础/01_windows快捷键/) -->
<ol>
<li><h4 id="windows快捷键"><a href="#windows快捷键" class="headerlink" title="windows快捷键"></a><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/01_计算机基础/01_windows快捷键/" target="_blank">windows快捷键</a></h4><ol>
<li>win+r  —-&gt; cmd—-&gt; 输入  ipconfig   查看本机ip</li>
<li>win+r  —-&gt; cmd—-&gt; 输入ping + url（ip）  查看与对方url（ip）是否互通<!--    2. [Linux](/01_测试初阶/02_测试理论/01_第一章基础/901_文件/01_计算机基础/02_Linux系统/)--></li>
</ol>
<p>	</p>
</li>
<li><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/01_计算机基础/02_Linux系统/" target="_blank">Linux</a></h4><!--    3. [windows与linux的区别](/01_测试初阶/02_测试理论/01_第一章基础/901_文件/01_计算机基础/03_windows与linux的区别/)-->	</li>
<li><h4 id="windows与linux的区别"><a href="#windows与linux的区别" class="headerlink" title="windows与linux的区别"></a><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/01_计算机基础/03_windows与linux的区别/" target="_blank">windows与linux的区别</a></h4></li>
</ol>
</li>
<li><h3 id="编程基础："><a href="#编程基础：" class="headerlink" title="编程基础："></a>编程基础：</h3><ol>
<li>什么是编程语言<ol>
<li>编程语言（programming language）可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。编程语言处在不断的发展和变化中，从最初的机器语言发展到如今的2500种以上的高级语言，每种语言都有其特定的用途和不同的发展轨迹。编程语言并不像人类自然语言发展变化一样的缓慢而又持久，其发展是相当快速的，这主要是计算机硬件、互联网和IT业的发展促进了编程语言的发展。</li>
<li><a href="https://www.runoob.com/">编码基础课程（所有）</a></li>
</ol>
</li>
<li>计算机编程语言能够实现人与机器之间的交流和沟通，而计算机编程语言主要包括汇编语言、机器语言以及高级语言，具体内容如下：<ol>
<li>汇编语言<br> 该语言主要是以缩写英文作为标符进行编写的，运用汇编语言进行编写的一般都是较为简练的小程序，其在执行方面较为便利，但汇编语言在程序方面较为冗长，所以具有较高的出错率。</li>
<li>机器语言<br> 这种语言主要是利用二进制编码进行指令的发送，能够被计算机快速地识别，其灵活性相对较高，且执行速度较为可观，机器语言与汇编语言之间的相似性较高，但由于具有局限性，所以在使用上存在一定的约束性。</li>
<li>高级语言<br> 所谓的高级语言，其实是由多种编程语言结合之后的总称，其可以对多条指令进行整合，将其变为单条指令完成输送，其在操作细节指令以及中间过程等方面都得到了适当的简化，所以，整个程序更为简便，具有较强的操作性，而这种编码方式的简化，使得计算机编程对于相关工作人员的专业水平要求不断放宽。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="公司中常用的文件类型"><a href="#公司中常用的文件类型" class="headerlink" title="公司中常用的文件类型"></a>公司中常用的文件类型</h3><ol>
<li>.txt，.doc（word），.xls（excel），.ppt，.pdf,   .csv、.xmind<br> 压缩文件：.rar格式，.zip格式，.tar格式<br> 执行文件：.bat格式（windows），.sh格式（linux），.exe格式（windows）<br> 日志文件：.log（一般是日志debug日志，系统日志，错误日志）<ul>
<li>xmind 快捷键<ul>
<li><img src="/assets/1/image-20220215095739-lhdjz41.png" alt="image.png"><!-- 5. ### [二进制、八进制、十进制、十六进制之间的转换](/01_测试初阶/02_测试理论/01_第一章基础/901_文件/01_计算机基础/04_进制之间的转换/)--></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><h4 id="二进制、八进制、十进制、十六进制之间的转换"><a href="#二进制、八进制、十进制、十六进制之间的转换" class="headerlink" title="二进制、八进制、十进制、十六进制之间的转换"></a><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/01_计算机基础/04_进制之间的转换/" target="_blank">二进制、八进制、十进制、十六进制之间的转换</a></h4></li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>测试理论概念</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ol>
<li><h4 id="软件测试的定义，什么是软件测试"><a href="#软件测试的定义，什么是软件测试" class="headerlink" title="软件测试的定义，什么是软件测试"></a>软件测试的定义，什么是软件测试</h4><ol>
<li>使用人工或自动手段，来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。</li>
</ol>
</li>
<li><h4 id="软件测试的目的"><a href="#软件测试的目的" class="headerlink" title="软件测试的目的"></a>软件测试的目的</h4><ol>
<li>测试是程序的执行过程，目的在于发现错误。</li>
<li>确保产品完成了它所承诺或公布的功能</li>
<li>确保产品满足性能和效率的要求</li>
<li>确保产品是健壮的和适应用户环境的</li>
</ol>
</li>
<li><h4 id="是否了解二八定律？"><a href="#是否了解二八定律？" class="headerlink" title="是否了解二八定律？"></a>是否了解二八定律？</h4><ol>
<li>了解</li>
<li>80%的问题可以在20%的模块中发现，换句话来说，软件系统中的问题存在群集现象，大部分的问题会集中在少数的模块上。</li>
<li><h5 id="二八定律怎么避免"><a href="#二八定律怎么避免" class="headerlink" title="二八定律怎么避免"></a>二八定律怎么避免</h5><ul>
<li>在分析设计以及实现阶段的复审能够发现和避免80%的缺陷，</li>
<li>在系统测试中能够找到剩余的80%的错误，</li>
<li>最后剩余的4%只能在用户的大范围使用长时间积累爆发出来<!-- 4. #### [软件测试的分类](/01_测试初阶/02_测试理论/01_第一章基础/901_文件/902_测试理论/02_软件测试的分类/) --></li>
</ul>
</li>
</ol>
</li>
<li><h4 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/902_测试理论/02_软件测试的分类/" target="_blank">软件测试的分类</a></h4><ol>
<li><img src="/assets/1/image-20220109174021-s16k61v.png" alt="image.png"><br> 黑盒测试：不考虑程序运行本身的逻辑，只考虑输入与输出之间的关系的测试<br> 白盒测试：开发人员进行的测试，代码测试<br> 灰盒测试：介于黑盒与白盒之间的测试<br> α测试：使用真实的环境，用户参与，全部产品、开发、测试参与，现场操作发现问题及时解决<br> β测试：使用真实的环境用户不参与，部分产品、开发、测试参与，现场操作发现问题后期解决</li>
<li>软件测试分类关系图<ol>
<li><img src="/assets/1/475aa778a57237c7e6a571329668eb4-20220109175114-4ddp7g5.jpg" alt="475aa778a57237c7e6a571329668eb4.jpg"></li>
</ol>
</li>
<li>软件测试类型<ol>
<li>功能测试、性能测试、安全测试、自动化测试、渗透性测试、UI测试</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h3><ol>
<li>所有的测试都应该追溯到需求</li>
<li>尽早参与测试</li>
<li>测试中80%的缺陷来源于20%的模块中</li>
<li>不做不准备不充分的测试</li>
<li>避免测试的随意性</li>
<li>要长期保存我们的测试用例，直到系统废弃</li>
</ol>
</li>
<li><h3 id="项目流程——-gt-gt-软件的生命周期"><a href="#项目流程——-gt-gt-软件的生命周期" class="headerlink" title="项目流程——-&gt;&gt;软件的生命周期"></a>项目流程——-&gt;&gt;软件的生命周期</h3><ol>
<li>首先有需求人员编写需求文档，提供产品模型，并对这个需求进行评审，开发根据自己得到的任务进行编写代码、详设文档，测试人员根据自己得到的任务编写测试用例，进行用例评审，开发编写完成后会提交一个测试版本，我们测试用编写的用例进行测试，测试过程中如果发现bug，找到对应的开发给予解决，等bug修改以后，我们进行返测，如果通过直接关闭，如果不通过打回重新修改，直到bug关闭为止，编写测试报告， 然后进行版本发布，编写测试总结</li>
<li><strong>是不是所有的bug都关闭才能发布版本？</strong><ol>
<li><strong>不一定，有不影响项目上线的bug是允许存在的，比如说提示类说明文字与需求不一致</strong></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="测试平时工作的内容"><a href="#测试平时工作的内容" class="headerlink" title="测试平时工作的内容"></a>测试平时工作的内容</h3><ol>
<li>参与需求评审   编写测试用例  评审用例  搭建环境  执行测试   发现bug  协助开发定位问题  返测  版本发布    测试总结  测试报告</li>
</ol>
</li>
<li><h3 id="怎么把控软件的进度"><a href="#怎么把控软件的进度" class="headerlink" title="怎么把控软件的进度"></a>怎么把控软件的进度</h3><ol>
<li>通过测试计划，晨会，测试日报，里程碑</li>
</ol>
</li>
<li><h3 id="怎么把控软件质量"><a href="#怎么把控软件质量" class="headerlink" title="怎么把控软件质量"></a>怎么把控软件质量</h3><ol>
<li>需求文档明确</li>
<li>严格根据我们用例进行测试</li>
<li>保证用例的全面覆盖</li>
</ol>
</li>
<li><h3 id="一名优秀的测试人员应该具有的素质包括："><a href="#一名优秀的测试人员应该具有的素质包括：" class="headerlink" title="一名优秀的测试人员应该具有的素质包括："></a>一名优秀的测试人员应该具有的素质包括：</h3> 一  踏实细心和积极主动<br> 二  好奇心，怀疑一切<br> 三  与他人良好交流的能力<br> 四  持续不断的自我提高和总结能力<br> 五  强烈的责任感<!-- 11. ### [测试计划](/02_测试理论/01_第一章 基础/901_文件/902_测试理论/01_测试计划/) --></li>
<li><h4 id="测试计划"><a href="#测试计划" class="headerlink" title="测试计划"></a><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/902_测试理论/01_测试计划/" target="_blank">测试计划</a></h4><ol>
<li>什么是测试计划？</li>
<li>测试计划的目的？</li>
<li>测试计划是由谁写的？<!-- 12. ### [测试用例设计](/02_测试理论/01_第一章 基础/901_文件/902_测试理论/05_测试用例设计/) --></li>
</ol>
</li>
<li><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/902_测试理论/05_测试用例设计/" target="_blank">测试用例设计</a><!-- 13. [软件测试执行](/02_测试理论/01_第一章 基础/901_文件/902_测试理论/07_软件测试执行/) --></li>
<li><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/902_测试理论/07_软件测试执行/" target="_blank">软件测试执行</a><!-- 14. [软件测试报告](/02_测试理论/01_第一章 基础/901_文件/902_测试理论/08_软件测试报告/) --></li>
<li><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/902_测试理论/08_软件测试报告/" target="_blank">软件测试报告</a><!-- 15. [软件测试概念总结](/02_测试理论/01_第一章 基础/901_文件/902_测试理论/09_测试概念总结/) --></li>
<li><a href="/01_测试初阶/02_测试理论/01_第一章基础/901_文件/902_测试理论/09_测试概念总结/" target="_blank">软件测试概念总结</a></li>
</ol>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
  <entry>
    <title>windows快捷键</title>
    <url>/01_%E6%B5%8B%E8%AF%95%E5%88%9D%E9%98%B6/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01_windows%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h5 id="win快捷键："><a href="#win快捷键：" class="headerlink" title="win快捷键："></a>win快捷键：</h5><p>单独按Windows：显示或隐藏 “开始”功能表<br>Windows+BREAK：显示“系统属性” 对话框<br>Windows+D：显示桌面或恢复桌面<br>Windows+M：最小化所有窗口<br>Windows+Shift+M：还原最小化的窗口<br>Ctrl+Shift+N：新建文件夹<br>Windows+E：打开”我的电脑”<br>Windows+F：查找文件或文件夹<br>Windows+CTRL+ F：查找电脑<br>Windows+F1：显示 Windows “帮助”<br>Windows+R：开启“运行” 对话框<br>Windows+U：开启 “公用程序管理器”<br>Windows+L：锁定计算机（Windows XP新功能）<br>Windows按住不动+Tab：打开的应用程序切换，立体效果（win7系统支持）<br>windows +alt +F4：windows 关机窗口</p>
<h5 id="Ctr快捷键（文本编辑使用较多）"><a href="#Ctr快捷键（文本编辑使用较多）" class="headerlink" title="Ctr快捷键（文本编辑使用较多）"></a>Ctr快捷键（文本编辑使用较多）</h5><p>Ctrl+S 保存<br>Ctrl+W 关闭程序<br>Ctrl+N 新建<br>Ctrl+O 打开<br>Ctrl+Z 撤销<br>Ctrl+F 查找<br>Ctrl+P 打印文档<br>Ctrl+X 剪切<br>Ctrl+C 复制<br>Ctrl+V 粘贴<br>Ctrl+A全选<br>Ctrl+B 粗体<br>Ctrl+I 斜体<br>Ctrl+U 下划线<br>Ctrl+Shift输入法切换<br>Ctrl+ 空格 中英文切换<br>Ctrl+Home 光标快速移到文件头<br>Ctrl+End 光标快速移到文件尾<br>Ctrl+Esc 显示开始菜单<br>Ctrl+Shift+&lt; 快速缩小文字<br>Ctrl+Shift+&gt; 快速放大文字<br>Ctrl+F5 在IE中强行刷新<br>Ctrl+拖动文件 复制文件<br>Ctrl+Backspace 启动\关闭输入法<br>Ctrl+Alt+A 截屏(QQ的截屏）<br>shift + Alt + Print Screen(选中要截屏的地方，然后按这三个键，然后打开图画或者word，粘贴即可)<br>拖动文件时按住Ctrl+Shift 创建快捷方式<br>Ctrl+Tab+shift在打开的应用程序中以反方向切换</p>
<h5 id="ALT快捷键"><a href="#ALT快捷键" class="headerlink" title="ALT快捷键"></a>ALT快捷键</h5><p>Alt+F4 关闭当前程序<br>Alt+空格+C 关闭窗口<br>Alt+空格+N 最小化当前窗口<br>Alt+空格+R 恢复最大化窗口<br>Alt+空格+X 最大化当前窗口<br>Alt+空格+M 移动窗口<br>Alt+空格+S 改变窗口大小<br>Alt+u+v word全屏视图<br>Alt+F 打开文件菜单<br>Alt+V 打开视图菜单<br>Alt+E 打开编辑菜单<br>Alt+I 打开插入菜单<br>Alt+O 打开格式菜单<br>Alt+T 打开工具菜单<br>Alt+A 打开表格菜单<br>Alt+W 打开窗口菜单<br>Alt+H 打开帮助菜单<br>Alt+回车 查看文件属性<br>Alt+双击文件 查看文件属性<br>Alt+Tab在打开的应用不同窗口间进行切换</p>
<h5 id="shift快捷键"><a href="#shift快捷键" class="headerlink" title="shift快捷键"></a>shift快捷键</h5><p>Shift+空格 半\全角切换<br>Shift+F10 选中文件的右菜单<br>Shift+Del 永久删除</p>
<h5 id="FN快捷键"><a href="#FN快捷键" class="headerlink" title="FN快捷键"></a>FN快捷键</h5><p>F1 帮助<br>F2 重命名<br>F3 在windows中搜索文件<br>F5 刷新<br>F6 在窗口或桌面上循环切换屏幕元素。<br>F7 DoS下专用功能<br>F8 Windows 启动选项<br>F9 Excel 中计算公式<br>F11 切换全屏<br>F12 Word 里另存文档</p>
<h5 id="常规快捷键"><a href="#常规快捷键" class="headerlink" title="常规快捷键"></a>常规快捷键</h5><p>拖动某一项时按 CTRL 复制所选项。<br>拖动某一项时按 CTRL + SHIFT 创建所选项目的快捷键。<br>F2 重新命名所选项目。<br>CTRL + 向右键 将插入点移动到下一个单词的起始处。<br>CTRL + 向左键 将插入点移动到前一个单词的起始处。<br>CTRL + 向下键 将插入点移动到下一段落的起始处。<br>CTRL + 向上键 将插入点移动到前一段落的起始处。<br>CTRL + SHIFT + 任何箭头键突出显示一块文本。<br>SHIFT + 任何箭头键 在窗口或桌面上选择多项，或者选中文档中的文本。<br>Ctrl + A 选中全部内容。<br>F3 同一浏览器中打开的窗口切换。<br>Alt + Enter 查看所选项目的属性。<br>Alt + F4 打开关机，待机，重启<br>Alt +空格键为当前窗口打开快捷菜单。<br>Alt + Tab 在打开的项目之间切换。<br>Alt + Esc 以项目打开的顺序循环切换。<br>Shift + F10 显示所选项的快捷菜单。<br>ALT + 菜单名中带下划线的字母 显示相应的菜单（ALT在写字板中）。<br>右箭头键 打开右边的下一菜单或者打开子菜单。<br>Ctrl+Alt+Home或ctrl+home 回到页首</p>
<h5 id="FN键"><a href="#FN键" class="headerlink" title="FN键"></a>FN键</h5><p>F1 帮助<br>F2 重命名<br>F3 在windows中搜索文件<br>F5 刷新<br>F6 在窗口或桌面上循环切换屏幕元素。<br>F7 DoS下专用功能<br>F8 Windows 启动选项<br>F9 Excel 中计算公式<br>F11 切换全屏<br>F12 Word 里另存文档<br>Enter 执行活选项动或按钮所对应的命令。<br>方向键 活选项动是一组选项按钮时，请选中某个按钮。<br>BackSpace 如果在“另存为”或“打开”对话框中选中了某个文件夹，则打开上一级文件夹</p>
<h5 id="END-显示当前窗口的底端。"><a href="#END-显示当前窗口的底端。" class="headerlink" title="END 显示当前窗口的底端。"></a>END 显示当前窗口的底端。</h5><p>Home 显示当前窗口的顶端。<br>NUM LOCK+数字键盘星号* 显示所选文件夹的所有子文件夹。<br>NUM LOCK+数字键盘加号+ 显示所选文件夹的内容。<br>NUM LOCK+数字键盘减号- 折叠所选的文件夹。<br>左方向键 光标左移<br>右方向键 光标右移<br>TAB 制表键</p>
]]></content>
      <categories>
        <category>01_测试初阶</category>
        <category>02_测试理论</category>
        <category>01_第一章基础</category>
        <category>901_文件</category>
        <category>01_计算机基础</category>
      </categories>
      <tags>
        <tag>测试理论</tag>
      </tags>
  </entry>
</search>
