<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>软件测试技术分享</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-15T19:56:51.723Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yulong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pytest文档03_pycharm运行pytest</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A303_pycharm%E8%BF%90%E8%A1%8Cpytest/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A303_pycharm%E8%BF%90%E8%A1%8Cpytest/</id>
    <published>2022-05-15T15:58:57.804Z</published>
    <updated>2022-05-15T19:56:51.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇<a href="https://www.cnblogs.com/yoyoketang/p/9362415.html">pytest文档2-用例运行规则</a>已经介绍了如何在cmd执行pytest用例，平常我们写代码在pycharm比较多<br>写完用例之后，需要调试看看，是不是能正常运行，如果每次跑去cmd执行，太麻烦，所以很有必要学习如何在pycharm里面运行pytest用例</p><h1 id="pycharm运行三种方式"><a href="#pycharm运行三种方式" class="headerlink" title="pycharm运行三种方式"></a>pycharm运行三种方式</h1><p>1.以xx.py脚本方式直接执行，当写的代码里面没用到unittest和pytest框架时，并且脚本名称不是以test_开头命名的，此时pycharm会以xx.py脚本方式运行</p><p><img src="/assets/2/image-20220516000404-mnk1zvu.png" alt="image.png"></p><p>2.当脚本命名为test_xx.py时，用到unittest框架，此时运行代码，pycharm会自动识别到以unittest方式运行</p><p><img src="/assets/2/image-20220516000411-7dvsdge.png" alt="image.png"></p><p>3.以pytest方式运行，需要改该工程设置默认的运行器：file-&gt;Setting-&gt;Tools-&gt;Python Integrated Tools-&gt;项目名称-&gt;Default test runner-&gt;选择py.test</p><p><img src="/assets/2/image-20220516000429-4fvw1wa.png" alt="image.png"></p><p><strong>备注：pytest是可以兼容unittest框架代码的</strong></p><h1 id="pycharm写pytest代码"><a href="#pycharm写pytest代码" class="headerlink" title="pycharm写pytest代码"></a>pycharm写pytest代码</h1><p>1.在pycharm里面写pytest用例，先导入pytest</p><pre><code class="python"># D:/YOYO/test_class.py** 作者：上海-悠悠 QQ交流群：588402570**import pytestclass TestClass:        def test_one(self):            x = &quot;this&quot;            assert &#39;h&#39; in x        def test_two(self):            x = &quot;hello&quot;            assert hasattr(x, &#39;check&#39;)        def test_three(self):            a = &quot;hello&quot;            b = &quot;hello world&quot;            assert a in bif __name__ == &quot;__main__&quot;:    pytest.main(&#39;-q test_class.py&#39;)</code></pre><p>运行结果</p><pre><code class="python">.F.                                                                      [100%]================================== FAILURES ===================================_____________________________ TestClass.test_two ______________________________self = &lt;YOYO.test_class.TestClass object at 0x00000000039F9080&gt;    def test_two(self):        x = &quot;hello&quot;&gt;       assert hasattr(x, &#39;check&#39;)E       AssertionError: assert FalseE        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)test_class.py:11: AssertionError============================== warnings summary ===============================&lt;undetermined location&gt;  passing a string to pytest.main() is deprecated, pass a list of arguments instead.-- Docs: http://doc.pytest.org/en/latest/warnings.html1 failed, 2 passed, 1 warnings in 0.06 seconds</code></pre><p>2.运行结果“.F. ” 点是代表测试通过，F是Fail的意思，1 warnings是用于pytest.main(‘-q test_class.py’)里面参数需要传list，多个参数放list就不会有警告了</p><blockquote><p>pytest.main([‘-q’, ‘test_class.py’])</p></blockquote><h1 id="pycharm设置pytest"><a href="#pycharm设置pytest" class="headerlink" title="pycharm设置pytest"></a>pycharm设置pytest</h1><p>1.新建一个工程后，左上角file-&gt;Setting-&gt;Tools-&gt;Python Integrated Tools-&gt;项目名称-&gt;Default test runner-&gt;选择py.test</p><p><img src="/assets/2/image-20220516000438-pf9g134.png" alt="image.png"></p><p>2.改完之后，再重新建个脚本（注意是先改项目运行方式，再写代码才能出来），接下来右键运行就能出来pytest运行了</p><p><img src="/assets/2/image-20220516000445-ccombr5.png" alt="image.png"></p><p>3.pytest是可以兼容unittest脚本的，之前写的unittest用例也能用pytest框架去运行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇&lt;a href=&quot;https://www.cnblogs.com/yoyoketang/p/9362415.html&quot;&gt;pytest文</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档56-插件打包上传到 pypi 库</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A356-%E6%8F%92%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%88%B0%20pypi%20%E5%BA%93/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A356-%E6%8F%92%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%88%B0%20pypi%20%E5%BA%93/</id>
    <published>2022-05-15T15:58:57.799Z</published>
    <updated>2022-05-15T20:03:55.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 的插件完成之后，可以上传到 github，方便其他小伙伴通过 pip 源码安装。如果我们想通过 <code>pip install packages</code> 这种方式安装的话，需上传到 pypi 仓库</p><h1 id="pypi仓库"><a href="#pypi仓库" class="headerlink" title="pypi仓库"></a>pypi仓库</h1><p>pip，全称是：python install packages，它是一个通用的 Python 包管理工具，是easy_install的替代品, 主要是用于安装 PyPI 上的软件包。<br>PyPI，全称是：Python Package Index，它是Python官方的第三方库的仓库，所有人都可以下载第三方库或上传自己开发的库到PyPI。<br>PyPI推荐使用pip包管理器来下载第三方库。</p><p>我们想把python包上传到pypi,需在 <a href="https://pypi.org/">https://pypi.org/</a> 注册一个账号</p><p><img src="/assets/2/image-20220516013547-usjebga.png" alt="image.png"></p><h1 id="整理项目结构"><a href="#整理项目结构" class="headerlink" title="整理项目结构"></a>整理项目结构</h1><p>前面这篇<a href="https://www.cnblogs.com/yoyoketang/p/13638661.html">https://www.cnblogs.com/yoyoketang/p/13638661.html</a>pytest 插件的开发，就是一个半成品了</p><p>整个目录结构如下</p><pre><code class="markdown">pytest-change-report├── LICENSE├── README.rst├── requirements.txt├── setup.py├── pytest_change_report.py├── tests│   ├──__init__.py│   ├──conftest.py│   └──test_change_report.py</code></pre><ul><li>pytest-change-report 是项目的包名</li><li>LICENSE LICENSE文件是授权文件，比如：MIT license， APACHE license</li><li>requirements.txt 依赖包，比如这个插件依赖pytest模块，可以写pytest&#x3D;&#x3D;4.5.0</li><li>README.rst 其实就是项目介绍和使用说明帮助文档</li><li>setup.py python模块安装所需要的文件</li><li>tests 是测试的目录</li><li>pytest_change_report.py 插件实现功能的核心模块</li></ul><p>代码写完测试没问题后，上传到github仓库，并打个v1.0的标签<br><img src="/assets/2/image-20220516013556-80bz1es.png" alt="image.png"><br>打完 tag 标签，push 到 github 仓库，这样在 tag 目录就能看到 release 的记录了<br><img src="/assets/2/image-20220516013603-anemu9c.png" alt="image.png"></p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>cd到项目的根目录，执行</p><blockquote><p>python setup.py sdist build</p></blockquote><p>执行完成后，在dist目录，会生成一个.tar.gz的压缩包，这个压缩包就可以通过 pip 安装了</p><p><img src="/assets/2/image-20220516013609-4l2x0gw.png" alt="image.png"></p><p>也可以打包一个wheels格式的包，需要安装wheel包：</p><blockquote><p>pip install wheel</p></blockquote><p>执行以下命令打包</p><blockquote><p>python setup.py bdist_wheel –universal</p></blockquote><p>这样在dist目录生成一个 pytest_change_report-1.0-py2.py3-none-any.whl 文件，.whl 后置的文件也可以通过 pip 直接安装</p><h1 id="上传发布"><a href="#上传发布" class="headerlink" title="上传发布"></a>上传发布</h1><p>使用twine上传,先安装twine</p><blockquote><p>pip install twine</p></blockquote><p>上传输入指令，接着会提示输入账号和密码</p><blockquote><p>twine upload dist&#x2F;*</p></blockquote><pre><code class="shell">&gt;twine upload dist/*Uploading distributions to https://upload.pypi.org/legacy/Enter your username: yoyoketangEnter your password:Uploading pytest_change_report-1.0-py2.py3-none-any.whl100%|█████████████████████████████████████████████████████████ ████████████████████| 5.56k/5.56k [00:00&lt;00:00, 6.17kB/s]Uploading pytest-change-report-1.0.tar.gz100%|█████████████████████████████████████████████████████████ ████████████████████| 5.15k/5.15k [00:01&lt;00:00, 4.71kB/s]View at:https://pypi.org/project/pytest-change-report/1.0/</code></pre><p>上传后访问地址 <a href="https://pypi.org/project/pytest-change-report/1.0/">https://pypi.org/project/pytest-change-report/1.0/</a></p><h1 id="查看pypi"><a href="#查看pypi" class="headerlink" title="查看pypi"></a>查看pypi</h1><p>打开上面的访问地址可以查看到已经上传成功<br><img src="/assets/2/image-20220516013621-wdscgqx.png" alt="image.png"></p><p>点 Homepage 可以跳转到 github 仓库去</p><p>这样小伙伴们就能直接使用 pip 安装了</p><blockquote><p>pip install pytest-change-report</p></blockquote><p>python 打包发布到 pypi 的就完成了，是不是很激动！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;pytest 的插件完成之后，可以上传到 github，方便其他小伙伴通过 pip 源码安装。如果我们想通过 &lt;code&gt;pip insta</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档04_测试用例setup和teardown</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A304_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8Bsetup%E5%92%8Cteardown/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A304_%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8Bsetup%E5%92%8Cteardown/</id>
    <published>2022-05-15T15:58:57.794Z</published>
    <updated>2022-05-15T19:56:59.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学过unittest的都知道里面用前置和后置setup和teardown非常好用，在每次用例开始前和结束后都去执行一次。<br>当然还有更高级一点的setupClass和teardownClass，需配合@classmethod装饰器一起使用，在做selenium自动化的时候，它的效率尤为突出，可以只启动一次浏览器执行多个用例。<br>pytest框架也有类似于setup和teardown的语法，并且还不止这四个</p><h1 id="用例运行级别"><a href="#用例运行级别" class="headerlink" title="用例运行级别"></a>用例运行级别</h1><ul><li>模块级（setup_module&#x2F;teardown_module）开始于模块始末，全局的</li><li>函数级（setup_function&#x2F;teardown_function）只对函数用例生效（不在类中）</li><li>类级（setup_class&#x2F;teardown_class）只在类中前后运行一次(在类中)</li><li>方法级（setup_method&#x2F;teardown_method）开始于方法始末（在类中）</li><li>类里面的（setup&#x2F;teardown）运行在调用方法的前后</li></ul><h1 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h1><h3 id="setup-function-x2F-teardown-function"><a href="#setup-function-x2F-teardown-function" class="headerlink" title="setup_function&#x2F;teardown_function"></a>setup_function&#x2F;teardown_function</h3><p>1.pytest框架支持函数和类两种用例方式，先看函数里面的前置与后置用法：</p><blockquote><p><strong>setup_function&#x2F;teardown_function</strong> 每个用例开始和结束调用一次</p></blockquote><pre><code class="python"># test_fixt.py# coding:utf-8import pytest# 函数式** 作者：上海-悠悠 QQ交流群：588402570**def setup_function():    print(&quot;setup_function：每个用例开始前都会执行&quot;)def teardown_function():    print(&quot;teardown_function：每个用例结束后都会执行&quot;)def test_one():    print(&quot;正在执行----test_one&quot;)    x = &quot;this&quot;    assert &#39;h&#39; in xdef test_two():    print(&quot;正在执行----test_two&quot;)    x = &quot;hello&quot;    assert hasattr(x, &#39;check&#39;)def test_three():    print(&quot;正在执行----test_three&quot;)    a = &quot;hello&quot;    b = &quot;hello world&quot;    assert a in bif __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_fixt.py&quot;])</code></pre><p>运行结果：</p><pre><code class="markdown">============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0rootdir: E:\YOYO, inifile:collected 3 itemstest_fixt.py setup_function：每个用例开始前都会执行正在执行----test_one.teardown_function：每个用例结束后都会执行setup_function：每个用例开始前都会执行正在执行----test_twoFteardown_function：每个用例结束后都会执行setup_function：每个用例开始前都会执行正在执行----test_three.teardown_function：每个用例结束后都会执行================================== FAILURES ===================================__________________________________ test_two ___________________________________    def test_two():        print(&quot;正在执行----test_two&quot;)        x = &quot;hello&quot;&gt;       assert hasattr(x, &#39;check&#39;)E       AssertionError: assert FalseE        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)test_fixt.py:19: AssertionError===================== 1 failed, 2 passed in 0.03 seconds ======================</code></pre><p>2.从结果可以看出用例执行顺序：setup_function》用例1》teardown_function， setup_function》用例2》teardown_function， setup_function》用例3》teardown_function</p><p><strong>备注：-s参数是为了显示用例的打印信息。 -q参数只显示结果，不显示过程</strong></p><h3 id="setup-module-x2F-teardown-module"><a href="#setup-module-x2F-teardown-module" class="headerlink" title="setup_module&#x2F;teardown_module"></a>setup_module&#x2F;teardown_module</h3><p>1.setup_module是所有用例开始前只执行一次，teardown_module是所有用例结束后只执行一次</p><pre><code class="python"># test_fixt.py# coding:utf-8import pytest# 函数式** 作者：上海-悠悠 QQ交流群：588402570**def setup_module():    print(&quot;setup_module：整个.py模块只执行一次&quot;)    print(&quot;比如：所有用例开始前只打开一次浏览器&quot;)def teardown_module():    print(&quot;teardown_module：整个.py模块只执行一次&quot;)    print(&quot;比如：所有用例结束只最后关闭浏览器&quot;)def setup_function():    print(&quot;setup_function：每个用例开始前都会执行&quot;)def teardown_function():    print(&quot;teardown_function：每个用例结束前都会执行&quot;)def test_one():    print(&quot;正在执行----test_one&quot;)    x = &quot;this&quot;    assert &#39;h&#39; in xdef test_two():    print(&quot;正在执行----test_two&quot;)    x = &quot;hello&quot;    assert hasattr(x, &#39;check&#39;)def test_three():    print(&quot;正在执行----test_three&quot;)    a = &quot;hello&quot;    b = &quot;hello world&quot;    assert a in bif __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_fixt.py&quot;])</code></pre><p>2.从运行结果可以看到setup_module和teardown_module只执行了一次</p><pre><code class="css">test_fixt.py setup_module：整个.py模块只执行一次比如：所有用例开始前只打开一次浏览器setup_function：每个用例开始前都会执行正在执行----test_one.teardown_function：每个用例结束前都会执行setup_function：每个用例开始前都会执行正在执行----test_twoFteardown_function：每个用例结束前都会执行setup_function：每个用例开始前都会执行正在执行----test_three.teardown_function：每个用例结束前都会执行teardown_module：整个.py模块只执行一次比如：所有用例结束只最好关闭浏览器</code></pre><p><strong>备注：setup_function&#x2F;teardown_function和setup_module&#x2F;teardown_module这四种方法是可以任意组合的，用一个和多个都可以</strong></p><h1 id="类和方法"><a href="#类和方法" class="headerlink" title="类和方法"></a>类和方法</h1><p>1.setup&#x2F;teardown和unittest里面的setup&#x2F;teardown是一样的功能，setup_class和teardown_class等价于unittest里面的setupClass和teardownClass</p><pre><code class="python">#test_fixtclass.py# coding:utf-8import pytest# 类和方法** 作者：上海-悠悠 QQ交流群：588402570**class TestCase():    def setup(self):        print(&quot;setup: 每个用例开始前执行&quot;)    def teardown(self):        print(&quot;teardown: 每个用例结束后执行&quot;)    def setup_class(self):        print(&quot;setup_class：所有用例执行之前&quot;)    def teardown_class(self):        print(&quot;teardown_class：所有用例执行之前&quot;)    def setup_method(self):        print(&quot;setup_method:  每个用例开始前执行&quot;)    def teardown_method(self):        print(&quot;teardown_method:  每个用例结束后执行&quot;)    def test_one(self):        print(&quot;正在执行----test_one&quot;)        x = &quot;this&quot;        assert &#39;h&#39; in x    def test_two(self):        print(&quot;正在执行----test_two&quot;)        x = &quot;hello&quot;        assert hasattr(x, &#39;check&#39;)    def test_three(self):        print(&quot;正在执行----test_three&quot;)        a = &quot;hello&quot;        b = &quot;hello world&quot;        assert a in bif __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_fixtclass.py&quot;])</code></pre><p>运行结果</p><pre><code class="makefile">test_fixtclass.py setup_class：所有用例执行之前setup_method:  每个用例开始前执行setup: 每个用例开始前执行正在执行----test_one.teardown: 每个用例结束后执行teardown_method:  每个用例结束后执行setup_method:  每个用例开始前执行setup: 每个用例开始前执行正在执行----test_twoFteardown: 每个用例结束后执行teardown_method:  每个用例结束后执行setup_method:  每个用例开始前执行setup: 每个用例开始前执行正在执行----test_three.teardown: 每个用例结束后执行teardown_method:  每个用例结束后执行teardown_class：所有用例执行之前</code></pre><p>2.从结果看出，运行的优先级：setup_class》setup_method》setup 》用例》teardown》teardown_method》teardown_class<br><strong>备注：这里setup_method和teardown_method的功能和setup&#x2F;teardown功能是一样的，一般二者用其中一个即可</strong></p><h1 id="函数和类混合"><a href="#函数和类混合" class="headerlink" title="函数和类混合"></a>函数和类混合</h1><p>1.如果一个.py的文件里面既有函数用例又有类和方法用例，运行顺序又是怎样的呢？</p><pre><code class="python"># coding:utf-8import pytest# 类和方法** 作者：上海-悠悠 QQ交流群：588402570**def setup_module():    print(&quot;setup_module：整个.py模块只执行一次&quot;)    print(&quot;比如：所有用例开始前只打开一次浏览器&quot;)def teardown_module():    print(&quot;teardown_module：整个.py模块只执行一次&quot;)    print(&quot;比如：所有用例结束只最后关闭浏览器&quot;)def setup_function():    print(&quot;setup_function：每个用例开始前都会执行&quot;)def teardown_function():    print(&quot;teardown_function：每个用例结束前都会执行&quot;)def test_one():    print(&quot;正在执行----test_one&quot;)    x = &quot;this&quot;    assert &#39;h&#39; in xdef test_two():    print(&quot;正在执行----test_two&quot;)    x = &quot;hello&quot;    assert hasattr(x, &#39;check&#39;)class TestCase():    def setup_class(self):        print(&quot;setup_class：所有用例执行之前&quot;)    def teardown_class(self):        print(&quot;teardown_class：所有用例执行之前&quot;)    def test_three(self):        print(&quot;正在执行----test_three&quot;)        x = &quot;this&quot;        assert &#39;h&#39; in x    def test_four(self):        print(&quot;正在执行----test_four&quot;)        x = &quot;hello&quot;        assert hasattr(x, &#39;check&#39;)if __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_fixtclass.py&quot;])</code></pre><p>运行结果：</p><pre><code class="css">test_fixtclass.py setup_module：整个.py模块只执行一次比如：所有用例开始前只打开一次浏览器setup_function：每个用例开始前都会执行正在执行----test_one.teardown_function：每个用例结束前都会执行setup_function：每个用例开始前都会执行正在执行----test_twoFteardown_function：每个用例结束前都会执行setup_class：所有用例执行之前正在执行----test_three.正在执行----test_fourFteardown_class：所有用例执行之前teardown_module：整个.py模块只执行一次比如：所有用例结束只最后关闭浏览器</code></pre><p>2.从运行结果看出，setup_module&#x2F;teardown_module的优先级是最大的，然后函数里面用到的setup_function&#x2F;teardown_function与类里面的setup_class&#x2F;teardown_class互不干涉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学过unittest的都知道里面用前置和后置setup和teardown非常好用，在每次用例开始前和结束后都去执行一次。&lt;br&gt;当然还有更高</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档43-元数据使用(pytest-metadata)</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A343-%E5%85%83%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8(pytest-metadata)/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A343-%E5%85%83%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8(pytest-metadata)/</id>
    <published>2022-05-15T15:58:57.788Z</published>
    <updated>2022-05-15T20:02:56.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>什么是元数据？元数据是关于数据的描述，存储着关于数据的信息，为人们更方便地检索信息提供了帮助。<br>pytest 框架里面的元数据可以使用 pytest-metadata 插件实现。文档地址<a href="https://pypi.org/project/pytest-metadata/">https://pypi.org/project/pytest-metadata/</a></p><h1 id="pytest-metadata-环境准备"><a href="#pytest-metadata-环境准备" class="headerlink" title="pytest-metadata 环境准备"></a>pytest-metadata 环境准备</h1><p>使用 pip 安装 pytest-metadata</p><blockquote><p>pip install pytest-metadata</p></blockquote><h1 id="查看-pytest-元数据"><a href="#查看-pytest-元数据" class="headerlink" title="查看 pytest 元数据"></a>查看 pytest 元数据</h1><p>使用pytest 执行用例的时候加上 <code>-v</code> 参数(或<code>--verbose</code>),在控制台输出报告的头部就会输出元数据(metadata)</p><pre><code class="lua">&gt;pytest --verbose============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-4.5.0, py-1.5.4, pluggy-0.13.1 -- e:\python36\python.execachedir: .pytest_cachemetadata: &#123;&#39;Python&#39;: &#39;3.6.0&#39;, &#39;Platform&#39;: &#39;Windows-10-10.0.17134-SP0&#39;, &#39;Packages&#39;: &#123;&#39;pytest&#39;: &#39;4.5.0&#39;, &#39;py&#39;: &#39;1.5.4&#39;, &#39;pluggy&#39;: &#39;0.13.1&#39;&#125;, &#39;Plugins&#39;: &#123;&#39;allure-pytest&#39;: &#39;2.8.6&#39;, &#39;PyTestReport&#39;: &#39;0.1.9.3&#39;, &#39;assume&#39;: &#39;2.2.1&#39;, &#39;forked&#39;: &#39;0.2&#39;, &#39;html&#39;: &#39;1.19.0&#39;, &#39;metadata&#39;: &#39;1.7.0&#39;, &#39;ordering&#39;: &#39;0.6&#39;, &#39;repeat&#39;: &#39;0.7.0&#39;, &#39;rerunfailures&#39;: &#39;8.0&#39;, &#39;xdist&#39;: &#39;1.23.2&#39;&#125;, &#39;JAVA_HOME&#39;: &#39;D:\\java\\jdk1.8&#39;&#125;rootdir: D:\soft\code\pytest_api_2020_03plugins: allure-pytest-2.8.6</code></pre><p>可以获取到的元数据</p><table><thead><tr><th>Key</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>Python</td><td>Python 版本</td><td>‘3.6.0’</td></tr><tr><td>Platform</td><td>运行平台</td><td>‘Windows-10-10.0.17134-SP0’</td></tr><tr><td>Packages</td><td>pytest 包相关信息</td><td>{‘pytest’: ‘4.5.0’, ‘py’: ‘1.5.4’, ‘pluggy’: ‘0.13.1’}</td></tr><tr><td>Plugins</td><td>pytest 插件</td><td>{‘allure-pytest’: ‘2.8.6’, ‘PyTestReport’: ‘0.1.9.3’}</td></tr><tr><td>JAVA_HOME</td><td>JAVA环境变量</td><td>‘D:\java\jdk1.8’</td></tr></tbody></table><p>元数据是以键值对(key-value)方式存储的</p><h1 id="添加-metadata"><a href="#添加-metadata" class="headerlink" title="添加 metadata"></a>添加 metadata</h1><p>我们可以在命令行用 <code>--metadata</code> 参数添加键值对(key, value)的元数据。<br>比如当我们完成了一个项目，需要添加作者信息，于是就可以添加元数据</p><blockquote><p>pytest –metadata auther yoyo</p></blockquote><p>如果需要添加多个元数据，可以使用多次 <code>--metadata</code> 参数添加</p><blockquote><p>pytest –metadata auther yoyo –metadata version v1.0</p></blockquote><p>从文档上看可以支持json格式，一次性传多组元数据，使用<code>--metadata-from-json</code>,但我自己试了下，并不支持这个参数,这种方式可以忽略！</p><blockquote><p>pytest –metadata-from-json ‘{“cat_says”: “bring the cat nip”, “human_says”: “yes kitty”}’</p></blockquote><h1 id="pytest-metadata-hook函数"><a href="#pytest-metadata-hook函数" class="headerlink" title="pytest_metadata hook函数"></a>pytest_metadata hook函数</h1><p>在代码里面也可以新增&#x2F;修改&#x2F;删除 元数据，我们可以使用 pytest_metadata hook函数</p><pre><code class="python">import pytest@pytest.mark.optionalhookdef pytest_metadata(metadata):    metadata.pop(&quot;password&quot;, None)</code></pre><p>我们可以使用 metadata fixture，用于测试用例或fixture 访问元数据（metadata）</p><pre><code class="python">def test_metadata(metadata):    assert &#39;metadata&#39; in metadata[&#39;Plugins&#39;]</code></pre><p>在插件里面访问 metadata，可以在config对象使用 _metadata 属性来新增&#x2F;修改&#x2F;删除 元数据</p><pre><code class="lua">def pytest_configure(config):  if hasattr(config, &#39;_metadata&#39;):      config._metadata[&#39;foo&#39;] = &#39;bar&#39;</code></pre><h1 id="插件集成"><a href="#插件集成" class="headerlink" title="插件集成"></a>插件集成</h1><p>下面是一个方便的插件列表，这些插件要么读取元数据，要么对元数据有贡献：</p><ul><li>pytest-base-url - Adds the base URL to the metadata.</li><li>pytest-html - Displays the metadata at the start of each report.</li><li>pytest-selenium - Adds the driver, capabilities, and remote server to the metadata.</li></ul><h1 id="pytest-ini-管理元数据"><a href="#pytest-ini-管理元数据" class="headerlink" title="pytest.ini 管理元数据"></a>pytest.ini 管理元数据</h1><p>如果新增的元数据较多，在命令行输入不太方便，可以在pytest.ini配置里面配置你的项目元数据</p><pre><code class="haskell"># pytest.ini# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/[pytest]addopts = -v   --html=report.html   --self-contained-html  --metadata auther yoyo   --metadata version v1.0</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;什么是元数据？元数据是关于数据的描述，存储着关于数据的信息，为人们更方便地检索信息提供了帮助。&lt;br&gt;pytest 框架里面的元数据可以使用</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档05_fixture之conftest.py</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A305_fixture%E4%B9%8Bconftest.py/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A305_fixture%E4%B9%8Bconftest.py/</id>
    <published>2022-05-15T15:58:57.782Z</published>
    <updated>2022-05-15T19:57:25.346Z</updated>
    
    <content type="html"><![CDATA[<p>前言</p><p>前面一篇讲到用例加setup和teardown可以实现在测试用例之前或之后加入一些操作，但这种是整个脚本全局生效的，如果我想实现以下场景：<br>用例1需要先登录，用例2不需要登录，用例3需要先登录。很显然这就无法用setup和teardown来实现了。这就是本篇学习的目的，自定义测试用例的预置条件</p><h1 id="fixture优势"><a href="#fixture优势" class="headerlink" title="fixture优势"></a>fixture优势</h1><p>1.firture相对于setup和teardown来说应该有以下几点优势</p><ul><li>命名方式灵活，不局限于setup和teardown这几个命名</li><li>conftest.py 配置里可以实现数据共享，不需要import就能自动找到一些配置</li><li>scope&#x3D;”module” 可以实现多个.py跨文件共享前置, 每一个.py文件调用一次</li><li>scope&#x3D;”session” 以实现多个.py跨文件使用一个session来完成多个用例</li></ul><pre><code class="sql">fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None):    &quot;&quot;&quot;使用装饰器标记fixture的功能     ** 作者：上海-悠悠 QQ交流群：588402570**     可以使用此装饰器（带或不带参数）来定义fixture功能。 fixture功能的名称可以在以后使用     引用它会在运行测试之前调用它：test模块或类可以使用pytest.mark.usefixtures（fixturename标记。      测试功能可以直接使用fixture名称作为输入参数，在这种情况下，夹具实例从fixture返回功能将被注入。    :arg scope: scope 有四个级别参数 &quot;function&quot; (默认), &quot;class&quot;, &quot;module&quot; or &quot;session&quot;.    :arg params: 一个可选的参数列表，它将导致多个参数调用fixture功能和所有测试使用它    :arg autouse:  如果为True，则为所有测试激活fixture func 可以看到它。 如果为False（默认值）则显式需要参考来激活fixture    :arg ids: 每个字符串id的列表，每个字符串对应于params 这样他们就是测试ID的一部分。 如果没有提供ID它们将从params自动生成    :arg name:   fixture的名称。 这默认为装饰函数的名称。 如果fixture在定义它的同一模块中使用，夹具的功能名称将被请求夹具的功能arg遮蔽; 解决这个问题的一种方法是将装饰函数命名                       “fixture_ &lt;fixturename&gt;”然后使用”@ pytest.fixture（name =&#39;&lt;fixturename&gt;&#39;）“”。</code></pre><p><strong>Fixtures可以选择使用<code>yield</code>语句为测试函数提供它们的值，而不是<code>return</code>。 在这种情况下，<code>yield</code>语句之后的代码块作为拆卸代码执行，而不管测试结果如何。fixture功能必须只产生一次</strong></p><h1 id="fixture参数传入（scope-x3D-”function”）"><a href="#fixture参数传入（scope-x3D-”function”）" class="headerlink" title="fixture参数传入（scope&#x3D;”function”）"></a>fixture参数传入（scope&#x3D;”function”）</h1><p>1.实现场景：用例1需要先登录，用例2不需要登录，用例3需要先登录</p><pre><code class="python"># 新建一个文件test_fixt.py# coding:utf-8** 作者：上海-悠悠 QQ交流群：588402570**import pytest# 不带参数时默认scope=&quot;function&quot;@pytest.fixture()def login():    print(&quot;输入账号，密码先登录&quot;)def test_s1(login):    print(&quot;用例1：登录之后其它动作111&quot;)def test_s2():  # 不传login    print(&quot;用例2：不需要登录，操作222&quot;)def test_s3(login):    print(&quot;用例3：登录之后其它动作333&quot;)if __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_fix.py&quot;])</code></pre><p>运行结果：</p><pre><code class="diff">============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0rootdir: E:\YOYO, inifile:collected 3 itemstest_fix.py 输入账号，密码先登录用例1：登录之后其它动作111.用例2：不需要登录，操作222.输入账号，密码先登录用例3：登录之后其它动作333.========================== 3 passed in 0.06 seconds ===========================</code></pre><p>2.如果@pytest.fixture()里面没有参数，那么默认scope&#x3D;”function”，也就是此时的级别的function，针对函数有效</p><h1 id="conftest-py配置"><a href="#conftest-py配置" class="headerlink" title="conftest.py配置"></a>conftest.py配置</h1><p>1.上面一个案例是在同一个.py文件中，多个用例调用一个登陆功能，如果有多个.py的文件都需要调用这个登陆功能的话，那就不能把登陆写到用例里面去了。<br>此时应该要有一个配置文件，单独管理一些预置的操作场景，pytest里面默认读取conftest.py里面的配置</p><p>conftest.py配置需要注意以下点：</p><ul><li>conftest.py配置脚本名称是固定的，不能改名称</li><li>conftest.py与运行的用例要在同一个pakage下，并且有__init__.py文件</li><li>不需要import导入 conftest.py，pytest用例会自动查找</li></ul><p>2.参考脚本代码设计如下</p><pre><code class="python">** 作者：上海-悠悠 QQ交流群：588402570**__init__.pyconftest.py    # coding:utf-8    import pytest    @pytest.fixture()    def login():        print(&quot;输入账号，密码先登录&quot;)test_fix1.py    # coding:utf-8    import pytest      def test_s1(login):        print(&quot;用例1：登录之后其它动作111&quot;)      def test_s2():  # 不传login        print(&quot;用例2：不需要登录，操作222&quot;)      def test_s3(login):        print(&quot;用例3：登录之后其它动作333&quot;)      if __name__ == &quot;__main__&quot;:        pytest.main([&quot;-s&quot;, &quot;test_fix1.py&quot;])test_fix2.py    # coding:utf-8    import pytest      def test_s4(login):        print(&quot;用例4：登录之后其它动作111&quot;)      def test_s5():  # 不传login        print(&quot;用例5：不需要登录，操作222&quot;)      if __name__ == &quot;__main__&quot;:        pytest.main([&quot;-s&quot;, &quot;test_fix2.py&quot;])</code></pre><p>3.单独运行test_fix1.py和test_fix2.py都能调用到login()方法，这样就能实现一些公共的操作可以单独拿出来了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;前面一篇讲到用例加setup和teardown可以实现在测试用例之前或之后加入一些操作，但这种是整个脚本全局生效的，如果我想实现以下场景：&lt;br&gt;用例1需要先登录，用例2不需要登录，用例3需要先登录。很显然这就无法用setup和teardown来实现了。</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档51-内置fixture之cache使用</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A351-%E5%86%85%E7%BD%AEfixture%E4%B9%8Bcache%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A351-%E5%86%85%E7%BD%AEfixture%E4%B9%8Bcache%E4%BD%BF%E7%94%A8/</id>
    <published>2022-05-15T15:58:57.777Z</published>
    <updated>2022-05-15T20:03:32.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 运行完用例之后会生成一个 .pytest_cache 的缓存文件夹，用于记录用例的ids和上一次失败的用例。<br>方便我们在运行用例的时候加上–lf 和 –ff 参数，快速运行上一次失败的用例。<br>–lf, –last-failed 只重新运行上次运行失败的用例（或如果没有失败的话会全部跑）<br>–ff, –failed-first 运行所有测试，但首先运行上次运行失败的测试（这可能会重新测试，从而导致重复的fixture setup&#x2F;teardown）<br>–lf 和 –ff 相关介绍查看之前的这篇<a href="https://www.cnblogs.com/yoyoketang/p/9769559.html">https://www.cnblogs.com/yoyoketang/p/9769559.html</a></p><h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><p><code>pytest -h</code> 查看命令行参数，关于 cache 参数的使用方式</p><pre><code class="vhdl">&gt;pytest -h--lf, --last-failed   rerun only the tests that failed at the last run (or                        all if none failed)--ff, --failed-first  run all tests but run the last failures first. This                        may re-order tests and thus lead to repeated fixture--nf, --new-first     run tests from new files first, then the rest of the                        tests sorted by file mtime--cache-show=[CACHESHOW]                        show cache contents, don&#39;t perform collection or                        tests. Optional argument: glob (default: &#39;*&#39;).--cache-clear         remove all cache contents at start of test run.</code></pre><p>参数说明：</p><ul><li>–lf 也可以使用 <code>--last-failed</code> 仅运行上一次失败的用例</li><li>–ff 也可以使用 <code>--failed-first</code> 运行全部的用例，但是上一次失败的用例先运行</li><li>–nf 也可以使用 <code>--new-first</code> 根据文件插件的时间，新的测试用例会先运行</li><li>–cache-show&#x3D;[CACHESHOW] 显示.pytest_cache文件内容，不会收集用例也不会测试用例，选项参数: glob (默认: ‘*’)</li><li>–cache-clear 测试之前先清空.pytest_cache文件</li></ul><h1 id="–cache-show"><a href="#–cache-show" class="headerlink" title="–cache-show"></a>–cache-show</h1><p>测试案例代码test_x.py</p><pre><code class="armasm"># test_x.py# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/def test_01():    a = &quot;hello&quot;    b = &quot;hello&quot;    assert a == bdef test_02():    a = &quot;hello&quot;    b = &quot;hello world&quot;    assert a == bdef test_03():    a = &quot;hello&quot;    b = &quot;hello world&quot;    assert a in bdef test_04():    a = &quot;hello&quot;    b = &quot;hello world&quot;    assert a not in b</code></pre><p>命令行输入 运行完成后，会有2个用例失败，2个用例成功</p><pre><code class="diff">&gt;pytest test_x.py --tb=no============================= test session starts =============================collected 4 itemstest_x.py .F.F                                                           [100%]===================== 2 failed, 2 passed in 0.11 seconds ======================</code></pre><p>运行完成后，会在当前的目录生成一个 <code>.pytest_cache</code> 的缓存文件夹,层级结构如下<br><img src="/assets/2/image-20220516013951-vgcsno0.png" alt="image.png"></p><p>lastfailed 文件记录上一次运行失败的用例</p><pre><code class="json">&#123;  &quot;test_x.py::test_02&quot;: true,  &quot;test_x.py::test_04&quot;: true&#125;</code></pre><p>nodeids 文件记录所有用例的节点</p><pre><code class="bash">[  &quot;test_x.py::test_01&quot;,  &quot;test_x.py::test_02&quot;,  &quot;test_x.py::test_03&quot;,  &quot;test_x.py::test_04&quot;]</code></pre><p>于是可以通过 pytest –cache-show 命令查看cache目录</p><pre><code class="rust">D:\soft\kecheng202004\xuexi&gt;pytest --cache-show============================= test session starts =============================cachedir: \.pytest_cache---------------------------- cache values for &#39;*&#39; -----------------------------cache\lastfailed contains:  &#123;&#39;test_x.py::test_02&#39;: True, &#39;test_x.py::test_04&#39;: True&#125;cache\nodeids contains:  [&#39;test_x.py::test_01&#39;,   &#39;test_x.py::test_02&#39;,   &#39;test_x.py::test_03&#39;,   &#39;test_x.py::test_04&#39;]cache\stepwise contains:  []======================== no tests ran in 0.02 seconds =========================</code></pre><h1 id="–cache-clear"><a href="#–cache-clear" class="headerlink" title="–cache-clear"></a>–cache-clear</h1><p>–cache-clear 用于在测试用例开始之前清空cache的内容</p><blockquote><p>pytest –cache-clear</p></blockquote><p>查看pytest关于cache的更多文档 <a href="https://docs.pytest.org/en/latest/cache.html">https://docs.pytest.org/en/latest/cache.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;pytest 运行完用例之后会生成一个 .pytest_cache 的缓存文件夹，用于记录用例的ids和上一次失败的用例。&lt;br&gt;方便我们在</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档67-pytest.mark.parametrize 中使用 fixture</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A367-pytest.mark.parametrize%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20fixture/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A367-pytest.mark.parametrize%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20fixture/</id>
    <published>2022-05-15T15:58:57.773Z</published>
    <updated>2022-05-15T20:04:57.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>测试用例参数化的时候，使用 pytest.mark.parametrize 参数化传测试数据，如果我们想引用前面不同fixture返回的数据当测试用例的入参。<br>可以用fixture 参数化 prams 来间接解决这个问题</p><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>我们需要在测试用例里面参数化，参数化的数据来源于前面不同fixture的返回值，示例</p><pre><code class="python">import pytest@pytest.fixturedef a():    return &#39;a&#39;@pytest.fixturedef b():    return &#39;b&#39;@pytest.mark.parametrize(&#39;arg&#39;, [a, b])def test_foo(arg):    assert len(arg) == 1</code></pre><p>这时候运行会报错</p><pre><code class="python">..\test_xx.py Farg = &lt;function a at 0x000001C7E77CE7B8&gt;    @pytest.mark.parametrize(&#39;arg&#39;, [a, b])    def test_foo(arg):&gt;       assert len(arg) == 1E       TypeError: object of type &#39;function&#39; has no len()\test_xx.py:16: TypeErrorFarg = &lt;function b at 0x000001C7E77CE8C8&gt;    @pytest.mark.parametrize(&#39;arg&#39;, [a, b])    def test_foo(arg):&gt;       assert len(arg) == 1E       TypeError: object of type &#39;function&#39; has no len()\test_xx.py:16: TypeError</code></pre><p>关于此问题的讨论可以看github 上的issue <a href="https://github.com/pytest-dev/pytest/issues/349">Using fixtures in pytest.mark.parametrize #349</a></p><h1 id="使用-fixture-参数化"><a href="#使用-fixture-参数化" class="headerlink" title="使用 fixture 参数化"></a>使用 fixture 参数化</h1><p>可以使用 fixture 的参数化来解决上面的问题，通过 request.getfixturevalue(“fixture name”) 方法来获取fixture的返回值<br>有些文档看到的是 request.getfuncargvalue 那是早期的版本，目前新版本改名换成了 request.getfixturevalue<br>getfixturevalue 的作用是获取 fixture 的返回值</p><pre><code class="python">import pytest# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/@pytest.fixturedef a():    return &#39;a&#39;@pytest.fixturedef b():    return &#39;b&#39;@pytest.fixture(params=[&#39;a&#39;, &#39;b&#39;])def arg(request):    return request.getfixturevalue(request.param)def test_foo(arg):    assert len(arg) == 1</code></pre><p>这样运行就不会有问题了</p><h1 id="实例场景"><a href="#实例场景" class="headerlink" title="实例场景"></a>实例场景</h1><p>web自动化的时候，想在 chrome 和 firefox 浏览器上测试同一功能的测试用例</p><pre><code class="python">import pytestfrom selenium import webdriver# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/@pytest.fixturedef chrome():    driver = webdriver.Chrome()    yield driver    driver.quit()@pytest.fixturedef firefox():    driver = webdriver.Firefox()    yield driver    driver.quit()@pytest.fixture(params=[&#39;chrome&#39;, &#39;firefox&#39;])def driver(request):    &#39;&#39;&#39;启动浏览器参数化&#39;&#39;&#39;    return request.getfixturevalue(request.param)def test_foo(driver):    &#39;&#39;&#39;测试用例&#39;&#39;&#39;    driver.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)</code></pre><p>这样就可以分别打开 chrome 和 fixfox 执行测试用例了<br>关于此问题的更多讨论可以看github 上的issue <a href="https://github.com/pytest-dev/pytest/issues/349">Using fixtures in pytest.mark.parametrize #349</a><br>还有另外一个解决方案，使用 pytest-lazy-fixture 插件解决 <a href="https://www.cnblogs.com/yoyoketang/p/14096749.html">https://www.cnblogs.com/yoyoketang/p/14096749.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;测试用例参数化的时候，使用 pytest.mark.parametrize 参数化传测试数据，如果我们想引用前面不同fixture返回的数据</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档06_fixture之yield实现teardown</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A306_fixture%E4%B9%8Byield%E5%AE%9E%E7%8E%B0teardown/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A306_fixture%E4%B9%8Byield%E5%AE%9E%E7%8E%B0teardown/</id>
    <published>2022-05-15T15:58:57.769Z</published>
    <updated>2022-05-15T19:57:32.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇讲到fixture通过scope参数控制setup级别，既然有setup作为用例之前前的操作，用例执行完之后那肯定也有teardown操作。<br>这里用到fixture的teardown操作并不是独立的函数，用yield关键字呼唤teardown操作</p><h1 id="scope-x3D-”module”"><a href="#scope-x3D-”module”" class="headerlink" title="scope&#x3D;”module”"></a>scope&#x3D;”module”</h1><p>1.fixture参数scope&#x3D;”module”，module作用是整个.py文件都会生效，用例调用时，参数写上函数名称就行</p><pre><code class="python"># 新建一个文件test_f1.py# coding:utf-8import pytest&#39;&#39;&#39;** 作者：上海-悠悠 QQ交流群：588402570**&#39;&#39;&#39;@pytest.fixture(scope=&quot;module&quot;)def open():    print(&quot;打开浏览器，并且打开百度首页&quot;)def test_s1(open):    print(&quot;用例1：搜索python-1&quot;)def test_s2(open):    print(&quot;用例2：搜索python-2&quot;)def test_s3(open):    print(&quot;用例3：搜索python-3&quot;)if __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_f1.py&quot;])</code></pre><p>运行结果：</p><pre><code class="diff">============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0rootdir: D:\, inifile:collected 3 items..\..\..\..\..\..\YOYO\test_f1.py 打开浏览器，并且打开百度首页用例1：搜索python-1.用例2：搜索python-2.用例3：搜索python-3.========================== 3 passed in 0.01 seconds ===========================</code></pre><p><strong>从结果看出，虽然test_s1,test_s2,test_s3三个地方都调用了open函数，但是它只会在第一个用例前执行一次</strong></p><p>2.如果test_s1不调用,test_s2（调用open）,test_s3不调用，运行顺序会是怎样的？</p><pre><code class="python"># 新建一个文件test_f1.py# coding:utf-8import pytest&#39;&#39;&#39;** 作者：上海-悠悠 QQ交流群：588402570**&#39;&#39;&#39;@pytest.fixture(scope=&quot;module&quot;)def open():    print(&quot;打开浏览器，并且打开百度首页&quot;)def test_s1():    print(&quot;用例1：搜索python-1&quot;)def test_s2(open):     print(&quot;用例2：搜索python-2&quot;)def test_s3():    print(&quot;用例3：搜索python-3&quot;)if __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_f1.py&quot;])</code></pre><p>运行结果：</p><pre><code class="diff">============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0rootdir: D:\, inifile:collected 3 items..\..\..\..\..\..\YOYO\test_f1.py 用例1：搜索python-1.打开浏览器，并且打开百度首页用例2：搜索python-2.用例3：搜索python-3.========================== 3 passed in 0.01 seconds ===========================</code></pre><p><strong>从结果看出，module级别的fixture在当前.py模块里，只会在用例（test_s2）第一次调用前执行一次</strong></p><h1 id="yield执行teardown"><a href="#yield执行teardown" class="headerlink" title="yield执行teardown"></a>yield执行teardown</h1><p>1.前面讲的是在用例前加前置条件，相当于setup,既然有setup那就有teardown,fixture里面的teardown用yield来唤醒teardown的执行</p><pre><code class="python"># 新建一个文件test_f1.py# coding:utf-8import pytest&#39;&#39;&#39;** 作者：上海-悠悠 QQ交流群：588402570**&#39;&#39;&#39;@pytest.fixture(scope=&quot;module&quot;)def open():    print(&quot;打开浏览器，并且打开百度首页&quot;)    yield    print(&quot;执行teardown!&quot;)    print(&quot;最后关闭浏览器&quot;)def test_s1(open):    print(&quot;用例1：搜索python-1&quot;)def test_s2(open):    print(&quot;用例2：搜索python-2&quot;)def test_s3(open):    print(&quot;用例3：搜索python-3&quot;)if __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_f1.py&quot;])</code></pre><p>运行结果：</p><pre><code class="diff">============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0rootdir: D:\, inifile:collected 3 items..\..\..\..\..\..\YOYO\test_f1.py 打开浏览器，并且打开百度首页用例1：搜索python-1.用例2：搜索python-2.用例3：搜索python-3.执行teardown!最后关闭浏览器========================== 3 passed in 0.01 seconds ===========================</code></pre><h1 id="yield遇到异常"><a href="#yield遇到异常" class="headerlink" title="yield遇到异常"></a>yield遇到异常</h1><p>1.如果其中一个用例出现异常，不影响yield后面的teardown执行,运行结果互不影响，并且全部用例执行完之后，yield呼唤teardown操作</p><pre><code class="python"># 新建一个文件test_f1.py# coding:utf-8import pytest&#39;&#39;&#39;** 作者：上海-悠悠 QQ交流群：588402570**&#39;&#39;&#39;@pytest.fixture(scope=&quot;module&quot;)def open():    print(&quot;打开浏览器，并且打开百度首页&quot;)    yield    print(&quot;执行teardown!&quot;)    print(&quot;最后关闭浏览器&quot;)def test_s1(open):    print(&quot;用例1：搜索python-1&quot;)    # 如果第一个用例异常了，不影响其他的用例执行    raise NameError  # 模拟异常def test_s2(open):    print(&quot;用例2：搜索python-2&quot;)def test_s3(open):    print(&quot;用例3：搜索python-3&quot;)if __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_f1.py&quot;])</code></pre><p>运行结果：</p><pre><code class="python">\YOYO\test_f1.py 打开浏览器，并且打开百度首页用例1：搜索python-1Fopen = None    def test_s1(open):        print(&quot;用例1：搜索python-1&quot;)          # 如果第一个用例异常了，不影响其他的用例执行&gt;       raise NameError  # 模拟异常E       NameErrorD:\YOYO\test_f1.py:16: NameError用例2：搜索python-2.用例3：搜索python-3.执行teardown!最后关闭浏览器</code></pre><p>2.如果在setup就异常了，那么是不会去执行yield后面的teardown内容了</p><p>3.yield也可以配合with语句使用，以下是官方文档给的案例</p><pre><code class="python"># 官方文档案例# content of test_yield2.pyimport smtplibimport pytest&#39;&#39;&#39;** 作者：上海-悠悠 QQ交流群：588402570**&#39;&#39;&#39;@pytest.fixture(scope=&quot;module&quot;)def smtp():    with smtplib.SMTP(&quot;smtp.gmail.com&quot;) as smtp:        yield smtp  # provide the fixture value</code></pre><h1 id="addfinalizer终结函数"><a href="#addfinalizer终结函数" class="headerlink" title="addfinalizer终结函数"></a>addfinalizer终结函数</h1><p>1.除了yield可以实现teardown,在request-context对象中注册addfinalizer方法也可以实现终结函数。</p><pre><code class="python"># 官方案例# content of conftest.pyimport smtplibimport pytest@pytest.fixture(scope=&quot;module&quot;)def smtp_connection(request):    smtp_connection = smtplib.SMTP(&quot;smtp.gmail.com&quot;, 587, timeout=5)    def fin():        print(&quot;teardown smtp_connection&quot;)        smtp_connection.close()    request.addfinalizer(fin)    return smtp_connection  # provide the fixture value</code></pre><p>2.yield和addfinalizer方法都是在测试完成后呼叫相应的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇讲到fixture通过scope参数控制setup级别，既然有setup作为用例之前前的操作，用例执行完之后那肯定也有teardown</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档08_html报告报错截图+失败重跑</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A308_html%E6%8A%A5%E5%91%8A%E6%8A%A5%E9%94%99%E6%88%AA%E5%9B%BE+%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%B7%91/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A308_html%E6%8A%A5%E5%91%8A%E6%8A%A5%E9%94%99%E6%88%AA%E5%9B%BE+%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%B7%91/</id>
    <published>2022-05-15T15:58:57.763Z</published>
    <updated>2022-05-15T19:57:43.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做web自动化的小伙伴应该都希望在html报告中展示失败后的截图，提升报告的档次，pytest-html也可以生成带截图的报告。</p><h1 id="conftest-py"><a href="#conftest-py" class="headerlink" title="conftest.py"></a>conftest.py</h1><p>1.失败截图可以写到conftest.py文件里，这样用例运行时，只要检测到用例实例，就调用截图的方法，并且把截图存到html报告上</p><pre><code class="python"># conftest.py文件# coding:utf-8from selenium import webdriverimport pytestdriver = None@pytest.mark.hookwrapperdef pytest_runtest_makereport(item):    &quot;&quot;&quot;    当测试失败的时候，自动截图，展示到html报告中    ** 作者：上海-悠悠 QQ交流群：588402570**    :param item:    &quot;&quot;&quot;    pytest_html = item.config.pluginmanager.getplugin(&#39;html&#39;)    outcome = yield    report = outcome.get_result()    extra = getattr(report, &#39;extra&#39;, [])    if report.when == &#39;call&#39; or report.when == &quot;setup&quot;:        xfail = hasattr(report, &#39;wasxfail&#39;)        if (report.skipped and xfail) or (report.failed and not xfail):            file_name = report.nodeid.replace(&quot;::&quot;, &quot;_&quot;)+&quot;.png&quot;            screen_img = _capture_screenshot()            if file_name:                html = &#39;&lt;div&gt;&lt;img src=&quot;data:image/png;base64,%s&quot; alt=&quot;screenshot&quot; style=&quot;width:600px;height:300px;&quot; &#39; \                       &#39;onclick=&quot;window.open(this.src)&quot; align=&quot;right&quot;/&gt;&lt;/div&gt;&#39; % screen_img                extra.append(pytest_html.extras.html(html))        report.extra = extradef _capture_screenshot():    &#39;&#39;&#39;    ** 作者：上海-悠悠 QQ交流群：588402570**    截图保存为base64，展示到html中    :return:    &#39;&#39;&#39;    return driver.get_screenshot_as_base64()@pytest.fixture(scope=&#39;session&#39;, autouse=True)def browser(request):    global driver    if driver is None:        driver = webdriver.Firefox()    def end():        driver.quit()    request.addfinalizer(end)    return driver</code></pre><p>2.用例部分如下：</p><pre><code class="python"># test_01.py文件from selenium import webdriverimport time#** 作者：上海-悠悠 QQ交流群：588402570**def test_yoyo_01(browser):    browser.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)    time.sleep(2)    t = browser.title    assert t == &quot;上海-悠悠&quot;# test_02.py文件from selenium import webdriverimport time# ** 作者：上海-悠悠 QQ交流群：588402570**def test_yoyo_01(browser):    browser.get(&quot;https://www.cnblogs.com/yoyoketang/&quot;)    time.sleep(2)    t = browser.title    assert &quot;上海-悠悠&quot; in t</code></pre><h1 id="报告展示"><a href="#报告展示" class="headerlink" title="报告展示"></a>报告展示</h1><p>1.cmd打开，cd到用例的目录，执行指令</p><blockquote><p>$ pytest –html&#x3D;report.html –self-contained-html</p></blockquote><p><img src="/assets/2/image-20220516001612-m24nqsv.png" alt="image.png"></p><p>2.生成报告如下</p><p><img src="/assets/2/image-20220516001619-6ty9avx.png" alt="image.png"></p><h1 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h1><p>失败重跑需要依赖pytest-rerunfailures插件，使用pip安装就行</p><blockquote><p>$ pip install pytest-rerunfailures</p></blockquote><p><img src="/assets/2/image-20220516001626-5l8qcqf.png" alt="image.png"></p><p>用例失败再重跑1次,命令行加个参数–reruns就行了</p><blockquote><p>$ py.test –reruns 1 –html&#x3D;report.html –self-contained-html</p></blockquote><p><img src="/assets/2/image-20220516001644-nfycp7s.png" alt="image.png"></p><p>关于reruns参数的2个用法</p><pre><code class="sql">re-run failing tests to eliminate flaky failures:  --reruns=RERUNS       number of times to re-run failed tests. defaults to 0.  --reruns-delay=RERUNS_DELAY                        add time (seconds) delay between reruns.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;做web自动化的小伙伴应该都希望在html报告中展示失败后的截图，提升报告的档次，pytest-html也可以生成带截图的报告。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档50-命令行参数--durations统计用例运行时间</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A350-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--durations%E7%BB%9F%E8%AE%A1%E7%94%A8%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A350-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--durations%E7%BB%9F%E8%AE%A1%E7%94%A8%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/</id>
    <published>2022-05-15T15:58:57.759Z</published>
    <updated>2022-05-15T20:03:27.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写完一个项目的自动化用例之后，发现有些用例运行较慢，影响整体的用例运行速度，于是领导说找出运行慢的那几个用例优化下。<br><code>--durations</code> 参数可以统计出每个用例运行的时间，对用例的时间做个排序。</p><h1 id="–durations-x3D-N"><a href="#–durations-x3D-N" class="headerlink" title="–durations&#x3D;N"></a>–durations&#x3D;N</h1><p><code>pytest -h</code> 查看命令行参数，关于 <code>--durations=N</code> 参数的使用方式</p><pre><code class="bash">&gt;pytest -hreporting:  --durations=N         show N slowest setup/test durations (N=0 for all).</code></pre><p>当 N&#x3D;0 的时候显示全部用例的运行时间</p><h1 id="–durations-x3D-0"><a href="#–durations-x3D-0" class="headerlink" title="–durations&#x3D;0"></a>–durations&#x3D;0</h1><p>先写几个pytest的用例，在用例里面加sleep时间，这样方便看到每个用例运行的持续时间</p><pre><code class="python">import pytestimport time# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/@pytest.fixture()def set_up_fixture():    time.sleep(0.1)    yield    time.sleep(0.2)def test_01(set_up_fixture):    print(&quot;用例1&quot;)    time.sleep(1.0)def test_02(set_up_fixture):    print(&quot;用例2&quot;)    time.sleep(0.6)def test_03(set_up_fixture):    print(&quot;用例3&quot;)    time.sleep(1.2)def test_04(set_up_fixture):    print(&quot;用例4&quot;)    time.sleep(0.3)def test_05(set_up_fixture):    print(&quot;用例5&quot;)    time.sleep(2.3)</code></pre><p>当 N&#x3D;0 的时候显示全部用例的运行时间</p><pre><code class="php">&gt;pytest test_dur.py --durations=0 -v============================= test session starts =============================collected 5 itemstest_dur.py::test_01 PASSED                                              [ 20%]test_dur.py::test_02 PASSED                                              [ 40%]test_dur.py::test_03 PASSED                                              [ 60%]test_dur.py::test_04 PASSED                                              [ 80%]test_dur.py::test_05 PASSED                                              [100%]=========================== slowest test durations ============================2.30s call     test_dur.py::test_051.20s call     test_dur.py::test_031.00s call     test_dur.py::test_010.60s call     test_dur.py::test_020.30s call     test_dur.py::test_040.20s teardown test_dur.py::test_050.20s teardown test_dur.py::test_010.20s teardown test_dur.py::test_020.20s teardown test_dur.py::test_030.20s teardown test_dur.py::test_040.10s setup    test_dur.py::test_030.10s setup    test_dur.py::test_010.10s setup    test_dur.py::test_020.10s setup    test_dur.py::test_050.10s setup    test_dur.py::test_04========================== 5 passed in 7.05 seconds ===========================</code></pre><p>用例运行的时候会经历3个阶段：setup,call,teardown。call就是测试用例，setup和teardown就是用例的fixture部分。</p><h1 id="–durations-x3D-3"><a href="#–durations-x3D-3" class="headerlink" title="–durations&#x3D;3"></a>–durations&#x3D;3</h1><p>如果我们只需要筛选出运行时间最慢的3条用例，可以设置<code>--durations=3</code></p><pre><code class="php">&gt;pytest test_dur.py --durations=3 -v============================= test session starts =============================collected 5 itemstest_dur.py::test_01 PASSED                                              [ 20%]test_dur.py::test_02 PASSED                                              [ 40%]test_dur.py::test_03 PASSED                                              [ 60%]test_dur.py::test_04 PASSED                                              [ 80%]test_dur.py::test_05 PASSED                                              [100%]========================== slowest 3 test durations ===========================2.30s call     test_dur.py::test_051.20s call     test_dur.py::test_031.00s call     test_dur.py::test_01========================== 5 passed in 7.00 seconds ===========================</code></pre><p>这样就可以对运行慢的用例针对性优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;写完一个项目的自动化用例之后，发现有些用例运行较慢，影响整体的用例运行速度，于是领导说找出运行慢的那几个用例优化下。&lt;br&gt;&lt;code&gt;--</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档07_pytest-html生成html报告</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A307_pytest-html%E7%94%9F%E6%88%90html%E6%8A%A5%E5%91%8A/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A307_pytest-html%E7%94%9F%E6%88%90html%E6%8A%A5%E5%91%8A/</id>
    <published>2022-05-15T15:58:54.492Z</published>
    <updated>2022-05-15T19:57:38.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest-HTML是一个插件，pytest用于生成测试结果的HTML报告。兼容Python 2.7,3.6</p><h1 id="pytest-html"><a href="#pytest-html" class="headerlink" title="pytest-html"></a>pytest-html</h1><p>1.github上源码地址<a href="https://github.com/pytest-dev/pytest-html">【https://github.com/pytest-dev/pytest-html】</a></p><p>2.pip安装</p><blockquote><p>$ pip install pytest-html</p></blockquote><p><img src="/assets/2/image-20220516001356-6zs7ypp.png" alt="image.png"></p><p>3.执行方法</p><blockquote><p>$ pytest –html&#x3D;report.html</p></blockquote><h1 id="html报告"><a href="#html报告" class="headerlink" title="html报告"></a>html报告</h1><p>1.打开cmd，cd到需要执行pytest用例的目录，执行指令：pytest –html&#x3D;report.html</p><p><img src="/assets/2/image-20220516001403-jbuctku.png" alt="image.png"></p><p>2.执行完之后，在当前目录会生成一个report.html的报告文件，显示效果如下</p><p><img src="/assets/2/image-20220516001417-37ojnzw.png" alt="image.png"></p><h1 id="指定报告路径"><a href="#指定报告路径" class="headerlink" title="指定报告路径"></a>指定报告路径</h1><p>1.直接执行”pytest –html&#x3D;report.html”生成的报告会在当前脚本的同一路径，如果想指定报告的存放位置，放到当前脚本的同一目录下的report文件夹里</p><blockquote><p>pytest –html&#x3D;.&#x2F;report&#x2F;report.html</p></blockquote><p><img src="/assets/2/image-20220516001426-fulsp6s.png" alt="image.png"></p><p>2.如果想指定执行某个.py文件用例或者某个文件夹里面的所有用例，需加个参数。具体规则参考<a href="https://www.cnblogs.com/yoyoketang/p/9362415.html">【pytest文档2-用例运行规则】</a></p><p><img src="/assets/2/image-20220516001436-kdb1uuj.png" alt="image.png"></p><h1 id="报告独立显示"><a href="#报告独立显示" class="headerlink" title="报告独立显示"></a>报告独立显示</h1><p>1.上面方法生成的报告，css是独立的，分享报告的时候样式会丢失，为了更好的分享发邮件展示报告，可以把css样式合并到html里</p><blockquote><p>$ pytest –html&#x3D;report.html –self-contained-html</p></blockquote><h1 id="显示选项"><a href="#显示选项" class="headerlink" title="显示选项"></a>显示选项</h1><p>默认情况下，“ 结果”表中的所有行都将被展开，但具测试通过的行除外Passed。</p><p>可以使用查询参数自定义此行为：?collapsed&#x3D;Passed,XFailed,Skipped。</p><h1 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h1><p>1.更多功能查看官方文档<a href="https://github.com/pytest-dev/pytest-html">【https://github.com/pytest-dev/pytest-html】</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;pytest-HTML是一个插件，pytest用于生成测试结果的HTML报告。兼容Python 2.7,3.6&lt;/p&gt;
&lt;h1 id=&quot;py</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档60-pytest.main()的使用</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A360-pytest.main()%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A360-pytest.main()%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-05-15T15:58:54.486Z</published>
    <updated>2022-05-15T20:04:15.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 运行用例的时候，一般用命令行去执行，有些小伙伴不太习惯命令行运行用例，可能是之前深受 unittest 框架的影响，习惯在项目的根目录下写一个 run_all.py 的文件。<br>运行的时候，使用 python 运行 run_all.py 来执行测试用例。</p><h1 id="pytest-main"><a href="#pytest-main" class="headerlink" title="pytest.main()"></a>pytest.main()</h1><p>先看看 pytest.main() 的源码, main 函数的内容</p><ul><li>args 传一个list对象，list 里面是多个命令行的参数</li><li>plugins 传一个list对象，list 里面是初始化的时候需注册的插件</li></ul><pre><code class="python">def main(args=None, plugins=None):    &quot;&quot;&quot; return exit code, after performing an in-process test run.    :arg args: list of command line arguments.    :arg plugins: list of plugin objects to be auto-registered during                  initialization.    &quot;&quot;&quot;    from _pytest.main import EXIT_USAGEERROR    try:        try:            config = _prepareconfig(args, plugins)        except ConftestImportFailure as e:            exc_info = ExceptionInfo(e.excinfo)            tw = py.io.TerminalWriter(sys.stderr)            tw.line(                &quot;ImportError while loading conftest &#39;&#123;e.path&#125;&#39;.&quot;.format(e=e), red=True            )            exc_info.traceback = exc_info.traceback.filter(filter_traceback)            exc_repr = (                exc_info.getrepr(style=&quot;short&quot;, chain=False)                if exc_info.traceback                else exc_info.exconly()            )            formatted_tb = safe_str(exc_repr)            for line in formatted_tb.splitlines():                tw.line(line.rstrip(), red=True)            return 4        else:            try:                return config.hook.pytest_cmdline_main(config=config)            finally:                config._ensure_unconfigure()    except UsageError as e:        tw = py.io.TerminalWriter(sys.stderr)        for msg in e.args:            tw.line(&quot;ERROR: &#123;&#125;\n&quot;.format(msg), red=True)        return EXIT_USAGEERROR</code></pre><p>如果不带任何参数，那么执行的效果跟我们在 cmd 直接运行 pytest 命令一样，默认运行的是当前目录及子目录的所有文件夹的测试用例</p><pre><code class="markdown">&gt; pytest</code></pre><h1 id="run-all-py"><a href="#run-all-py" class="headerlink" title="run_all.py"></a>run_all.py</h1><p>在项目的根目录，新建一个 run_all.py 的文件</p><p><img src="/assets/2/image-20220516013052-n4ydf9k.png" alt="image.png"></p><p>只需写简单的2行代码</p><pre><code class="haskell">import pytest# 默认运行的是当前目录及子目录的所有文件夹的测试用例pytest.main()</code></pre><p>这样就能在 pycharm 里面右键运行，不带参数默认运行当前目录及子目录的所有文件夹的测试用例</p><h1 id="带参数运行"><a href="#带参数运行" class="headerlink" title="带参数运行"></a>带参数运行</h1><p>在运行的时候，也可以指定参数运行</p><p>-s： 显示程序中的 print&#x2F;logging 输出<br>-v: 丰富信息模式, 输出更详细的用例执行信息<br>-k： 运行包含某个字符串的测试用例。如：pytest -k add XX.py 表示运行 XX.py 中包含 add 的测试用例。<br>-q: 简单输出模式, 不输出环境信息<br>-x: 出现一条测试用例失败就退出测试。在调试阶段非常有用，当测试用例失败时，应该先调试通过，而不是继续执行测试用例。</p><p>在命令行运行带上 -s 参数</p><pre><code class="markdown">&gt; pytest -s</code></pre><p>那么在 pytest.main() 里面等价于</p><pre><code class="haskell">import pytest# 带上-s参数pytest.main([&quot;-s&quot;])</code></pre><p>在命令行运行带上多个参数时</p><pre><code class="markdown">&gt; pytest -s -x</code></pre><p>那么在 pytest.main() 里面等价于</p><pre><code class="haskell">import pytest# 带上-s -x参数pytest.main([&quot;-s&quot;, &quot;-x&quot;])</code></pre><h1 id="指定运行某个用例"><a href="#指定运行某个用例" class="headerlink" title="指定运行某个用例"></a>指定运行某个用例</h1><p>指定运行 cases&#x2F;module1 文件夹下的全部用例, 在命令行运行时, 先 cd 到项目的根目录</p><pre><code class="shell">&gt;pytest cases/module1</code></pre><p>那么在 pytest.main() 里面等价于</p><pre><code class="haskell">import pytest# 运行指定文件夹目录pytest.main([&quot;cases/module1&quot;])</code></pre><p>运行指定的 cases&#x2F;module1&#x2F;test_x1.py 下的全部用例,在命令行运行时, 先cd到项目的根目录</p><pre><code class="shell">&gt;pytest cases/module1/test_x1.py</code></pre><p>那么在 pytest.main() 里面等价于</p><pre><code class="haskell">import pytest# 运行指定py文件pytest.main([&quot;cases/module1/test_x1.py&quot;])</code></pre><p>运行指定的 cases&#x2F;module1&#x2F;test_x1.py 下的某一个用例 test_x, 在命令行运行时, 先cd到项目的根目录</p><pre><code class="shell">&gt;pytest cases/module1/test_x1.py::test_x</code></pre><p>那么在 pytest.main() 里面等价于</p><pre><code class="haskell">import pytest# 运行指定py文件下的test_xpytest.main([&quot;cases/module1/test_x1.py::test_x&quot;])</code></pre><p>通过上面跟命令行运行的对比，对 pytest.main() 的使用也就基本掌握了</p><h1 id="plugins参数的使用"><a href="#plugins参数的使用" class="headerlink" title="plugins参数的使用"></a>plugins参数的使用</h1><p>一般我们写插件的代码放到 conftest.py 会被pytest查找到，如果不是写到 conftest.py 的插件内容，可以通过 plugins 参数指定加载</p><pre><code class="python"># run_all.py import pytest# 在run_all.py下自定义插件class MyPlugin(object):    def pytest_sessionstart(self):        print(&quot;*** test run start blog地址 https://www.cnblogs.com/yoyoketang/&quot;)# plugins指定加载插件pytest.main([&quot;cases/module1&quot;], plugins=[MyPlugin()])</code></pre><p>运行后会看到在参数用例开始之前答应上面的内容</p><pre><code class="sql">*** test run start blog地址 https://www.cnblogs.com/yoyoketang/============================= test session starts =============================platform win32 -- Python 3.6.6, pytest-4.5.0, py-1.9.0, pluggy-0.13.1Test order randomisation NOT enabled. Enable with --random-order or --random-order-bucket=&lt;bucket_type&gt;rootdir: D:\wangyiyun\webplugins: repeat-0.8.0, rerunfailures-9.1, xdist-2.1.0collected 5 itemscases\module1\test_x1.py .                                               [ 20%]cases\module1\test_x2.py ....                                            [100%]========================== 5 passed in 0.05 seconds ===========================</code></pre><p>plugins参数的作用就是指定需加载的插件，也可以指定多个。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;pytest 运行用例的时候，一般用命令行去执行，有些小伙伴不太习惯命令行运行用例，可能是之前深受 unittest 框架的影响，习惯在项目</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档09_参数化parametrize</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A309_%E5%8F%82%E6%95%B0%E5%8C%96parametrize/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A309_%E5%8F%82%E6%95%B0%E5%8C%96parametrize/</id>
    <published>2022-05-15T15:58:54.482Z</published>
    <updated>2022-05-15T19:57:48.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest.mark.parametrize装饰器可以实现测试用例参数化。</p><h1 id="parametrizing"><a href="#parametrizing" class="headerlink" title="parametrizing"></a>parametrizing</h1><p>1.这里是一个实现检查一定的输入和期望输出测试功能的典型例子</p><pre><code class="python"># content of test_expectation.py# coding:utf-8import pytest@pytest.mark.parametrize(&quot;test_input,expected&quot;,                         [ (&quot;3+5&quot;, 8),                           (&quot;2+4&quot;, 6),                           (&quot;6 * 9&quot;, 42),                         ])def test_eval(test_input, expected):    assert eval(test_input) == expectedif __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_canshu1.py&quot;])</code></pre><p>运行结果</p><pre><code class="python">================================== FAILURES ===================================_____________________________ test_eval[6 * 9-42] _____________________________test_input = &#39;6 * 9&#39;, expected = 42    @pytest.mark.parametrize(&quot;test_input,expected&quot;,                             [ (&quot;3+5&quot;, 8),                               (&quot;2+4&quot;, 6),                               (&quot;6 * 9&quot;, 42),                             ])    def test_eval(test_input, expected):&gt;       assert eval(test_input) == expectedE       AssertionError: assert 54 == 42E        +  where 54 = eval(&#39;6 * 9&#39;)test_canshu1.py:11: AssertionError===================== 1 failed, 2 passed in 1.98 seconds ======================</code></pre><p>在这个例子中设计的，只有一条输入&#x2F;输出值的简单测试功能。和往常一样</p><p>函数的参数，你可以在运行结果看到在输入和输出值</p><p>2.它也可以标记单个测试实例在参数化，例如使用内置的mark.xfail</p><pre><code class="python"># content of test_expectation.pyimport pytest@pytest.mark.parametrize(&quot;test_input,expected&quot;, [                        (&quot;3+5&quot;, 8),                        (&quot;2+4&quot;, 6),                        pytest.param(&quot;6 * 9&quot;, 42, marks=pytest.mark.xfail),                        ])def test_eval(test_input, expected):    print(&quot;-------开始用例------&quot;)    assert eval(test_input) == expectedif __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_canshu1.py&quot;])</code></pre><p>运行结果：</p><pre><code class="lua">test_canshu1.py -------开始用例------.-------开始用例------.-------开始用例------x===================== 2 passed, 1 xfailed in 1.84 seconds =====================</code></pre><p>标记为失败的用例，预期结果是失败，实际运行也是失败，显示xfailed</p><h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><p>1.若要获得多个参数化参数的所有组合，可以堆叠参数化装饰器</p><pre><code class="python">import pytest@pytest.mark.parametrize(&quot;x&quot;, [0, 1])@pytest.mark.parametrize(&quot;y&quot;, [2, 3])def test_foo(x, y):    print(&quot;测试数据组合：x-&gt;%s, y-&gt;%s&quot; % (x, y))if __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_canshu1.py&quot;])</code></pre><p>运行结果</p><pre><code class="rust">test_canshu1.py 测试数据组合：x-&gt;0, y-&gt;2.测试数据组合：x-&gt;1, y-&gt;2.测试数据组合：x-&gt;0, y-&gt;3.测试数据组合：x-&gt;1, y-&gt;3.========================== 4 passed in 1.75 seconds ===========================</code></pre><p>这将运行测试，参数设置为x＝0／y＝2，x＝1／y＝2，x＝0／y＝3，x＝1／y＝3组合参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;pytest.mark.parametrize装饰器可以实现测试用例参数化。&lt;/p&gt;
&lt;h1 id=&quot;parametrizing&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档38-allure.step()添加测试用例步骤</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A338-allure.step()%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%AD%A5%E9%AA%A4/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A338-allure.step()%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-05-15T15:58:54.467Z</published>
    <updated>2022-05-15T20:02:33.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一般流程性的测试用例，写成自动化用例时，步骤较多写起来会比较长。在测试用例里面添加详细的步骤有助于更好的阅读，也方便报错后快速的定位到问题。<br>举个常见的测试场景用例：从登陆开始，到浏览商品添加购物车，最后下单支付<br>用例步骤：1.登陆， 2.浏览商品 3.添加购物车 4.生成订单 5.支付成功</p><h1 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h1><p>先把上面的每个环节，写成函数放到common_fucntion.py</p><pre><code class="python"># common_fucntion.pyimport allureimport pytest&#39;&#39;&#39;流程性的用例，添加测试步骤，让用例更清晰用例步骤：1.登陆， 2.浏览商品 3.添加购物车  4.生成订单  5.支付成功作者：上海-悠悠 QQ交流群：779429633&#39;&#39;&#39;def login(username, password):    &#39;&#39;&#39;登陆&#39;&#39;&#39;    print(&quot;前置操作：先登陆&quot;)def open_goods():    &#39;&#39;&#39;浏览商品&#39;&#39;&#39;    print(&quot;浏览商品&quot;)def add_shopping_cart(goods_id=&quot;10086&quot;):    &#39;&#39;&#39;添加购物车&#39;&#39;&#39;    print(&quot;添加购物车&quot;)def buy_goods():    &#39;&#39;&#39;生成订单&#39;&#39;&#39;    print(&quot;buy&quot;)def pay_goods():    &#39;&#39;&#39;支付&#39;&#39;&#39;    print(&quot;pay&quot;)  </code></pre><p>接下来测试用例设计，登陆可以单独拿出来，当成前置操作，后面的步骤合起来就是一个用例test_allure_step.py</p><pre><code class="python"># test_allure_step.pyimport allureimport pytestfrom .common_function import *&#39;&#39;&#39;流程性的用例，添加测试步骤，让用例更清晰用例步骤：1.登陆， 2.浏览商品 3.添加购物车  4.生成订单  5.支付成功作者：上海-悠悠 QQ交流群：779429633&#39;&#39;&#39;@pytest.fixture(scope=&quot;session&quot;)def login_setup():    login(&quot;yoyo&quot;, &quot;123456&quot;)@allure.feature(&quot;功能模块&quot;)@allure.story(&quot;测试用例小模块-成功案例&quot;)@allure.title(&quot;测试用例名称：流程性的用例，添加测试步骤&quot;)def test_add_goods_and_buy(login_setup):    &#39;&#39;&#39;    用例描述：    前置：登陆    用例步骤：1.浏览商品 2.添加购物车  3.购买  4.支付成功    &#39;&#39;&#39;    with allure.step(&quot;step1：浏览商品&quot;):        open_goods()    with allure.step(&quot;step2：添加购物车&quot;):        add_shopping_cart()    with allure.step(&quot;step3：生成订单&quot;):        buy_goods()    with allure.step(&quot;step4：支付&quot;):        pay_goods()    with allure.step(&quot;断言&quot;):        assert 1 == 1</code></pre><p>执行用例，生成allure报告</p><pre><code class="shell">&gt; pytest --alluredir ./allure_report test_allure_step.py&gt; allure serve ./allure_report</code></pre><p>报告展示效果如下</p><p><img src="/assets/2/image-20220516014937-e803vbq.png" alt="image.png"></p><h1 id="测试步骤-allure-step"><a href="#测试步骤-allure-step" class="headerlink" title="测试步骤@allure.step()"></a>测试步骤@allure.step()</h1><p>测试步骤也可以在 common_fucntion.py 里面定义的函数上加上装饰器实现：@allure.step()</p><pre><code class="python">import allureimport pytest&#39;&#39;&#39;流程性的用例，添加测试步骤，让用例更清晰用例步骤：1.登陆， 2.浏览商品 3.添加购物车  4.生成订单  5.支付成功&#39;&#39;&#39;@allure.step(&quot;setup:登陆&quot;)def login(username, password):    &#39;&#39;&#39;登陆&#39;&#39;&#39;    print(&quot;前置操作：先登陆&quot;)@allure.step(&quot;step:浏览商品&quot;)def open_goods():    &#39;&#39;&#39;浏览商品&#39;&#39;&#39;    print(&quot;浏览商品&quot;)@allure.step(&quot;step:添加购物车&quot;)def add_shopping_cart(goods_id=&quot;10086&quot;):    &#39;&#39;&#39;添加购物车&#39;&#39;&#39;    print(&quot;添加购物车&quot;)@allure.step(&quot;step:生成订单&quot;)def buy_goods():    &#39;&#39;&#39;生成订单&#39;&#39;&#39;    print(&quot;buy&quot;)@allure.step(&quot;step:支付&quot;)def pay_goods():    &#39;&#39;&#39;支付&#39;&#39;&#39;    print(&quot;pay&quot;)</code></pre><p>测试用例设计 test_allure_step_x.py</p><pre><code class="python">import allureimport pytestfrom .common_function import *# 作者：上海-悠悠 QQ交流群：779429633@pytest.fixture(scope=&quot;session&quot;)def login_setup():    login(&quot;yoyo&quot;, &quot;123456&quot;)@allure.feature(&quot;功能模块&quot;)@allure.story(&quot;测试用例小模块-成功案例&quot;)@allure.title(&quot;第二种实现方式：流程性的用例，添加测试步骤&quot;)def test_add_goods_and_buy_2(login_setup):    &#39;&#39;&#39;    用例描述：    前置：登陆    用例步骤：1.浏览商品 2.添加购物车  3.购买  4.支付成功    &#39;&#39;&#39;    open_goods()    add_shopping_cart(goods_id=&quot;10086&quot;)    buy_goods()    pay_goods()    assert 1 == 1</code></pre><p>执行用例，生成allure报告</p><pre><code class="shell">&gt; pytest --alluredir ./allure_report test_allure_step_x.py&gt; allure serve ./allure_report</code></pre><p>报告展示效果如下</p><p><img src="/assets/2/image-20220516014947-0tm5kff.png" alt="image.png"></p><h1 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a>两种方式对比</h1><p>使用 <code>with allure.step(&quot;step:步骤&quot;)</code> 这种方式代码可读性更好一点，但不会带上函数里面的传参和对应的值。<br>使用 <code>@allure.step(&quot;step:步骤&quot;)</code> 这种方式会带上函数的传参和对应的值。<br>这两种方式结合起来使用，才能更好的展示测试报告！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一般流程性的测试用例，写成自动化用例时，步骤较多写起来会比较长。在测试用例里面添加详细的步骤有助于更好的阅读，也方便报错后快速的定位到问题。</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档11-assert断言</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A311-assert%E6%96%AD%E8%A8%80/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A311-assert%E6%96%AD%E8%A8%80/</id>
    <published>2022-05-15T15:58:54.464Z</published>
    <updated>2022-05-15T19:57:59.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>断言是写自动化测试基本最重要的一步，一个用例没有断言，就失去了自动化测试的意义了。什么是断言呢？<br>简单来讲就是实际结果和期望结果去对比，符合预期那就测试pass，不符合预期那就测试 failed</p><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>pytest允许您使用标准Python断言来验证Python测试中的期望和值。例如，你可以写下</p><pre><code class="csharp"># content of test_assert1.pydef f():    return 3def test_function():    assert f() == 4</code></pre><p>断言f()函数的返回值，接下来会看到断言失败，因为返回的值是3，判断等于4，所以失败了</p><pre><code class="markdown">$ pytest test_assert1.py=========================== test session starts ============================platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.yrootdir: $REGENDOC_TMPDIR, inifile:collected 1 itemtest_assert1.py F [100%]================================= FAILURES =================================______________________________ test_function _______________________________def test_function():&gt; assert f() == 4E assert 3 == 4E + where 3 = f()test_assert1.py:5: AssertionError========================= 1 failed in 0.12 seconds =========================</code></pre><p>从报错信息可以看到断言失败原因：E assert 3 &#x3D;&#x3D; 4</p><h1 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h1><p>接下来再看一个案例，如果想在异常的时候，输出一些提示信息，这样报错后，就方便查看是什么原因了</p><pre><code class="ruby">def f():    return 3def test_function():    a = f()    assert a % 2 == 0, &quot;判断a为偶数，当前a的值为：%s&quot;%a</code></pre><p>运行结果</p><pre><code class="markdown">================================== FAILURES ===================================________________________________ test_function ________________________________    def test_function():          a = f()&gt;       assert a % 2 == 0, &quot;判断a为偶数，当前a的值为：%s&quot;%aE       AssertionError: 判断a为偶数，当前a的值为：3E       assert (3 % 2) == 0test_03.py:9: AssertionError========================== 1 failed in 0.18 seconds ===========================</code></pre><p>这样当断言失败的时候，会给出自己写的失败原因了E AssertionError: 判断a为偶数，当前a的值为：3</p><h1 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h1><p>为了写关于引发异常的断言，可以使用pytest.raises作为上下文管理器，如下</p><pre><code class="python"># content of test_assert1.pyimport pytestdef test_zero_division():    with pytest.raises(ZeroDivisionError):        1 / 0</code></pre><p>运行结果</p><pre><code class="yaml">============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0rootdir: D:\YOYO\canshuhua, inifile:plugins: metadata-1.7.0, html-1.19.0collected 1 itemtest_assert1.py.========================== 1 passed in 0.31 seconds ===========================</code></pre><p>如果我们要断言它抛的异常是不是预期的，比如执行：1&#x2F;0,预期结果是抛异常：ZeroDivisionError: division by zero，那我们要断言这个异常，通常是断言异常的type和value值了。<br>这里1&#x2F;0的异常类型是ZeroDivisionError，异常的value值是division by zero，于是用例可以这样设计</p><pre><code class="python"># content of test_assert1.py# ** 作者：上海-悠悠 QQ交流群：588402570**import pytestdef test_zero_division():    &#39;&#39;&#39;断言异常&#39;&#39;&#39;    with pytest.raises(ZeroDivisionError) as excinfo:        1 / 0    # 断言异常类型type    assert excinfo.type == ZeroDivisionError    # 断言异常value值    assert &quot;division by zero&quot; in str(excinfo.value)</code></pre><p><strong>excinfo 是一个异常信息实例，它是围绕实际引发的异常的包装器。主要属性是.type、 .value 和 .traceback</strong></p><p>注意：断言type的时候，异常类型是不需要加引号的，断言value值的时候需转str</p><p>在上下文管理器窗体中，可以使用关键字参数消息指定自定义失败消息：</p><pre><code class="python">with pytest.raises(ZeroDivisionError, message=&quot;Expecting ZeroDivisionError&quot;):    pass结果：Failed: Expecting ZeroDivisionError</code></pre><h1 id="常用断言"><a href="#常用断言" class="headerlink" title="常用断言"></a>常用断言</h1><p>pytest里面断言实际上就是python里面的assert断言方法，常用的有以下几种</p><ul><li>assert xx 判断xx为真</li><li>assert not xx 判断xx不为真</li><li>assert a in b 判断b包含a</li><li>assert a &#x3D;&#x3D; b 判断a等于b</li><li>assert a !&#x3D; b 判断a不等于b</li></ul><pre><code class="python">import pytest# ** 作者：上海-悠悠 QQ交流群：588402570**def is_true(a):    if a &gt; 0:        return True    else:        return Falsedef test_01():    &#39;&#39;&#39;断言xx为真&#39;&#39;&#39;    a = 5    b = -1    assert is_true(a)    assert not is_true(b)def test_02():    &#39;&#39;&#39;断言b 包含 a&#39;&#39;&#39;    a = &quot;hello&quot;    b = &quot;hello world&quot;    assert a in bdef test_03():    &#39;&#39;&#39;断言相等&#39;&#39;&#39;    a = &quot;yoyo&quot;    b = &quot;yoyo&quot;    assert a == bdef test_04():    &#39;&#39;&#39;断言不等于&#39;&#39;&#39;    a = 5    b = 6    assert a != bif __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_01.py&quot;])</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;断言是写自动化测试基本最重要的一步，一个用例没有断言，就失去了自动化测试的意义了。什么是断言呢？&lt;br&gt;简单来讲就是实际结果和期望结果去对比</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档02_用例运行规则</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A302_%E7%94%A8%E4%BE%8B%E8%BF%90%E8%A1%8C%E8%A7%84%E5%88%99/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A302_%E7%94%A8%E4%BE%8B%E8%BF%90%E8%A1%8C%E8%A7%84%E5%88%99/</id>
    <published>2022-05-15T15:58:54.458Z</published>
    <updated>2022-05-15T19:56:45.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用例设计原则"><a href="#用例设计原则" class="headerlink" title="用例设计原则"></a>用例设计原则</h1><ul><li>文件名以test_*.py文件和*_test.py</li><li>以test_开头的函数</li><li>以Test开头的类，test_开头的方法，并且不能带有__init__ 方法</li><li>所有的包pakege必须要有__init__.py文件</li><li>断言使用assert</li></ul><h1 id="help帮助"><a href="#help帮助" class="headerlink" title="help帮助"></a>help帮助</h1><p>1.查看pytest命令行参数，可以用pytest -h 或pytest –help查看</p><pre><code class="vhdl">C:\Users\admin&gt;pytest -husage: pytest [options] [file_or_dir] [file_or_dir] [...]positional arguments:  file_or_dirgeneral:  -k EXPRESSION         only run tests which match the given substring                        expression. An expression is a python evaluatable                        expression where all names are substring-matched                        against test names and their parent classes. Example:                        -k &#39;test_method or test_other&#39; matches all test                        functions and classes whose name contains                        &#39;test_method&#39; or &#39;test_other&#39;, while -k &#39;not                        test_method&#39; matches those that don&#39;t contain                        &#39;test_method&#39; in their names. Additionally keywords                        are matched to classes and functions containing extra                        names in their &#39;extra_keyword_matches&#39; set, as well as                        functions which have names assigned directly to them.  -m MARKEXPR           only run tests matching given mark expression.                        example: -m &#39;mark1 and not mark2&#39;.  --markers             show markers (builtin, plugin and per-project ones).  -x, --exitfirst       exit instantly on first error or failed testreporting:  -v, --verbose         increase verbosity.  -q, --quiet           decrease verbosity.  --verbosity=VERBOSE   set verbosity 只贴了一部分</code></pre><h1 id="按以下目录写用例"><a href="#按以下目录写用例" class="headerlink" title="按以下目录写用例"></a>按以下目录写用例</h1><pre><code class="python">D:YOYO\    __init__.py      test_class.py        #  content of  test_class.py          class TestClass:            def test_one(self):                x = &quot;this&quot;                assert &#39;h&#39; in x                  def test_two(self):                x = &quot;hello&quot;                assert hasattr(x, &#39;check&#39;)                          def test_three(self):                a = &quot;hello&quot;                b = &quot;hello world&quot;                assert a in b              test_sample.py        #  content of  test_sample.py        def func(x):            return x +1          def test_answer():            assert func(3)==5</code></pre><h1 id="python-m"><a href="#python-m" class="headerlink" title="python -m"></a>python -m</h1><p>cmd执行pytest用例有三种方法,以下三种方法都可以，一般推荐第一个</p><ul><li><blockquote><p>pytest</p></blockquote></li><li><blockquote><p>py.test</p></blockquote></li><li><blockquote><p>python -m pytest</p></blockquote></li></ul><p>如果不带参数，在某个文件夹下执行时，它会查找该文件夹下所有的符合条件的用例（查看用例设计原则）</p><h1 id="执行用例规则"><a href="#执行用例规则" class="headerlink" title="执行用例规则"></a>执行用例规则</h1><p>1.执行某个目录下所有的用例</p><blockquote><p>pytest 文件名&#x2F;</p></blockquote><p>2.执行某一个py文件下用例</p><blockquote><p>pytest 脚本名称.py</p></blockquote><p>3.-k 按关键字匹配</p><blockquote><p>pytest -k “MyClass and not method”</p></blockquote><p>这将运行包含与给定字符串表达式匹配的名称的测试，其中包括Python<br>使用文件名，类名和函数名作为变量的运算符。 上面的例子将运行<br>TestMyClass.test_something但不运行TestMyClass.test_method_simple</p><p>4.按节点运行</p><p>每个收集的测试都分配了一个唯一的nodeid，它由模块文件名和后跟说明符组成<br>来自参数化的类名，函数名和参数，由:: characters分隔。</p><p>运行.py模块里面的某个函数</p><blockquote><p>pytest test_mod.py::test_func</p></blockquote><p>运行.py模块里面,测试类里面的某个方法</p><blockquote><p>pytest test_mod.py::TestClass::test_method</p></blockquote><p>5.标记表达式</p><blockquote><p>pytest -m slow</p></blockquote><p>将运行用@ pytest.mark.slow装饰器修饰的所有测试。</p><p>6.从包里面运行</p><blockquote><p>pytest –pyargs pkg.testing</p></blockquote><p>这将导入pkg.testing并使用其文件系统位置来查找和运行测试。</p><h1 id="x-遇到错误时停止测试"><a href="#x-遇到错误时停止测试" class="headerlink" title="-x 遇到错误时停止测试"></a>-x 遇到错误时停止测试</h1><blockquote><p>pytest -x test_class.py</p></blockquote><p>从运行结果可以看出，本来有3个用例，第二个用例失败后就没继续往下执行了</p><pre><code class="markdown">D:\YOYO&gt;pytest -x test_class.py============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0rootdir: D:\YOYO, inifile:collected 3 itemstest_class.py .F================================== FAILURES ===================================_____________________________ TestClass.test_two ______________________________self = &lt;YOYO.test_class.TestClass object at 0x0000000003A29780&gt;    def test_two(self):        x = &quot;hello&quot;&gt;       assert hasattr(x, &#39;check&#39;)E       AssertionError: assert FalseE        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)test_class.py:11: AssertionError===================== 1 failed, 1 passed in 0.05 seconds ======================</code></pre><h1 id="–maxfail-x3D-num"><a href="#–maxfail-x3D-num" class="headerlink" title="–maxfail&#x3D;num"></a>–maxfail&#x3D;num</h1><blockquote><p>pytest –maxfail&#x3D;1</p></blockquote><p>当用例错误个数达到指定数量时，停止测试</p><pre><code class="markdown">D:\YOYO&gt;pytest --maxfail=1============================= test session starts =============================platform win32 -- Python 3.6.0, pytest-3.6.3, py-1.5.4, pluggy-0.6.0rootdir: D:\YOYO, inifile:collected 4 itemstest_class.py .F================================== FAILURES ===================================_____________________________ TestClass.test_two ______________________________self = &lt;YOYO.test_class.TestClass object at 0x0000000003A3D080&gt;    def test_two(self):        x = &quot;hello&quot;&gt;       assert hasattr(x, &#39;check&#39;)E       AssertionError: assert FalseE        +  where False = hasattr(&#39;hello&#39;, &#39;check&#39;)test_class.py:11: AssertionError===================== 1 failed, 1 passed in 0.06 seconds ======================</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用例设计原则&quot;&gt;&lt;a href=&quot;#用例设计原则&quot; class=&quot;headerlink&quot; title=&quot;用例设计原则&quot;&gt;&lt;/a&gt;用例设计原则&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;文件名以test_*.py文件和*_test.py&lt;/li&gt;
&lt;li&gt;以test_开头的函数&lt;/</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档77-parametrize 参数化跳过部分用例(pytest.param)</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A377-parametrize%20%E5%8F%82%E6%95%B0%E5%8C%96%E8%B7%B3%E8%BF%87%E9%83%A8%E5%88%86%E7%94%A8%E4%BE%8B(pytest.param)/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A377-parametrize%20%E5%8F%82%E6%95%B0%E5%8C%96%E8%B7%B3%E8%BF%87%E9%83%A8%E5%88%86%E7%94%A8%E4%BE%8B(pytest.param)/</id>
    <published>2022-05-15T15:58:54.455Z</published>
    <updated>2022-05-15T20:07:23.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>pytest 参数化的时候，希望能跳过部分测试用例，可以用 pytest.param 来实现。</p><h1 id="parametrize-参数化示例"><a href="#parametrize-参数化示例" class="headerlink" title="parametrize 参数化示例"></a>parametrize 参数化示例</h1><p>parametrize 参数化</p><pre><code class="python">import pytest@pytest.mark.parametrize(&#39;input1, input2, expected&#39;, [    [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;],    [&quot;1&quot;, &quot;2&quot;, &quot;12&quot;],    [2, 3, 5],    [1, 3, 4],    ])def test_foo(input1, input2, expected):    assert input1 + input2 == expected</code></pre><p>运行结果</p><pre><code class="x86asm">collected 4 items..\..\..\..\..\demo\demo\aaa\test_x.py ....total times: 0.13 seconds================ 4 passed in 0.14s ==================</code></pre><h1 id="pytest-param-跳过用例"><a href="#pytest-param-跳过用例" class="headerlink" title="pytest.param 跳过用例"></a>pytest.param 跳过用例</h1><p>如果想跳过其中部分用例，可以用 pytest.param()来实现，给参数化中单个用例加 marks 标记 skip。</p><pre><code class="python">import pytest@pytest.mark.parametrize(&#39;input1, input2, expected&#39;, [    [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;],    [&quot;1&quot;, &quot;2&quot;, &quot;12&quot;],    pytest.param(2, 3, 5, marks=pytest.mark.skip),    [1, 3, 4],    ])def test_foo(input1, input2, expected):    assert input1 + input2 == expected</code></pre><p>运行结果</p><pre><code class="x86asm">collected 4 items..\..\..\..\..\demo\demo\aaa\test_x.py ..sTest ignored..total times: 0.14 seconds============== 3 passed, 1 skipped in 0.14s ==============</code></pre><p>运行结果可以看出1个 skipped 了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;pytest 参数化的时候，希望能跳过部分测试用例，可以用 pytest.param 来实现。&lt;/p&gt;
&lt;h1 id=&quot;parametriz</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档13-allure2生成html报告(史上最详细)-已废弃，不用看了</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A313-allure2%E7%94%9F%E6%88%90html%E6%8A%A5%E5%91%8A(%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86)-%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%8C%E4%B8%8D%E7%94%A8%E7%9C%8B%E4%BA%86/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A313-allure2%E7%94%9F%E6%88%90html%E6%8A%A5%E5%91%8A(%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86)-%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%8C%E4%B8%8D%E7%94%A8%E7%9C%8B%E4%BA%86/</id>
    <published>2022-05-15T15:58:54.449Z</published>
    <updated>2022-05-15T20:00:35.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>allure是一个report框架,支持java的Junit&#x2F;testng等框架,当然也可以支持python的pytest框架，也可以集成到Jenkins上展示高大上的报告界面。</p><p>环境准备</p><ul><li>1.python3.6</li><li>2.windows环境</li><li>3.pycharm</li><li>4.pytest-allure-adaptor</li><li>5.allure2.7.0</li><li>6.java1.8</li></ul><p>** 作者：上海-悠悠 QQ交流群：588402570**</p><h1 id="pytest-allure-adaptor下载"><a href="#pytest-allure-adaptor下载" class="headerlink" title="pytest-allure-adaptor下载"></a>pytest-allure-adaptor下载</h1><p>pip安装pytest-allure-adaptor,<a href="https://github.com/allure-framework/allure-pytest">github地址https://github.com/allure-framework/allure-pytest</a></p><blockquote><p>pip3 install pytest-allure-adaptor</p></blockquote><h1 id="生成xml报告"><a href="#生成xml报告" class="headerlink" title="生成xml报告"></a>生成xml报告</h1><blockquote><p>pytest -s -q –alluredir report</p></blockquote><p>如果不指定路径，默认在当前目录下新建一个report目录，当然也可以指定路径</p><blockquote><p>pytest -s -q –alluredir 指定report路径</p></blockquote><p>执行完之后打开report文件夹,会自动生成xml格式的报告</p><h1 id="安装-Command-Tool"><a href="#安装-Command-Tool" class="headerlink" title="安装 Command Tool"></a>安装 Command Tool</h1><p>allure的版本目前有2个，从github上看，allure1不再被支持，请考虑使用allure2 <a href="https://github.com/allure-framework/allure2%E6%9B%BF%E4%BB%A3">https://github.com/allure-framework/allure2替代</a></p><p><img src="/assets/2/image-20220516002220-ya5d3ht.png" alt="image.png"></p><p><a href="https://github.com/allure-framework/allure2/releases">allure-commandline releases版本https://github.com/allure-framework/allure2/releases</a></p><p>下载最新的Download allure2.7.0版本</p><p><img src="/assets/2/image-20220516002228-mtxaqix.png" alt="image.png"></p><p>[下载Download allure2.7.0 地址：<a href="https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip">https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip</a>]<br>(<a href="https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip">https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/allure-2.7.0.zip</a>)</p><p>下载好之后，解压到运行pytest的目录下</p><p><img src="/assets/2/image-20220516002235-6dv34xv.png" alt="image.png"></p><p>打开\allure-2.7.0\bin文件夹，会看到allure.bat文件，讲此路径设置为系统环境变量path下，这样cmd任意目录都能执行了</p><p><img src="/assets/2/image-20220516002242-2kqqalh.png" alt="image.png"></p><p>比如我的路径：D:\YOYO\case\allure-2.7.0\bin</p><p><img src="/assets/2/image-20220516002249-m7hw61j.png" alt="image.png"></p><h1 id="运行allure2"><a href="#运行allure2" class="headerlink" title="运行allure2"></a>运行allure2</h1><p>前面pytest -s -q –alluredir 这一步已经生产了xml格式的报告，放到了report目录下，接着执行以下命令格式</p><blockquote><p>allure generate directory-with-results&#x2F; -o directory-with-report</p></blockquote><p><strong>directory-with-results是alluredir生成的xml目录，directory-with-report是最终生成html的目录</strong></p><p>allure.bat已经加到环境变量了，所以可以用相对路径去生成html报告</p><blockquote><p>allure generate report&#x2F; -o report&#x2F;html</p></blockquote><p>执行完之后目录结构如下：</p><p><img src="/assets/2/image-20220516002256-b37vhve.png" alt="image.png"></p><h1 id="打开报告"><a href="#打开报告" class="headerlink" title="打开报告"></a>打开报告</h1><p>直接找到report&#x2F;html打开index.html会显示一个空的报告，这里用pycharm去打开</p><p><img src="/assets/2/image-20220516002303-rl6grln.png" alt="image.png"></p><p>打开后报告展示</p><p><img src="/assets/2/image-20220516002310-rqr8rah.png" alt="image.png"></p><h1 id="依赖java环境"><a href="#依赖java环境" class="headerlink" title="依赖java环境"></a>依赖java环境</h1><p>之前用的jdk1.7版本，执行allure时候报错：Unsupported major.minor VERSION 51.0<br>由于allure2是java开发的，需要依赖java环境，解决办法：jdk版本用1.8就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;allure是一个report框架,支持java的Junit&amp;#x2F;testng等框架,当然也可以支持python的pytest框架，也</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档10_命令行传参</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A310_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A310_%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82/</id>
    <published>2022-05-15T15:58:54.445Z</published>
    <updated>2022-05-15T19:57:54.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>命令行参数是根据命令行选项将不同的值传递给测试函数，比如平常在cmd执行”pytest –html&#x3D;report.html”,这里面的”–html&#x3D;report.html“就是从命令行传入的参数<br>对应的参数名称是html，参数值是report.html</p><h1 id="conftest配置参数"><a href="#conftest配置参数" class="headerlink" title="conftest配置参数"></a>conftest配置参数</h1><p>1.首先需要在conftest.py添加命令行选项,命令行传入参数”–cmdopt“, 用例如果需要用到从命令行传入的参数，就调用cmdopt函数：</p><pre><code class="python"># content of conftest.pyimport pytestdef pytest_addoption(parser):    parser.addoption(        &quot;--cmdopt&quot;, action=&quot;store&quot;, default=&quot;type1&quot;, help=&quot;my option: type1 or type2&quot;    )@pytest.fixturedef cmdopt(request):    return request.config.getoption(&quot;--cmdopt&quot;)</code></pre><p>2.测试用例编写案例</p><pre><code class="python"># content of test_sample.pyimport pytestdef test_answer(cmdopt):    if cmdopt == &quot;type1&quot;:        print(&quot;first&quot;)    elif cmdopt == &quot;type2&quot;:        print(&quot;second&quot;)    assert 0  # to see what was printedif __name__ == &quot;__main__&quot;:    pytest.main([&quot;-s&quot;, &quot;test_case1.py&quot;])</code></pre><p>cmd打开，输入指令启动，也可以在pycharm里面右键执行上面代码</p><blockquote><p>$ pytest -s test_sample.py</p></blockquote><p>运行结果：</p><pre><code class="markdown">&gt;pytest -s============================= test session starts =============================test_sample.py firstF================================== FAILURES ===================================_________________________________ test_answer _________________________________cmdopt = &#39;type1&#39;    def test_answer(cmdopt):        if cmdopt == &quot;type1&quot;:            print(&quot;first&quot;)        elif cmdopt == &quot;type2&quot;:            print(&quot;second&quot;)&gt;       assert 0  # to see what was printedE       assert 0test_case1.py:8: AssertionError========================== 1 failed in 0.05 seconds ===========================</code></pre><h1 id="带参数启动"><a href="#带参数启动" class="headerlink" title="带参数启动"></a>带参数启动</h1><p>1.如果不带参数执行，那么传默认的default&#x3D;”type1”，接下来在命令行带上参数去执行</p><blockquote><p>$ pytest -s test_sample.py –cmdopt&#x3D;type2</p></blockquote><pre><code class="markdown">test_sample.py secondF================================== FAILURES ===================================_________________________________ test_answer _________________________________cmdopt = &#39;type2&#39;    def test_answer(cmdopt):        if cmdopt == &quot;type1&quot;:            print(&quot;first&quot;)        elif cmdopt == &quot;type2&quot;:            print(&quot;second&quot;)&gt;       assert 0  # to see what was printedE       assert 0test_case1.py:8: AssertionError========================== 1 failed in 0.05 seconds ===========================</code></pre><p>2.命令行传参数有两种写法，还有一种分成2个参数也可以的,参数和名称用空格隔开</p><blockquote><p>$ pytest -s test_case1.py –cmdopt type2</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;命令行参数是根据命令行选项将不同的值传递给测试函数，比如平常在cmd执行”pytest –html&amp;#x3D;report.html”,这里</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>pytest文档55-plugins插件开发</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A355-plugins%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04_pytest/pytest%E6%96%87%E6%A1%A355-plugins%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</id>
    <published>2022-05-15T15:58:54.431Z</published>
    <updated>2022-05-15T20:03:51.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面一篇已经学会了使用hook函数改变pytest运行的结果，代码写在conftest.py文件，实际上就是本地的插件了。<br>当有一天你公司的小伙伴觉得你写的还不错，或者更多的小伙伴想要你这个功能，于是你就想着放到github上，写成一个插件，方便小伙伴使用pip去安装。</p><h1 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h1><p>先新建一个工程，工程名称就是插件名称，一般以pytest-开头命名，目录结构如下</p><p><img src="/assets/2/image-20220516013721-oru1t3c.png" alt="image.png"></p><ul><li>setup.py 在安装python的相关模块和库时，我们一般使用<code>pip install 模块名</code>或者<code>python setup.py install</code>，前者是在线安装，会安装该包的相关依赖包；<br>后者是下载源码包然后在本地安装，不会安装该包的相关依赖包</li><li>README.rst README 文档，告诉用户如何使用你的插件，具体能实现什么功能</li><li>pytest_change_report.py 也就是之前conftest.py里面写的hook函数实现的功能</li><li>tests 用于测试本插件的相关功能，属于自测的内容</li><li>tests&#x2F;conftest.py 开启需要的插件pytester</li><li>tests&#x2F;test_change_report.py 测试插件的代码</li></ul><h1 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h1><p>在安装python的相关模块和库时，我们一般使用<code>pip install 模块名</code>或者<code>python setup.py install</code>，前者是在线安装，会安装该包的相关依赖包；<br>后者是下载源码包然后在本地安装，不会安装该包的相关依赖包.<br>setup.py 描述安装包相关的信息</p><pre><code class="python">from setuptools import setup&quot;&quot;&quot;The setup script.# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/&quot;&quot;&quot;setup(    name=&#39;pytest-change-report&#39;,    url=&#39;https://github.com/yoyoketang/pytest-change-report&#39;,    version=&#39;1.0&#39;,    author=&quot;yoyo&quot;,    author_email=&#39;283340479@qq.com&#39;,    description=&#39;turn . into √，turn F into x&#39;,    long_description=&#39;print result on terminal turn . into √，turn F into x using hook&#39;,    classifiers=[        &#39;Framework :: Pytest&#39;,        &#39;Programming Language :: Python&#39;,        &#39;Topic :: Software Development :: Testing&#39;,        &#39;Programming Language :: Python :: 3.6&#39;,    ],    license=&#39;proprietary&#39;,    py_modules=[&#39;pytest_change_report&#39;],    keywords=[        &#39;pytest&#39;, &#39;py.test&#39;, &#39;pytest-change-report&#39;,    ],    install_requires=[        &#39;pytest&#39;    ],    entry_points=&#123;        &#39;pytest11&#39;: [            &#39;change-report = pytest_change_report&#39;,        ]    &#125;)</code></pre><h1 id="pytest-change-report-py"><a href="#pytest-change-report-py" class="headerlink" title="pytest_change_report.py"></a>pytest_change_report.py</h1><p>插件的核心功能，也就是之前在conftest.py用hook函数实现的功能。<br>我们现在实现的功能:<br>1.把测试的结果.改成√，F改成x<br>2.命令行加个<code>--change</code>参数开关，默认不开启，当加上参数&#96;–change on·的时候才生效</p><pre><code class="python">import pytest# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/def pytest_addoption(parser):    parser.addoption(        &quot;--change&quot;,        action=&quot;store&quot;,        default=&quot;off&quot;,        help=&quot;&#39;Default &#39;off&#39; for change, option: on or off&quot;    )def pytest_report_teststatus(report, config):    &#39;&#39;&#39;turn . into √，turn F into x, turn E into 0&#39;&#39;&#39;    if config.getoption(&quot;--change&quot;) == &quot;on&quot;:        if report.when == &#39;call&#39; and report.failed:            return (report.outcome, &#39;x&#39;, &#39;failed&#39;)        if report.when == &#39;call&#39; and report.passed:            return (report.outcome, &#39;√&#39;, &#39;passed&#39;)</code></pre><h1 id="测试插件"><a href="#测试插件" class="headerlink" title="测试插件"></a>测试插件</h1><p>当插件功能实现完成后，需要在tests目录测试自己写的插件</p><p>tests&#x2F;conftest.py 文件开启pytester,专门用于测试插件的</p><pre><code class="python">&#39;&#39;&#39;pytester is needed for testing plgugins.&#39;&#39;&#39;pytest_plugins = [&#39;pytester&#39;]</code></pre><p>tests&#x2F;test_change_report.py 文件写测试用例</p><pre><code class="python">import pytest# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/def test_raw_report(testdir):    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;    # create a temporary pytest test file    testdir.makepyfile(        &quot;&quot;&quot;        def test_01():            a = &quot;hello&quot;            b = &quot;hello&quot;            assert a == b        def test_02():            a = &quot;hello&quot;            b = &quot;hello world&quot;            assert a == b         &quot;&quot;&quot;            )    # run all tests with pytest    result = testdir.runpytest()    # check that 1 test passed, 1 test failed.    result.assert_outcomes(passed=1, failed=1)    result.stdout.fnmatch_lines([&quot;*.F*&quot;, ])def test_change_on_report(testdir):    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;    # create a temporary pytest test file    testdir.makepyfile(        &quot;&quot;&quot;        def test_01():            a = &quot;hello&quot;            b = &quot;hello&quot;            assert a == b        def test_02():            a = &quot;hello&quot;            b = &quot;hello world&quot;            assert a == b         &quot;&quot;&quot;            )    # run all tests with pytest    result = testdir.runpytest(&quot;--change&quot;, &quot;on&quot;)    # check that 1 test passed, 1 test failed.    result.stdout.fnmatch_lines([&#39;*√x*&#39;, ])def test_change_off_report(testdir):    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;    # create a temporary pytest test file    testdir.makepyfile(        &quot;&quot;&quot;        def test_01():            a = &quot;hello&quot;            b = &quot;hello&quot;            assert a == b        def test_02():            a = &quot;hello&quot;            b = &quot;hello world&quot;            assert a == b         &quot;&quot;&quot;            )    # run all tests with pytest    result = testdir.runpytest(&quot;--change&quot;, &quot;off&quot;)    # check that 1 test passed, 1 test failed.    result.stdout.fnmatch_lines([&#39;*.F*&#39;, ])def test_change_default_report(testdir):    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;    # create a temporary pytest test file    testdir.makepyfile(        &quot;&quot;&quot;        def test_01():            a = &quot;hello&quot;            b = &quot;hello&quot;            assert a == b        def test_02():            a = &quot;hello&quot;            b = &quot;hello world&quot;            assert a == b         &quot;&quot;&quot;            )    # run all tests with pytest    result = testdir.runpytest(&quot;--change&quot;)    # check stderr pytest: error: argument --change: expected one argument    result.stderr.fnmatch_lines([&#39;*argument --change: expected one argument*&#39;, ])def test_verbose_report(testdir):    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;    # create a temporary pytest test file    testdir.makepyfile(        &quot;&quot;&quot;        def test_01():            a = &quot;hello&quot;            b = &quot;hello&quot;            assert a == b        def test_02():            a = &quot;hello&quot;            b = &quot;hello world&quot;            assert a == b         &quot;&quot;&quot;            )    # run all tests with pytest    result = testdir.runpytest(&quot;-v&quot;)    # check that 1 test passed, 1 test failed.    result.stdout.fnmatch_lines([&#39;*::test_01 PASSED*&#39;, &#39;*::test_02 FAILED*&#39;])def test_change_verbose_report(testdir):    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;    # create a temporary pytest test file    testdir.makepyfile(        &quot;&quot;&quot;        def test_01():            a = &quot;hello&quot;            b = &quot;hello&quot;            assert a == b        def test_02():            a = &quot;hello&quot;            b = &quot;hello world&quot;            assert a == b         &quot;&quot;&quot;            )    # run all tests with pytest    result = testdir.runpytest(&quot;--change&quot;, &quot;on&quot;, &quot;-v&quot;)    # check that 1 test passed, 1 test failed.    result.stdout.fnmatch_lines([&#39;*::test_01 passed*&#39;, &#39;*::test_02 failed*&#39;])def test_help(testdir):    &quot;&quot;&quot;Make sure that our plugin works.&quot;&quot;&quot;    # create a temporary pytest test file    testdir.makepyfile(        &quot;&quot;&quot;        def test_01():            a = &quot;hello&quot;            b = &quot;hello&quot;            assert a == b         &quot;&quot;&quot;            )    # run all tests with pytest    result = testdir.runpytest(&quot;--help&quot;)    # check --help    result.stdout.fnmatch_lines([&quot;*--change=*&quot;, ])</code></pre><h1 id="本地安装插件"><a href="#本地安装插件" class="headerlink" title="本地安装插件"></a>本地安装插件</h1><p>cd到插件的项目目录，使用pip安装</p><blockquote><p>pip install .</p></blockquote><pre><code class="powershell">&gt;pip install .Processing d:\soft\pytest-change-reportUsing legacy setup.py install for pytest-change-report, since package &#39;wheel&#39; is not installed.Installing collected packages: pytest-change-report  Attempting uninstall: pytest-change-report    Found existing installation: pytest-change-report 1.0    Uninstalling pytest-change-report-1.0:      Successfully uninstalled pytest-change-report-1.0    Running setup.py install for pytest-change-report ... doneSuccessfully installed pytest-change-report-1.0</code></pre><p>安装完成后，在cmd输入 pip show pytest-change-report就可以看到前面setup.py里面的描述内容</p><pre><code class="makefile">&gt;pip show pytest-change-reportName: pytest-change-reportVersion: 1.0Summary: turn . into √，turn F into xHome-page: https://github.com/yoyoketang/pytest-change-reportAuthor: yoyoAuthor-email: 283340479@qq.comLicense: proprietaryLocation: e:\python36\lib\site-packages\pytest_change_report-1.0-py3.6.eggRequires: pytestRequired-by:</code></pre><p>安装完成后，输入pytest测试tests&#x2F;test_change_report.py</p><pre><code class="diff">&gt;pytest============================= test session starts =============================collected 7 itemstests\test_change_report.py .......                                      [100%]========================== 7 passed in 0.89 seconds ===========================</code></pre><p>测试文件里面的用例全部通过</p><h1 id="README-rst"><a href="#README-rst" class="headerlink" title="README.rst"></a>README.rst</h1><p>最后需要写个 README.rst 使用教程文档，这样你写的插件就能被其它小伙伴学习和使用了。</p><pre><code class="csharp">==============pytest-change-report: pytest plugin==============**This pytest plugin turn . into √，turn F into x**Usage=====从github源码安装   pip install git+https://github.com/yoyoketang/pytest-change-report.git命令行运行示例   pytest --change ondemo====先写pytest用例test_demo.py    def test_01():        a = &quot;hello&quot;        b = &quot;hello&quot;        assert a == b    def test_02(login):        a = &quot;hello&quot;        b = &quot;hello world&quot;        assert a == b命令行执行pytest, 默认不会改变之前的报告内容    &gt;pytest test_demo.py    ============================= test session starts =============================    collected 2 items    test_demo.py .F                                                          [100%]    ================================== FAILURES ===================================    ___________________________________ test_02 ___________________________________        def test_02():            a = &quot;hello&quot;            b = &quot;hello world&quot;    &gt;       assert a == b    E       AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;    E         - hello    E         + hello world    test_demo.py:10: AssertionError    ===================== 1 failed, 1 passed in 0.11 seconds ======================加上 --change on 参数后运行    &gt;pytest test_demo.py --change on    ============================= test session starts =============================    collected 2 items    test_demo.py √x                                                          [100%]    ================================== FAILURES ===================================    ___________________________________ test_02 ___________________________________        def test_02():            a = &quot;hello&quot;            b = &quot;hello world&quot;    &gt;       assert a == b    E       AssertionError: assert &#39;hello&#39; == &#39;hello world&#39;    E         - hello    E         + hello world    test_demo.py:10: AssertionError    ===================== 1 failed, 1 passed in 0.08 seconds ======================pytest.ini==========可以添加到pytest.ini配置文件，这样默认就会带上--change参数      [pytest]      --change = on# 作者-上海悠悠 QQ交流群:717225969# blog地址 https://www.cnblogs.com/yoyoketang/</code></pre><h1 id="提交github"><a href="#提交github" class="headerlink" title="提交github"></a>提交github</h1><p>最后把插件代码提交到github仓库，方便下载<a href="https://github.com/yoyoketang/pytest-change-report">https://github.com/yoyoketang/pytest-change-report</a></p><p><img src="/assets/2/image-20220516013742-6wff5ee.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面一篇已经学会了使用hook函数改变pytest运行的结果，代码写在conftest.py文件，实际上就是本地的插件了。&lt;br&gt;当有一天你</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="04_pytest" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/04-pytest/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
