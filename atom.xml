<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>软件测试技术分享</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-15T07:58:29.601Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yulong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件测试的16种测试类型</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%8416%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%8416%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-05-15T07:56:11.599Z</published>
    <updated>2022-05-15T07:58:29.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件测试主要从以下16种类型进行测试："><a href="#软件测试主要从以下16种类型进行测试：" class="headerlink" title="软件测试主要从以下16种类型进行测试："></a>软件测试主要从以下16种类型进行测试：</h2><h3 id="一：功能测试（10个方面）"><a href="#一：功能测试（10个方面）" class="headerlink" title="一：功能测试（10个方面）"></a>一：功能测试（10个方面）</h3><p>　　菜单、工具栏、快捷键、下拉框、按钮、单选按钮、复选按钮、切换、链接、触发键</p><h3 id="二：界面测试"><a href="#二：界面测试" class="headerlink" title="二：界面测试"></a>二：界面测试</h3><pre><code>登陆界面、总界面、输入界面（增、删、改、查）、处理界面、输出界面、报表界面、提示界面</code></pre><h3 id="三：容错测试"><a href="#三：容错测试" class="headerlink" title="三：容错测试"></a>三：容错测试</h3><p>　　数据长度、数据类型、非法此操作</p><h3 id="四：接口测试"><a href="#四：接口测试" class="headerlink" title="四：接口测试"></a>四：接口测试</h3><p>　　接口测试也叫业务流程测试（包括功能模块之间、模块与模块之间、子系统之间）<br>　　内部接口：例如：导入、导出（通俗的讲是接口就是调用）<br>　　外部接口：</p><h3 id="五：性能测试（TPS吞吐量、响应速度、cpu占用率、内存占用率）"><a href="#五：性能测试（TPS吞吐量、响应速度、cpu占用率、内存占用率）" class="headerlink" title="五：性能测试（TPS吞吐量、响应速度、cpu占用率、内存占用率）"></a>五：性能测试（TPS吞吐量、响应速度、cpu占用率、内存占用率）</h3><p>　　平均吞吐量：单位时间内处理事务的个数<br>　　平均响应速度：做一个事务处理所用时间<br>　　例如：界面操作效率测试；报表输出及查询效率测试</p><h3 id="六：负载测试（压力测试、强度测试、容量测试）"><a href="#六：负载测试（压力测试、强度测试、容量测试）" class="headerlink" title="六：负载测试（压力测试、强度测试、容量测试）"></a>六：负载测试（压力测试、强度测试、容量测试）</h3><p>　　压力测试即就是大用户测试（针对B&#x2F;S而言）<br>　　容量测试即就是大数据量测试</p><h3 id="七：并发测试"><a href="#七：并发测试" class="headerlink" title="七：并发测试"></a>七：并发测试</h3><p>　　指多个用户在同一时间对同一条数据的删除或者修改等处理</p><h3 id="八：稳定性测试"><a href="#八：稳定性测试" class="headerlink" title="八：稳定性测试"></a>八：稳定性测试</h3><p>　　例如：1小时触发600条信息，那么8个、10个等发信息的条数测试</p><h3 id="九：恢复测试"><a href="#九：恢复测试" class="headerlink" title="九：恢复测试"></a>九：恢复测试</h3><p>　　突然断电（系统触发正常启动；数据包要在断电的地方继续进行处理）</p><h3 id="十：配置测试"><a href="#十：配置测试" class="headerlink" title="十：配置测试"></a>十：配置测试</h3><p>　　最低配置：<br>　　推荐配置：大多数用户所用的配置</p><h3 id="十一：安装测试"><a href="#十一：安装测试" class="headerlink" title="十一：安装测试"></a>十一：安装测试</h3><p>　　安装过程；卸载过程</p><h3 id="十二：文档测试"><a href="#十二：文档测试" class="headerlink" title="十二：文档测试"></a>十二：文档测试</h3><p>　　交给用户的文档。例如：系统帮助、用户使用手册、用户安装手册</p><h3 id="十三：可用性测试（纯粹靠经验）"><a href="#十三：可用性测试（纯粹靠经验）" class="headerlink" title="十三：可用性测试（纯粹靠经验）"></a>十三：可用性测试（纯粹靠经验）</h3><h3 id="十四：初始化测试"><a href="#十四：初始化测试" class="headerlink" title="十四：初始化测试"></a>十四：初始化测试</h3><p>　　是指系统刚刚安装完成后，在数据位空的情况下，如果被调用的模块为空，点击调用模块的时候，是否进行容错的测试。</p><h3 id="十五：数据完整性测试"><a href="#十五：数据完整性测试" class="headerlink" title="十五：数据完整性测试"></a>十五：数据完整性测试</h3><p>　　是指当主表的某一条件信息被删除后，和这一条相关的从表的信息都应该被删除。<br>　　如果某些数据的主键是由数据库本身而实现的，可以不用删除，如果有些主从表是由程序员写的代码而实现，则要进行数据完整性的测试。</p><h3 id="16种测试类型归类"><a href="#16种测试类型归类" class="headerlink" title="16种测试类型归类"></a>16种测试类型归类</h3><h4 id="1、此软件能做什么？"><a href="#1、此软件能做什么？" class="headerlink" title="1、此软件能做什么？"></a>1、此软件能做什么？</h4><p>　　针对数据进行”功能、接口、容错、界面、权限、初始化、数据完整性测试“</p><h4 id="2、软件做的怎么样？"><a href="#2、软件做的怎么样？" class="headerlink" title="2、软件做的怎么样？"></a>2、软件做的怎么样？</h4><p>　　性能、负载、恢复、稳定性、并发、系统安全</p><h4 id="3、软件在什么环境条件下做？"><a href="#3、软件在什么环境条件下做？" class="headerlink" title="3、软件在什么环境条件下做？"></a>3、软件在什么环境条件下做？</h4><p>　　配置、安装、文档、可用性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软件测试主要从以下16种类型进行测试：&quot;&gt;&lt;a href=&quot;#软件测试主要从以下16种类型进行测试：&quot; class=&quot;headerlink&quot; title=&quot;软件测试主要从以下16种类型进行测试：&quot;&gt;&lt;/a&gt;软件测试主要从以下16种类型进行测试：&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="01_第一章基础" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/"/>
    
    <category term="901_文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901-%E6%96%87%E4%BB%B6/"/>
    
    <category term="902_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901-%E6%96%87%E4%BB%B6/902-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/README/"/>
    <id>http://example.com/README/</id>
    <published>2022-05-15T07:36:01.938Z</published>
    <updated>2022-05-15T07:36:01.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="md"><a href="#md" class="headerlink" title="md"></a>md</h1><p>自己使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;md&quot;&gt;&lt;a href=&quot;#md&quot; class=&quot;headerlink&quot; title=&quot;md&quot;&gt;&lt;/a&gt;md&lt;/h1&gt;&lt;p&gt;自己使用&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UI自动化</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <published>2022-05-15T07:36:01.746Z</published>
    <updated>2022-05-15T07:36:01.746Z</updated>
    
    <content type="html"><![CDATA[<p>一、原理<br>1、什么是UI自动化测试<br>使用工具或者脚本对需要测试的软件的前端界面在预设的条件下和已经的测试数据下运行系统或者应用程序，并获取其前端页面显示的数据结果进行校验，评估得出测试结论。</p><p>2、UI自动化测试可用于哪里<br>基于测试渠道可分为：手机App、Pc web端、手机Web端等；</p><p>基于测试阶段可分为：冒烟测试、回归测试、生产验收、兼容性测试</p><p>3、为什么要使用UI自动化测试<br>（1）目前测试案例数量过多导致人工执行测试案例耗时过长，并且会出现无法执行完该执行的测试案例导致版本无法按预期上线；</p><p>（2）案例的步骤繁琐，场景复杂，制作测试数据的过程复杂，导致人工执行时间过长；</p><p>（3）需求简单，无前端功能开发的需求可以使用UI自动化进行测试并得出结论；</p><p>（4）可以帮助开发人员进行自测。</p><p>4、哪些测试可以执行UI自动化<br>（1）已经比较成熟的项目，暂无任何大的改动需求的项目；</p><p>（2）人工执行耗时长，流程繁琐的项目；</p><p>（3）单纯的数据校验，列表功能校验；</p><p>5、怎么执行自动化测试<br>（1）开发提测前自用，配置环境和工具，下载脚本执行，可通过测试报告查看执行情况和结果；</p><p>（2）冒烟测试中，测试在开发提测后执行，通过测试报告查看执行情况和测试结果；</p><p>（3）回归测试中，测试人员执行执行纳入回归测试的测试脚本并执行</p><p>（4）生产验收，UI自动化测试脚本可用于生产验收中，无须手动操作就可验证生产的情况。</p><p>6、UI自动化测试的利与弊<br>利处：快捷、方便、无须手工操作</p><p>弊端：脚本编写成本高、案例开发时间长、需要长期维护</p><p>二、总结<br>UI自动化应用于项目组的所负责的系统需求较多，测试案例数量也较多，测试场景复杂，测试数据制作复杂，并且有部分系统已经趋于成熟。</p><p>UI自动化测试其实是一门【水】很深的工作，因为UI自动化测试是需要根据前端页面元素，也就是HTML脚本来进行元素提取、操作、验证的测试流程，另外再加上项目的测试环境软件硬件的因素，在编写自动化测试脚本的时候需要考虑到很多的情况出现而要去判断当前页面出现的元素到底是什么情况，不然脚本的稳定性很不好，维护工作也会非常的高。另外在编写自动化脚本的时候，你会慢慢的熟悉你项目系统前端页面的代码，当下很多前端开发人员在制作新的项目前端页面时都会直接用现成的组件生成，这种HTML代码会使你开发脚本时难上加难，因为里面的标签命名根本就是乱来的。</p><p>三、自动化框架<br>搭建测试框架，框架目录解析</p><p><img src="/assets/2/image-20220510223500-pv7tycu.png" alt="image.png"></p><h2 id="config-配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini"><a href="#config-配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini" class="headerlink" title="config : 配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini"></a>config : 配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini</h2><p><strong>ini文件介绍</strong></p><p>以[section]开始</p><p>以[option&#x3D;value]结尾</p><p>备注以；开头</p><p>section不可重名</p><p><strong>yaml文件介绍</strong></p><p>以—开头，表明文件的开始</p><p>列表中的所有成员都开始于相同的缩进级别，并且使用一个“-”作为开头（一个横杠和一个空格）</p><p>一个字典是由一个简单的键：值的形式（这个冒号后面必须是一个空格）</p><p><strong>ini读取文件封装,yaml读取文件封装</strong></p><p><strong>configutil.py</strong></p><pre><code class="text">import configparserimport osimport yamlclass ReadIni():    def read_ini(file, section, option):        conf = configparser.ConfigParser()        conf.read(file)        res=conf.get(section, option)        print(res)        return resclass ReafYaml():    def read_yaml(file,key):        f=open(file,encoding=&#39;utf-8&#39;)        file_data =f.read()        res=yaml.load(file_data,Loader=yaml.FullLoader)        print(res.get(key))        return res.get(key)if __name__ == &#39;__main__&#39;:    current_path = os.path.dirname(os.path.realpath(__file__))    config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;    yaml_file = os.path.join(config_path, &#39;test.yaml&#39;)    ReafYaml.read_yaml(yaml_file, &#39;username&#39;)</code></pre><h2 id="data-数据文件，将测试用例参数化相关的文件放在这里，xlsx-csv-json"><a href="#data-数据文件，将测试用例参数化相关的文件放在这里，xlsx-csv-json" class="headerlink" title="data : 数据文件，将测试用例参数化相关的文件放在这里，xlsx,csv,json"></a>data : 数据文件，将测试用例参数化相关的文件放在这里，xlsx,csv,json</h2><h2 id="driver-：驱动文件"><a href="#driver-：驱动文件" class="headerlink" title="driver ：驱动文件"></a>driver ：驱动文件</h2><h2 id="log-：日志文件，如test-log-error-log"><a href="#log-：日志文件，如test-log-error-log" class="headerlink" title="log ：日志文件，如test log,error log"></a>log ：日志文件，如test log,error log</h2><h2 id="report-：测试报告"><a href="#report-：测试报告" class="headerlink" title="report ：测试报告"></a>report ：测试报告</h2><h2 id="test-：测试文件"><a href="#test-：测试文件" class="headerlink" title="test ：测试文件"></a>test ：测试文件</h2><p>case-测试用例</p><p><strong>test.py</strong></p><pre><code class="text">import unittestfrom selenium import webdriverfrom test.locators import *from utils.configutil import ReadIni,ReafYamlfrom test.page import *from utils.excelutil import *from selenium.webdriver.common.action_chains import ActionChainsimport yamlimport osfrom utils.logutil import *current_path = os.path.dirname(os.path.realpath(__file__))config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;ini_file = os.path.join(config_path, &#39;test.ini&#39;)ip = ReadIni.read_ini(ini_file, &#39;ip_address&#39;, &#39;ip&#39;)# print(ip)url = &#39;&#123;&#125;user/login?redirect=http%3A%2F%2Fmis-next.aunbox.ce%2FuserDetail&#39;.format(ip)excel_file = os.path.join(os.path.dirname(current_path) + os.sep + &quot;data&quot;, &#39;case.xlsx&#39;)username = ReadExcel.read_excel(excel_file,&#39;Sheet1&#39;,&#39;A&#39;)class LoginTest(unittest.TestCase):    def setUp(self):        self.driver = webdriver.Chrome()        self.driver.maximize_window()        self.driver.implicitly_wait(10)        self.driver.get(url)    def test_login(self):        Logger(&#39;C:\\Users\\Administrator\\PycharmProjects\\yunding\\log\\test.log&#39;,&#39;info&#39;).info(&#39;add project&#39;)        for user in username:            loginpage=LoginPage(self.driver)            loginpage.enter_username(user)            loginpage.enter_password()            loginpage.click_login_button()            self.assertEqual(&#39;超级管理员&#39;,loginpage.get_login_name())            quitlogin=self.driver.find_element_by_xpath(&#39;//*[@id=&quot;root&quot;]/section/section/header/div[2]/span&#39;)            ActionChains(self.driver).move_to_element(quitlogin).perform()            self.driver.find_element_by_class_name(&#39;ant-dropdown-menu-item&#39;).click()            self.driver.get(url)        # self.driver.find_element(*LoginLocators.username).send_keys(&quot;&#123;&#125;&quot;.format(user))        # self.driver.find_element(*LoginLocators.password).send_keys(&quot;&#123;&#125;&quot;.format(pad))        # self.driver.find_element(*LoginLocators.loginbutton).click()        # id=self.driver.find_element(*LoginLocators.loginname)        # self.assertEqual(&#39;超级管理员&#39;,id.text)    def tearDown(self):        self.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><p>common-测试相关的抽象通用代码</p><p>page-页面类</p><p>元素定位</p><p><strong>locators.py</strong></p><pre><code class="text">from selenium.webdriver.common.by import By# 页面元素class LoginLocators():    username=(By.ID,&#39;account&#39;)    password=(By.ID,&#39;password&#39;)    loginbutton=(By.CLASS_NAME,&#39;ant-btn&#39;)    loginname=(By.CLASS_NAME,&#39;userName___fQOhV&#39;)</code></pre><p>元素操作</p><p><strong>page.py</strong></p><pre><code class="text">from test.locators import *# 页面元素的操作class BasePage():    def __init__(self,driver):        self.driver = driverclass LoginPage(BasePage):    &#39;&#39;&#39;    用户登录页面元素的操作,,,到这里消失    &#39;&#39;&#39;    UserName = (By.XPATH,&#39;//*[@id=&quot;username&quot;]&#39;) #登录名    def enter_username(self,name):        ele = self.driver.find_element(*LoginLocators.username)        # ele.clear()        ele.send_keys(name)  #对用户名元素进行输入    def enter_password(self):        ele = self.driver.find_element(*LoginLocators.password)        ele.send_keys(&#39;123456&#39;) #输入密码    def click_login_button(self):        ele = self.driver.find_element(*LoginLocators.loginbutton)        ele.click()  #点击登录按钮    def get_login_name(self):        ele = self.driver.find_element(*LoginLocators.loginname)        return ele.text  #返回登录名</code></pre><h2 id="utils-：公共方法"><a href="#utils-：公共方法" class="headerlink" title="utils ：公共方法"></a>utils ：公共方法</h2><p>config的类</p><p>log的类</p><p><strong>logutil.py</strong></p><pre><code class="text">import loggingfrom logging import handlersclass Logger(object):    level_relations = &#123;        &#39;debug&#39;:logging.DEBUG,        &#39;info&#39;:logging.INFO,        &#39;warning&#39;:logging.WARNING,        &#39;error&#39;:logging.ERROR,        &#39;critical&#39;:logging.CRITICAL    &#125;    def __init__(self,fp=&#39;d:\\Project_Redmine_01\\log\\test.log&#39;,level=&#39;info&#39;):        self.level = self.level_relations.get(level)        self.logger = logging.getLogger(fp)        self.logger.setLevel(self.level)        formatter = logging.Formatter(&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;)        th = handlers.TimedRotatingFileHandler(fp)        th.setFormatter(formatter)        th.setLevel(self.level)        self.logger.addHandler(th)    def debug(self,msg):        self.logger.debug(msg)    def info(self,msg):        self.logger.info(msg)    def warning(self,msg):        self.logger.warning(msg)    def error(self,msg):        self.logger.error(msg)    def critical(self,msg):        self.logger.critical(msg)if __name__ == &#39;__main__&#39;:    log = Logger(&#39;abcd.log&#39;,&#39;debug&#39;)    log.info(&#39;this is info msg&#39;)    log.critical(&#39;this is critical msg&#39;)</code></pre><p>读，写excel的类</p><p><strong>excelutil.py</strong></p><pre><code class="text">import configparserimport osimport yamlclass ReadIni():    def read_ini(file, section, option):        conf = configparser.ConfigParser()        conf.read(file)        res=conf.get(section, option)        print(res)        return resclass ReafYaml():    def read_yaml(file,key):        f=open(file,encoding=&#39;utf-8&#39;)        file_data =f.read()        res=yaml.load(file_data,Loader=yaml.FullLoader)        print(res.get(key))        return res.get(key)if __name__ == &#39;__main__&#39;:    current_path = os.path.dirname(os.path.realpath(__file__))    config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;    yaml_file = os.path.join(config_path, &#39;test.yaml&#39;)    ReafYaml.read_yaml(yaml_file, &#39;username&#39;)</code></pre><p>生成报告的类</p><p><strong>run.py</strong></p><pre><code class="text">import osimport timeimport unittestimport HTMLTestRunnercurrent_path = os.path.dirname(os.path.realpath(__file__))# print(current_path)report_path = os.path.join(current_path,&#39;report&#39;)# print(report_path)case_path = os.path.join(current_path,&#39;test&#39;)# print(case_path)report_name = time.strftime(&#39;%Y%m%d%H%M%S&#39;,time.localtime((time.time())))testsuite = unittest.TestLoader().discover(case_path)filename = &quot;&#123;&#125;\\&#123;&#125;.html&quot;.format(report_path,report_name)f = open(filename,&#39;wb&#39;)runner = HTMLTestRunner.HTMLTestRunner(stream=f,title=&#39;report&#39;,description=&#39;this is a report&#39;)runner.run(testsuite)f.close()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、原理&lt;br&gt;1、什么是UI自动化测试&lt;br&gt;使用工具或者脚本对需要测试的软件的前端界面在预设的条件下和已经的测试数据下运行系统或者应用程序，并获取其前端页面显示的数据结果进行校验，评估得出测试结论。&lt;/p&gt;
&lt;p&gt;2、UI自动化测试可用于哪里&lt;br&gt;基于测试渠道可分为：</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
    <category term="课后" scheme="http://example.com/tags/%E8%AF%BE%E5%90%8E/"/>
    
  </entry>
  
  <entry>
    <title>python基础练习</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/10_python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/10_python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/</id>
    <published>2022-05-15T07:36:01.438Z</published>
    <updated>2022-05-15T07:36:01.438Z</updated>
    
    <content type="html"><![CDATA[<p>一. 数据类型</p><ol><li>数据类型实战<ol><li>示例1：存在一个变量number &#x3D;1 ，如果需要输出格式为“001”应如何实现？<ol start="4"><li><blockquote><p>number &#x3D;1<br>print(“03d” %number)</p></blockquote></li><li>上面的实例中，变量number的数据类型是数值型，如果需要格式化字符串输出，则需要使用%d,相当于使用%d替换number变量的真实值1,即如果表达式是”%d”%number,那么结果实际是输出1;而题目要求输出格式是001，则需要在1前面添加两个0，所以此时可以通过使用03d表示输出3位数值型;如果真实数值只有1位，则会在高位自动补0输出，所以结果可以得到001。</li><li>注意：<br> 此处有同学可能会想可不可直接使用pit(0O1)?若采用这种方式输出，终端会提示“不允许十进制<br> 整数前添加0：八进制整型文字前可以使用0作为前缀”。</li></ol></li><li>示例2：存在一个变量number1&#x3D;1.222222,如果需要保留两位小数应如何实现？<ol><li><blockquote><p>print (“8.2f”Snumber1)</p></blockquote></li><li>上面的示例与示例1类似，示例1主要是对整数的处理，示例2主要是对小数的处理。小数的格式化输出需要使用%f,结合示例1综合分析可知保留两位小数表示为%.2f。</li></ol></li><li>示例3：存在一个变量number2&#x3D;1,如果需要输出“%d1”应如何实现？<ol><li><blockquote><p>print(“%%d%d”%number2)</p></blockquote></li><li>示例3需要输出“%d”字符串，在字符串格式化输出中%d表示整型占位符，如果需要以字符串的形式输出，则需要在%d前面添加%进行转义。所以上述代码中%%d表示输出“%d”字符串，第二个%d表示number2的占位符，即可得到结果“%d1”。</li></ol></li></ol></li><li>字符串主流机制问题<ol><li>在Python中会出现字符串驻留(intern)的情况，这是由于CPython的优化产生的，即在某些情况下尝试使用现有的不可变对象，而不是每次都创建一个新对象，这些驻留的对象在内部使用类似字典的结构（驻留池）进行驻留。在被驻留之后，许多变量可能指向内存中的相同字符串对象，从而节省内存。简单来说，字符串驻留表示一种方法，能够实现仅仅存储一份相同而又不可变的字符串。字符串存储的非驻留机制与驻留机制如图1.1所示。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一. 数据类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据类型实战&lt;ol&gt;
&lt;li&gt;示例1：存在一个变量number &amp;#x3D;1 ，如果需要输出格式为“001”应如何实现？&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;number &amp;#x3D;1&lt;br&gt;pr</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="06_第六章自动化测试" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="999_自动化测试文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>APP自动化</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/09_APP%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/09_APP%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <published>2022-05-15T07:36:01.437Z</published>
    <updated>2022-05-15T07:36:01.437Z</updated>
    
    <content type="html"><![CDATA[<p>APP自动化</p><h2 id="什么是App自动化？为什么要做App自动化？"><a href="#什么是App自动化？为什么要做App自动化？" class="headerlink" title="什么是App自动化？为什么要做App自动化？"></a>什么是App自动化？为什么要做App自动化？</h2><p>App自动化是指给 Android或iOS上的软件应用程序做的自动化测试。<br><strong>手工测试和自动化测试的对比如下：</strong><br> <strong>手工测试优势：</strong> 不可替代、发现更多bug、包含了人的想象力与理解力。</p><blockquote><p>注意，不是所有功能都需要自动化。<br> <strong>自动化测试优势：</strong> 可重复、效率高，增加软件信任度。<br>执行自动化测试可以让测试同事有更多的精力来关注复杂场景，做更多更深层次的测试。</p></blockquote><h2 id="风险分析"><a href="#风险分析" class="headerlink" title="风险分析"></a><strong>风险分析</strong></h2><p><strong>自动化测试的主要风险分析如下：</strong><br>（1）测试用例覆盖率（覆盖率决定测试效率，选择合适用例，应约占功能用例集的20%~50%）<br>（2）测试结果准确度（准确度决定了测试有效性，应尽可能减少误报）。<br>（3）自动化代码维护（维护决定了成本，数据关键字驱动自动化框架，代码应尽可能优化和少改动）。<br>（4）版本开发和测试时间进度（当项目需求和功能较为稳定时，建议用自动化）。<br>（5）开发对控件元素增修改的程度（需开发人员尽可能地用name元素，并且和UI设计一致，修改变动程度不大，测试人员可根据提供的元素提前介入，开发自动化脚本）。<br>App源码权限控制，iOS上测试需要源码。实际测试只需SVN或者git下载权限，而不需要上传权限。防止改动SVN或者git 上的源码。</p><hr><h2 id="技术框架"><a href="#技术框架" class="headerlink" title="技术框架"></a><strong>技术框架</strong></h2><p><strong>1、自动化学习过程</strong><br>自动化测试环境的部署–&gt;自动化测试脚本开发能力—&gt;自动化测试框架研发—&gt;手机自动化持续集成<br><strong>2、andorid 系统架构图</strong><br><img src="/assets/1/image-20211205190326-wan8a0k.png" alt="image.png"><br><strong>3、手机自动化测试环境</strong><br>安装Appium–&gt;安装手机模拟器–&gt;安装selenium和appium的客户端–&gt;安装被测试app<br><strong>4、</strong> <strong>Appium 软件架构</strong><br><img src="/assets/1/image-20211205190332-te9euht.png" alt="image.png"><br>5、<strong>常用的定位技术和工具</strong><br><img src="/assets/1/image-20211205190339-t5x1z1g.png" alt="image.png"><br><strong>6、自动化测试脚本技术</strong><br><img src="/assets/1/image-20211205190345-dv6lxzo.png" alt="image.png"><br><strong>7、技术框架结构图</strong><br><img src="/assets/1/image-20211205190351-9b4ojeg.png" alt="image.png"></p><hr><h2 id="APP自动化测试流程"><a href="#APP自动化测试流程" class="headerlink" title="APP自动化测试流程"></a><strong>APP自动化测试流程</strong></h2><p><strong>1、环境的安装</strong><br><strong>1.1 环境的准备</strong></p><ul><li>jdk1.6以上</li><li>python2.7以上</li><li>android-sdk</li><li>Appium desktop 安装</li></ul><p><strong>1.2 jdk 安装</strong></p><ul><li>下载JDK后傻瓜式安装，<strong>注意：不要有中文路径和空格</strong></li><li><strong>配置环境变量：</strong></li></ul><p><strong>右击“我的电脑”–&gt;”属性”–&gt;”高级系统设置”–&gt;”高级”–&gt;”环境变量”</strong></p><ol><li>在系统变量里新建”JAVA_HOME”变量，变量值为：C:\Program Files\Java\jdk1.8.0_60（根据自己的jdk的安装路径填写）</li><li>在系统变量里新建”classpath”变量，变量值为：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar <strong>(注意最前面有一点)</strong></li><li>找到path变量（已存在不用新建）添加变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</li></ol><p><strong>1.3 python 安装</strong></p><ol><li><strong>傻瓜式安装</strong> ，</li><li><strong>配置环境变量</strong> ：电脑属性系统变量添加python根目录</li></ol><p><strong>1.4 安装Android的测试开发环境</strong></p><ol><li><strong>Android-SDK的安装：</strong> SDK manager.exe 双击打开下载<br><img src="/assets/1/image-20211205190359-2l4539b.png" alt="image.png"></li></ol><p><strong>2.android-sdk环境变量的配置</strong><br>具体操作步骤：</p><ul><li><strong>新建ANDROID_HOME</strong><br>路径为C:\Program Files (x86)\Android\android-sdk\</li><li><strong>在Path 变量中加入路径</strong><br>%ANDROID_HOME%\platform-tools 和 %ANDROID_HOME%\tools</li></ul><p><strong>3.检查adb 环境变量</strong><br><img src="/assets/1/image-20211205190406-lp0oe3n.png" alt="image.png"><br><strong>4.连接手机</strong><br>如果是真机，手机插上USB连接电脑，打开开发者模式，cmd输入adb devices<br>如果是模拟器，需要输入adb connect 127.0.0.1:62001或者52001连接，然后再输入adb devices<br><strong>Appium desktop 安装</strong><br>下载地址：<a href="https://github.com/appium/appium-desktop/releases/tag/v1.3.1">https://github.com/appium/appium-desktop/releases/tag/v1.3.1</a><br>傻瓜式安装 注意：一定要选择所有用户权限要不然用不了<strong>UiAutomator2</strong><br><strong>2、 API脚本</strong><br><strong>2.1 如何获取APP启动的AppPackage和AppActivity</strong></p><ol><li><strong>通过appt获取切换到aapt所在的目录，执行aapt dump</strong> （aapt是sdk自带的一个工具，在sdk\builds-tools\目录下）使用命令aapt dump badging “D:\ jinritoutiao_7500.apk”运行后的结果中以下两行分别是应用包名package和入口activity名称<br>package: name&#x3D;’ com.ss.android.article.news’<br>launchable-activity: name&#x3D;‘com.ss.android.article.news.activity.LaunchActivity’</li></ol><p>**2. 通过 adb shell am start **com.ss.android.article.news&#x2F;com.ss.android.article.news.activity.MainActivity<br>来判断启动的app 是否正确<br><strong>2.2 启动appium</strong><br><img src="/assets/1/image-20211205190411-bss5xmz.png" alt="image.png"><br><img src="/assets/1/image-20211205190416-w001ahq.png" alt="image.png"><br><strong>2.3 写脚本</strong><br> <strong>1.platformName：</strong> 这里是 android 的 apk<br> <strong>2.deviceName：</strong> 手机设备名称，通过 adb devices 查看<br> <strong>3.platformVersion：</strong> android 系统的版本号<br> <strong>4.appPackage：</strong> apk 包名<br> <strong>5.appActivity：</strong> apk 的 launcherActivity<br><img src="/assets/1/image-20211205190422-d8tyhef.png" alt="image.png"><br><strong>2.4生成测试报告</strong><br><img src="/assets/1/image-20211205190433-n8seppi.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;APP自动化&lt;/p&gt;
&lt;h2 id=&quot;什么是App自动化？为什么要做App自动化？&quot;&gt;&lt;a href=&quot;#什么是App自动化？为什么要做App自动化？&quot; class=&quot;headerlink&quot; title=&quot;什么是App自动化？为什么要做App自动化？&quot;&gt;&lt;/a&gt;什么是App</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="06_第六章自动化测试" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="999_自动化测试文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>selenium</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_selenium/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/03_selenium/</id>
    <published>2022-05-15T07:36:01.428Z</published>
    <updated>2022-05-15T07:36:01.428Z</updated>
    
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="06_第六章自动化测试" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="999_自动化测试文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Puppeteer</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_Puppeteer/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/04_Puppeteer/</id>
    <published>2022-05-15T07:36:01.428Z</published>
    <updated>2022-05-15T07:36:01.428Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>python系列</p><ul><li><p><a href="">python基础</a></p></li><li><p><a href="">UI自动化</a></p><ul><li><p><a href="">Selenium</a></p></li><li><p><a href="">Puppeteer</a></p></li><li><p><a href="">Playwright</a></p><ul><li><a href="">“【PlayWright教程（一）】核心概念”</a></li><li><a href="">“PlayWright教程（二）】基础操作汇总”</a></li></ul></li></ul></li><li><p><a href="">接口自动化</a></p></li><li><p><a href="">APP自动化</a></p></li></ul></li><li><p>自动化平台</p><ul><li><strong>Phoenix Framework</strong></li><li><strong>metersphere</strong>       </li><li><strong>PhoenixPlatform</strong></li><li><strong>LuckyFrameWeb</strong></li><li><strong>Automagica</strong></li><li><strong>phoenixframe</strong></li><li><strong>TestMP</strong></li><li><strong>sosotest</strong></li><li><strong>EasyTest</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;python系列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;python基础&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;UI自动化&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;Selenium&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="06_第六章自动化测试" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="999_自动化测试文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Playwright</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_Playwright/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/05_Playwright/</id>
    <published>2022-05-15T07:36:01.428Z</published>
    <updated>2022-05-15T07:36:01.428Z</updated>
    
    <content type="html"><![CDATA[<p>Playwright是由微软公司2020年初发布的新一代自动化测试工具，相较于目前最常用的Selenium，本文就详细的介绍一下快速上手指南，对新手有一定的帮助，感兴趣的可以了解一下<br><a href="https://playwright.bootcss.com/docs/installation" title="Installation | Playwright 中文文档 | Playwright 中文网">Installation | Playwright 中文文档 | Playwright 中文网</a></p><h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ul><li><ol><li>为什么选择Playwright</li></ol><ul><li>1.1 Playwright的优势</li><li>1.2 已知局限性</li></ul></li><li><ol start="2"><li>Playwright使用</li></ol></li><li>2.1 安装</li><li>2.2 自动录制</li><li>2.3 定制化编写</li><li>2.4 网络拦截（Mock接口），示例如下：</li><li>2.6 异步执行，示例如下：</li><li>2.7 Pytest结合，示例如下：</li><li>2.8 移动端操作，示例如下：</li><li><ol start="3"><li>总结<br>Playwright是由微软公司2020年初发布的新一代自动化测试工具，相较于目前最常用的Selenium，它仅用一个API即可自动执行Chromium、Firefox、WebKit等主流浏览器自动化操作。作为针对 Python 语言纯自动化的工具，在回归测试中可更快的实现自动化。<h2 id="1-为什么选择Playwright"><a href="#1-为什么选择Playwright" class="headerlink" title="1. 为什么选择Playwright"></a>1. 为什么选择Playwright</h2><h3 id="1-1-Playwright的优势"><a href="#1-1-Playwright的优势" class="headerlink" title="1.1 Playwright的优势"></a>1.1 Playwright的优势</h3>（1） Selenium需要通过WebDriver操作浏览器；Playwright通过开发者工具与浏览器交互，安装简洁，不需要安装各种Driver。<br>（2） Playwright几乎支持所有语言，且不依赖于各种Driver，通过调用内置浏览器所以启动速度更快。<br>（3） Selenium基于HTTP协议（单向通讯），Playwright基于Websocket（双向通讯）可自动获取浏览器实际情况。<br>（4） Playwright为自动等待。</li></ol></li><li>等待元素出现（定位元素时，自动等待30s，等待时间可以自定义，单位毫秒）</li><li>等待事件发生<h3 id="1-2-已知局限性"><a href="#1-2-已知局限性" class="headerlink" title="1.2 已知局限性"></a>1.2 已知局限性</h3>（1） Playwright不支持旧版Microsoft Edge或IE11。支持新的Microsoft Edge（在Chromium上）；所以对浏览器版本有硬性要求的项目不适用。<br>（2） 需要SSL证书进行访问的网站可能无法录制，该过程需要单独定位编写。<br>（3） 移动端测试是通过桌面浏览器来模拟移动设备（相当于自带模拟器），无法控制真机。<h2 id="2-Playwright使用"><a href="#2-Playwright使用" class="headerlink" title="2. Playwright使用"></a>2. Playwright使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3>（1）安装Playwright依赖库（Playwright支持Async\Await语法，故需要Python3.7+）<table><thead><tr><th>1</th><th><code>pip install playwright</code></th></tr></thead></table></li></ul><p>（2）安装Chromium、Firefox、WebKit等浏览器的驱动文件（内置浏览器）</p><table><thead><tr><th>1</th><th><code>python ``-``m playwright install</code></th></tr></thead></table><h3 id="2-2-自动录制"><a href="#2-2-自动录制" class="headerlink" title="2.2 自动录制"></a>2.2 自动录制</h3><p>（1）命令行键入 –help 看到所有可后接选项</p><table><thead><tr><th>1</th><th><code>python ``-``m playwright codegen ``-``-``help</code></th></tr></thead></table><p>（2）从起始页为xingzheai.cn开始录制</p><table><thead><tr><th>1</th><th><code>python ``-``m playwright codegen https:``/``/``xingzheai.cn``/</code></th></tr></thead></table><p>（3）打开xingzheai.cn，用Chromium驱动，将结果保存为my.py的python文件</p><table><thead><tr><th>1</th><th><code>python ``-``m playwright codegen ``-``-``target python ``-``o ``&#39;my.py&#39;</code> <code>-``b chromium https:``/``/``xingzheai.cn``/</code></th></tr></thead></table><p> -target：规定生成脚本的语言，有JS和Python两种，默认为Python<br>-b：指定浏览器驱动<br>-o：将录制的脚本保存到一个文件</p><h3 id="2-3-定制化编写"><a href="#2-3-定制化编写" class="headerlink" title="2.3 定制化编写"></a>2.3 定制化编写</h3><p>（1）元素定位</p><ul><li>选择单个元素：querySelector(engine&#x3D;body)</li><li>选择多个元素：querySelectorAll(engine&#x3D;body)</li><li>选择单个元素，并且自动等待：waitForSelector(engine&#x3D;body)<br>By的8种定位方式，实际为4种</li><li>id、name、tag name、class name（java和pythona将该4种都归为CSS）</li><li>xpath、link text、partial link text、css selector<br>W3C标准规定的webDriver协议为5种定位方式</li><li>CSS、Link text、Partial link text、Tag name、XPath<br>Playwright将选择器汇总为3种</li><li>CSS、XPATH（支持逻辑表达式和函数）、TEXT<br>（2）选择器规则</li><li>CSS： ID选择器、类选择器、元素选择器、属性选择器、通配选择器、层次选择器。</li><li>XPath： XML路径语言，通过“路径标识符”，导航XML文档的，在类XML种（HTML）也可以使用。</li><li>Text： 结构化内容（html，xml，json）使用模糊匹配（忽略大小写，忽略前后空格，搜索子字符串）及精确匹配、非结构化内容使用正则匹配。<br>（3）元素常用操作</li><li>下拉选择框：selectOpion、value、labei、index</li><li>文件上传：setInputFiles、单个文件、多个文件、拖放上传</li><li>鼠标点击：click、dbclick</li><li>鼠标拖动：down、up</li><li>鼠标移动：move</li><li>触摸屏幕：tag</li><li>键盘按键：press</li><li>截屏、录屏：screenshot、recordVideo<h3 id="2-4-网络拦截（Mock接口），示例如下：2-5-同步执行，示例如下："><a href="#2-4-网络拦截（Mock接口），示例如下：2-5-同步执行，示例如下：" class="headerlink" title="2.4 网络拦截（Mock接口），示例如下：2.5 同步执行，示例如下："></a>2.4 网络拦截（Mock接口），示例如下：2.5 同步执行，示例如下：</h3><blockquote><p>page &#x3D; context.newPage()<br>def Whether_intercept() -&gt; bool:<br>return True  #进行拦截</p><h6 id="return-False-不进行拦截"><a href="#return-False-不进行拦截" class="headerlink" title="# return False #不进行拦截"></a># return False #不进行拦截</h6><p>def handler(route:Route):<br>print(route.request.url)<br>#正常访问<br># route.continue_()<br>#拒绝访问<br># route.abort(“网络拦截”)<br># 重定向到非目标地址<br>route.fulfill(<br>    status&#x3D;302,<br>    headers&#x3D;{<br>        ‘Location’ : “<a href="https://xingzheai.cn/&quot;">https://xingzheai.cn/&quot;</a><br>    }<br>)<br>page.route(Whether_intercept,handler)</p></blockquote></li></ul><h3 id="2-5-同步执行，示例如下："><a href="#2-5-同步执行，示例如下：" class="headerlink" title="2.5 同步执行，示例如下："></a>2.5 同步执行，示例如下：</h3><blockquote><p>#依次打开三个浏览器，前往行者官网，截图后退出。<br>from playwright import sync_playwright with sync_playwright() as p:<br>    for browser_type in [p.chromium, p.firefox, p.webkit]:<br>         # 指定为有头模式，Ture为无头模式<br>        browser &#x3D; browser_type.launch(headless&#x3D;False)<br>        page &#x3D; browser.newPage()<br>        page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>        # 等待页面加载完全后截图<br>        page.waitForSelector(“text&#x3D;智能内容审核”)<br>        page.screenshot(path&#x3D;f’example-{browser_type.name}.png’)<br>        browser.close()</p></blockquote><h3 id="2-6-异步执行，示例如下："><a href="#2-6-异步执行，示例如下：" class="headerlink" title="2.6 异步执行，示例如下："></a>2.6 异步执行，示例如下：</h3><blockquote><p>#同时进行三个浏览器操作<br>import asyncio<br>from playwright import async_playwright<br>async def main():<br> async with async_playwright() as p:<br>     for browser_type in [p.chromium, p.firefox, p.webkit]:<br>          browser &#x3D; await browser_type.launch()<br>         page &#x3D; await browser.newPage()<br>         await page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>          await page.waitForSelector(“text&#x3D;智能内容审核”)<br>          await page.screenshot(path&#x3D;f’example-{browser_type.name}.png’)<br>          await browser.close()<br>         asyncio.get_event_loop().run_until_complete(main())</p></blockquote><h3 id="2-7-Pytest结合，示例如下："><a href="#2-7-Pytest结合，示例如下：" class="headerlink" title="2.7 Pytest结合，示例如下："></a>2.7 Pytest结合，示例如下：</h3><p>安装：<code>pip install pytest-playwright</code></p><blockquote><p>def test_playwright(page):<br>    page.goto(“<a href="https://xingzheai.cn/&quot;">https://xingzheai.cn/&quot;</a>)<br>    with page.expect_popup() as popup_info:<br /> page.click(‘text&#x3D;”智能内容审核”‘)<br />    assert “智能内容审核” &#x3D;&#x3D; element.textContent()</p></blockquote><h3 id="2-8-移动端操作，示例如下："><a href="#2-8-移动端操作，示例如下：" class="headerlink" title="2.8 移动端操作，示例如下："></a>2.8 移动端操作，示例如下：</h3><p>目前支持模拟机型较少， 参照：仿真设备列表</p><blockquote><p>from time import sleep<br>from playwright import sync_playwright<br />with sync_playwright() as p:<br>    GalaxyS5 &#x3D; p.devices[‘Galaxy S5’]<br>    browser &#x3D; p.chromium.launch(headless&#x3D;False)<br>    context &#x3D; browser.newContext(**GalaxyS5)<br>    page &#x3D; context.newPage()<br>    page.goto(‘<a href="https://xingzheai.cn/&#39;">https://xingzheai.cn/&#39;</a>)<br>    page.click(‘text&#x3D;”智能内容审核”‘)<br>    # 截图<br>    # page.screenshot(path&#x3D;’colosseum-GalaxyS5.png’)<br>    sleep(10)<br>    browser.close()</p></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>Playwright作为新一代自动化测试工具，相较于Selenium不论是易用性，还是实用性都得到了全方位的提升。做到了简约而不简单，相信使用该工具可以帮助我们提升做自动化的工作效率。<br>到此这篇关于Playwright快速上手指南(入门教程)的文章就介绍到这了,更多相关Playwright入门内容请搜索脚本之家以前的文章或继续浏览下面的相关文章希望大家以后多多支持脚本之家！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Playwright是由微软公司2020年初发布的新一代自动化测试工具，相较于目前最常用的Selenium，本文就详细的介绍一下快速上手指南，对新手有一定的帮助，感兴趣的可以了解一下&lt;br&gt;&lt;a href=&quot;https://playwright.bootcss.com/do</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="06_第六章自动化测试" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="999_自动化测试文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>PlayWright教程(二)</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/07_PlayWright%E6%95%99%E7%A8%8B(%E4%BA%8C)/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/07_PlayWright%E6%95%99%E7%A8%8B(%E4%BA%8C)/</id>
    <published>2022-05-15T07:36:01.428Z</published>
    <updated>2022-05-15T07:36:01.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面基本操作"><a href="#页面基本操作" class="headerlink" title="页面基本操作"></a><strong>页面基本操作</strong></h2><p><a href="https://playwright.bootcss.com/docs/navigations" title="Navigations | Playwright 中文文档 | Playwright 中文网">Navigations | Playwright 中文文档 | Playwright 中文网</a></p><p>按照官网文档，调用 page.goto(url) 后页面加载过程：</p><ol><li>设定 url</li><li>通过网络加载解析页面</li><li>触发 page.on(“domcontentloaded”) 事件</li><li>执行页面的 js 脚本，加载静态资源</li><li>触发 page.on(“laod”) 事件</li><li>页面执行动态加载的脚本</li><li>当 500ms 都没有新的网络请求的时候，触发 networkidle 事件<br><code>page.goto(url)</code> 会跳转到一个新的链接。默认情况下 Playwright 会等待到 load 状态。如果我们不关心加载的 CSS 图片等信息，可以改为等待到 domcontentloaded 状态，如果页面是 ajax 加载，那么我们需要等待到 networkidle 状态。如果 networkidle 也不合适的话，可以采用 page.wait_for_selector 等待某个元素出现。不过对于 click 等操作会自动等待。<pre><code class="python">page.goto(url, referer=&quot;&quot;, timeout=30, wait_until=&quot;domcontentloaded|load|networkidle&quot;)// Navigate and wait until network is idleawait page.goto(&#39;https://example.com&#39;, &#123; waitUntil: &#39;networkidle&#39; &#125;);</code></pre></li></ol><p>Playwright 会自动等待元素处于可操作的稳定状态。当然也可以用 <code>page.wait_for_*</code> 函数来手工等待：</p><pre><code class="python">page.wait_for_event(&quot;event&quot;, event_predict, timeout)page.wait_for_function(js_function)page.wait_for_load_state(state=&quot;domcontentloaded|load|networkidle&quot;, timeout)page.wait_for_selector(selector, timeout)page.wait_for_timeout(timeout)  # 不推荐使用</code></pre><p>对页面的操作方法主要有：</p><pre><code class="python"># selector 指的是 CSS 等表达式page.click(selector)page.fill(selector, value)  # 在 input 中填充值# 例子page.click(&quot;#search&quot;)</code></pre><p>获取页面中的数据的主要方法有：</p><pre><code class="python">page.url  # urlpage.title()  # titlepage.content()  # 获取页面全文page.inner_text(selector)  # element.inner_text()page.inner_html(selector)page.text_content(selector)page.get_attribute(selector, attr)# eval_on_selector 用于获取 DOM 中的值page.eval_on_selector(selector, js_expression)# 比如：search_value = page.eval_on_selector(&quot;#search&quot;, &quot;el =&gt; el.value&quot;)# evaluate 用于获取页面中 JS 中的数据，比如说可以读取 window 中的值result = page.evaluate(&quot;([x, y]) =&gt; Promise.resolve(x * y)&quot;, [7, 8])print(result) # prints &quot;56&quot;</code></pre><h3 id="选择器表达式"><a href="#选择器表达式" class="headerlink" title="选择器表达式"></a><strong>选择器表达式</strong></h3><p>在上面的代码中，我们使用了 CSS 表达式（比如<code>#button</code>）来选取元素。实际上，Playwright 还支持 XPath 和自己定义的两种简单表达式，并且是自动识别的。</p><pre><code class="python"># 通过文本选择元素，这是 Playwright 自定义的一种表达式page.click(&quot;text=login&quot;)# 直接通过 id 选择page.click(&quot;id=login&quot;)# 通过 CSS 选择元素page.click(&quot;#search&quot;)# 除了常用的 CSS 表达式外，Playwright 还支持了几个新的伪类# :has 表示包含某个元素的元素page.click(&quot;article:has(div.prome)&quot;)# :is 用来对自身做断言page.click(&quot;button:is(:text(&#39;sign in&#39;), :text(&#39;log in&#39;))&quot;)# :text 表示包含某个文本的元素page.click(&quot;button:text(&#39;Sign in&#39;)&quot;)  # 包含page.click(&quot;button:text-is(&#39;Sign is&#39;)&quot;)  # 严格匹配page.click(&quot;button:text-matches(&#39;\w+&#39;)&quot;)  # 正则# 还可以根据方位匹配page.click(&quot;button:right-of(#search)&quot;)  # 右边page.click(&quot;button:left-of(#search)&quot;)  # 左边page.click(&quot;button:above(#search)&quot;)  # 上边page.click(&quot;button:below(#search)&quot;)  # 下边page.click(&quot;button:near(#search)&quot;)  # 50px 之内的元素# 通过 XPath 选择page.click(&quot;//button[@id=&#39;search&#39;])&quot;)# 所有 // 或者 .. 开头的表达式都会默认为 XPath 表达式</code></pre><p>对于 CSS 表达式，还可以添加前缀<code>css=</code>来显式指定，比如说 <code>css=.login</code> 就相当于 <code>.login</code>.</p><p>除了上面介绍的四种表达式以外，Playwright 还支持使用 <code>&gt;&gt;</code> 组合表达式，也就是混合使用四种表达式。</p><pre><code class="python">page.click(&#39;css=nav &gt;&gt; text=Login&#39;)</code></pre><h2 id="复用-Cookies-等认证信息"><a href="#复用-Cookies-等认证信息" class="headerlink" title="复用 Cookies 等认证信息"></a><strong>复用 Cookies 等认证信息</strong></h2><p>在 Puppeteer 中，复用 Cookies 也是一个老大难问题了。这个是 Playwright 特别方便的一点，他可以直接导出 Cookies 和 LocalStorage, 然后在新的 Context 中使用。</p><pre><code class="python"># 保存状态import jsonstorage = context.storage_state()with open(&quot;state.json&quot;, &quot;w&quot;) as f:    f.write(json.dumps(storage))# 加载状态with open(&quot;state.json&quot;) as f:    storage_state = json.loads(f.read())context = browser.new_context(storage_state=storage_state)</code></pre><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a><strong>监听事件</strong></h2><p>通过 page.on(event, fn) 可以来注册对应事件的处理函数：</p><pre><code class="python">def log_request(intercepted_request):    print(&quot;a request was made:&quot;, intercepted_request.url)page.on(&quot;request&quot;, log_request)# sometime later...page.remove_listener(&quot;request&quot;, log_request)</code></pre><p>其中比较重要的就是 request 和 response 两个事件</p><h3 id="拦截更改网络请求"><a href="#拦截更改网络请求" class="headerlink" title="拦截更改网络请求"></a><strong>拦截更改网络请求</strong></h3><p>可以通过 page.on(“request”) 和 page.on(“response”) 来监听请求和响应事件。</p><pre><code class="python">from playwright.sync_api import sync_playwright as playwrightdef run(pw):    browser = pw.webkit.launch()    page = browser.new_page()    # Subscribe to &quot;request&quot; and &quot;response&quot; events.    page.on(&quot;request&quot;, lambda request: print(&quot;&gt;&gt;&quot;, request.method, request.url))    page.on(&quot;response&quot;, lambda response: print(&quot;&lt;&lt;&quot;, response.status, response.url))    page.goto(&quot;https://example.com&quot;)    browser.close()with playwright() as pw:    run(pw)</code></pre><p>其中 request 和 response 的属性和方法，可以查阅文档：<a href="https://link.zhihu.com/?target=https://playwright.dev/python/docs/api/class-request" title="https://playwright.dev/python/docs/api/class-request">https://playwright.dev/python/docs/api/class-request</a></p><p>通过 context.route, 还可以伪造修改拦截请求等。比如说，拦截所有的图片请求以减少带宽占用：</p><pre><code class="python">context = browser.new_context()page = context.new_page()# route 的参数默认是通配符，也可以传递编译好的正则表达式对象context.route(&quot;**/*.&#123;png,jpg,jpeg&#125;&quot;, lambda route: route.abort())context.route(re.compile(r&quot;(\.png$)|(\.jpg$)&quot;), lambda route: route.abort())page.goto(&quot;https://example.com&quot;)browser.close()</code></pre><p>其中 route 对象的相关属性和方法，可以查阅文档：<a href="https://link.zhihu.com/?target=https://playwright.dev/python/docs/api/class-route" title="https://playwright.dev/python/docs/api/class-route">https://playwright.dev/python/docs/api/class-route</a></p><h3 id="灵活设置代理"><a href="#灵活设置代理" class="headerlink" title="灵活设置代理"></a><strong>灵活设置代理</strong></h3><p>Playwright 还可以很方便地设置代理。Puppeteer 在打开浏览器之后就无法在更改代理了，对于爬虫类应用非常不友好，而 Playwright 可以通过 Context 设置代理，这样就非常轻量，不用为了切换代理而重启浏览器。</p><pre><code class="python">context = browser.new_context(    proxy=&#123;&quot;server&quot;: &quot;http://example.com:3128&quot;, &quot;bypass&quot;: &quot;.example.com&quot;, &quot;username&quot;: &quot;&quot;, &quot;password&quot;: &quot;&quot;&#125;)</code></pre><h2 id="杀手级功能：录制操作直接生成代码"><a href="#杀手级功能：录制操作直接生成代码" class="headerlink" title="杀手级功能：录制操作直接生成代码"></a><strong>杀手级功能：录制操作直接生成代码</strong></h2><p>Playwright 的命令行还内置了一个有趣的功能：可以通过录制你的点击操作，直接生成 Python 代码。</p><pre><code class="python">python -m playwright codegen http://example.com/</code></pre><p>Playwright 还有很多命令行功能，比如生成截图等等，可以通过 <code>python -m playwright -h</code> 查看。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><p>除此之外，Playwright 还支持处理页面弹出的窗口，模拟键盘，模拟鼠标拖动（用于滑动验证码），下载文件等等各种功能，请查看官方文档吧，这里不赘述了。对于写爬虫来说，Playwright 的几个特性可以说是秒杀 Puppeteer&#x2F;Pyppeteer:</p><ol><li>官方同步版本的 API</li><li>方便导入导出 Cookies</li><li>轻量级设置和切换代理</li><li>支持丰富的选择表达式</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;页面基本操作&quot;&gt;&lt;a href=&quot;#页面基本操作&quot; class=&quot;headerlink&quot; title=&quot;页面基本操作&quot;&gt;&lt;/a&gt;&lt;strong&gt;页面基本操作&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://playwright.bootcss.c</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="06_第六章自动化测试" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="999_自动化测试文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>PlayWright教程(一)</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/06_PlayWright%E6%95%99%E7%A8%8B(%E4%B8%80)/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/06_PlayWright%E6%95%99%E7%A8%8B(%E4%B8%80)/</id>
    <published>2022-05-15T07:36:01.428Z</published>
    <updated>2022-05-15T07:36:01.428Z</updated>
    
    <content type="html"><![CDATA[<p>PlayWright的核心概念包括：</p><ul><li><a href="https://playwright.dev/python/docs/core-concepts#browser" title="Browser">Browser</a></li><li><a href="https://playwright.dev/python/docs/core-concepts#browser-contexts" title="Browser contexts">Browser contexts</a></li><li><a href="https://playwright.dev/python/docs/core-concepts#pages-and-frames" title="Pages and frames">Pages and frames</a></li><li><a href="https://playwright.dev/python/docs/core-concepts#selectors" title="Selectors">Selectors</a></li><li><a href="https://playwright.dev/python/docs/core-concepts#auto-waiting" title="Auto-waiting">Auto-waiting</a></li><li><a href="https://playwright.dev/python/docs/core-concepts#execution-contexts-playwright-and-browser" title="Execution contexts: Playwright and Browser">Execution contexts: Playwright and Browser</a></li><li><a href="https://playwright.dev/python/docs/core-concepts#evaluation-argument" title="Evaluation Argument">Evaluation Argument</a><h1 id="1-Browser"><a href="#1-Browser" class="headerlink" title="1. Browser"></a>1. Browser</h1>一个Browser是一个Chromium, Firefox 或 <a href="https://so.csdn.net/so/search?q=WebKit&spm=1001.2101.3001.7020">WebKit</a>（plarywright支持的三种浏览器）的实例plarywright脚本通常以启动浏览器实例开始，以关闭浏览器结束。浏览器实例可以在headless（没有 GUI）或head模式下启动。Browser实例创建：<pre><code class="python">from playwright.sync_api import sync_playwrightwith sync_playwright() as p:  browser = p.chromium.launch(headless=False)  browser.close()</code></pre>启动browser实例是比较耗费资源的，plarywright做的就是如何通过一个browser实例最大化多个BrowserContext的性能。<br>API:</li><li><a href="https://playwright.dev/python/docs/api/class-browser" title="Browser">Browser</a><h1 id="2-BrowserContext"><a href="#2-BrowserContext" class="headerlink" title="2.BrowserContext"></a>2.BrowserContext</h1>一个BrowserContex就像是一个独立的匿名模式会话（session），非常轻量，但是又完全隔离。<br>（译者注：每个browser实例可有多个BrowserContex，且完全隔离。比如可以在两个BrowserContext中登录两个不同的账号，也可以在两个 context 中使用不同的代理。 ）<br>context创建：<pre><code class="python">browser = playwright.chromium.launch()context = browser.new_context()</code></pre>context还可用于模拟涉及移动设备、权限、区域设置和配色方案的多页面场景，如移动端context创建：<pre><code class="python">from playwright.sync_api import sync_playwrightwith sync_playwright() as p:  iphone_11 = p.devices[&#39;iPhone 11 Pro&#39;]  browser = p.webkit.launch(headless=False)  context = browser.new_context(      **iphone_11,      locale=&#39;de-DE&#39;,      geolocation=&#123; &#39;longitude&#39;: 12.492507, &#39;latitude&#39;: 41.889938 &#125;,      permissions=[&#39;geolocation&#39;]  )  browser.close()</code></pre>API:</li><li><a href="https://playwright.dev/python/docs/api/class-browsercontext" title="BrowserContext">BrowserContext</a></li><li><a href="https://playwright.dev/python/docs/api/class-browser#browser-new-context" title="browser.new_context(**kwargs)">browser.new_context(**kwargs)</a></li></ul><h1 id="3-Page-和-Frame"><a href="#3-Page-和-Frame" class="headerlink" title="3. Page 和 Frame"></a>3. Page 和 <a href="https://so.csdn.net/so/search?q=Frame&spm=1001.2101.3001.7020">Frame</a></h1><p> 一个BrowserContext可以有多个page，每个page代表一个tab或者一个弹窗。page用于导航到URL并与page内的内容交互。<br>创建page:</p><pre><code class="python">page = context.new_page()# Navigate explicitly, similar to entering a URL in the browser.page.goto(&#39;http://example.com&#39;)# Fill an input.page.fill(&#39;#search&#39;, &#39;query&#39;)# Navigate implicitly by clicking a link.page.click(&#39;#submit&#39;)# Expect a new url.print(page.url)# Page can navigate from the script - this will be picked up by Playwright.# window.location.href = &#39;https://example.com&#39;</code></pre><p> 一个page可以有多个frame对象，但只有一个主frame，所有page-level的操作(比如click），都是作用在主frame上的。page的其他frame会打上<code>iframe</code> HTML标签，这些frame可以在内部操作实现访问。</p><pre><code class="python"># 通过name属性获取frameframe = page.frame(&#39;frame-login&#39;)# 通过URL获取frameframe = page.frame(url=r&#39;.*domain.*&#39;)# 通过其他选择器(selector)获取frameframe_element_handle = page.query_selector(&#39;.frame-class&#39;)frame = frame_element_handle.content_frame()# 与frame交互frame.fill(&#39;#username-input&#39;, &#39;John&#39;)</code></pre><p>在录制模式下，会自动识别是否是frame内的操作，不好定位frame时，那么可以使用录制模式来找。</p><p>API：</p><ul><li><a href="https://playwright.dev/python/docs/api/class-page" title="Page">Page</a></li><li><a href="https://playwright.dev/python/docs/api/class-frame" title="Frame">Frame</a></li><li><a href="https://playwright.dev/python/docs/api/class-page#page-frame" title="page.frame(**kwargs)">page.frame(**kwargs)</a></li></ul><h1 id="4-Selector"><a href="#4-Selector" class="headerlink" title="4. Selector"></a>4. <a href="https://so.csdn.net/so/search?q=Selector&spm=1001.2101.3001.7020">Selector</a></h1><p> playwright可以通过 CSS selector, XPath selector, HTML 属性（比如 <code>id</code>, <code>data-test-id）或者是文本内容</code>定位元素。</p><p>除了xpath selector外，所有selector默认都是指向shadow DOM，如果要指向常规DOM，可使用*:light。不过通常不需要。</p><pre><code class="python"># Using data-test-id= selector enginepage.click(&#39;data-test-id=foo&#39;)# CSS and XPath selector engines are automatically detectedpage.click(&#39;div&#39;)page.click(&#39;//html/body/div&#39;)# Find node by text substringpage.click(&#39;text=Hello w&#39;)# Explicit CSS and XPath notationpage.click(&#39;css=div&#39;)page.click(&#39;xpath=//html/body/div&#39;)# Only search light DOM, outside WebComponent shadow DOM:page.click(&#39;css:light=div&#39;)# 不同的selector可组合使用，用 &gt;&gt;连接# Click an element with text &#39;Sign Up&#39; inside of a #free-month-promo.page.click(&#39;#free-month-promo &gt;&gt; text=Sign Up&#39;)# Capture textContent of a section that contains an element with text &#39;Selectors&#39;.section_text = page.eval_on_selector(&#39;*css=section &gt;&gt; text=Selectors&#39;, &#39;e =&gt; e.textContent&#39;)</code></pre><p>详细：</p><p><a href="https://playwright.dev/python/docs/selectors/" title="Element selectors | Playwright Python">Element selectors | Playwright Python</a></p><h1 id="5-Auto-waiting"><a href="#5-Auto-waiting" class="headerlink" title="5.  Auto-waiting"></a>5.  Auto-waiting</h1><p>playwright在执行操作之前对元素执行一系列可操作性检查，以确保这些行动按预期运行。它会自动等待（auto-wait）所有相关检查通过，然后才执行请求的操作。如果所需的检查未在给定的范围内通过<code>timeout</code>，则操作将失败并显示<code>TimeoutError</code></p><p>如 <a href="https://playwright.dev/python/docs/api/class-page#page-click" title="page.click(selector, **kwargs)">page.click(selector, **kwargs)</a> 和 <a href="https://playwright.dev/python/docs/api/class-page#page-fill" title="page.fill(selector, value, **kwargs)">page.fill(selector, value, **kwargs)</a> 这样的操作会执行auto-wait ，等待元素变成可见（visible）和 可操作（ <a href="https://playwright.dev/python/docs/actionability" title="actionable">actionable</a>）。例如，click将会:</p><ul><li>等待selectorx选定元素出现在 DOM 中</li><li>待它变得可见（visible）：有非空的边界框且没有 <code>visibility:hidden</code></li><li>等待它停止移动：例如，等待 css 过渡（css transition）完成</li><li>将元素滚动到视图中</li><li>等待它在动作点接收点事件：例如，等待元素不被其他元素遮挡</li><li>如果在上述任何检查期间元素被分离，则重试</li></ul><pre><code class="python"># Playwright waits for #search element to be in the DOMpage.fill(&#39;#search&#39;, &#39;query&#39;)# Playwright waits for element to stop animating# and accept clicks.page.click(&#39;#search&#39;)#也可显示执行等待动作# Wait for #search to appear in the DOM.page.wait_for_selector(&#39;#search&#39;, state=&#39;attached&#39;)# Wait for #promo to become visible, for example with `visibility:visible`.page.wait_for_selector(&#39;#promo&#39;)# Wait for #details to become hidden, for example with `display:none`.page.wait_for_selector(&#39;#details&#39;, state=&#39;hidden&#39;)# Wait for #promo to be removed from the DOM.page.wait_for_selector(&#39;#promo&#39;, state=&#39;detached&#39;)</code></pre><p> API:</p><ul><li><a href="https://playwright.dev/python/docs/api/class-page#page-click" title="page.click(selector, **kwargs)">page.click(selector, **kwargs)</a></li><li><a href="https://playwright.dev/python/docs/api/class-page#page-fill" title="page.fill(selector, value, **kwargs)">page.fill(selector, value, **kwargs)</a></li><li><a href="https://playwright.dev/python/docs/api/class-page#page-wait-for-selector" title="page.wait_for_selector(selector, **kwargs)">page.wait_for_selector(selector, **kwargs)</a></li></ul><h1 id="6-Execution-context"><a href="#6-Execution-context" class="headerlink" title="6. Execution context"></a>6. Execution context</h1><p>API <a href="https://playwright.dev/python/docs/api/class-page#page-evaluate" title="page.evaluate(expression, **kwargs)">page.evaluate(expression, **kwargs)</a> 可以用来运行web页面中的 JavaScript函数，并将结果返回到plarywright环境中。浏览器的<a href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">全局变量</a>，如 <code>window</code> 和 <code>document，</code> 可用于 <code>evaluate。</code></p><pre><code class="python">href = page.evaluate(&#39;() =&gt; document.location.href&#39;)# if the result is a Promise or if the function is asynchronous evaluate will automatically wait until it&#39;s resolvedstatus = page.evaluate(&quot;&quot;&quot;async () =&gt; &#123;  response = fetch(location.href)  return response.status&#125;&quot;&quot;&quot;)</code></pre><h2 id="7-Evaluation-Argument"><a href="#7-Evaluation-Argument" class="headerlink" title="7. Evaluation Argument"></a>7. Evaluation Argument</h2><p>  <a href="https://playwright.dev/python/docs/api/class-page#page-evaluate" title="page.evaluate(expression, **kwargs)">page.evaluate(expression, **kwargs)</a> 方法接收单个可选参数。此参数可以是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description" title="Serializable">Serializable</a>值和<a href="https://playwright.dev/python/docs/api/class-jshandle" title="JSHandle">JSHandle</a>或<a href="https://playwright.dev/python/docs/api/class-elementhandle" title="ElementHandle">ElementHandle</a>实例的混合。句柄会自动转换为它们所代表的值</p><pre><code class="python">result = page.evaluate(&quot;([x, y]) =&gt; Promise.resolve(x * y)&quot;, [7, 8])print(result) # prints &quot;56&quot;print(page.evaluate(&quot;1 + 2&quot;)) # prints &quot;3&quot;x = 10print(page.evaluate(f&quot;1 + &#123;x&#125;&quot;)) # prints &quot;11&quot;body_handle = page.query_selector(&quot;body&quot;)html = page.evaluate(&quot;([body, suffix]) =&gt; body.innerHTML + suffix&quot;, [body_handle, &quot;hello&quot;])body_handle.dispose()# A primitive value.page.evaluate(&#39;num =&gt; num&#39;, 42)# An array.page.evaluate(&#39;array =&gt; array.length&#39;, [1, 2, 3])# An object.page.evaluate(&#39;object =&gt; object.foo&#39;, &#123; &#39;foo&#39;: &#39;bar&#39; &#125;)# A single handle.button = page.query_selector(&#39;button&#39;)page.evaluate(&#39;button =&gt; button.textContent&#39;, button)# Alternative notation using elementHandle.evaluate.button.evaluate(&#39;(button, from) =&gt; button.textContent.substring(from)&#39;, 5)# Object with multiple handles.button1 = page.query_selector(&#39;.button1&#39;)button2 = page.query_selector(&#39;.button2&#39;)page.evaluate(&quot;&quot;&quot;o =&gt; o.button1.textContent + o.button2.textContent&quot;&quot;&quot;,    &#123; &#39;button1&#39;: button1, &#39;button2&#39;: button2 &#125;)# Object destructuring works. Note that property names must match# between the destructured object and the argument.# Also note the required parenthesis.page.evaluate(&quot;&quot;&quot;    (&#123; button1, button2 &#125;) =&gt; button1.textContent + button2.textContent&quot;&quot;&quot;,    &#123; &#39;button1&#39;: button1, &#39;button2&#39;: button2 &#125;)# Array works as well. Arbitrary names can be used for destructuring.# Note the required parenthesis.page.evaluate(&quot;&quot;&quot;    ([b1, b2]) =&gt; b1.textContent + b2.textContent&quot;&quot;&quot;,    [button1, button2])# Any non-cyclic mix of serializables and handles works.page.evaluate(&quot;&quot;&quot;    x =&gt; x.button1.textContent + x.list[0].textContent + String(x.foo)&quot;&quot;&quot;,    &#123; &#39;button1&#39;: button1, &#39;list&#39;: [button2], &#39;foo&#39;: None &#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PlayWright的核心概念包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://playwright.dev/python/docs/core-concepts#browser&quot; title=&quot;Browser&quot;&gt;Browser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="06_第六章自动化测试" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="999_自动化测试文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>接口自动化</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/08_%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06_%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999_%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/08_%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <published>2022-05-15T07:36:01.428Z</published>
    <updated>2022-05-15T07:36:01.437Z</updated>
    
    <content type="html"><![CDATA[<ol><li>自动化测试具体怎么做的（流程怎么样的？）<ol><li>？？？？？<ol><li>用什么做的？</li><li>需要注意什么？核心关键是什么？</li><li>具体步骤是怎样的？</li></ol></li><li>接口自动化这块，我们当时用的 python+requests 库来写脚本的，例外，也会用到其他的一些库像ddt,unittest,xlrd,json,re,pymysql,htmlreport 等另外的话，我觉得做接口自动化，最关键的还是’用例数据的准备’，’请求数据的组装’，’及请求发送’， 和对’响应数据的提取处理’，与’判断校验&#x2F;做断言’。当然要做自动化，首先就是要搭建好自动化测试环境，之后就准备好用例数据嘛，像用例数据这块的话，公司统一要求用 excel 表格来管理的，这里面主要就是用例标题，url,请求方式，请求头，请求参数，用来做断言的响应数据。其实主要目的就是起到数据与脚本的分离方便后期的管理。数据准备好了之后，然后就开始写脚本，首先把相关的包导入进来，之后调用封装好的函数来读取excel表格中的用例数据，数据返回出来是一个列表形式。然后就是定义个类，去继承unittest.TestCase 基类,并重写其中 setUp,tearDown方法，在setUp方法中主要就是做一些初始化的准备工作，tearDown 中主要完成一些回收工作，比如，像连接数据库可以放在setUp方法中，在 tearDown 方法关闭数据库的连接然后实现用例函数，用例函数必须要以 test开头，这里的话，用例函数中主要就是实现请求数据的组装，还有就是调用 requests库中的get或 post方法发请求，把相关的参数传进去，请求参数这块我们需要用到 ddt 模型，去引用前面提取出来的 list 中的额数据这边请求发送之后会返回一个响应对象，这里面接下来其实最主要的就是对响应对象中的数据进行提取处理，并判断校验并做断言。断言这块这一块的话，主要就是关注几个点，一个就是状态码，还有就是响应信息，不过，这里面最重要的是响应的正文内容的判断。主要就是判断这几个块与结构文档是否一致。对于响应的正文内容，可能会比较麻烦一点，因为一般后台会返回两种格式的数据，一种是 json 格式的数据，其实对于 json 格式的数据我们需要把它转化为字典形式，治理其实主要就是调用response.json()函数就已经转为字典，然后去提取其中的一些核心信息去做断言判断就可以了。例外，如果返回的是 html 格式的数据，我们需要用到一个 re 库，并调用其中的一个函数 findall 结合正则表达式提取关键信息做断言判断。断言的一些函数，其实都是调用 unittest 框架中的函数实现,像assertEqual，assertIn,以及做全量对标的话，需要用到 assertListEuqal,assertDictEqual 主要就是这些。脚本这块差不多就是这么写的，最后我们需要引入一个 htmlreport 库去自动生成自动化报告，然后就是对报告进行分析，报告这一块的话，主要有通过，异常，失败几种请情况，如果如果错误的话，基本一般都是脚本问题，这个时候我们需要去重新调试我们的脚本，如果是失败的话，一般来说，我都会先检查自己的脚本是否有问题，如果没有问题基本就可以提 Bug了。接口自动化我们当时就这么做的。</li></ol></li><li><h3 id="request框架有哪些方法？"><a href="#request框架有哪些方法？" class="headerlink" title="request框架有哪些方法？"></a><strong>request</strong>框架有哪些方法？</h3><ol><li>像用来发送请求的一般都是调用以下方法<br> reponse &#x3D; requests.get()<br> reponse &#x3D; requests.post()<br> 获取响应数据一般都是调用以下方法<br> reponse.status_code<br> reponse.reason<br> reponse.text reponse.json()<br> reponse.headers<br> reponse.cookies</li></ol></li><li><h3 id="接口自动化用过哪些库？"><a href="#接口自动化用过哪些库？" class="headerlink" title="接口自动化用过哪些库？"></a>接口自动化用过哪些库？</h3><ol><li>Requests 库   这个里面主要封装了各种发送请求处理请求的方法<br> Json 库           这个库主要用来将 json 格式转化为字典，或者将字典转化为 json 格式数据<br> Re 库             这个库当时是针对后台返回的是 html 格式，用来提取html 格式中的数据的<br> Xlrd库            这个库当时主要用来读取 excel 表格数据的<br> Ddt 库           这个库主要用来实现数据驱动的<br> Pymysql库     这个库主要就是用来读取数据库，操作数据库的。差不多当时好像这些库都是有用过的吧。</li></ol></li><li><h3 id="如果要传递请求头如何处理？"><a href="#如果要传递请求头如何处理？" class="headerlink" title="如果要传递请求头如何处理？"></a>如果要传递请求头如何处理？</h3><ol><li>传递请求头，其实还是比较简单的，首先要搞清楚这个接口需要传递哪些请求求参数，然后订制一个请求头，一般都是组装成一个字典，然后在调用 post 或 get 方法发请求的时候，在这两个函数中有一个参数headers，这个参数就是用来传递请求头的，把组装好的请求头通过headers 参数进行传递就可以了。</li></ol></li><li><h3 id="你们做接口自动化，用例数据是怎么组织，管理的？"><a href="#你们做接口自动化，用例数据是怎么组织，管理的？" class="headerlink" title="你们做接口自动化，用例数据是怎么组织，管理的？"></a>你们做接口自动化，用例数据是怎么组织，管理的？</h3><ol><li>用例数据这块，当时公司要求使用 excel 表格来进行管理，其实这里主要也是为了实现数据与脚本的分离，提高整个工程后期的维护与优化，这里把数据封装到 excel 表格之后<br> 我们在脚本中通过调用封装好的读取 excel 表格的数据函数，然后利用 ddt 模型来引用这些数据组织请求参数或头，发请求。<br> 对 excel 表格中的用例数据，我们是这么组织的，会有以下几个字段像用例标题，请求地址， 请求方式，请求头，请求参数，响应结果，这个几个部分，对于请求头跟请求参数，因为<br> 脚本中发请求都是通过组装成字典的形式来发送的，所以这里我们也是通过类似于字典的形式文本格式来进行组织，主要就是方便后期脚本的提取与引用。<br> 其实我觉得，这样去处理的好处就是，后期如果用例数据有变动，或者需要增加或删除部分用例直接针对excel 表格数据进行操作就可以了，不需要改动脚本。<br> 这也就方便整个项目工程的管理与维护了。</li></ol></li><li><h3 id="接口自动化的用例又是怎么管理的？"><a href="#接口自动化的用例又是怎么管理的？" class="headerlink" title="接口自动化的用例又是怎么管理的？"></a>接口自动化的用例又是怎么管理的？</h3><ol><li>自动化用例这块，我们利用 unittest 框架来编写的，然后利用unittest 帮我们去统一加载执行用例。如果要全量执行的话， 通过调用 unittest 里面提供的 defaultTestLoader.discover()这个函数来加载test_case目录下的所有用例执行即可， 如果某条用例没有通过， 需要单独调试， 可以通过unittest.TestLoader()来创建一个加载器，加载具体的某条用例进行执行，调试即可。最后就是结合HTMLReport 这个库最终会自动帮我们生成报告。</li></ol></li><li><h3 id="对于返回的数据，你怎么检查校验？"><a href="#对于返回的数据，你怎么检查校验？" class="headerlink" title="对于返回的数据，你怎么检查校验？"></a>对于返回的数据，你怎么检查校验？</h3><ol><li>这块的话，首先我们一定得搞清楚后台返回的到底是什么格式的数据，一般都是两种情况，一种就是json格式的数据，一种就是 html格式的数据，关注几个点一般有以下几个点，1.  状态码   2.  响应信息对不对     3.也是最重要的就是响应内容，如果正文内容是 json 格式的数据，我们就使用 response.json()函数来提取就可以了，如果是正文内容 html格式的数据，我们就使用 response.text来提取，然后利用re 库中 findall函数结合正则表达式来提取核心字段进行校验。对于响应内容，我们需要根据接口文档的说明， 去检查一些核心的字段信息，去判断就行了。例外，如果有些接口需要检查数据库的话，那我们去连接数据库，查询对应数据，然后去判断校验,断言这块我当时就是这么做的。</li></ol></li><li><h3 id="对于接口响应数据，你是怎么做断言的？"><a href="#对于接口响应数据，你是怎么做断言的？" class="headerlink" title="对于接口响应数据，你是怎么做断言的？"></a>对于接口响应数据，你是怎么做断言的？</h3><ol><li>我首先确定需要检查的键是否存在，assertIn 去判断键是否存在，如果键存在，然后根据键去获取其中的值，如果值是变化的，有可能有，有可能没有，或者值本身在发生变化，这里需要读取数据库中的实际对应的字段值，然后判断返回结果中的对应字段的值与数据库中读取出来的值是否一致。</li></ol></li><li><h3 id="你写了多少接口自动化用例"><a href="#你写了多少接口自动化用例" class="headerlink" title="你写了多少接口自动化用例"></a>你写了多少接口自动化用例</h3><ol><li>自动化用例，也没有具体数过，当时我负责的所有模块的接口的自动用例都是我这边独立完成的，有模块的用例会多一点，有些会少一点，这具体看接口的参数有多少，参数多限制条件多的，一般用例会比较多一点，我负责的模块大概有 100多条用例是有的吧！</li></ol></li><li><h3 id="你们接口自动化用例是怎么跑的？"><a href="#你们接口自动化用例是怎么跑的？" class="headerlink" title="你们接口自动化用例是怎么跑的？"></a>你们接口自动化用例是怎么跑的？</h3><ol><li>一般正常我们都是全量跑的，如果要全量跑，我们一般都是加载用例目录也就是 testcase下的所有用例文件这里主要就是调用unittest.defaultTestLoader.discover(用例目录的路径，匹配规则)函数进行加载所有用例文件。有时候如果只是某个模块的用例执行不通过，需要单独执行调试某个模块的用例。这里可以先创建一个套件，调用 unittest.testsuite()来进行创建然后调用  unittest.testLoader()函数来创建一个加载器然后在加载具体某个模块的具体用例去执行调试。如果要定时全量跑所有的用例，一般我们都是在每周五下午会定时全量跑所有的用例，然后周一过来看报告分析报告，这里就需要用到持续集成，我们当时用的 jenkins，从 SVN上检出自动化脚本，然后让jenkins自动帮我们去跑。</li></ol></li><li><h3 id="有没有了解过数据驱动？"><a href="#有没有了解过数据驱动？" class="headerlink" title="有没有了解过数据驱动？"></a>有没有了解过数据驱动？</h3><ol><li>数据驱动就是把用例数据与脚本代码进行分离，把用例数据进行独立出来嘛，它的好处就在于方便后台的管理维护。这样的话，如果数据后期发生变化，只要维护修改 excel 表格中的数据就可以，比如，需要增加数据或者需要删除某条用例数据，或者修改数据就变得比较方便。<br> 对于自动化用例数据我们公司当时要求放在 Excel 表格中来管理的，然后保存在工程中的 data 目录下，之后就是通过调用封装好的函数去读取数据，然后利用 ddt 模型来实现数据的驱动，对于 ddt 模型， 它所采用的就是 python 装饰器的原理来引用数据的。<br> 例外，对于一些其他的一些常量数据，比如：文件的路径，用例的路径，邮件的配置信息，数据库的一些配置信息，我们都是通过配置文件来管理的，我们会在工程中创建一个 config目录，然后把配置文件都是放在这个目录下的。<br> 当时数据驱动这块就是这么来实现的。</li></ol></li><li><h3 id="有没有自己封装过函数"><a href="#有没有自己封装过函数" class="headerlink" title="有没有自己封装过函数]()?"></a><strong>有没有自己封装过函数]()</strong>?</h3><ol><li>也有自己封装过，但是不很多，大部分都调用公司&#x2F;老大封装好的函数来进行实现的像当时那个数据操作的相关模块这边是我封装，例外，像读取 Excel 表格数据的模块<br> 也是我这边封装，除了这个之外，还封装过一些其他函数，比如获取 cookie 值，获取手机验证码的函数等，这边都是有封装过的……</li><li><img src="/assets/1/image-20211203223308-nfhjajx.png" alt="image.png"></li><li><img src="/assets/1/image-20211203223328-08gzxth.png" alt="image.png"></li></ol></li><li><h3 id="接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？"><a href="#接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？" class="headerlink" title="接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？"></a>接口自动化这块是怎么出报告的？对于报告具体怎么分析的？报告中有哪些内容？</h3><ol><li>报告这一块，我们当时是用那个htmlreport 这个库去生成的？首先主要关注运行结果，看有多少用例通过了，有多少执行失败，有多少执行错误。一般报告上都会详细说明，我们主要看失败用例以及错误用例，对于失败的用例跟错误的用例一般在报告上都会有详细细节说明，到底哪里执行没有通过。对于执行错误的用例，一般都是自己的脚本编写有问题，这个我一般会找到对应用例代码去调试查看。<br> 对于失败用例，我一般首先怀疑自己的脚本，先检查自己的脚本有没有问题，如果不是自己脚本问题导致的，那这就说明这条用例真的执行失败了，一般就提 BUG 就可以了。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;自动化测试具体怎么做的（流程怎么样的？）&lt;ol&gt;
&lt;li&gt;？？？？？&lt;ol&gt;
&lt;li&gt;用什么做的？&lt;/li&gt;
&lt;li&gt;需要注意什么？核心关键是什么？&lt;/li&gt;
&lt;li&gt;具体步骤是怎样的？&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;接口自动化这块，我们当时用的 p</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="06_第六章自动化测试" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="999_自动化测试文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/06-%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/999-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试的分类</title>
    <link href="http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://example.com/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/02_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2022-05-15T07:36:01.388Z</published>
    <updated>2022-05-15T08:01:15.590Z</updated>
    
    <content type="html"><![CDATA[<p>目前，软件测试已经形成一个完整的、体系庞大的学科，不同的测试领域都有不同的测试方法、技术与名称，有很多读者可能也听过类似的黑盒测试、白盒测试、冒烟测试、单元测试等，其实它们是按照不同的分类方法而产生的测试名称。按照不同的分类标准，可以将软件测试分为很多不同的种类，下面我们详细介绍这些软件测试行业的专业名词。</p><h2 id="按照测试阶段分类"><a href="#按照测试阶段分类" class="headerlink" title="按照测试阶段分类"></a><strong>按照测试阶段分类</strong></h2><p>按照测试阶段可以将软件测试分为单元测试、冒烟测试、集成测试、系统测试与验收测试。这种分类方式与软件开发过程相契合，是为了检验软件开发各个阶段是否符合要求。</p><p><strong>(1) 单元测试</strong></p><p>单元测试是软件开发的第一步测试，目的是为了验证软件单元是否符合软件需求与设计。单元测试大多是开发人员进行的自测。</p><p><strong>(2) 冒烟测试</strong></p><p>冒烟测试最初是从电路板测试得来的，当电路板做好以后，首先会加电测试，如果电路板没有冒烟再进行其他测试，否则就必须重新设计后再次测试。后来这种测试理念被引入到软件测试中。在软件测试中，冒烟测试是指软件构建版本建立后，对系统的基本功能进行简单的测试，这种测试重点验证的是程序的主要功能，而不会对具体功能进行深入测试。如果测试未通过，需要返回给开发人员进行修正;如果测试通过则再进行其他测试。因此，冒烟测试是对新构建版本软件进行的最基本测试。</p><p><strong>(3) 集成测试</strong></p><p>集成测试是冒烟测试之后进行的测试，它是将已经测试过的软件单元组合在一起测试它们之间的接口，用于验证软件是否满足设计需求。</p><p><strong>(4) 系统测试</strong>———————–把系统看成一个整体进行的测试<br>    * 功能测试<br>    * 兼容性测试<br>    * 性能测试<br>    * 安全测试</p><p>系统测试是将经过测试的软件在实际环境中运行，并与其他系统的成分(如数据库、硬件和操作人员等)组合在一起进行的测试。</p><p><strong>(5) 验收测试</strong></p><p>验收测试主要是对软件产品说明进行验证，逐行逐字地按照说明书的描述对软件产品进行测试，确保其符合客户的各项要求。</p><h2 id="按照测试技术分类"><a href="#按照测试技术分类" class="headerlink" title="按照测试技术分类"></a>按照测试技术分类</h2><p>按照使用的测试技术可以将软件测试分为黑盒测试与白盒测试。</p><p><strong>(1)<a href="/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/03_%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">黑盒测试</a></strong></p><p>黑盒测试就是把软件(程序)当作一个有输入与输出的黑匣子，它把程序当作一个输入域到输出域的映射，只要输入的数据能输出预期的结果即可，不必关心程序内部是怎么样实现的，下图所示。</p><p><img src="/assets/2/image-20220515154753-0m7737r.png" alt="image.png"></p><p><strong>(2)白盒测试</strong></p><p>白盒测试又叫透明盒测试，它是指测试人员了解软件程序的逻辑结构、路径与运行过程，在测试时，按照程序的执行路径得出结果。白盒测试就是把软件(程序)当作一个透明的盒子，测试人员清楚地知道从输入到输出的每一步过程，如下图所示。</p><p><img src="/assets/2/image-20220515154759-jcs045j.png" alt="image.png"></p><p>相对于黑盒测试来说，白盒测试对测试人员的要求会更高一点，他要求测试人员具有一定的编程能力，而且要熟悉各种脚本语言。但是在软件公司里，黑盒测试与白盒测试并不是界限分明的，在测试一款软件时往往是黑盒测试与白盒测试相结合对软件进行完整全面的测试。</p><h2 id="按照软件质量特性分类"><a href="#按照软件质量特性分类" class="headerlink" title="按照软件质量特性分类"></a>按照软件质量特性分类</h2><p>按照软件质量特性可以将软件测试分为功能测试与性能测试。</p><p><strong>(1)功能测试</strong></p><p>功能测试就是测试软件的功能是否满足客户的需求，包括准确性、易用性、适合性、互操作性等。</p><p><strong>(2)性能测试</strong></p><p>性能测试就是测试软件的性能是否满足客户的需求，性能测试包括负载测试、压力测试、兼容性测试、可移植性测试和健壮性测试。</p><h2 id="按照自动化程度分类"><a href="#按照自动化程度分类" class="headerlink" title="按照自动化程度分类"></a>按照自动化程度分类</h2><p>按照自动化程度可以将软件测试分为手工测试与自动化测试。</p><p><strong>(1)手工测试</strong></p><p>手工测试是测试人员一条一条地执行代码完成测试工作。手工测试比较耗时费力，而且测试人员如果是在疲惫状态下，则很难保证测试的效果。</p><p><strong>(2)自动化测试</strong></p><p>自动化测试是借助脚本、自动化测试工具等完成相应的测试工作，它也需要人工的参与，但是它可以将要执行的测试代码或流程写成脚本，执行脚本完成整个测试工作。</p><h2 id="按照测试类型分类"><a href="#按照测试类型分类" class="headerlink" title="按照测试类型分类"></a>按照测试类型分类</h2><p>软件测试类型有多种，包括界面类测试、功能测试、性能测试、安全性测试、文档测试等，其中功能测试与性能测试前面已经介绍，下面主要介绍其他几种测试。</p><p><strong>(1)界面类测试</strong></p><p>界面类测试是验证软件界面是否符合客户需求，包括界面布局是否美观、按钮是否齐全等。</p><p><strong>(2)安全性测试</strong></p><p>安全性测试是测试软件在没有授权的内部或外部用户的攻击或恶意破坏时如何进行处理，是否能保证软件与数据的安全。</p><p><strong>(3)文档测试</strong></p><p>文档测试以需求分析、软件设计、用户手册、安装手册为主，主要验证文档说明与实际软件之间是否存在差异。</p><h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a><strong>其他分类</strong></h2><p>还有一些软件测试无法具体归到哪一类，但在测试行业中也会经常进行这些测试，如α测试、β测试、回归测试等，具体介绍如下。</p><p><strong>(1) α测试</strong></p><p>α测试是指对软件最初版本进行测试。软件最初版本一般不对外发布，在上线之前，由开发人员和测试人员或者用户协助进行测试。测试人员记录使用过程中出现的错误与问题整个测试过程是可控的。</p><p><strong>(2) β测试</strong></p><p>β测试是指对上线之后的软件版本进行测试，此时软件已上线发布，但发布的版本中可能会存在较轻微的Bug，由用户在使用过程中发现错误与问题并进行记录，然后反馈给开发人员进行修复。</p><p><strong>(3)回归测试</strong></p><p>当测试人员发现缺陷以后，会将缺陷提交给开发人员，开发人员对程序进行修改，修改之后，测试人员会对修改后的程序重新进行测试，确认原有的缺陷已经消除并且没有引入新的缺陷，这个重新测试的过程就叫作回归测试。回归测试是软件测试工作中非常重要的一部分，软件开发的各个阶段都会进行多次回归测试。</p><p><strong>(4)随机测试</strong></p><p>随机测试是没有测试用例、检查列表、脚本或指令的测试，它主要是根据测试人员的经验对软件进行功能和性能抽查。随机测试是根据测试用例说明书执行测试用例的重要补充手段，是保证测试覆盖完整性的有效方式和过程。</p><p><strong>(5)探索性测试</strong>    </p><p>随机测试的升级版，测试的一种思维方式，强调遇到问题之后，改变测试策略，能够发现更加深入的问题，是未来测试发展的一个领域</p><p><a href="/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/04_%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%88%92%E5%88%86/">测试种类划分</a><br><a href="/02_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01_%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901_%E6%96%87%E4%BB%B6/902_%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/11_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%8416%E7%A7%8D%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B/">软件测试的16种测试类型</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前，软件测试已经形成一个完整的、体系庞大的学科，不同的测试领域都有不同的测试方法、技术与名称，有很多读者可能也听过类似的黑盒测试、白盒测试、冒烟测试、单元测试等，其实它们是按照不同的分类方法而产生的测试名称。按照不同的分类标准，可以将软件测试分为很多不同的种类，下面我们详</summary>
      
    
    
    
    <category term="02_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    <category term="01_第一章基础" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/"/>
    
    <category term="901_文件" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901-%E6%96%87%E4%BB%B6/"/>
    
    <category term="902_测试理论" scheme="http://example.com/categories/02-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/01-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80/901-%E6%96%87%E4%BB%B6/902-%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="测试理论" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>selenium-webdriver常见报错问题</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/05_selenium-webdriver%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/05_selenium-webdriver%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-15T07:16:36.084Z</published>
    <updated>2022-05-15T07:25:11.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。"><a href="#一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。" class="headerlink" title="一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。"></a>一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。</h2><h4 id="selenium-common-exceptions-WebDriverException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-WebDriverException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.WebDriverException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.WebDriverException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：WebDriver基础的异常类    解决思路：检查驱动版本与浏览器版本</code></pre><h4 id="selenium-common-exceptions-TimeoutException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-TimeoutException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.TimeoutException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.TimeoutException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：在足够的时间内没有完成某项操作    解决思路：适当的增加时长，等待界面元素的渲染</code></pre><h4 id="selenium-common-exceptions-NoSuchElementException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoSuchElementException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoSuchElementException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoSuchElementException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：定位元素不被找到    解决思路：检查是否写错了元素，更换定位元素</code></pre><h4 id="selenium-common-exceptions-NoSuchAttributeException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoSuchAttributeException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoSuchAttributeException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoSuchAttributeException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：元素属性不能被找到    解决思路：检查是否写错了元素属性</code></pre><h4 id="selenium-common-exceptions-NoAlertPresentException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoAlertPresentException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoAlertPresentException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoAlertPresentException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：切换到alert弹窗，alert并没有弹出    解决思路：增加等待时间</code></pre><h4 id="selenium-common-exceptions-NoSuchFrameException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoSuchFrameException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoSuchFrameException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoSuchFrameException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：没有iframe窗口    解决思路：检查是否存在此类窗口</code></pre><h4 id="selenium-common-exceptions-InvalidElementStateException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-InvalidElementStateException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.InvalidElementStateException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.InvalidElementStateException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：元素无效    解决思路：更改定位元素</code></pre><h4 id="selenium-common-exceptions-ElementNotSelectableException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-ElementNotSelectableException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.ElementNotSelectableException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.ElementNotSelectableException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：元素不能被选中    解决思路：检查是否是元素是否写错，检查属性</code></pre><h4 id="selenium-common-exceptions-ElementNotVisibleException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-ElementNotVisibleException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.ElementNotVisibleException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.ElementNotVisibleException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：元素不可见，不能操作    解决思路：检查元素是否带有display:none属性</code></pre><h4 id="selenium-common-exceptions-InvalidSwitchToTargetException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-InvalidSwitchToTargetException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.InvalidSwitchToTargetException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.InvalidSwitchToTargetException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：切换窗口或框架不存在    解决思路：检查页面元素，查看是否存在此类窗口或检查定位元素</code></pre><h4 id="selenium-common-exceptions-NoSuchWindowException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None"><a href="#selenium-common-exceptions-NoSuchWindowException-msg-x3D-None-screen-x3D-None-stacktrace-x3D-None" class="headerlink" title="selenium.common.exceptions.NoSuchWindowException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)"></a>selenium.common.exceptions.NoSuchWindowException(msg&#x3D;None, screen&#x3D;None, stacktrace&#x3D;None)</h4><pre><code>    描述：目标窗口不存在    解决思路：打印窗口信息，核对切换的窗口是否存在</code></pre><h2 id="二、关于selenium中webdriver版本报错"><a href="#二、关于selenium中webdriver版本报错" class="headerlink" title="二、关于selenium中webdriver版本报错"></a>二、关于selenium中webdriver版本报错</h2><p>###报错信息<br>####selenium.common.exceptions.SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 95 Current browser version is 100.0.4896.88 with binary path C:\Program Files\Google\Chrome\Application\chrome.exe<br>解决办法<br>查看Chrome版本<br>chrome:&#x2F;&#x2F;settings&#x2F;help<br><img src="/assets/2/image-20220515152357-6kac3mb.png" alt="image.png"></p><p>webdriver下载地址<br><a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></p><p>永久解决办法<br>关闭Chrome版本更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇到过的还未解决的吧。&quot;&gt;&lt;a href=&quot;#一、前面也学了很多的selenium元素定位了，相信肯定也是遇到了很多的问题，此处列举出一些，来看看是否有你遇</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="01_selenium" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01-selenium/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>selenium-webdriver基础操作二</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/04_selenium-webdriver%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BA%8C/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/04_selenium-webdriver%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BA%8C/</id>
    <published>2022-05-15T07:02:34.152Z</published>
    <updated>2022-05-15T07:15:53.438Z</updated>
    
    <content type="html"><![CDATA[<p>查找页面元素<br>前置条件：①Firefox浏览器 ②例子里的网页为<a href="https://www.baidu.com/">https://www.baidu.com</a></p><p>1.按id属性查找  一般作为查找元素的首选属性  注意特殊情况-动态id</p><pre><code>from selenium import webdriver  # 从selenium库导入网络驱动包from time import sleep          # 从time库导入sleepfrom selenium.webdriver.common.by import By  # 用于对象的定位 browser = webdriver.Firefox()         # 定义一个变量browser，代表浏览器的驱动browser.get(&#39;https://www.baidu.com&#39;)  # 打开浏览器browser.maximize_window()             # 窗口最大化 browser.find_element(By.ID, &#39;kw&#39;).send_keys(&#39;Selenium&#39;)  # 在百度输入栏内输入Seleniumbrowser.find_element(By.ID, &#39;su&#39;).click()                # 点击“百度一下”sleep(2)</code></pre><p>2 class定位 可能重复</p><pre><code>browser.find_element(By.CLASS_NAME, &#39;s_ipt&#39;).send_keys(&#39;Selenium&#39;)browser.find_element(By.CLASS_NAME, &#39;s_btn&#39;).click()sleep(3)</code></pre><p>3 tag定位  极其容易重复</p><pre><code>browser.find_element(By.TAG_NAME, &#39;input&#39;).send_keys(&#39;Selenium&#39;)# 报错：ElementNotInteractableException 元素不可输入异常</code></pre><p>4 name定位 可能重复</p><pre><code>browser.find_element(By.NAME, &#39;wd&#39;).send_keys(&#39;Selenium&#39;)browser.find_element(By.ID, &#39;su&#39;).click()</code></pre><p>5 link精确定位</p><pre><code>browser.find_element(By.LINK_TEXT, &#39;新闻&#39;).click()</code></pre><p>6 link模糊定位</p><pre><code>browser.find_element(By.PARTIAL_LINK_TEXT, &#39;闻&#39;).click()</code></pre><p>7 CSS定位<br>7.1 id定位</p><pre><code>browser.find_element(By.CSS_SELECTOR, &#39;#kw&#39;).send_keys(&#39;Selenium&#39;)</code></pre><p>7.2 tag定位</p><pre><code>browser.find_element(By.CSS_SELECTOR, &#39;input&#39;).send_keys(&#39;Selenium&#39;)</code></pre><p>7.3 class定位</p><pre><code>browser.find_element(By.CSS_SELECTOR, &#39;.s_ipt&#39;).send_keys(&#39;Selenium&#39;)</code></pre><p>7.4 其余属性定位   [属性名&#x3D;’属性值’]</p><pre><code>browser.find_element(By.CSS_SELECTOR, &#39;[name=&quot;wd&quot;]&#39;).send_keys(&#39;Selenium&#39;)browser.find_element(By.CSS_SELECTOR, &#39;[maxlength=&quot;255&quot;]&#39;).send_keys(&#39;Selenium&#39;)</code></pre><p>7.5 父子定位 即层级定位</p><pre><code>browser.find_element(By.CSS_SELECTOR, &#39;span&gt;input&#39;).send_keys(&#39;Selenium&#39;)</code></pre><p>7.6 组合定位 特别不容易定位时才考虑</p><pre><code>browser.find_element(By.CSS_SELECTOR, &#39;span.quickdelete-wrap&gt;input[maxlength=&quot;255&quot;][name=&quot;wd&quot;]&#39;).send_keys(&#39;Selenium&#39;)</code></pre><p>8 XPATH定位</p><pre><code>browser.find_element(By.XPATH, &#39;//*[@id=&quot;kw&quot;]&#39;).send_keys(&#39;Selenium&#39;)</code></pre><p>在每一步骤间最好设定好sleep时间，可以解决响应延迟带来的问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查找页面元素&lt;br&gt;前置条件：①Firefox浏览器 ②例子里的网页为&lt;a href=&quot;https://www.baidu.com/&quot;&gt;https://www.baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.按id属性查找  一般作为查找元素的首选属性  注意特殊情况-动态i</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="01_selenium" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01-selenium/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>selenium-webdriver基础操作一</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/03_selenium-webdriver%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%80/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/03_selenium-webdriver%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%80/</id>
    <published>2022-05-15T07:02:33.182Z</published>
    <updated>2022-05-15T07:08:22.579Z</updated>
    
    <content type="html"><![CDATA[<p>基于Firefox浏览器的基本操作<br>1.浏览器的导航操作</p><pre><code>from selenium import webdriver        #从selenium库中导入webdriver模块firefox = webdriver.Firefox()         #定义一个firefox变量，用于代指浏览器firefox.get(&quot;https://www.baidu.com&quot;)  #打开浏览器并进入百度网页</code></pre><p>后退、前进、刷新操作对应的代码为：</p><pre><code>driver.back()    #后退driver.forward() #前进driver.refresh() #刷新</code></pre><p>2.浏览器的窗口操作<br>—窗口的位置和大小在一定程度上会影响页面的显示和操作，Selenium提供了一些函数，用于调整浏览器窗口的位置和大小，以及关闭浏览器的窗口等操作。</p><p>窗口最大化、最小化以及关闭操作的代码如下：</p><pre><code>driver.minimize_window()  #最大化窗口driver.minimize_window()  #最小化窗口driver.close()            #关闭窗口</code></pre><pre><code>也可以引入time模块，使用sleep函数在每个操作间休眠，具体示例代码如下：</code></pre><pre><code>from selenium import webdriver        #从selenium库中导入webdriver模块import time                           #引入time模块firefox = webdriver.Firefox()         #定义一个firefox变量，用于代指浏览器firefox.get(&quot;https://www.baidu.com&quot;)  #打开浏览器并进入百度网页firefox.maximize_window()             #最大化窗口time.sleep(3)                         #sleep函数，用于每个操作间休眠3秒firefox.quit()                        #关闭浏览器</code></pre><p>上述代码还可获知，关闭浏览器的代码是.quit()</p><p>3.获取浏览器信息<br>最常用的的获取：</p><pre><code>driver.title         #获取浏览器窗口的当前标题drive.current_url    #获取浏览器窗口的当前网址driver.get_window_position()    #获取位置对象driver.get_window_size()        #获取大小对象driver.get_window_rect()        #获取位置以及大小对象</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于Firefox浏览器的基本操作&lt;br&gt;1.浏览器的导航操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from selenium import webdriver        #从selenium库中导入webdriver模块
firefox = webdriver.Firefo</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="01_selenium" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01-selenium/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>selenium-webdriver基础操作</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/02_selenium-webdriver%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01_selenium/02_selenium-webdriver%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2022-05-15T06:47:30.528Z</published>
    <updated>2022-05-15T07:25:52.407Z</updated>
    
    <content type="html"><![CDATA[<p>这是<strong>Selenium</strong>里面最总要的东西。 <strong>Selenium Webdriver</strong> （也就是 <strong>Selenium2，Selenium3</strong> ）和 <strong>Selenium RC</strong> （ <strong>Selenium 1</strong> ）一样提供了<strong>web</strong>自动化的各种语言调用接口库。相比 <strong>Selenium RC</strong> ，<strong>Selenium WebDriver</strong>的编程接口更加直观易懂，也更加简练。但是和<strong>Selenium RC</strong>不同的是，<strong>Selenium Webdriver</strong>是通过各种浏览器的驱动（ <strong>web driver</strong> ）来驱动浏览器的，而不是通过注入<strong>JavaScript</strong>的方式，下面是其原理的示意图：</p><p><img src="/assets/2/image-20220515145116-jknthhg.png" alt="image.png"></p><p>image.png</p><p>我们的代码运行起来是一个进程，里面调用<strong>Selenium WebDriver</strong>的库 和 各个浏览器的驱动进程 进行交互，传递<strong>Selenium</strong>命令 给它们，并且获取命令执行的结果，返回给我们的代码进行处理。</p><p><strong>Selenium WebDriver</strong>目前包括两个版本<strong>Selenium 2</strong>和 <strong>Selenium 3</strong> 。这两个版本从开发代码调用接口上来看，几乎没什么区别。区别在于库的实现和<strong>web driver</strong>的实现。<strong>Selenium2</strong>是<strong>Selenium</strong>组织帮各种浏览器写<strong>web driver</strong>的，而<strong>Selenium 3</strong>里面的<strong>web driver</strong>是由各个浏览器厂商（ <strong>Apple,Google,Microsoft,Mozilla</strong> ）自己提供的。所以<strong>Selenium 3</strong>的自动化效率更高，成功率也更高。</p><p><strong>Selenium WebDriver</strong> 支持浏览器众多：</p><ul><li><strong>Google Chrome</strong></li><li><strong>Microsoft Internet Explorer 7，8，9，10，11</strong>在 <strong>Windows Vista，Windows 7，Windows 8，Windows 8.1.</strong></li><li>Microsoft Edge</li><li>Firefox</li><li>Safari</li><li>Opera</li></ul><h4 id="3-1安装"><a href="#3-1安装" class="headerlink" title="3.1安装"></a>3.1安装</h4><p><strong>Selenium WebDriver</strong>提供了各种语言的编程接口，来进行<strong>Web</strong>自动化开发。我们以<strong>Python</strong>来讲解它的使用。首先我们要确保<strong>Python</strong>解释器已经安装好了。由于我们习惯在<strong>Windows</strong>操作系统上进行操作，建议大家安装<strong>Python</strong>官方的<strong>Python 3.6</strong></p><ul><li><p>安装编程接口库</p><p><strong>python</strong>安装好后，我们用<strong>Pip</strong>来安装<strong>Selenium Web Driver</strong>的<strong>python</strong>库，执行下面的命令即可。（执行该命令之前，要确保<strong>python</strong>的<strong>script</strong>目录在系统环境变量<strong>path</strong>里面已经包括了）。命令为：<strong>pip install selenium</strong></p></li></ul><p>安装完成后，运行python解释器，执行命令 <strong>import selenium</strong> ，如果没有异常，则表示安装成功了，如下所示</p><p><img src="/assets/2/image-20220515145129-y4ykbjr.png" alt="image.png"></p><p>image.png</p><ul><li><p>安装各浏览器的驱动</p><p>当然我们是通过各浏览器的驱动程序 来操作浏览器的，所以，还要有各浏览器的驱动程序。我们主要以谷歌的<strong>chrome</strong>浏览器为例来演示。</p></li></ul><p><strong>chrom</strong>浏览器的 <strong>web driver</strong> （ <strong>chromedriver.exe</strong> ），可以在下面网址访问：</p><p><a href="https://links.jianshu.com/go?to=http://npm.taobao.org/mirrors/chromedriver/">http://npm.taobao.org/mirrors/chromedriver/</a></p><p> <strong>firefox</strong> （火狐浏览器）的 <strong>web driver （geckodriver.exe）</strong> 在这里访问：</p><p><a href="https://links.jianshu.com/go?to=https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a></p><p>其他浏览器驱动可以见下面列表:</p><p> <strong>Edge:</strong> <a href="https://links.jianshu.com/go?to=https://developer.microsoft.com/en-us/micrsosft-edage/tools/webdriver">https://developer.microsoft.com/en-us/micrsosft-edage/tools/webdriver</a></p><p> <strong>Safari:</strong> <a href="https://links.jianshu.com/go?to=https://webkit.org/blog/6900/webdriver-support-in-safari-10/">https://webkit.org/blog/6900/webdriver-support-in-safari-10/</a></p><h4 id="3-2从一个例子开始"><a href="#3-2从一个例子开始" class="headerlink" title="3.2从一个例子开始"></a>3.2从一个例子开始</h4><pre><code>#从selenium里面导入webdriverfrom selenium import webdriver#指定chrom的驱动#执行到这里的时候Selenium会到指定的路径将chrome driver程序运行起来driver = webdriver.Chrome(&#39;E:\ChromDriver\chromedriver.exe&#39;)#driver = webdriver.Firefox()#这里是火狐的浏览器运行方法#get 方法 打开指定网址driver.get(&#39;http://www.baidu.com&#39;)#选择网页元素element_keyword = driver.find_element_by_id(&#39;kw&#39;)#输入字符element_keyword.send_keys(&#39;宋曲&#39;)#找到搜索按钮element_search_button = driver.find_element_by_id(&#39;su&#39;)</code></pre><p>下面是对搜索结果的验证：</p><pre><code>import time#注意这里必须要等待时间，因为代码运行过快，代码运行完的时候页面还没加载出来就会找不到元素time.sleep(2)ret = driver.find_element_by_id(&#39;1&#39;)print(ret.text)if ret.text.startswith(&#39;宋曲&#39;):#是不是已宋曲开头    print(&#39;测试通过&#39;)else:    print(&#39;不通过&#39;)#最后，driver.quit()让浏览器和驱动进程一起退出，不然桌面会有好多窗口driver.quit()</code></pre><p>下面是对代码的详细分析：</p><pre><code>driver = webdriver.Chrome(&#39;E:\ChromDriver\chromedriver.exe&#39;)</code></pre><p>执行到这里的时候<strong>Selenium</strong>会到指定的路径将<strong>chrom driver</strong>程序运行起来，<strong>chrome driver</strong>会将浏览器运行起来。成功后会返回一个<strong>WebDriver</strong>实例对象，通过它的方法，可以控制浏览器，我们可以把它想象成浏览器的遥控器一样。</p><p>浏览器运行起来后，通常第一件事情就是打开网址了。一般我们通过控制对象的<strong>get</strong>方法来控制浏览器打开指定网址</p><pre><code>driver.get(&#39;http://www.baidu.com&#39;)</code></pre><p>这一行执行后，<strong>web</strong>浏览器将会访问<code>http://www.baidu.com</code>这个网址。<strong>Selenium</strong>的官方文档说，不同的<strong>WebDriver</strong>和浏览器行为可能会有所不同。有的浏览器不一定等<strong>web</strong>页面完全加载完成，就返回了。当然通常我们希望的是加载完毕，再返回，不然可能页面上有的元素还没有出现，后续的操作可能有问题。这样还需要加入一些其他的代码等待某个关键的页面元素出现再进行后续操作。个人测试的情况看，<strong>Selenium 3</strong>的<strong>Chrom WebDriver</strong>驱动相应的<strong>chrom</strong>浏览器是会等待页面完全加载完成才返回的。所以我们可以放心。</p><p>接下来我们要查找到那个搜索输入栏网页元素，这里是根据该网页元素的<strong>id</strong>来选择的。</p><pre><code>element_keyword = driver.find_element_by_id(&#39;kw&#39;)</code></pre><p>网页元素的信息可以通过浏览器的<strong>debug</strong>功能来查看。怎么寻找网页元素，可以说是<strong>web</strong>自动化最重要的东西之一。下一节会讲到。</p><p><strong>driver</strong>找到该元素的话，就会返回一个该元素的<strong>WebElement</strong>对象。我们接着就可以对其进行操作了，这个例子里面的操作，就是在这个输入框里面输入字符。</p><pre><code>element_keyword.send_keys(&#39;宋曲&#39;)</code></pre><p>后面就是在进行一次元素的选择和操作，找到搜索按钮，点击它。最后，执行下面的代码让浏览器和驱动进程一起退出</p><pre><code>driver.quit()</code></pre><p>这里大家要注意代码里我们用了 <strong>time</strong> ，<strong>注意这里必须</strong>要等待时间，因为代码运行过快，代码运行完的时候页面还没加载出来就会找不到元素。后面我们会想到更好的解决方法。</p><h4 id="3-3-Web元素选择"><a href="#3-3-Web元素选择" class="headerlink" title="3.3 Web元素选择"></a>3.3 Web元素选择</h4><p>浏览器读入页面文档（html格式）后，通过内置的 <strong>layout engine</strong> （就是页面渲染引擎，也成为浏览器内核，比如 <strong>Webkit、Gecko</strong> ）将整个页面显示出我们看到的样子。我们人在看<strong>web</strong>页面的时候，是用眼睛视觉上<strong>web</strong>页面的元素，比如上面有个输入框。下面有个按钮。可是对浏览器这个程序来说，他会创建一个 <strong>HTML DOM（Document Object Model）</strong> 来理解和操作整个页面结构。这是一个树状的结构，下面是一张示意图：</p><p><strong>DOM</strong>是<strong>W3C</strong>指定的标准，<strong>DOM</strong>是由一个个的 <strong>node</strong> （节点）组成。而 <strong>element</strong> （元素）是最重要的一种 <strong>node</strong> ，他是<strong>html</strong>中一个<strong>tag</strong>里面的内容，比如</p><pre><code>&lt;a href=&quot;www.baidu.com&quot;&gt;My link&lt;/a&gt;</code></pre><p>这个 <strong><a></strong> 就是一个 <strong>element</strong> ，我们中文称之为元素。<strong>HTML DOM</strong>就是一个用来给程序增删改查<strong>HTML</strong>元素的接口。</p><p>所以，我们在程序中选择元素，就是在网页的<strong>DOM</strong>结构里选择元素。就像上面说的，<strong>web</strong>元素的选择，是<strong>Selenium</strong>开发的重中之重。因为，我们首先必须要找到<strong>web</strong>元素，才能对其进行操作。<strong>web</strong>元素的选择，在<strong>Selenium</strong>可以通过<strong>WebDriver</strong>对象，也可以通过<strong>WebElement</strong>对象选择，它们都有成员 方法来进行选择。通过<strong>WebDriver</strong>对象选择，查找范围是 <strong>整个html文档</strong> 。而通过WebElement对象选择，查找范围是整个该对象的子元素，<strong>web</strong>元素的选择，有好几种方式。下面会一一讲述。</p><h4 id="3-3-1通过id选择属性"><a href="#3-3-1通过id选择属性" class="headerlink" title="3.3.1通过id选择属性"></a>3.3.1通过id选择属性</h4><p><strong>web</strong>元素可以有很多属性（ <strong>attribute</strong> ）</p><blockquote><p>&lt;input <strong>id&#x3D;”kw” name&#x3D;”wd” class&#x3D;”s_ipt” value&#x3D;”” maxlength&#x3D;”255” autocomplete&#x3D;”off”&gt;</strong></p></blockquote><p>上面元素的属性被用黑体显示了。这些属性中，id是非常特殊的一个，它是在<strong>DOM</strong>中唯一标志这个元素的。所以，如果<strong>web</strong>元素有<strong>id</strong>属性的话，是最好查找的，也是效率最高的，通过<strong>id</strong>就唯一的找到了它。</p><p>要找到该元素，可以用下面的方法</p><pre><code>element = driver.find_element_by_id(&quot;kw&quot;)</code></pre><p>或者换一种写法，导入Selenium by这个类，效果是一样的，个人更喜欢上面的方法</p><pre><code>from selenium.webdriver.common.by import Byelement = driver.find_element(by=By.ID, value=&quot;kw&quot;)</code></pre><p>都是可以的，大家以后看到别人的代码这样写，不要感到吃惊</p><p> <strong>注</strong> ：<strong>id</strong>其实还有重复的，虽然我们讲<strong>id</strong>不应该重复</p><p>的，但是有的人可能写错了，如果有重复的假如说你要查个某个<strong>id</strong>通过<strong>Webdriver</strong>对象查找，他查找的是整个页面查找的是第一个符合条件的，他可能不是你想要的，你可以先通过先缩小查找范围，先查找他的父节点 <strong>id</strong> ，再通过父节点<strong>id</strong>再去<strong>find_element_by_id</strong>这样就限制他的范围了，这是一种常用的方法。</p><p>没有找到会抛出如下异常</p><pre><code>selenium.common.exceptions.NoSuchElementException</code></pre><p>如果抛出异常，后面的程序就执行不到了，假如</p><p>你不希望由于某一个异常导致程序结束的话，我们可以加一个异常的捕获</p><pre><code>from selenium.common.exceptions import NoSuchElementExceptiontry:    ele = driver.find_element_by_id(&quot;food333&quot;)except NoSuchElementException:    print(&#39;NoSuchElementException&#39;)</code></pre><h4 id="3-3-2获取元素-inner-Text"><a href="#3-3-2获取元素-inner-Text" class="headerlink" title="3.3.2获取元素 inner Text"></a>3.3.2获取元素 inner Text</h4><p><strong>innerText</strong> 是 <strong>DOM</strong>节点的属性，它代表了 <strong>node</strong> 节点（通常是元素）可以显示出来的文本内容。通俗点说，就是我们能在界面上看到的文本内容，比如按钮上的问题、输入框里面的内容、 <strong><p></strong> 元素的内容、链接的文本内容，等等。可想而知，这是我们经常需要获取的东西。<strong>Selenium</strong> 通过 <strong>Webdriver</strong> 的 <strong>text</strong>属性来获取其内容。下面的代码将当前页面上的 <strong>id</strong> 为 <strong>1</strong> 的元素的可见文本打印出来。代码实例如下</p><ul><li><p><strong>text</strong>属性 显示该元素在<strong>web</strong>页面显示出来的文本内容。</p><pre><code>ret = driver.find_element_by_id(&#39;1&#39;)print(ret.text)</code></pre></li><li><p>我们有的时候，希望获取的不是某个元素的页面展示部分，而是它的一个属性的值， 这时候，我们可以通过一个方法<strong>get_attribute</strong>方法，这个方法就是返回元素的某个属性的值。看下面示例：</p></li></ul><blockquote><p>&lt;a href&#x3D;”<a href="https://links.jianshu.com/go?to=http://www.baidu.com">http://www.baidu.com</a>“ id&#x3D;”baidulink&gt;转到百度</a></p></blockquote><p>下面的代码就是获取<strong>href</strong>属性的值，就获取到了链接</p><pre><code>ele = driver.find_element_by_id(&quot;baidulink&quot;)print (ele.get_attribute(&#39;href&#39;))</code></pre><ul><li><p>有的时候，我们需要完整的获取这个元素对应的<strong>html</strong>进行分析，比如</p><p>我们还是通过<strong>get_attribute</strong>方法，只需要参数指定为<strong>outerHTML</strong>就可以了。</p><pre><code>ele = driver.find_element_by_id(&quot;baidulink&quot;)print (ele.get_attribute(&#39;outerHTML &#39;))</code></pre></li></ul><p>上面代码输出的结果就是：</p><pre><code>&lt;a href=&quot;http://www.baidu.com&quot; id=&quot;baidulink&gt;转到百度&lt;/a&gt;</code></pre><ul><li><p>如果我们只想获取 该元素的内部的<strong>html</strong>源代码，我们还是通过<strong>get_attribute</strong>方法， 只需要参数指定为<strong>innerHTML</strong>就可以了。</p><pre><code>ele = driver.find_element_by_id(&quot;baidulink&quot;)print (ele.get_attribute(&#39;innerHTML&#39;))</code></pre></li></ul><p>上面代码输出结果就是：</p><pre><code>转到百度</code></pre><p>有如下一段<strong>html</strong></p><pre><code>div id=&quot;food&quot; style=&quot;margin-top:10px;color:red&quot;&gt;    &lt;span calss=&quot;vegetable good&quot;&gt;黄瓜&lt;/span&gt;    &lt;span calss=&quot;meat&quot;&gt;牛肉&lt;/span&gt;    &lt;p calss=&quot;vegetable&quot;&gt;南瓜&lt;/p&gt;    &lt;p calss=&quot;vegetable&quot;&gt;青菜&lt;/p&gt;</code></pre><p>用attribute(‘innerHTML’)方法获取该元素的内部的html源代码效果如下:</p><pre><code>ele = driver.find_element_by_id(&quot;food&quot;)print (ele.get_attribute(&#39;innerHTML&#39;))</code></pre><p>上面代码输出结果就是：</p><pre><code>    &lt;span calss=&quot;vegetable good&quot;&gt;黄瓜&lt;/span&gt;    &lt;span calss=&quot;meat&quot;&gt;黄瓜&lt;/span&gt;    &lt;p calss=&quot;vegetable&quot;&gt;南瓜&lt;/p&gt;    &lt;p calss=&quot;vegetable&quot;&gt;青菜&lt;/p&gt;</code></pre><p>就是这个元素的内部的内容，不包括它本身的这段。</p><p>各位可能会疑惑我们获取这些东西干嘛？我们为什么要或整个<strong>html</strong>呢，因为有的时候我们开发自动化程序的时候，比如测试不通过，某个点不通过，这个时候想把比如说选择元素没选择到，或者元素的内容和预期的内容不一样，这个时候需要判断分析定位，这个时候把它放在自动化用例里面，就可以把他整个<strong>html</strong>信息弄回来，把它打印到日志里面，方便自动化用例执行完了用来分析和判断，用来定位问题的一种手段。</p><p>还有一种场景有时候你去选择一个元素的时候根据常规手段，无法去获取选择内容了比如看下面的例子。</p><pre><code>div id=&quot;food&quot; style=&quot;margin-top:10px;color:red&quot;&gt;    &lt;span calss=&quot;vegetable good&quot;&gt;黄瓜&lt;/span&gt;    &lt;span calss=&quot;meat&quot;&gt;牛肉&lt;/span&gt;    &lt;p calss=&quot;vegetable&quot;&gt;南瓜&lt;/p&gt;    &lt;p calss=&quot;vegetable&quot;&gt;青菜&lt;/p&gt;</code></pre><p>假如我要获取牛肉他的<strong>class</strong>属性是否是 <strong>meat</strong> ，我们后面学到的选择元素方法是很简单获取到的，假如根据现在的知识点，只有父元素有<strong>id</strong>他本身没有<strong>id</strong>的，根据当前的知识点获取不到他，那怎么办呢？我们可以把有<strong>id</strong>的父元素整个<strong>HTML</strong>拿回来，通过 <strong>get_arrtibute(innerHTML)</strong> 方法拿回来，然后通过 <strong>split()</strong> 切割字符串的方法得到。</p><p>代码如下：</p><pre><code>#找到id为food的元素ele = driver.find_element_by_id(&#39;food&#39;)#通过get_attribute(&#39;innerHTML&#39;)方法拿到内部元素foodText = ele.get_attribute(&#39;innerHTML&#39;)#通过split()方法得到数据ret1 = foodText.split(&#39;&lt;/span&gt;)[1]ret2 = ret1.split(&#39;&quot;&#39;)[1]</code></pre><p>通过这样一个方法，我们就得到了<strong>meat</strong>上面这种方法当然可以达到目的，但是比较丑陋代码多了一点让人费解，更重要的是不够健壮，比如属性值可以用单引号也可以用双引号，如果开发下次改代码改成了单引号，我们的代码就没用了。</p><p>我们怎么样让程序更健壮一点呢，不需要那么麻烦使用字符串分割，我们可以使用另外一种方法<strong>BeautifulSoup4</strong>这个库。</p><h4 id="3-3-3-BeautifulSoup4的介绍与安装"><a href="#3-3-3-BeautifulSoup4的介绍与安装" class="headerlink" title="3.3.3 BeautifulSoup4的介绍与安装"></a>3.3.3 BeautifulSoup4的介绍与安装</h4><p><strong>BS</strong>是可以从<strong>HTML</strong>或<strong>XMl</strong>文件中提取数据的库,他就是一个让你来<strong>HTML</strong>的工具，他可以把信息提取出来，不需要用字符串切割这种方法<strong>Selenium</strong>可以 用来远程获取数据。有的时候，感觉用<strong>Selenium</strong>获取某些元素数据不太方便</p><p>我们可以将它 和 <strong>Selenium</strong>两种技术融合使用达到我们的目的。</p><p><strong>beautifulSoup4</strong> 和** Selenium <strong>的关系：直接的讲他们 两者没有直接关系，</strong> beautifulSoup4** 是<strong>python</strong>程序直接对一个字符串进行分析的，这个字符串要符合<strong>HTML</strong>或<strong>XMl</strong>的格式，他是专门用来处理<strong>HTML</strong>或<strong>XMl</strong>格式的字符串的，他和<strong>selenium</strong>自动化没有直接的关系。他是<strong>python</strong>语言独有的</p><p><strong>beautifulSoup4</strong> 中文文档大家可以看一下：</p><p><a href="https://links.jianshu.com/go?to=https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</a></p><ul><li><p>安装编程接口库</p><p>我们用<strong>Pip</strong>来安装<strong>BeautifulSoup4</strong>这个库，执行下面的命令即可。（执行该命令之前，要确保<strong>python</strong>的<strong>script</strong>目录在系统环境变量<strong>path</strong>里面已经包括了）。命令为：<strong>pip install beautifulsoup4</strong></p></li></ul><p>安装好<strong>beautifulsoup</strong>之后强烈要求大家安装<strong>html5lib</strong> 这个库，如果大家要进行<strong>HTML</strong>分析的话，因为<strong>beautifulsoup4</strong>内置分析<strong>HTML</strong>他对<strong>HTML</strong>语法兼容性不够好，指定用<strong>html5lib</strong>来分析，<strong>html5lib</strong>库对<strong>HTML</strong>兼容性比较好，这个库对<strong>html</strong>的兼容性基本和浏览器差不多。</p><ul><li><p>安装<strong>html5lib</strong></p><p><strong>pip install html5lib</strong></p></li></ul><h4 id="3-3-4-BeautifulSoup4的使用"><a href="#3-3-4-BeautifulSoup4的使用" class="headerlink" title="3.3.4 BeautifulSoup4的使用"></a>3.3.4 BeautifulSoup4的使用</h4><p>现在我们根据一个例子来讲解如何使用 <strong>bs</strong> ，本地有一个<strong>html</strong>文档，注意他只是本地的一个磁盘文件和Selenium没有关系，如下</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;三兄弟的故事&lt;/title&gt;    &lt;title&gt;三兄弟的故事23454554545&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class=&quot;title tile2&quot; style=&quot;color:red&quot;&gt;&lt;b&gt;三兄弟的故事&lt;/b&gt;&lt;/p&gt;    &lt;p class=&quot;story&quot;&gt;从前有三个兄弟，他们的名字是    &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;张三&lt;/a&gt;,    &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;李四&lt;/a&gt; 和    &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;王二&lt;/a&gt;;    他们都住在一口井里.&lt;/p&gt;    &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;    &lt;div id=&quot;d1&quot;&gt;        &lt;a href=&quot;http://baidu.com/tillie&quot; class=&quot;sister&quot; &gt;百度&lt;/a&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>下面是使用<strong>BeautifulSoup</strong>库处理<strong>HTML</strong>字符串</p><pre><code>with open(&#39;bs1.html&#39;,encoding=&#39;utf8&#39;) as f:    html_doc = f.read()#从bs4这个库导入BeautifulSoup对象from bs4 import BeautifulSoup#指定用html5lib来解析文档soup = BeautifulSoup(html_doc,&#39;html5lib&#39;)</code></pre><p>下面我们从<strong>html</strong>文档获取我们想要获取的信息，比如说获取一个标签名为<strong>title</strong>的元素，怎么做呢？看示例</p><pre><code># 查找 标签名为title的第一个元素 ，# 返回一个 &lt;class &#39;bs4.element.Tag&#39;&gt; 实例print(soup.find(&#39;title&#39;))</code></pre><p><strong>find</strong>就是找，这里我们找到的是标签名为<strong>title</strong>的元素.</p><pre><code>&lt;titile&gt;三兄弟的故事&lt;/title&gt;</code></pre><p>大家看我上面<strong>HTML</strong>的截图，里面有两个元素标签名为 <strong>title</strong> ，他找的是第一个，这里代码运行会很快因为我们是本地运行，不需要和浏览器交互和<strong>Selenium</strong>没关系，假如我们想要获取<strong>title</strong>的内容进行分析的话该怎么办？</p><p>可以用<strong>string</strong>方法</p><pre><code>#.string就是获取内部的内容print(soup.find(title).string)#也可以这样写print(soup.title.string)</code></pre><p>也可以用<strong>get</strong></p><pre><code>print(soup.find(title).get_text())#也可以这样写print(soup.title.get_text())</code></pre><p>输出结果为:</p><pre><code>三兄弟的故事</code></pre><p>这两种方法是有区别的，建议大家使用get_text()方法，下面给大家举个例子，看下面的<strong>html</strong></p><pre><code>&lt;div id=&quot;dl&quot;&gt;    &lt;a herf=&quot;http://baidu.com/tillie&quot; class=&quot;sister&quot;&gt;百度&lt;/a&gt;&gt;&lt;div&gt;   </code></pre><p>如果想要获取<strong>div</strong>元素里面的文本内容，百度并不是直接内容，是他子节点的内容，这个时候就用 <strong>get_text()</strong> 才能获取到“百度”，如果用**.string<strong>的话会打印出 <strong>“None”</strong> ，</strong>None<strong>就是没有因为</strong>string<strong>优先显示</strong>div**元素的直接文本，但是这里面的文本是他子元素的文本，所以建议大家优先使用 <strong>get_text()</strong> 。</p><p>目前我们只简单介绍了<strong>BeautifulSoup</strong>如果获取文本，这还没有什么神奇的，我们还可以进行更为复杂的分析，比如我们想获取其中某一个属性的值，我们要获取第一个<strong>a</strong>的<strong>class</strong>属性值</p><pre><code>&lt;body&gt;    &lt;p class=&quot;title tile2&quot; style=&quot;color:red&quot;&gt;&lt;b&gt;三兄弟的故事&lt;/b&gt;&lt;/p&gt;    &lt;p class=&quot;story&quot;&gt;从前有三个兄弟，他们的名字是    &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;张三&lt;/a&gt;,    &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;李四&lt;/a&gt; 和    &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;王二&lt;/a&gt;;    他们都住在一口井里.&lt;/p&gt;</code></pre><p>那我们该怎么写呢？</p><pre><code>#第一种方法print(soup.find(&#39;a&#39;)[&#39;class&#39;])#第二种方法print(soup.a[&#39;calss&#39;])</code></pre><p>就获取到了第一个<strong>a</strong>的<strong>class</strong>属性的值，这样我们就可以获取属性的值了，讲到这里大家发现我们都是找第一个元素，如果我想找第三个第四个怎么办?<strong>find</strong>还有一个方法叫 <strong>find_all</strong> ，那我们要找到所有的a该怎么写呢？？</p><pre><code>print(soup.find_all(&#39;a&#39;))</code></pre><p>这个时候打印出来的是一个列表，就全找到了</p><pre><code>[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;张三&lt;/a&gt;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;李四&lt;/a&gt;,  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;王二&lt;/a&gt;, &lt;a class=&quot;sister&quot; href=&quot;http://baidu.com/tillie&quot;&gt;百度&lt;/a&gt;, &lt;a class=&quot;sister&quot; herf=&quot;http://baidu.com/tillie&quot;&gt;百度&lt;/a&gt;]</code></pre><p>我们想找第二个怎么办，直接用<strong>python</strong>的知识下标。</p><pre><code>print(soup.find_all(&#39;a&#39;))[1]</code></pre><p>就找到李四了，这种方法有时候比较麻烦，有的时候网页很大很大，比如有上百个 <strong>a</strong> ，你要找第几个你也不知道，一个个数肯定不现实，那怎么办？还一种方法根本不需要<strong>find_all</strong>把所有的都找出来再通过下标去找，可以通过其他的属性还限定他，假如说我们要找第二个 <strong>a</strong> ，发现他有id这个时候我们可以通过id属性来找。</p><pre><code>print(soup.find(&#39;a&#39;，id=&#39;link2&#39;))</code></pre><p>通过上面的代码就可以直接找到他，不一定要用<strong>id</strong>属性，任何属性都可以</p><p>这里就可以发现<strong>BeautifulSoup</strong>可以进行数据的提取，我们甚至可以用多个条件进行提取。</p><pre><code>print(soup.find(&#39;a&#39;，id=&#39;link2&#39;,herf=&#39;http://exaple.com/lacie&#39;))</code></pre><p>大家还记得上面我们想获取牛肉的<strong>calss</strong>属性是否是 <strong>meat</strong> ，当时我们用<strong>python</strong>字符串切割的方法得到的，我们可以通过<strong>BeautifulSoup</strong>直接获取啦！</p><pre><code>ele = driver.find_element_by_id(&#39;food&#39;)html= ele.get_Attribute(&#39;innerHTML)print(html)from bs4 import BeautifulSoupsoup = BeautifulSoup(html,&#39;html5lib&#39;)target = soup.find_all(&#39;span&#39;)[1][&#39;class&#39;]#列表print(taget)</code></pre><p>这种写法更稳定可靠，写法有很多种下面再介绍一种写法,目的就是判断值是不是 <strong>meat</strong> ，我们直接根据<strong>class</strong>属性去找，如果我们根据<strong>class</strong>等于<strong>meat</strong>能找到说明也有。</p><pre><code>from bs4 import BeautifulSoup soup = BeautifulSoup(html,&#39;html5lib&#39;)target = soup.find(&#39;span&#39;,&#123;&#39;class&#39;:&#39;meat&#39;&#125;)if target：  print(&#39;是meat&#39;)print(taget)</code></pre><p>注意这里不能直接这样写 <strong>find(‘span’,class&#x3D;’meat’)，</strong> 因为<strong>class</strong>是我们定义类的关键字</p><h4 id="3-3-5-查看元素的属性"><a href="#3-3-5-查看元素的属性" class="headerlink" title="3.3.5 查看元素的属性"></a>3.3.5 查看元素的属性</h4><p>上面讲了可以根据<strong>id</strong>来查找元素，可是，面对一个别人开发的网页，我们怎么知道元素的属性值呢？现在，基本上每款浏览器都会内置开发者工具（通常是在浏览器窗口下按<strong>F12</strong>按键打开），我们可以利用浏览器的开发者工具来查看。在<strong>chrom</strong>浏览器里，按 <strong>F12</strong> ，打开开发工具窗口，<strong>chrom</strong>界面如下所示：</p><p><img src="/assets/2/image-20220515145819-e706oly.png" alt="image.png"></p><p>image.png</p><p>其中右边红框里面的窗口就是开发者工具窗口。它的功能非常强大，<strong>web</strong>前端开发人员经常用来调试前端代码。我们这里先使用它来查看<strong>web</strong>元素的属性信息。工具栏的上边最左边的箭头，就是用来选择界面元素，并且查看其信息用的。我们点击这个箭头，再异动鼠标到左边的页面上，点击一下搜索输入框，结果右边的开发工具窗口内容如下：</p><p><img src="/assets/2/image-20220515145828-29kjp8a.png" alt="image.png"></p><p>image.png</p><p>大家请注意红圈里面的内容，这里就是该输入框的<strong>html</strong>代码内容，里面的属性有<strong>id，name，class</strong>等。这样我们就可以知道该元素的信息了。这是<strong>Chrom</strong>浏览器的用法。事实上，其他浏览器基本也大同小异。大家可以自己尝试一下</p><h4 id="3-3-6-通过name属性选择"><a href="#3-3-6-通过name属性选择" class="headerlink" title="3.3.6 通过name属性选择"></a>3.3.6 通过name属性选择</h4><p><strong>name</strong>也是<strong>html</strong>标准属性之一，假设要选择的元素具有该属性的话，也可以通过它来进行选择。假设<strong>html</strong>中有如下元素：</p><pre><code>&lt;input name=&quot;cheese&quot; type=&quot;text&quot;/&gt;</code></pre><p>要找到该元素，可以用下面的方法:</p><pre><code>cheese = driver.find_element_by_name(&quot;cheese&quot;)</code></pre><p>或者：</p><pre><code>from selenium.webdriver.common.by import Bycheese = driver.find_element(By.NAME, &quot;cheese&quot;)</code></pre><p>要注意的是，和<strong>id</strong>不同，<strong>name</strong>不一定是唯一的（当然通常是唯一的）。</p><p>当指定选择的名字，在网页中有多个元素都具有时，返回的是第一个找到的元素。</p><p>如果我们要找出所有具有该名字的元素可以这样，代码如下：</p><pre><code>cheeses = driver.find_elements_by_name(&quot;cheese&quot;)</code></pre><p>或者：</p><pre><code>from selenium.webdriver.common.by import Bycheeses = driver.find_elements(By.NAME,&quot;cheese&quot;)</code></pre><p>这时，返回的是一个 <strong>python list</strong> ，里面包含了所有找到的<strong>WebElement</strong>对象,如果找不到，返回空列表，不抛出异常。</p><h4 id="3-3-7-通过class选择元素"><a href="#3-3-7-通过class选择元素" class="headerlink" title="3.3.7 通过class选择元素"></a>3.3.7 通过class选择元素</h4><p><strong>class</strong>也是html标准属性之一，假设要选择的元素具有该属性的话，也可以通过它来进行查找。但是通常具有相同<strong>class</strong> 属性值的元素很多，我们往往调用选择多个元素的方法，而不是选择一个元素。假设<strong>html</strong>中有如下片段：</p><pre><code>&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Cheddar&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;cheese&quot;&gt;&lt;span&gt;Gouda&lt;/span&gt;&lt;/div&gt;</code></pre><p>要找到该元素，可以用下面的方法:</p><pre><code>cheeses = driver.find_elements_by_class_name(&quot;cheese&quot;)</code></pre><p>或者：</p><pre><code>from selenium.webdriver.common.by import Bycheeses = driver.find_elements(By.CLASS_NAME, &quot;cheese&quot;)</code></pre><p>这时，返回的是一个python list，里面包含了所有找到的WebElement对象。</p><p>注意：通过elements这个返回的就不是一个webelement对象了，他是所有的符合条件的wedelement对象，既然是所有的返回的时候放在一个列表里面，所以他的返回值就是列表，这个时候我们就不能用这种写法了</p><pre><code>eles = find_elements_by_name(&#39;button&#39;)print(eles.get_attribute(&#39;outerHTMl&#39;))</code></pre><p>上面这种写法是不对的，因为eles是个列表，列表并没有get_attribute()方法，这个方法只有webelement对象才有的，只有列表里的每一个元素才有的，那我们该怎么写呢？</p><pre><code>eles = find_elements_by_name(&#39;button&#39;)for ele in eles:  print(ele.get_attribute(&#39;outerHTMl&#39;))</code></pre><p>这样就可以了，通过for循环去遍历class同理</p><h4 id="3-3-8通过-tag-名称选择"><a href="#3-3-8通过-tag-名称选择" class="headerlink" title="3.3.8通过 tag 名称选择"></a>3.3.8通过 tag 名称选择</h4><p>有的时候，有的上述的定位方式都不能定位到，比如 一个元素没有 <strong>id</strong> ，没有 <strong>class</strong> 、 <strong>name</strong> 。 但是它的<strong>tag</strong>名却是唯一的。可以根据<strong>tag</strong>名定位</p><p>假设<strong>html</strong>中有如下片段:</p><pre><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></pre><p>如果<strong>iframe</strong>这个tag在本html中是唯一的，可以根据<strong>iframe</strong>这个<strong>tag</strong>名来找到该元素:</p><pre><code>frame = driver.find_element_by_tag_name(&quot;iframe&quot;)</code></pre><p>或者：</p><pre><code>from selenium.webdriver.common.by import Byframe = driver.find_element(By.TAG_NAME, &quot;iframe&quot;)</code></pre><h4 id="3-3-9-通过链接文本选择"><a href="#3-3-9-通过链接文本选择" class="headerlink" title="3.3.9 通过链接文本选择"></a>3.3.9 通过链接文本选择</h4><p><strong>web</strong>自动化的时候，经常会自动化点击某个链接，对于链接，可以通过其链接文本的内容或者部分内容进行选择。假设html中有如下片段：</p><pre><code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;转到百度&lt;/a&gt;</code></pre><p>可以这样选择:</p><pre><code>ele = driver.find_element_by_link_text(&quot;转到百度&quot;)</code></pre><p>或者：</p><pre><code>from selenium.webdriver.common.by import Byele = driver.find_element(By.LINK_TEXT, &quot;转到百度&quot;)</code></pre><p>有的时候，链接的文本很长，我们甚至只需要通过部分文本去找到该链接元素只要这个链接文本是唯一的就行，可以这样选择。</p><pre><code>ele = driver.find_element_by_partial_link_text(&quot;百度&quot;)</code></pre><p>或者：</p><pre><code>from selenium.webdriver.common.by import Byele = driver.find_element(By.PARTIAL_LINK_TEXT, &quot;百度&quot;)</code></pre><hr><h4 id="下面是小练习，自己练习玩的"><a href="#下面是小练习，自己练习玩的" class="headerlink" title="下面是小练习，自己练习玩的"></a>下面是小练习，自己练习玩的</h4><p><strong>Selenium 练习1</strong></p><p>1.访问天气查询网站（网址如下），查询江苏省天气</p><p><a href="https://links.jianshu.com/go?to=http://www.weather.com.cn/html/province/jiangsu.shtml">http://www.weather.com.cn/html/province/jiangsu.shtml</a></p><p>获取江苏所有城市的天气，并找出其中每天最低气温最低的城市，显示出来，比如</p><p>温度最低为12℃, 城市有连云港 盐城</p><p> <strong>方法1：</strong> 取回 整个 <strong>html</strong> 代码片段， 用<strong>python</strong>语言， 直接分析</p><pre><code>from selenium import webdriverdriver = webdriver.Chrome(r&quot;d:\tools\webdrivers\chromedriver.exe&quot;)# ------------------------driver.get(&#39;http://www.weather.com.cn/html/province/jiangsu.shtml&#39;)ele = driver.find_element_by_id(&quot;forecastID&quot;)print(ele.text)citysWeather = ele.text.split(&#39;℃\n&#39;)# 这样：citysWeather是每个城市的温度信息 list## 每个元素像这样：# 南京# 12℃/27#下面就是算法，算出温度最低城市，# 有很多方法，大家看看这种# 我们循环 去遍历这个城市文档信息列表，# 得到城市名和 低气温的值，## 依次和取出当前的所有城市最低气温比较，# 如果更低，就记录到当前的低温城市列表中。lowest = None  #  记录目前最低温，先设置为NonelowestCitys = []  # 温度最低城市列表for one in citysWeather:    one = one.replace(&#39;℃&#39;,&#39;&#39;)    print(one)    parts = one.split(&#39;\n&#39;)    curcity = parts[0]    lowweather = min([int(one)  for one in parts[1].split(&#39;/&#39;)])    # 还没有最低温记录，或者发现气温更低的城市    # 注意 条件不能写反    if lowest==None or lowweather&lt;lowest:        lowest = lowweather        lowestCity = [curcity]    #  温度和当前最低相同，加入列表    elif lowweather ==lowest:        lowestCity.append(curcity)print(&#39;温度最低为%s℃, 城市有%s&#39; % (lowest, &#39; &#39;.join(lowestCity)))# ------------------------driver.quit()</code></pre><p> <strong>方法2：</strong> 用 <strong>selenium</strong> 直接的获取我们要的数据，我们分析一下 <strong>html</strong> ，看看能否精确的直接获取每个城市的名字和温度，发现每个城市的信息都在<strong>dl</strong>里面。</p><pre><code>driver.get(&#39;http://www.weather.com.cn/html/province/jiangsu.shtml&#39;)ele = driver.find_element_by_id(&quot;forecastID&quot;)print(ele.text)# 再从 forecastID 元素获取所有子元素dldls = ele.find_elements_by_tag_name(&#39;dl&#39;)# 将城市和气温信息保存到列表citys中citys = []for dl in dls:    # print dl.get_attribute(&#39;innerHTML&#39;)    name = dl.find_element_by_tag_name(&#39;dt&#39;).text    # 最高最低气温位置会变，根据位置决定是span还是b    ltemp = dl.find_element_by_tag_name(&#39;span&#39;).text    ltemp = int(ltemp.replace(&#39;℃&#39;,&#39;&#39;))    print(name, ltemp)    citys.append([name, ltemp])</code></pre><p>既然每个城市的名字和温度都有了， 下面的做法就和前面差不多</p><pre><code>lowest = NonelowestCitys = []  # 温度最低城市列表for one in citys:    curcity = one[0]    ltemp = one[1]    # 发现气温更低的城市    if lowest==None or ltemp&lt;lowest:        lowest = ltemp        lowestCitys = [curcity]    #  温度和当前最低相同，加入列表    elif ltemp ==lowest:        lowestCitys.append(curcity)print(&#39;温度最低为%s℃, 城市有%s&#39; % (lowest, &#39; &#39;.join(lowestCitys)))</code></pre><p> <strong>方法3:</strong> 取回 整个<strong>html</strong>代码片段， 用<strong>beatifulsoup</strong> 分析大体思路和方法二 一样， 唯一的区别在于，我们不是用<strong>selenium</strong>获取每个城市温度对应的<strong>web</strong>元素信息而是用<strong>BS</strong>本地操作。</p><pre><code>driver.get(&#39;http://www.weather.com.cn/html/province/jiangsu.shtml&#39;)ele = driver.find_element_by_id(&quot;forecastID&quot;)print(ele.text)# -----------------------------------# 再从 forecastID 元素获取所有子元素dlhtml_doc = ele.get_attribute(&#39;innerHTML&#39;)from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc, &quot;html5lib&quot;)# 发现每个城市的信息都在dl里面dls = soup.find_all(&#39;dl&#39;)# 将城市和气温信息保存到列表citys中citys = []for dl in dls:     name = dl.a.stringltemp = dl.b.stringltemp = int(ltemp.replace(&#39;℃&#39;,&#39;&#39;))    print(name, ltemp)    citys.append([name,ltemp])</code></pre><p>后面的代码一模一样，直接拷贝即可</p><pre><code>lowest = NonelowestCitys = []  # 温度最低城市列表for one in citys:    curcity = one[0]    ltemp = one[1]    # 发现气温更低的城市    if lowest==None or ltemp&lt;lowest:        lowest = ltemp        lowestCitys = [curcity]    #  温度和当前最低相同，加入列表    elif ltemp ==lowest:        lowestCitys.append(curcity)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是&lt;strong&gt;Selenium&lt;/strong&gt;里面最总要的东西。 &lt;strong&gt;Selenium Webdriver&lt;/strong&gt; （也就是 &lt;strong&gt;Selenium2，Selenium3&lt;/strong&gt; ）和 &lt;strong&gt;Selenium RC</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="UI自动化测试框架" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
    <category term="01_selenium" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/01-selenium/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>UI自动化理论</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E7%90%86%E8%AE%BA/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06_%E8%87%AA%E5%8A%A8%E5%8C%96/02_%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96/01_UI%E8%87%AA%E5%8A%A8%E5%8C%96%E7%90%86%E8%AE%BA/</id>
    <published>2022-05-15T03:46:45.547Z</published>
    <updated>2022-05-15T06:27:30.824Z</updated>
    
    <content type="html"><![CDATA[<p>一、原理<br>1、什么是UI自动化测试<br>使用工具或者脚本对需要测试的软件的前端界面在预设的条件下和已经的测试数据下运行系统或者应用程序，并获取其前端页面显示的数据结果进行校验，评估得出测试结论。</p><p>2、UI自动化测试可用于哪里<br>基于测试渠道可分为：手机App、Pc web端、手机Web端等；</p><p>基于测试阶段可分为：冒烟测试、回归测试、生产验收、兼容性测试</p><p>3、为什么要使用UI自动化测试<br>（1）目前测试案例数量过多导致人工执行测试案例耗时过长，并且会出现无法执行完该执行的测试案例导致版本无法按预期上线；</p><p>（2）案例的步骤繁琐，场景复杂，制作测试数据的过程复杂，导致人工执行时间过长；</p><p>（3）需求简单，无前端功能开发的需求可以使用UI自动化进行测试并得出结论；</p><p>（4）可以帮助开发人员进行自测。</p><p>4、哪些测试可以执行UI自动化<br>（1）已经比较成熟的项目，暂无任何大的改动需求的项目；</p><p>（2）人工执行耗时长，流程繁琐的项目；</p><p>（3）单纯的数据校验，列表功能校验；</p><p>5、怎么执行自动化测试<br>（1）开发提测前自用，配置环境和工具，下载脚本执行，可通过测试报告查看执行情况和结果；</p><p>（2）冒烟测试中，测试在开发提测后执行，通过测试报告查看执行情况和测试结果；</p><p>（3）回归测试中，测试人员执行执行纳入回归测试的测试脚本并执行</p><p>（4）生产验收，UI自动化测试脚本可用于生产验收中，无须手动操作就可验证生产的情况。</p><p>6、UI自动化测试的利与弊<br>利处：快捷、方便、无须手工操作</p><p>弊端：脚本编写成本高、案例开发时间长、需要长期维护</p><p>二、总结<br>UI自动化应用于项目组的所负责的系统需求较多，测试案例数量也较多，测试场景复杂，测试数据制作复杂，并且有部分系统已经趋于成熟。</p><p>UI自动化测试其实是一门【水】很深的工作，因为UI自动化测试是需要根据前端页面元素，也就是HTML脚本来进行元素提取、操作、验证的测试流程，另外再加上项目的测试环境软件硬件的因素，在编写自动化测试脚本的时候需要考虑到很多的情况出现而要去判断当前页面出现的元素到底是什么情况，不然脚本的稳定性很不好，维护工作也会非常的高。另外在编写自动化脚本的时候，你会慢慢的熟悉你项目系统前端页面的代码，当下很多前端开发人员在制作新的项目前端页面时都会直接用现成的组件生成，这种HTML代码会使你开发脚本时难上加难，因为里面的标签命名根本就是乱来的。</p><p>三、自动化框架<br>搭建测试框架，框架目录解析</p><p><img src="/assets/2/image-20220510223500-pv7tycu.png" alt="image.png"></p><h2 id="config-配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini"><a href="#config-配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini" class="headerlink" title="config : 配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini"></a>config : 配置文件，将项目相关的配置全放到这个文件夹中，python支持yaml，ini</h2><p><strong>ini文件介绍</strong></p><p>以[section]开始</p><p>以[option&#x3D;value]结尾</p><p>备注以；开头</p><p>section不可重名</p><p><strong>yaml文件介绍</strong></p><p>以—开头，表明文件的开始</p><p>列表中的所有成员都开始于相同的缩进级别，并且使用一个“-”作为开头（一个横杠和一个空格）</p><p>一个字典是由一个简单的键：值的形式（这个冒号后面必须是一个空格）</p><p><strong>ini读取文件封装,yaml读取文件封装</strong></p><p><strong>configutil.py</strong></p><pre><code class="text">import configparserimport osimport yamlclass ReadIni():    def read_ini(file, section, option):        conf = configparser.ConfigParser()        conf.read(file)        res=conf.get(section, option)        print(res)        return resclass ReafYaml():    def read_yaml(file,key):        f=open(file,encoding=&#39;utf-8&#39;)        file_data =f.read()        res=yaml.load(file_data,Loader=yaml.FullLoader)        print(res.get(key))        return res.get(key)if __name__ == &#39;__main__&#39;:    current_path = os.path.dirname(os.path.realpath(__file__))    config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;    yaml_file = os.path.join(config_path, &#39;test.yaml&#39;)    ReafYaml.read_yaml(yaml_file, &#39;username&#39;)</code></pre><h2 id="data-数据文件，将测试用例参数化相关的文件放在这里，xlsx-csv-json"><a href="#data-数据文件，将测试用例参数化相关的文件放在这里，xlsx-csv-json" class="headerlink" title="data : 数据文件，将测试用例参数化相关的文件放在这里，xlsx,csv,json"></a>data : 数据文件，将测试用例参数化相关的文件放在这里，xlsx,csv,json</h2><h2 id="driver-：驱动文件"><a href="#driver-：驱动文件" class="headerlink" title="driver ：驱动文件"></a>driver ：驱动文件</h2><h2 id="log-：日志文件，如test-log-error-log"><a href="#log-：日志文件，如test-log-error-log" class="headerlink" title="log ：日志文件，如test log,error log"></a>log ：日志文件，如test log,error log</h2><h2 id="report-：测试报告"><a href="#report-：测试报告" class="headerlink" title="report ：测试报告"></a>report ：测试报告</h2><h2 id="test-：测试文件"><a href="#test-：测试文件" class="headerlink" title="test ：测试文件"></a>test ：测试文件</h2><p>case-测试用例</p><p><strong>test.py</strong></p><pre><code class="text">import unittestfrom selenium import webdriverfrom test.locators import *from utils.configutil import ReadIni,ReafYamlfrom test.page import *from utils.excelutil import *from selenium.webdriver.common.action_chains import ActionChainsimport yamlimport osfrom utils.logutil import *current_path = os.path.dirname(os.path.realpath(__file__))config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;ini_file = os.path.join(config_path, &#39;test.ini&#39;)ip = ReadIni.read_ini(ini_file, &#39;ip_address&#39;, &#39;ip&#39;)# print(ip)url = &#39;&#123;&#125;user/login?redirect=http%3A%2F%2Fmis-next.aunbox.ce%2FuserDetail&#39;.format(ip)excel_file = os.path.join(os.path.dirname(current_path) + os.sep + &quot;data&quot;, &#39;case.xlsx&#39;)username = ReadExcel.read_excel(excel_file,&#39;Sheet1&#39;,&#39;A&#39;)class LoginTest(unittest.TestCase):    def setUp(self):        self.driver = webdriver.Chrome()        self.driver.maximize_window()        self.driver.implicitly_wait(10)        self.driver.get(url)    def test_login(self):        Logger(&#39;C:\\Users\\Administrator\\PycharmProjects\\yunding\\log\\test.log&#39;,&#39;info&#39;).info(&#39;add project&#39;)        for user in username:            loginpage=LoginPage(self.driver)            loginpage.enter_username(user)            loginpage.enter_password()            loginpage.click_login_button()            self.assertEqual(&#39;超级管理员&#39;,loginpage.get_login_name())            quitlogin=self.driver.find_element_by_xpath(&#39;//*[@id=&quot;root&quot;]/section/section/header/div[2]/span&#39;)            ActionChains(self.driver).move_to_element(quitlogin).perform()            self.driver.find_element_by_class_name(&#39;ant-dropdown-menu-item&#39;).click()            self.driver.get(url)        # self.driver.find_element(*LoginLocators.username).send_keys(&quot;&#123;&#125;&quot;.format(user))        # self.driver.find_element(*LoginLocators.password).send_keys(&quot;&#123;&#125;&quot;.format(pad))        # self.driver.find_element(*LoginLocators.loginbutton).click()        # id=self.driver.find_element(*LoginLocators.loginname)        # self.assertEqual(&#39;超级管理员&#39;,id.text)    def tearDown(self):        self.driver.quit()if __name__ == &#39;__main__&#39;:    unittest.main()</code></pre><p>common-测试相关的抽象通用代码</p><p>page-页面类</p><p>元素定位</p><p><strong>locators.py</strong></p><pre><code class="text">from selenium.webdriver.common.by import By# 页面元素class LoginLocators():    username=(By.ID,&#39;account&#39;)    password=(By.ID,&#39;password&#39;)    loginbutton=(By.CLASS_NAME,&#39;ant-btn&#39;)    loginname=(By.CLASS_NAME,&#39;userName___fQOhV&#39;)</code></pre><p>元素操作</p><p><strong>page.py</strong></p><pre><code class="text">from test.locators import *# 页面元素的操作class BasePage():    def __init__(self,driver):        self.driver = driverclass LoginPage(BasePage):    &#39;&#39;&#39;    用户登录页面元素的操作,,,到这里消失    &#39;&#39;&#39;    UserName = (By.XPATH,&#39;//*[@id=&quot;username&quot;]&#39;) #登录名    def enter_username(self,name):        ele = self.driver.find_element(*LoginLocators.username)        # ele.clear()        ele.send_keys(name)  #对用户名元素进行输入    def enter_password(self):        ele = self.driver.find_element(*LoginLocators.password)        ele.send_keys(&#39;123456&#39;) #输入密码    def click_login_button(self):        ele = self.driver.find_element(*LoginLocators.loginbutton)        ele.click()  #点击登录按钮    def get_login_name(self):        ele = self.driver.find_element(*LoginLocators.loginname)        return ele.text  #返回登录名</code></pre><h2 id="utils-：公共方法"><a href="#utils-：公共方法" class="headerlink" title="utils ：公共方法"></a>utils ：公共方法</h2><p>config的类</p><p>log的类</p><p><strong>logutil.py</strong></p><pre><code class="text">import loggingfrom logging import handlersclass Logger(object):    level_relations = &#123;        &#39;debug&#39;:logging.DEBUG,        &#39;info&#39;:logging.INFO,        &#39;warning&#39;:logging.WARNING,        &#39;error&#39;:logging.ERROR,        &#39;critical&#39;:logging.CRITICAL    &#125;    def __init__(self,fp=&#39;d:\\Project_Redmine_01\\log\\test.log&#39;,level=&#39;info&#39;):        self.level = self.level_relations.get(level)        self.logger = logging.getLogger(fp)        self.logger.setLevel(self.level)        formatter = logging.Formatter(&#39;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;)        th = handlers.TimedRotatingFileHandler(fp)        th.setFormatter(formatter)        th.setLevel(self.level)        self.logger.addHandler(th)    def debug(self,msg):        self.logger.debug(msg)    def info(self,msg):        self.logger.info(msg)    def warning(self,msg):        self.logger.warning(msg)    def error(self,msg):        self.logger.error(msg)    def critical(self,msg):        self.logger.critical(msg)if __name__ == &#39;__main__&#39;:    log = Logger(&#39;abcd.log&#39;,&#39;debug&#39;)    log.info(&#39;this is info msg&#39;)    log.critical(&#39;this is critical msg&#39;)</code></pre><p>读，写excel的类</p><p><strong>excelutil.py</strong></p><pre><code class="text">import configparserimport osimport yamlclass ReadIni():    def read_ini(file, section, option):        conf = configparser.ConfigParser()        conf.read(file)        res=conf.get(section, option)        print(res)        return resclass ReafYaml():    def read_yaml(file,key):        f=open(file,encoding=&#39;utf-8&#39;)        file_data =f.read()        res=yaml.load(file_data,Loader=yaml.FullLoader)        print(res.get(key))        return res.get(key)if __name__ == &#39;__main__&#39;:    current_path = os.path.dirname(os.path.realpath(__file__))    config_path = os.path.dirname(current_path) + os.sep + &quot;config&quot;    yaml_file = os.path.join(config_path, &#39;test.yaml&#39;)    ReafYaml.read_yaml(yaml_file, &#39;username&#39;)</code></pre><p>生成报告的类</p><p><strong>run.py</strong></p><pre><code class="text">import osimport timeimport unittestimport HTMLTestRunnercurrent_path = os.path.dirname(os.path.realpath(__file__))# print(current_path)report_path = os.path.join(current_path,&#39;report&#39;)# print(report_path)case_path = os.path.join(current_path,&#39;test&#39;)# print(case_path)report_name = time.strftime(&#39;%Y%m%d%H%M%S&#39;,time.localtime((time.time())))testsuite = unittest.TestLoader().discover(case_path)filename = &quot;&#123;&#125;\\&#123;&#125;.html&quot;.format(report_path,report_name)f = open(filename,&#39;wb&#39;)runner = HTMLTestRunner.HTMLTestRunner(stream=f,title=&#39;report&#39;,description=&#39;this is a report&#39;)runner.run(testsuite)f.close()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、原理&lt;br&gt;1、什么是UI自动化测试&lt;br&gt;使用工具或者脚本对需要测试的软件的前端界面在预设的条件下和已经的测试数据下运行系统或者应用程序，并获取其前端页面显示的数据结果进行校验，评估得出测试结论。&lt;/p&gt;
&lt;p&gt;2、UI自动化测试可用于哪里&lt;br&gt;基于测试渠道可分为：</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="06_自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="02_自动化实操" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
    
    <category term="01_UI自动化" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/06-%E8%87%AA%E5%8A%A8%E5%8C%96/02-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E6%93%8D/01-UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
    <category term="课后" scheme="http://example.com/tags/%E8%AF%BE%E5%90%8E/"/>
    
  </entry>
  
  <entry>
    <title>持续集成</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/03_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/03_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</id>
    <published>2022-05-14T18:00:17.129Z</published>
    <updated>2022-05-14T16:12:47.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h1><p>Java环境安装配置</p><h2 id="Java环境安装"><a href="#Java环境安装" class="headerlink" title="Java环境安装"></a>Java环境安装</h2><p><strong>由于许多工具配套支持的jdk版本为1.8版本，所以尽量选择</strong>jdk1.8<strong>版本使用。</strong></p><h3 id="1-下载jdk"><a href="#1-下载jdk" class="headerlink" title="1.  下载jdk"></a>1.  <strong>下载</strong>jdk</h3><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p><p><strong>选择对应系统版本匹配的</strong>JDK<strong>，点击右边的下载。</strong></p><p><img src="/assets/1/image-20220324172511-lke1vl3.png" alt="image.png"></p><p><strong>在弹出的窗口中勾选同意用户协议，并点击下载，若没有登录则会弹出登录界面，注册一个账号进行下载即可。</strong></p><p><img src="/assets/1/image-20220324172521-1ya4f0w.png" alt="image.png"></p><p><strong>JDK</strong>下载完成后，直接双击运行安装，建议默认安装到C:\Program Files\Java，记住自己的安装路径。点击下一步等待安装即可。</p><p><img src="/assets/1/image-20220324172527-erl5zf5.png" alt="image.png"></p><p><strong>之后会弹出JRE环境安装的提示，建议同样使用默认路径，直接下一步。等待安装完成之后关闭。</strong></p><p><img src="/assets/1/image-20220324172533-ettqoz2.png" alt="image.png"></p><p><img src="/assets/1/image-20220324172539-8x11wj1.png" alt="image.png"></p><h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.  配置环境变量"></a>2.  <strong>配置环境变量</strong></h3><p><strong>配置环境变量之前，先检查确认java安装成功：</strong></p><p><strong>进入安装目录中，确认安装目录下jdk和jre都已经安装成功。确认jdk目录的bin目录下，包含java.exe，javac.exe,javaw.exe。如果没有，尝试卸载重装。</strong></p><p><img src="/assets/1/image-20220324172545-zymly6w.png" alt="image.png"></p><p><img src="/assets/1/image-20220324172550-2jd1t1a.png" alt="image.png"></p><p><strong>环境变量操作方法：</strong></p><p><strong>Win7</strong>：<a href="https://jingyan.baidu.com/article/d5a880eb6aca7213f047cc6c.html">https://jingyan.baidu.com/article/d5a880eb6aca7213f047cc6c.html</a></p><p><strong>Win10</strong>：<a href="https://jingyan.baidu.com/article/ad310e80d2ebe31848f49e59.html">https://jingyan.baidu.com/article/ad310e80d2ebe31848f49e59.html</a></p><p><strong>以</strong>WIN10<strong>为例：</strong></p><h4 id="一、在系统变量中，添加JAVA-HOME变量，值为JDK安装目录。"><a href="#一、在系统变量中，添加JAVA-HOME变量，值为JDK安装目录。" class="headerlink" title="一、在系统变量中，添加JAVA_HOME变量，值为JDK安装目录。"></a>一、在系统变量中，添加<strong>JAVA_HOME</strong>变量，值为<strong>JDK</strong>安装目录。</h4><p><img src="/assets/1/image-20220324172557-k5e0kcd.png" alt="image.png"></p><h4 id="二、编辑系统变量中的Path"><a href="#二、编辑系统变量中的Path" class="headerlink" title="二、编辑系统变量中的Path:"></a>二、编辑系统变量中的P<strong>ath</strong>:</h4><p><strong>1、删除变量</strong>C:\Program Files (x86)\Common Files\Oracle\Java\javapath，通常在第一个。</p><p><strong>确认是</strong>Oracle\Java\javapath再删除！！！<img src="/assets/1/image-20220324172606-hx3wr2s.png" alt="image.png"></p><p><strong>2、在Path中新建</strong>%<strong>JAVA_HOME%\bin</strong>请确保这个目录下包含<strong>java.exe</strong>和<strong>javac.exe。</strong></p><p><img src="/assets/1/image-20220324172626-q4ank4m.png" alt="image.png"></p><h4 id="三-安装检查"><a href="#三-安装检查" class="headerlink" title="三.  安装检查"></a>三.  <strong>安装检查</strong></h4><p><strong>检查</strong>path<strong>：在</strong>cmd<strong>下输入 echo %path% ，确保</strong>path<strong>里面，</strong>java<strong>的路径是正确的，并且没有其他</strong>java<strong>的路径。</strong></p><p><img src="/assets/1/image-20220324172632-c5i0tqu.png" alt="image.png"></p><p><strong>cmd</strong>在任意目录下，执行<strong>java -version</strong>和<strong>javac -version</strong>。两个版本与安装版本一致，说明配置成功。</p><p><img src="/assets/1/image-20220324172638-br4z8gt.png" alt="image.png"></p><h1 id="Jenkins安装部署"><a href="#Jenkins安装部署" class="headerlink" title="Jenkins安装部署"></a>Jenkins安装部署</h1><h2 id="Tomcat下载解压："><a href="#Tomcat下载解压：" class="headerlink" title="Tomcat下载解压："></a>Tomcat下载解压：</h2><p><strong>tomcat是非常常用的轻量级web应用服务器，用于进行web项目的发布。要完成jenkins的部署，首先需要安装Java环境和tomcat。</strong></p><p><strong>Java环境的安装请参考文档中的《java环境搭建》一文。</strong></p><p>1、下载tomcat： <a href="https://tomcat.apache.org/download-80.cgi">https://tomcat.apache.org/download-80.cgi</a></p><p><strong>2、下载之后直接解压即可使用。</strong></p><h2 id="Jenkins部署到tomcat启动"><a href="#Jenkins部署到tomcat启动" class="headerlink" title="Jenkins部署到tomcat启动"></a>Jenkins部署到tomcat启动</h2><p>1、下载Jenkins.war，联系悠米老师领取或者从官网下载均可： <a href="https://www.jenkins.io/download/">https://www.jenkins.io/download/</a></p><p><strong>2、将Jenkins.war包复制到到Tomcat的webapps目录下，然后在tomcat的bin目录下运行startup.bat，启动tomcat。</strong></p><p><img src="/assets/1/image-20220324172712-md4nob9.png" alt="image.png"></p><p><strong>3、   在浏览器中访问<a href="http://localhost:8080/jenkins%EF%BC%8C%E7%AD%89%E5%BE%85%E7%BD%91%E9%A1%B5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%8A%9F%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%87%BA%E7%8E%B0%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%95%8C%E9%9D%A2%EF%BC%9A">http://localhost:8080/jenkins，等待网页初始化成功，直到出现下面的界面：</a></strong></p><p><img src="/assets/1/image-20220324172717-fw32cnu.png" alt="image.png"></p><p><strong>4、  用记事本或Notepad++等文本编辑工具</strong>打开图中红色标识目录中的<strong>initialAdminPassword</strong>文件，复制里面的字符串，粘贴到图中输入框。然后点击图中的继续按钮。</p><p><strong>5、   跳转</strong>到下图页面，建议选择Install suggested plugins安装推荐插件，熟悉基本插件之后，可以选择Select plugins to install自定义配置安装的插件。</p><p><img src="/assets/1/image-20220324172725-r2o7lwv.png" alt="image.png"></p><hr><p><strong>6、    <strong>等待插件安装（需要较长时间），当进度条读满，所有插件项目都变成红色或者绿色之后，说明安装结束，如果安装完成页面没有自动跳转，请</strong>手动刷新浏览器页面。</strong></p><p><img src="/assets/1/image-20220324172731-py63260.png" alt="image.png"></p><p><strong>7、    <strong>忽略安装失败，点击</strong>continue</strong>。</p><p><img src="/assets/1/image-20220324172737-a5ccczb.png" alt="image.png"></p><p><strong>8、    <strong>创建一个管理员用户名密码，请</strong>记住</strong>用户名和密码，用于之后登录使用。配置完成点击<strong>save and finish</strong>结束。</p><p><img src="/assets/1/image-20220324172743-yybujku.png" alt="image.png"></p><p><strong>9、    <strong>进入</strong>Jenkins</strong>页面。此时，安装完成</p><p><img src="/assets/1/image-20220324172750-9wxgelu.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、准备工作&quot;&gt;&lt;a href=&quot;#一、准备工作&quot; class=&quot;headerlink&quot; title=&quot;一、准备工作&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、准备工作&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;Java环境安装配置&lt;/p&gt;
&lt;h2 id=&quot;Java环境安装&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="15_环境部署_持续集成" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Apache环境部署</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/01_apache%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/01_apache%E7%8E%AF%E5%A2%83/</id>
    <published>2022-05-14T18:00:17.121Z</published>
    <updated>2022-05-14T16:12:47.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a><strong>一、准备工作</strong></h1><h2 id="1-1-环境"><a href="#1-1-环境" class="headerlink" title="1.1 环境"></a>1.1 环境</h2><p>操作系统：centos7（CentOS-7-x86_64-Minimal-1708）</p><p>硬件：（这个根据项目运行和配置建议设置，一般我先配个1核1G）</p><h2 id="1-2-关闭selinux"><a href="#1-2-关闭selinux" class="headerlink" title="1.2 关闭selinux"></a>1.2 关闭selinux</h2><p>#修改selinux的配置文件</p><pre><code>vim /etc/selinux/config</code></pre><p>将内容中的SELINUX&#x3D;enforcing修改为SELINUX&#x3D;disabled，wq保存。</p><p>#本次不重启关闭selinux</p><pre><code>setenforce 0</code></pre><h2 id="1-3-更新"><a href="#1-3-更新" class="headerlink" title="1.3 更新"></a>1.3 更新</h2><pre><code>yum update -y</code></pre><h2 id="1-4-安装vim、wget"><a href="#1-4-安装vim、wget" class="headerlink" title="1.4 安装vim、wget"></a>1.4 安装vim、wget</h2><pre><code>yum install -y vim wget    </code></pre><hr><h1 id="二、部署apache"><a href="#二、部署apache" class="headerlink" title="二、部署apache"></a>二、部署apache</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><pre><code>yum install -y httpd</code></pre><h2 id="2-2-启动服务"><a href="#2-2-启动服务" class="headerlink" title="2.2 启动服务"></a>2.2 启动服务</h2><h1 id="启动apache"><a href="#启动apache" class="headerlink" title="启动apache"></a>启动apache</h1><pre><code>systemctl start httpd</code></pre><h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><pre><code>systemctl enable httpd</code></pre><h2 id="2-3-查看apache版本"><a href="#2-3-查看apache版本" class="headerlink" title="2.3 查看apache版本"></a>2.3 查看apache版本</h2><pre><code>httpd -v</code></pre><p><img src="/assets/1/image-20211122230737-ixxygo6.png" alt="image.png"></p><p> 可以看到apache安装的是2.4.6，也可以知道apache安装成功。</p><h2 id="2-4-开启80端口"><a href="#2-4-开启80端口" class="headerlink" title="2.4 开启80端口"></a>2.4 开启80端口</h2><h1 id="添加80端口永久开启"><a href="#添加80端口永久开启" class="headerlink" title="添加80端口永久开启"></a>添加80端口永久开启</h1><pre><code>firewall-cmd --add-port=80/tcp --permanent</code></pre><h1 id="防火墙修改立即生效"><a href="#防火墙修改立即生效" class="headerlink" title="防火墙修改立即生效"></a>防火墙修改立即生效</h1><pre><code>firewall-cmd --reload</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr><h1 id="三、部署mysql"><a href="#三、部署mysql" class="headerlink" title="三、部署mysql"></a>三、部署mysql</h1><h2 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h2><h1 id="获取rpm包"><a href="#获取rpm包" class="headerlink" title="获取rpm包"></a>获取rpm包</h1><pre><code>wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</code></pre><h1 id="安装rpm包"><a href="#安装rpm包" class="headerlink" title="安装rpm包"></a>安装rpm包</h1><pre><code>rpm -ivh mysql-community-release-el7-5.noarch.rpm</code></pre><h1 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h1><pre><code>yum install -y mysql-community-server</code></pre><h2 id="3-2-启动"><a href="#3-2-启动" class="headerlink" title="3.2 启动"></a>3.2 启动</h2><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><pre><code>systemctl start mysql</code></pre><h1 id="开机启动-1"><a href="#开机启动-1" class="headerlink" title="开机启动"></a>开机启动</h1><pre><code>systemctl enable mysql</code></pre><h2 id="3-3-修改root密码并设置允许远程连接"><a href="#3-3-修改root密码并设置允许远程连接" class="headerlink" title="3.3 修改root密码并设置允许远程连接"></a>3.3 修改root密码并设置允许远程连接</h2><h1 id="进入mysql"><a href="#进入mysql" class="headerlink" title="进入mysql"></a>进入mysql</h1><pre><code>mysql -uroot</code></pre><h1 id="设置root密码为123456"><a href="#设置root密码为123456" class="headerlink" title="设置root密码为123456"></a>设置root密码为123456</h1><pre><code>mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39; =password(&#39;123456&#39;);</code></pre><h1 id="设置允许用root账户进行远程连接，并设置其密码为123456"><a href="#设置允许用root账户进行远程连接，并设置其密码为123456" class="headerlink" title="设置允许用root账户进行远程连接，并设置其密码为123456"></a>设置允许用root账户进行远程连接，并设置其密码为123456</h1><pre><code>mysql&gt; grant all privileges on *.* to root@&#39;%&#39;identified by &#39;123456&#39;;</code></pre><h1 id="修改的配置立即生效"><a href="#修改的配置立即生效" class="headerlink" title="修改的配置立即生效"></a>修改的配置立即生效</h1><pre><code>mysql&gt; flush privileges;</code></pre><h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><pre><code>mysql&gt; exit;</code></pre><h2 id="3-4-查看mysql版本"><a href="#3-4-查看mysql版本" class="headerlink" title="3.4 查看mysql版本"></a>3.4 查看mysql版本</h2><pre><code>mysql -V</code></pre><p><img src="/assets/1/image-20211122230745-87is6zt.png" alt="image.png"></p><hr><h1 id="四、部署php"><a href="#四、部署php" class="headerlink" title="四、部署php"></a>四、部署php</h1><h2 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h2><pre><code>yum install -y php</code></pre><h2 id="4-2-安装组件是php支持mysql"><a href="#4-2-安装组件是php支持mysql" class="headerlink" title="4.2 安装组件是php支持mysql"></a>4.2 安装组件是php支持mysql</h2><pre><code>yum install -y php-mysql php-gd libjpeg* php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash</code></pre><h2 id="4-3-查看php版本"><a href="#4-3-查看php版本" class="headerlink" title="4.3 查看php版本"></a>4.3 查看php版本</h2><pre><code>php --version</code></pre><p><img src="/assets/1/image-20211122230751-hh1f83z.png" alt="image.png"></p><h2 id="4-4-查看详细信息"><a href="#4-4-查看详细信息" class="headerlink" title="4.4 查看详细信息"></a>4.4 查看详细信息</h2><h1 id="新增文件phpmess-php"><a href="#新增文件phpmess-php" class="headerlink" title="新增文件phpmess.php"></a>新增文件phpmess.php</h1><pre><code>vim /var/www/html/phpmess.php</code></pre><p> 增加下面的内容，wq保存。</p><pre><code>&lt;?php    phpinfo();</code></pre><p>浏览器访问ip&#x2F;phpmess.php查看，出现类似下面的内容就说明php安装是成功的。</p><p><img src="/assets/1/image-20211122230756-t0j1bii.png" alt="image.png"></p><h2 id="4-5-安全其他版本PHP"><a href="#4-5-安全其他版本PHP" class="headerlink" title="4.5 安全其他版本PHP"></a>4.5 安全其他版本PHP</h2><p>卸载原来低版本的PHP</p><pre><code>rpm -qa |grep php|xargs rpm -e</code></pre><p>更新yum源</p><p>&#x2F;&#x2F;CentOS&#x2F;RHEL 7.x<br>rpm -Uvh <a href="https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm">https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</a><br>rpm -Uvh <a href="http://rpms.famillecollet.com/enterprise/remi-release-7.rpm">http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</a></p><p>查看可使用的php包</p><pre><code>yum list | grep php</code></pre><p>安装PHP常用模块</p><p>yum -y install php72-php php72-php-common php72-php-devel php72-php-gd php72-php-mysqlnd php72-php-pecl-mysql php72-php-pecl-memcached php72-php-pecl-memcache php72-php-pecl-redis php72-php-opcache</p><p>&#x2F;&#x2F;装好后看一下装了哪些包<br>yum list installed |grep php</p><p>&#x2F;&#x2F;最后重启下httpd<br>systemctl restart httpd<br><img src="/assets/1/image-20211122230802-4mgxljy.png" alt="image.png"></p><h2 id="5-更改Apache网站默认目录"><a href="#5-更改Apache网站默认目录" class="headerlink" title="5.更改Apache网站默认目录"></a>5.更改Apache网站默认目录</h2><p>Apache默认的网站目录是在&#x2F;var&#x2F;www&#x2F;html，</p><p>现在要把网站目录更改到&#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs，</p><p>操作如下<br><strong>准备工作：</strong><br>创建目录：<br>cd &#x2F;home<br>mkdir wwwroot<br>cd wwwroot<br>mkdir web1<br>cd web1<br>mkdir htdocs<br>touch index.php<br><strong>操作步骤：</strong><br>1、vi &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf<br>找到 DocumentRoot “&#x2F;var&#x2F;www&#x2F;html” 这一段     #apache的根目录<br>把&#x2F;var&#x2F;www&#x2F;html 这个目录改为&#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs<br>再找到 &lt;Directory “&#x2F;var&#x2F;www&#x2F;html”&gt;   #定义apache &#x2F;var&#x2F;www&#x2F;html这个区域<br>把 &#x2F;var&#x2F;www&#x2F;html改成&#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs<br>这样我们就把apahce的默认路径改掉了<br>service httpd restart  #重启Apache服务器<br>2、访问localhost的时候，会发现访问拒绝，这是为什么呢？<br>系统运维 <a href="http://www.osyunwei.com/">www.osyunwei.com</a> 温馨提醒：qihang01原创内容©版权所有,转载请注明出处及原文链接<br>主要是因为你的&#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs的权限是750，apache这个用户没有权限访问，你需要更改掉权限，可以这样改<br>chmod -R 755 &#x2F;home&#x2F;wwwroot&#x2F;web1&#x2F;htdocs<br>然后去访问 发现正常运行了（apache的用户：apache 运行apache的组：apache）<br> <strong>至此，</strong> <strong>Apache****默认网站目录更改成功。</strong></p><h2 id="6-绑定域名"><a href="#6-绑定域名" class="headerlink" title="6.绑定域名"></a>6.绑定域名</h2><p>vi &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf　　更改配置文件</p><p><img src="/assets/1/image-20211122230808-8zh112f.png" alt="image.png"></p><p> 在配置文件最后加入如下</p><h1 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h1><p>&lt;VirtualHost *:80&gt;<br>DocumentRoot “&#x2F;www&#x2F;dz&#x2F;“<br>ServerName dz.m616.top<br></VirtualHost></p><p><img src="/assets/1/image-20211122230814-l1ybpb2.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、准备工作&quot;&gt;&lt;a href=&quot;#一、准备工作&quot; class=&quot;headerlink&quot; title=&quot;一、准备工作&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、准备工作&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-1-环境&quot;&gt;&lt;a href=&quot;#1-1-环境&quot; class=</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="15_环境部署_持续集成" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat环境部署</title>
    <link href="http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/02_Tomcat%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/07_%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15_%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2_%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/02_Tomcat%E7%8E%AF%E5%A2%83/</id>
    <published>2022-05-14T18:00:17.121Z</published>
    <updated>2022-05-14T16:12:47.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yum方式安装JDK"><a href="#yum方式安装JDK" class="headerlink" title="yum方式安装JDK"></a>yum方式安装JDK</h2><p>“*”表示将java-1.8.0的所有相关Java程序都安装上（是不是很方便快捷）</p><pre><code>[root@test ~]# yum -y install java-1.8.0-openjdk*</code></pre><p>查看是否安装成功java -version（出现版本号代表安装成功）</p><pre><code>[root@test ~]# java -versionopenjdk version &quot;1.8.0_212&quot;OpenJDK Runtime Environment (build 1.8.0_212-b04)OpenJDK 64-Bit Server VM (build 25.212-b04, mixed mode)</code></pre><h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><p>1.将tomcat安装在usr&#x2F;lcoal下一般软件安装处</p><p>将入其文件夹</p><p>[root@test ~]# cd &#x2F;usr&#x2F;local</p><p>2.去tomcat官网复制你想下载的版本下载链接。注意一定要选择tar.gz这是liunx下的安装包，比如链接：<a href="https://links.jianshu.com/go?to=http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.19/bin/apache-tomcat-9.0.19.tar.gz">http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.19/bin/apache-tomcat-9.0.19.tar.gz</a></p><p><img src="/assets/1/image-20211125152847-ggl37xb.png" alt="image.png"></p><p>在这里插入图片描述</p><p>3.wget命令下载安装包</p><blockquote><ol><li>[root@test ~]# wget <a href="http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.62/bin/apache-tomcat-9.0.62.tar.gz">http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.62/bin/apache-tomcat-9.0.62.tar.gz</a></li></ol></blockquote><p>4.查看</p><pre><code>[root@instance-wi0t3arq local]# ls</code></pre><p><img src="/assets/1/image-20211125152852-2lujja3.png" alt="image.png"></p><p>在这里插入图片描述</p><p>5.解压</p><p>个人习惯喜欢把安装包改一下名字</p><blockquote><p>[root@instance-wi0t3arq local]# mv apache-tomcat-9.0.19.tar.gz tomcats<br>[root@instance-wi0t3arq local]# tar -zxvf tomcats<br>[root@instance-wi0t3arq local]# mv apache-tomcat-9.0.19  tomcat</p></blockquote><p>6.查看是否安装成功</p><p>进入tomcat bin目录启动Tomcat（显示Tomcat started.则启动成功）</p><pre><code>[root@instance-wi0t3arq local]# cd tomcat[root@instance-wi0t3arq tomcat]# cd bin[root@instance-wi0t3arq bin]# ./startup.shUsing CATALINA_BASE:   /usr/local/tomcatUsing CATALINA_HOME:   /usr/local/tomcatUsing CATALINA_TMPDIR: /usr/local/tomcat/tempUsing JRE_HOME:        /usrUsing CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jarTomcat started.</code></pre><p>用curl命令测试本地能不能访问8080端口</p><pre><code>[root@instance-wi0t3arq bin]# curl http://localhost:8080</code></pre><p>出现页面代码表示tomcat安装成功</p><p><img src="/assets/1/image-20211125152856-tpa141d.png" alt="image.png"></p><p>在这里插入图片描述</p><hr><p>如果curl <a href="http://localhost:8080出现未知错误：需修改配置文件">http://localhost:8080出现未知错误：需修改配置文件</a>  操作如下：</p><p>[root@instance-wi0t3arq bin]#  cd ..</p><p>[root@instance-wi0t3arq tomcat]#  cd conf</p><p>[root@instance-wi0t3arq conf]#  vi server.xml</p><pre><code class="把">~~~~~~~~~~~~~~~~ 把  8080  改为 其他如  80~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre><p><img src="/assets/1/image-20220415181625-p6oh0j3.png" alt="image.png"></p><p>7.启动远程访问（不要瞎改配置这只会让你陷入死循环。按照这三步来一点问题都没有）</p><p>a.关闭防火墙并关机禁止启动</p><pre><code>[root@instance-wi0t3arq bin]# systemctl stop firewalld[root@instance-wi0t3arq bin]# systemctl status firewalld ?firewalld.service - firewalld - dynamic firewall daemon   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)   Active: inactive (dead)     Docs: man:firewalld(1)[root@instance-wi0t3arq bin]#  systemctl disable firewalld</code></pre><p>b.安全组配置8080端口(这个去云服务商网站配置一下就ok了)</p><p><img src="/assets/1/image-20211125152901-aehe6s1.png" alt="image.png"></p><p>在这里插入图片描述</p><p>c.重启tomcat</p><p>然后在你的浏览器里输入ip+:8080就可以访问到tomcat界面了</p><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>1.准备</p><pre><code># 下载mysql源安装包 [root@instance-wi0t3arq bin]# wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm# 安装mysql源 [root@instance-wi0t3arq bin]# yum localinstall mysql57-community-release-el7-8.noarch.rpm检查mysql源是否安装成功//不出现错误信息代表安装成功 [root@instance-wi0t3arq bin]#  yum repolist enabled | grep &quot;mysql.*-community.*&quot;</code></pre><p>2、安装MySQL</p><pre><code> [root@instance-wi0t3arq bin]#  yum install mysql-community-server</code></pre><p>3、启动MySQL服务</p><pre><code> [root@instance-wi0t3arq bin]#  systemctl start mysqld</code></pre><p>4.查看MySQL的启动状态</p><p>[root@instance-wi0t3arq bin] systemctl status mysqld</p><p>5.登录mysql修改本地登录密码</p><p>查看本机密码</p><p>[root@instance-wi0t3arq bin]  grep ‘temporary password’ &#x2F;var&#x2F;log&#x2F;mysqld.log</p><p><img src="/assets/1/image-20211125152906-kwvgdv6.png" alt="image.png"></p><p>在这里插入图片描述</p><p>登录修改密码：注意此处密码一定要按照此格式来因为有验证规则。</p><pre><code>  [root@instance-wi0t3arq local]#  mysql -u root -pEnter password: mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyNewPass4!&#39;; </code></pre><p>6.开启远程连接</p><p>a.配置安全组3306端口</p><p><img src="/assets/1/image-20211125152910-ziubdm5.png" alt="image.png"></p><p>在这里插入图片描述</p><p>b.开启远程访问</p><blockquote><p><code>mysql &gt;  GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;fanggus@1s23&#39; WITH GRANT OPTION;</code></p></blockquote><p>远程连接一下即可连接。</p><h2 id="出现其他问题"><a href="#出现其他问题" class="headerlink" title="出现其他问题"></a>出现其他问题</h2><p>1.本机版本与我的不一致我的linux内核版本是：centos7.5(换一下系统)</p><p>2.系统本身存在jdk、tomcat、mysql（重装）</p><p>3.如果系统不是第一次使用，建议重装系统这样不至于出现覆盖现象。如果不方便重装的话，就先将本机的jdk、mysql、tomcat卸载。</p><p>检索命令：</p><pre><code>[root@test ~]# yum list installed |grep java</code></pre><p>查看版本命令：</p><pre><code>java -version</code></pre><p>移除命令</p><pre><code>yum -y remove java-1.7.0-openjdk*</code></pre><p>嗯哼，通过这三个命令移除吧</p><pre><code>yum -y install libaioyum -y install net-toolsyum -y install perl</code></pre><h2 id="上传安装包"><a href="#上传安装包" class="headerlink" title="上传安装包"></a>上传安装包</h2><blockquote><p>在&#x2F;usr&#x2F;local目录下新建mysql目录</p></blockquote><pre><code>mkdir /usr/local/mysql</code></pre><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><blockquote><p>进入mysql目录,解压缩</p></blockquote><pre><code>tar xvf mysql-5.7.30-1.el7.x86_64.rpm-bundle.tar</code></pre><p>在这里插入图片描述<br><img src="https://lexiangla.com/assets/1/d1c7d855e0624a266d378bdde1956586?from_outside=1" alt="在这里插入图片描述"></p><h2 id="安装服务器端程序"><a href="#安装服务器端程序" class="headerlink" title="安装服务器端程序"></a>安装服务器端程序</h2><pre><code>[root@localhost src]# rpm -ivh mysql-community-common-5.7.32-1.el7.x86_64.rpm[root@localhost src]# rpm -ivh mysql-community-libs-5.7.32-1.el7.x86_64.rpm[root@localhost src]# rpm -ivh mysql-community-client-5.7.32-1.el7.x86_64.rpm[root@localhost src]# rpm -ivh mysql-community-server-5.7.32-1.el7.x86_64.rpm</code></pre><h2 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务"></a>启动mysql服务</h2><p>查看mysql状态</p><pre><code>service mysqld status</code></pre><p>启动mysql</p><pre><code>service mysqld start</code></pre><h2 id="查看并修改临时MySQL密码"><a href="#查看并修改临时MySQL密码" class="headerlink" title="查看并修改临时MySQL密码"></a>查看并修改临时MySQL密码</h2><pre><code>#查看临时密码：得知临时密码就是如图grep password /var/log/mysqld.log</code></pre><p><img src="https://lexiangla.com/assets/1/33ff088d3189441e781c1276b12695fe?from_outside=1" alt="在这里插入图片描述"></p><pre><code>#用临时密码登录mysql[root@localhost src]# mysql -uroot –p#修改成新的密码mysql&gt; set password = password(&quot;Root_123&quot;);</code></pre><p><img src="https://lexiangla.com/assets/1/7a8743824a3c49b453cbfe5c9e37611d?from_outside=1" alt="在这里插入图片描述"></p><h2 id="开启远程连接-允许远程连接数据库"><a href="#开启远程连接-允许远程连接数据库" class="headerlink" title="开启远程连接,允许远程连接数据库"></a>开启远程连接,允许远程连接数据库</h2><blockquote><p>设置远程访问（使用root密码）</p></blockquote><pre><code>mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;Mysql_123456&#39; WITH GRANT OPTION;</code></pre><h2 id="配置mysql的配置文件my-cnf"><a href="#配置mysql的配置文件my-cnf" class="headerlink" title="配置mysql的配置文件my.cnf"></a>配置mysql的配置文件my.cnf</h2><pre><code>#打开配置文件my.cnf[root@localhost src]# vi /etc/my.cnf#在[mysqld]下面配置几行lower_case_table_names=1   #配置表名不区分大小写 1：不区分大小写 0：区分大小写  这行必须配置 默认表名是区分大小写的，不利于开发character-set-server=utf8          #设置为默认编码为utf8init_connect=&#39;SET NAMES utf8&#39;max_connections=1024             #设置最大连接数skip-name-resolve                #在连接远程数据库的时候，直接跳过MySQL的DNS解析[root@localhost src]# service mysqld restart  #重启mysql 重启配置才能生效</code></pre><h2 id="防火墙设置允许3306端口"><a href="#防火墙设置允许3306端口" class="headerlink" title="防火墙设置允许3306端口"></a>防火墙设置允许3306端口</h2><pre><code>vim /etc/sysconfig/iptables</code></pre><p>模仿22端口开放命令添加如图所示的一行即表示对外开放3306端口<br><img src="https://lexiangla.com/assets/1/b075e7556ef2404d6bac3b3de8763b05?from_outside=1" alt="在这里插入图片描述"></p><blockquote><p>重启防火墙</p></blockquote><pre><code>service iptables restart</code></pre><p><strong>第二种方法启动远成端口</strong></p><pre><code>firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload</code></pre><h2 id="设置开机启动MySQL"><a href="#设置开机启动MySQL" class="headerlink" title="设置开机启动MySQL"></a>设置开机启动MySQL</h2><blockquote><p>编辑文件</p></blockquote><pre><code>vi /etc/rc.local</code></pre><p>加入mysql启动命令<br><img src="https://lexiangla.com/assets/1/c07c0b30d3a7456a6e85c952a2034310?from_outside=1" alt="在这里插入图片描述"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote><p>使用sqlyog连接mysql<br><img src="https://lexiangla.com/assets/1/719d1d2aec4b46437bfdabe5839cf993?from_outside=1" alt="在这里插入图片描述"></p></blockquote><h1 id="安装tomcat-1"><a href="#安装tomcat-1" class="headerlink" title="安装tomcat"></a>安装tomcat</h1><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><blockquote><p>在&#x2F;usr&#x2F;local目录下新建tomcat目录</p></blockquote><pre><code>mkdir /usr/local/tomcat</code></pre><blockquote><p>将apache-tomcat-7.0.57.tar.gz 上传到该目录</p></blockquote><h2 id="解压缩-1"><a href="#解压缩-1" class="headerlink" title="解压缩"></a>解压缩</h2><blockquote><p>进入&#x2F;usr&#x2F;local&#x2F;tomcat 目录并解压apache-tomcat-7.0.57.tar.gz 文件</p></blockquote><pre><code>$ tar -xvf apache-tomcat-7.0.57.tar.gz</code></pre><h2 id="防火墙设置允许8080端口"><a href="#防火墙设置允许8080端口" class="headerlink" title="防火墙设置允许8080端口"></a>防火墙设置允许8080端口</h2><pre><code>/****in/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT/etc/rc.d/init.d/iptables save</code></pre><h2 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h2><blockquote><p>进入到tomcat的安装目录下的bin目录：&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat-7.0.57&#x2F;bin</p></blockquote><pre><code>./startup.sh</code></pre><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><blockquote><p>访问 http:&#x2F;&#x2F;虚拟机地址:8080</p></blockquote><p><img src="https://lexiangla.com/assets/1/25bbfa73c8fe4d354ae7c2c10a38b22f?from_outside=1" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;yum方式安装JDK&quot;&gt;&lt;a href=&quot;#yum方式安装JDK&quot; class=&quot;headerlink&quot; title=&quot;yum方式安装JDK&quot;&gt;&lt;/a&gt;yum方式安装JDK&lt;/h2&gt;&lt;p&gt;“*”表示将java-1.8.0的所有相关Java程序都安装上（是不是很方便</summary>
      
    
    
    
    <category term="07_测试工具" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    <category term="15_环境部署_持续集成" scheme="http://example.com/categories/07-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/15-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
